#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Archive/Zip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP';
  package Archive::Zip;
  
  use 5.006;
  use strict;
  use Carp                ();
  use Cwd                 ();
  use IO::File            ();
  use IO::Seekable        ();
  use Compress::Raw::Zlib ();
  use File::Spec          ();
  use File::Temp          ();
  use FileHandle          ();
  
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
  
      require Exporter;
      @ISA = qw( Exporter );
  }
  
  use vars qw( $ChunkSize $ErrorHandler );
  
  BEGIN {
      # This is the size we'll try to read, write, and (de)compress.
      # You could set it to something different if you had lots of memory
      # and needed more speed.
      $ChunkSize ||= 32768;
  
      $ErrorHandler = \&Carp::carp;
  }
  
  # BEGIN block is necessary here so that other modules can use the constants.
  use vars qw( @EXPORT_OK %EXPORT_TAGS );
  
  BEGIN {
      @EXPORT_OK   = ('computeCRC32');
      %EXPORT_TAGS = (
          CONSTANTS => [
              qw(
                FA_MSDOS
                FA_UNIX
                GPBF_ENCRYPTED_MASK
                GPBF_DEFLATING_COMPRESSION_MASK
                GPBF_HAS_DATA_DESCRIPTOR_MASK
                COMPRESSION_STORED
                COMPRESSION_DEFLATED
                COMPRESSION_LEVEL_NONE
                COMPRESSION_LEVEL_DEFAULT
                COMPRESSION_LEVEL_FASTEST
                COMPRESSION_LEVEL_BEST_COMPRESSION
                IFA_TEXT_FILE_MASK
                IFA_TEXT_FILE
                IFA_BINARY_FILE
                )
          ],
  
          MISC_CONSTANTS => [
              qw(
                FA_AMIGA
                FA_VAX_VMS
                FA_VM_CMS
                FA_ATARI_ST
                FA_OS2_HPFS
                FA_MACINTOSH
                FA_Z_SYSTEM
                FA_CPM
                FA_TOPS20
                FA_WINDOWS_NTFS
                FA_QDOS
                FA_ACORN
                FA_VFAT
                FA_MVS
                FA_BEOS
                FA_TANDEM
                FA_THEOS
                GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK
                GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
                GPBF_IS_COMPRESSED_PATCHED_DATA_MASK
                COMPRESSION_SHRUNK
                DEFLATING_COMPRESSION_NORMAL
                DEFLATING_COMPRESSION_MAXIMUM
                DEFLATING_COMPRESSION_FAST
                DEFLATING_COMPRESSION_SUPER_FAST
                COMPRESSION_REDUCED_1
                COMPRESSION_REDUCED_2
                COMPRESSION_REDUCED_3
                COMPRESSION_REDUCED_4
                COMPRESSION_IMPLODED
                COMPRESSION_TOKENIZED
                COMPRESSION_DEFLATED_ENHANCED
                COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED
                )
          ],
  
          ERROR_CODES => [
              qw(
                AZ_OK
                AZ_STREAM_END
                AZ_ERROR
                AZ_FORMAT_ERROR
                AZ_IO_ERROR
                )
          ],
  
          # For Internal Use Only
          PKZIP_CONSTANTS => [
              qw(
                SIGNATURE_FORMAT
                SIGNATURE_LENGTH
  
                LOCAL_FILE_HEADER_SIGNATURE
                LOCAL_FILE_HEADER_FORMAT
                LOCAL_FILE_HEADER_LENGTH
  
                DATA_DESCRIPTOR_SIGNATURE
                DATA_DESCRIPTOR_FORMAT
                DATA_DESCRIPTOR_LENGTH
  
                DATA_DESCRIPTOR_FORMAT_NO_SIG
                DATA_DESCRIPTOR_LENGTH_NO_SIG
  
                CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE
                CENTRAL_DIRECTORY_FILE_HEADER_FORMAT
                CENTRAL_DIRECTORY_FILE_HEADER_LENGTH
  
                ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE
                ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_FORMAT
                ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH
  
                ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE
                ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_FORMAT
                ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH
  
                END_OF_CENTRAL_DIRECTORY_SIGNATURE
                END_OF_CENTRAL_DIRECTORY_FORMAT
                END_OF_CENTRAL_DIRECTORY_LENGTH
  
                END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING
                )
          ],
  
          # For Internal Use Only
          UTILITY_METHODS => [
              qw(
                _error
                _printError
                _ioError
                _formatError
                _subclassResponsibility
                _binmode
                _isSeekable
                _newFileHandle
                _readSignature
                _asZipDirName
                )
          ],
      );
  
      # Add all the constant names and error code names to @EXPORT_OK
      Exporter::export_ok_tags(
          qw(
            CONSTANTS
            ERROR_CODES
            PKZIP_CONSTANTS
            UTILITY_METHODS
            MISC_CONSTANTS
            ));
  
  }
  
  # Error codes
  use constant AZ_OK           => 0;
  use constant AZ_STREAM_END   => 1;
  use constant AZ_ERROR        => 2;
  use constant AZ_FORMAT_ERROR => 3;
  use constant AZ_IO_ERROR     => 4;
  
  # File types
  # Values of Archive::Zip::Member->fileAttributeFormat()
  
  use constant FA_MSDOS        => 0;
  use constant FA_AMIGA        => 1;
  use constant FA_VAX_VMS      => 2;
  use constant FA_UNIX         => 3;
  use constant FA_VM_CMS       => 4;
  use constant FA_ATARI_ST     => 5;
  use constant FA_OS2_HPFS     => 6;
  use constant FA_MACINTOSH    => 7;
  use constant FA_Z_SYSTEM     => 8;
  use constant FA_CPM          => 9;
  use constant FA_TOPS20       => 10;
  use constant FA_WINDOWS_NTFS => 11;
  use constant FA_QDOS         => 12;
  use constant FA_ACORN        => 13;
  use constant FA_VFAT         => 14;
  use constant FA_MVS          => 15;
  use constant FA_BEOS         => 16;
  use constant FA_TANDEM       => 17;
  use constant FA_THEOS        => 18;
  
  # general-purpose bit flag masks
  # Found in Archive::Zip::Member->bitFlag()
  
  use constant GPBF_ENCRYPTED_MASK             => 1 << 0;
  use constant GPBF_DEFLATING_COMPRESSION_MASK => 3 << 1;
  use constant GPBF_HAS_DATA_DESCRIPTOR_MASK   => 1 << 3;
  
  # deflating compression types, if compressionMethod == COMPRESSION_DEFLATED
  # ( Archive::Zip::Member->bitFlag() & GPBF_DEFLATING_COMPRESSION_MASK )
  
  use constant DEFLATING_COMPRESSION_NORMAL     => 0 << 1;
  use constant DEFLATING_COMPRESSION_MAXIMUM    => 1 << 1;
  use constant DEFLATING_COMPRESSION_FAST       => 2 << 1;
  use constant DEFLATING_COMPRESSION_SUPER_FAST => 3 << 1;
  
  # compression method
  
  # these two are the only ones supported in this module
  use constant COMPRESSION_STORED        => 0;   # file is stored (no compression)
  use constant COMPRESSION_DEFLATED      => 8;   # file is Deflated
  use constant COMPRESSION_LEVEL_NONE    => 0;
  use constant COMPRESSION_LEVEL_DEFAULT => -1;
  use constant COMPRESSION_LEVEL_FASTEST => 1;
  use constant COMPRESSION_LEVEL_BEST_COMPRESSION => 9;
  
  # internal file attribute bits
  # Found in Archive::Zip::Member::internalFileAttributes()
  
  use constant IFA_TEXT_FILE_MASK => 1;
  use constant IFA_TEXT_FILE      => 1;
  use constant IFA_BINARY_FILE    => 0;
  
  # PKZIP file format miscellaneous constants (for internal use only)
  use constant SIGNATURE_FORMAT => "V";
  use constant SIGNATURE_LENGTH => 4;
  
  # these lengths are without the signature.
  use constant LOCAL_FILE_HEADER_SIGNATURE => 0x04034b50;
  use constant LOCAL_FILE_HEADER_FORMAT    => "v3 V4 v2";
  use constant LOCAL_FILE_HEADER_LENGTH    => 26;
  
  # PKZIP docs don't mention the signature, but Info-Zip writes it.
  use constant DATA_DESCRIPTOR_SIGNATURE => 0x08074b50;
  use constant DATA_DESCRIPTOR_FORMAT    => "V3";
  use constant DATA_DESCRIPTOR_LENGTH    => 12;
  
  # but the signature is apparently optional.
  use constant DATA_DESCRIPTOR_FORMAT_NO_SIG => "V2";
  use constant DATA_DESCRIPTOR_LENGTH_NO_SIG => 8;
  
  use constant CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE => 0x02014b50;
  use constant CENTRAL_DIRECTORY_FILE_HEADER_FORMAT    => "C2 v3 V4 v5 V2";
  use constant CENTRAL_DIRECTORY_FILE_HEADER_LENGTH    => 42;
  
  # zip64 support
  use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE => 0x06064b50;
  use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_FORMAT => 0;
  use constant ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_LENGTH => 0;
  
  use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE => 0x07064b50;
  use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_FORMAT => 0;
  use constant ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_LENGTH => 0;
  
  
  use constant END_OF_CENTRAL_DIRECTORY_SIGNATURE => 0x06054b50;
  use constant END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING =>
    pack("V", END_OF_CENTRAL_DIRECTORY_SIGNATURE);
  use constant END_OF_CENTRAL_DIRECTORY_FORMAT => "v4 V2 v";
  use constant END_OF_CENTRAL_DIRECTORY_LENGTH => 18;
  
  use constant GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK => 1 << 1;
  use constant GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK  => 1 << 2;
  use constant GPBF_IS_COMPRESSED_PATCHED_DATA_MASK      => 1 << 5;
  
  # the rest of these are not supported in this module
  use constant COMPRESSION_SHRUNK    => 1;    # file is Shrunk
  use constant COMPRESSION_REDUCED_1 => 2;    # file is Reduced CF=1
  use constant COMPRESSION_REDUCED_2 => 3;    # file is Reduced CF=2
  use constant COMPRESSION_REDUCED_3 => 4;    # file is Reduced CF=3
  use constant COMPRESSION_REDUCED_4 => 5;    # file is Reduced CF=4
  use constant COMPRESSION_IMPLODED  => 6;    # file is Imploded
  use constant COMPRESSION_TOKENIZED => 7;    # reserved for Tokenizing compr.
  use constant COMPRESSION_DEFLATED_ENHANCED => 9;   # reserved for enh. Deflating
  use constant COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED => 10;
  
  # Load the various required classes
  require Archive::Zip::Archive;
  require Archive::Zip::Member;
  require Archive::Zip::FileMember;
  require Archive::Zip::DirectoryMember;
  require Archive::Zip::ZipFileMember;
  require Archive::Zip::NewFileMember;
  require Archive::Zip::StringMember;
  
  # Convenience functions
  
  sub _ISA ($$) {
  
      # Can't rely on Scalar::Util, so use the next best way
      local $@;
      !!eval { ref $_[0] and $_[0]->isa($_[1]) };
  }
  
  sub _CAN ($$) {
      local $@;
      !!eval { ref $_[0] and $_[0]->can($_[1]) };
  }
  
  #####################################################################
  # Methods
  
  sub new {
      my $class = shift;
      return Archive::Zip::Archive->new(@_);
  }
  
  sub computeCRC32 {
      my ($data, $crc);
  
      if (ref($_[0]) eq 'HASH') {
          $data = $_[0]->{string};
          $crc  = $_[0]->{checksum};
      } else {
          $data = shift;
          $data = shift if ref($data);
          $crc  = shift;
      }
  
      return Compress::Raw::Zlib::crc32($data, $crc);
  }
  
  # Report or change chunk size used for reading and writing.
  # Also sets Zlib's default buffer size (eventually).
  sub setChunkSize {
      shift if ref($_[0]) eq 'Archive::Zip::Archive';
      my $chunkSize = (ref($_[0]) eq 'HASH') ? shift->{chunkSize} : shift;
      my $oldChunkSize = $Archive::Zip::ChunkSize;
      $Archive::Zip::ChunkSize = $chunkSize if ($chunkSize);
      return $oldChunkSize;
  }
  
  sub chunkSize {
      return $Archive::Zip::ChunkSize;
  }
  
  sub setErrorHandler {
      my $errorHandler = (ref($_[0]) eq 'HASH') ? shift->{subroutine} : shift;
      $errorHandler = \&Carp::carp unless defined($errorHandler);
      my $oldErrorHandler = $Archive::Zip::ErrorHandler;
      $Archive::Zip::ErrorHandler = $errorHandler;
      return $oldErrorHandler;
  }
  
  ######################################################################
  # Private utility functions (not methods).
  
  sub _printError {
      my $string = join(' ', @_, "\n");
      my $oldCarpLevel = $Carp::CarpLevel;
      $Carp::CarpLevel += 2;
      &{$ErrorHandler}($string);
      $Carp::CarpLevel = $oldCarpLevel;
  }
  
  # This is called on format errors.
  sub _formatError {
      shift if ref($_[0]);
      _printError('format error:', @_);
      return AZ_FORMAT_ERROR;
  }
  
  # This is called on IO errors.
  sub _ioError {
      shift if ref($_[0]);
      _printError('IO error:', @_, ':', $!);
      return AZ_IO_ERROR;
  }
  
  # This is called on generic errors.
  sub _error {
      shift if ref($_[0]);
      _printError('error:', @_);
      return AZ_ERROR;
  }
  
  # Called when a subclass should have implemented
  # something but didn't
  sub _subclassResponsibility {
      Carp::croak("subclass Responsibility\n");
  }
  
  # Try to set the given file handle or object into binary mode.
  sub _binmode {
      my $fh = shift;
      return _CAN($fh, 'binmode') ? $fh->binmode() : binmode($fh);
  }
  
  # Attempt to guess whether file handle is seekable.
  # Because of problems with Windows, this only returns true when
  # the file handle is a real file.
  sub _isSeekable {
      my $fh = shift;
      return 0 unless ref $fh;
      _ISA($fh, "IO::Scalar")    # IO::Scalar objects are brokenly-seekable
        and return 0;
      _ISA($fh, "IO::String")
        and return 1;
      if (_ISA($fh, "IO::Seekable")) {
  
          # Unfortunately, some things like FileHandle objects
          # return true for Seekable, but AREN'T!!!!!
          _ISA($fh, "FileHandle")
            and return 0;
          return 1;
      }
  
      # open my $fh, "+<", \$data;
      ref $fh eq "GLOB" && eval { seek $fh, 0, 1 } and return 1;
      _CAN($fh, "stat")
        and return -f $fh;
      return (_CAN($fh, "seek") and _CAN($fh, "tell")) ? 1 : 0;
  }
  
  # Print to the filehandle, while making sure the pesky Perl special global
  # variables don't interfere.
  sub _print {
      my ($self, $fh, @data) = @_;
  
      local $\;
  
      return $fh->print(@data);
  }
  
  # Return an opened IO::Handle
  # my ( $status, fh ) = _newFileHandle( 'fileName', 'w' );
  # Can take a filename, file handle, or ref to GLOB
  # Or, if given something that is a ref but not an IO::Handle,
  # passes back the same thing.
  sub _newFileHandle {
      my $fd     = shift;
      my $status = 1;
      my $handle;
  
      if (ref($fd)) {
          if (_ISA($fd, 'IO::Scalar') or _ISA($fd, 'IO::String')) {
              $handle = $fd;
          } elsif (_ISA($fd, 'IO::Handle') or ref($fd) eq 'GLOB') {
              $handle = IO::File->new;
              $status = $handle->fdopen($fd, @_);
          } else {
              $handle = $fd;
          }
      } else {
          $handle = IO::File->new;
          $status = $handle->open($fd, @_);
      }
  
      return ($status, $handle);
  }
  
  # Returns next signature from given file handle, leaves
  # file handle positioned afterwards.
  # In list context, returns ($status, $signature)
  # ( $status, $signature) = _readSignature( $fh, $fileName );
  
  sub _readSignature {
      my $fh                = shift;
      my $fileName          = shift;
      my $expectedSignature = shift;    # optional
  
      my $signatureData;
      my $bytesRead = $fh->read($signatureData, SIGNATURE_LENGTH);
      if ($bytesRead != SIGNATURE_LENGTH) {
          return _ioError("reading header signature");
      }
      my $signature = unpack(SIGNATURE_FORMAT, $signatureData);
      my $status = AZ_OK;
  
      # compare with expected signature, if any, or any known signature.
      if (
          (defined($expectedSignature) && $signature != $expectedSignature)
          || (   !defined($expectedSignature)
              && $signature != CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE
              && $signature != LOCAL_FILE_HEADER_SIGNATURE
              && $signature != END_OF_CENTRAL_DIRECTORY_SIGNATURE
              && $signature != DATA_DESCRIPTOR_SIGNATURE
              && $signature != ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIGNATURE
              && $signature != ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE
          )
        ) {
          my $errmsg = sprintf("bad signature: 0x%08x", $signature);
          if (_isSeekable($fh)) {
              $errmsg .= sprintf(" at offset %d", $fh->tell() - SIGNATURE_LENGTH);
          }
  
          $status = _formatError("$errmsg in file $fileName");
      }
  
      return ($status, $signature);
  }
  
  # Utility method to make and open a temp file.
  # Will create $temp_dir if it does not exist.
  # Returns file handle and name:
  #
  # my ($fh, $name) = Archive::Zip::tempFile();
  # my ($fh, $name) = Archive::Zip::tempFile('mytempdir');
  #
  
  sub tempFile {
      my $dir = (ref($_[0]) eq 'HASH') ? shift->{tempDir} : shift;
      my ($fh, $filename) = File::Temp::tempfile(
          SUFFIX => '.zip',
          UNLINK => 1,
          $dir ? (DIR => $dir) : ());
      return (undef, undef) unless $fh;
      my ($status, $newfh) = _newFileHandle($fh, 'w+');
      $fh->close();
      return ($newfh, $filename);
  }
  
  # Return the normalized directory name as used in a zip file (path
  # separators become slashes, etc.).
  # Will translate internal slashes in path components (i.e. on Macs) to
  # underscores.  Discards volume names.
  # When $forceDir is set, returns paths with trailing slashes (or arrays
  # with trailing blank members).
  #
  # If third argument is a reference, returns volume information there.
  #
  # input         output
  # .             ('.')   '.'
  # ./a           ('a')   a
  # ./a/b         ('a','b')   a/b
  # ./a/b/        ('a','b')   a/b
  # a/b/          ('a','b')   a/b
  # /a/b/         ('','a','b')    a/b
  # c:\a\b\c.doc  ('','a','b','c.doc')    a/b/c.doc      # on Windows
  # "i/o maps:whatever"   ('i_o maps', 'whatever')  "i_o maps/whatever"   # on Macs
  sub _asZipDirName {
      my $name      = shift;
      my $forceDir  = shift;
      my $volReturn = shift;
      my ($volume, $directories, $file) =
        File::Spec->splitpath(File::Spec->canonpath($name), $forceDir);
      $$volReturn = $volume if (ref($volReturn));
      my @dirs = map { $_ =~ s{/}{_}g; $_ } File::Spec->splitdir($directories);
      if (@dirs > 0) { pop(@dirs) unless $dirs[-1] }    # remove empty component
      push(@dirs, defined($file) ? $file : '');
  
      #return wantarray ? @dirs : join ( '/', @dirs );
  
      my $normalised_path = join '/', @dirs;
  
      # Leading directory separators should not be stored in zip archives.
      # Example:
      #   C:\a\b\c\      a/b/c
      #   C:\a\b\c.txt   a/b/c.txt
      #   /a/b/c/        a/b/c
      #   /a/b/c.txt     a/b/c.txt
      $normalised_path =~ s{^/}{};    # remove leading separator
  
      return $normalised_path;
  }
  
  # Return an absolute local name for a zip name.
  # Assume a directory if zip name has trailing slash.
  # Takes an optional volume name in FS format (like 'a:').
  #
  sub _asLocalName {
      my $name   = shift;    # zip format
      my $volume = shift;
      $volume = '' unless defined($volume);    # local FS format
  
      my @paths = split(/\//, $name);
      my $filename = pop(@paths);
      $filename = '' unless defined($filename);
      my $localDirs = @paths ? File::Spec->catdir(@paths) : '';
      my $localName = File::Spec->catpath($volume, $localDirs, $filename);
      unless ($volume) {
          $localName = File::Spec->rel2abs($localName, Cwd::getcwd());
      }
      return $localName;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf8
  
  =head1 NAME
  
  Archive::Zip - Provide an interface to ZIP archive files.
  
  =head1 SYNOPSIS
  
     # Create a Zip file
     use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
     my $zip = Archive::Zip->new();
  
     # Add a directory
     my $dir_member = $zip->addDirectory( 'dirname/' );
  
     # Add a file from a string with compression
     my $string_member = $zip->addString( 'This is a test', 'stringMember.txt' );
     $string_member->desiredCompressionMethod( COMPRESSION_DEFLATED );
  
     # Add a file from disk
     my $file_member = $zip->addFile( 'xyz.pl', 'AnotherName.pl' );
  
     # Save the Zip file
     unless ( $zip->writeToFileNamed('someZip.zip') == AZ_OK ) {
         die 'write error';
     }
  
     # Read a Zip file
     my $somezip = Archive::Zip->new();
     unless ( $somezip->read( 'someZip.zip' ) == AZ_OK ) {
         die 'read error';
     }
  
     # Change the compression type for a file in the Zip
     my $member = $somezip->memberNamed( 'stringMember.txt' );
     $member->desiredCompressionMethod( COMPRESSION_STORED );
     unless ( $zip->writeToFileNamed( 'someOtherZip.zip' ) == AZ_OK ) {
         die 'write error';
     }
  
  =head1 DESCRIPTION
  
  The Archive::Zip module allows a Perl program to create, manipulate, read,
  and write Zip archive files.
  
  Zip archives can be created, or you can read from existing zip files.
  
  Once created, they can be written to files, streams, or strings. Members
  can be added, removed, extracted, replaced, rearranged, and enumerated.
  They can also be renamed or have their dates, comments, or other attributes
  queried or modified. Their data can be compressed or uncompressed as needed.
  
  Members can be created from members in existing Zip files, or from existing
  directories, files, or strings.
  
  This module uses the L<Compress::Raw::Zlib> library to read and write the
  compressed streams inside the files.
  
  One can use L<Archive::Zip::MemberRead> to read the zip file archive members
  as if they were files.
  
  =head2 File Naming
  
  Regardless of what your local file system uses for file naming, names in a
  Zip file are in Unix format (I<forward> slashes (/) separating directory
  names, etc.).
  
  C<Archive::Zip> tries to be consistent with file naming conventions, and will
  translate back and forth between native and Zip file names.
  
  However, it can't guess which format names are in. So two rules control what
  kind of file name you must pass various routines:
  
  =over 4
  
  =item Names of files are in local format.
  
  C<File::Spec> and C<File::Basename> are used for various file
  operations. When you're referring to a file on your system, use its
  file naming conventions.
  
  =item Names of archive members are in Unix format.
  
  This applies to every method that refers to an archive member, or
  provides a name for new archive members. The C<extract()> methods
  that can take one or two names will convert from local to zip names
  if you call them with a single name.
  
  =back
  
  =head2 Archive::Zip Object Model
  
  =head3 Overview
  
  Archive::Zip::Archive objects are what you ordinarily deal with.
  These maintain the structure of a zip file, without necessarily
  holding data. When a zip is read from a disk file, the (possibly
  compressed) data still lives in the file, not in memory. Archive
  members hold information about the individual members, but not
  (usually) the actual member data. When the zip is written to a
  (different) file, the member data is compressed or copied as needed.
  It is possible to make archive members whose data is held in a string
  in memory, but this is not done when a zip file is read. Directory
  members don't have any data.
  
  =head2 Inheritance
  
    Exporter
     Archive::Zip                            Common base class, has defs.
         Archive::Zip::Archive               A Zip archive.
         Archive::Zip::Member                Abstract superclass for all members.
             Archive::Zip::StringMember      Member made from a string
             Archive::Zip::FileMember        Member made from an external file
                 Archive::Zip::ZipFileMember Member that lives in a zip file
                 Archive::Zip::NewFileMember Member whose data is in a file
             Archive::Zip::DirectoryMember   Member that is a directory
  
  =head1 EXPORTS
  
  =over 4
  
  =item :CONSTANTS
  
  Exports the following constants:
  
  FA_MSDOS FA_UNIX GPBF_ENCRYPTED_MASK
  GPBF_DEFLATING_COMPRESSION_MASK GPBF_HAS_DATA_DESCRIPTOR_MASK
  COMPRESSION_STORED COMPRESSION_DEFLATED IFA_TEXT_FILE_MASK
  IFA_TEXT_FILE IFA_BINARY_FILE COMPRESSION_LEVEL_NONE
  COMPRESSION_LEVEL_DEFAULT COMPRESSION_LEVEL_FASTEST
  COMPRESSION_LEVEL_BEST_COMPRESSION
  
  =item :MISC_CONSTANTS
  
  Exports the following constants (only necessary for extending the
  module):
  
  FA_AMIGA FA_VAX_VMS FA_VM_CMS FA_ATARI_ST FA_OS2_HPFS
  FA_MACINTOSH FA_Z_SYSTEM FA_CPM FA_WINDOWS_NTFS
  GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK
  GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
  GPBF_IS_COMPRESSED_PATCHED_DATA_MASK COMPRESSION_SHRUNK
  DEFLATING_COMPRESSION_NORMAL DEFLATING_COMPRESSION_MAXIMUM
  DEFLATING_COMPRESSION_FAST DEFLATING_COMPRESSION_SUPER_FAST
  COMPRESSION_REDUCED_1 COMPRESSION_REDUCED_2 COMPRESSION_REDUCED_3
  COMPRESSION_REDUCED_4 COMPRESSION_IMPLODED COMPRESSION_TOKENIZED
  COMPRESSION_DEFLATED_ENHANCED
  COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED
  
  =item :ERROR_CODES
  
  Explained below. Returned from most methods.
  
  AZ_OK AZ_STREAM_END AZ_ERROR AZ_FORMAT_ERROR AZ_IO_ERROR
  
  =back
  
  =head1 ERROR CODES
  
  Many of the methods in Archive::Zip return error codes. These are implemented
  as inline subroutines, using the C<use constant> pragma. They can be imported
  into your namespace using the C<:ERROR_CODES> tag:
  
    use Archive::Zip qw( :ERROR_CODES );
  
    ...
  
    unless ( $zip->read( 'myfile.zip' ) == AZ_OK ) {
        die "whoops!";
    }
  
  =over 4
  
  =item AZ_OK (0)
  
  Everything is fine.
  
  =item AZ_STREAM_END (1)
  
  The read stream (or central directory) ended normally.
  
  =item AZ_ERROR (2)
  
  There was some generic kind of error.
  
  =item AZ_FORMAT_ERROR (3)
  
  There is a format error in a ZIP file being read.
  
  =item AZ_IO_ERROR (4)
  
  There was an IO error.
  
  =back
  
  =head2 Compression
  
  Archive::Zip allows each member of a ZIP file to be compressed (using the
  Deflate algorithm) or uncompressed.
  
  Other compression algorithms that some versions of ZIP have been able to
  produce are not supported. Each member has two compression methods: the
  one it's stored as (this is always COMPRESSION_STORED for string and external
  file members), and the one you desire for the member in the zip file.
  
  These can be different, of course, so you can make a zip member that is not
  compressed out of one that is, and vice versa.
  
  You can inquire about the current compression and set the desired
  compression method:
  
    my $member = $zip->memberNamed( 'xyz.txt' );
    $member->compressionMethod();    # return current compression
  
    # set to read uncompressed
    $member->desiredCompressionMethod( COMPRESSION_STORED );
  
    # set to read compressed
    $member->desiredCompressionMethod( COMPRESSION_DEFLATED );
  
  There are two different compression methods:
  
  =over 4
  
  =item COMPRESSION_STORED
  
  File is stored (no compression)
  
  =item COMPRESSION_DEFLATED
  
  File is Deflated
  
  =back
  
  =head2 Compression Levels
  
  If a member's desiredCompressionMethod is COMPRESSION_DEFLATED, you
  can choose different compression levels. This choice may affect the
  speed of compression and decompression, as well as the size of the
  compressed member data.
  
    $member->desiredCompressionLevel( 9 );
  
  The levels given can be:
  
  =over 4
  
  =item * 0 or COMPRESSION_LEVEL_NONE
  
  This is the same as saying
  
    $member->desiredCompressionMethod( COMPRESSION_STORED );
  
  =item * 1 .. 9
  
  1 gives the best speed and worst compression, and 9 gives the
  best compression and worst speed.
  
  =item * COMPRESSION_LEVEL_FASTEST
  
  This is a synonym for level 1.
  
  =item * COMPRESSION_LEVEL_BEST_COMPRESSION
  
  This is a synonym for level 9.
  
  =item * COMPRESSION_LEVEL_DEFAULT
  
  This gives a good compromise between speed and compression,
  and is currently equivalent to 6 (this is in the zlib code).
  This is the level that will be used if not specified.
  
  =back
  
  =head1 Archive::Zip Methods
  
  The Archive::Zip class (and its invisible subclass Archive::Zip::Archive)
  implement generic zip file functionality. Creating a new Archive::Zip object
  actually makes an Archive::Zip::Archive object, but you don't have to worry
  about this unless you're subclassing.
  
  =head2 Constructor
  
  =over 4
  
  =item new( [$fileName] )
  
  =item new( { filename => $fileName } )
  
  Make a new, empty zip archive.
  
      my $zip = Archive::Zip->new();
  
  If an additional argument is passed, new() will call read()
  to read the contents of an archive:
  
      my $zip = Archive::Zip->new( 'xyz.zip' );
  
  If a filename argument is passed and the read fails for any
  reason, new will return undef. For this reason, it may be
  better to call read separately.
  
  =back
  
  =head2 Zip Archive Utility Methods
  
  These Archive::Zip methods may be called as functions or as object
  methods. Do not call them as class methods:
  
      $zip = Archive::Zip->new();
      $crc = Archive::Zip::computeCRC32( 'ghijkl' );    # OK
      $crc = $zip->computeCRC32( 'ghijkl' );            # also OK
      $crc = Archive::Zip->computeCRC32( 'ghijkl' );    # NOT OK
  
  =over 4
  
  =item Archive::Zip::computeCRC32( $string [, $crc] )
  
  =item Archive::Zip::computeCRC32( { string => $string [, checksum => $crc ] } )
  
  This is a utility function that uses the Compress::Raw::Zlib CRC
  routine to compute a CRC-32. You can get the CRC of a string:
  
      $crc = Archive::Zip::computeCRC32( $string );
  
  Or you can compute the running CRC:
  
      $crc = 0;
      $crc = Archive::Zip::computeCRC32( 'abcdef', $crc );
      $crc = Archive::Zip::computeCRC32( 'ghijkl', $crc );
  
  =item Archive::Zip::setChunkSize( $number )
  
  =item Archive::Zip::setChunkSize( { chunkSize => $number } )
  
  Report or change chunk size used for reading and writing.
  This can make big differences in dealing with large files.
  Currently, this defaults to 32K. This also changes the chunk
  size used for Compress::Raw::Zlib. You must call setChunkSize()
  before reading or writing. This is not exportable, so you
  must call it like:
  
      Archive::Zip::setChunkSize( 4096 );
  
  or as a method on a zip (though this is a global setting).
  Returns old chunk size.
  
  =item Archive::Zip::chunkSize()
  
  Returns the current chunk size:
  
      my $chunkSize = Archive::Zip::chunkSize();
  
  =item Archive::Zip::setErrorHandler( \&subroutine )
  
  =item Archive::Zip::setErrorHandler( { subroutine => \&subroutine } )
  
  Change the subroutine called with error strings. This
  defaults to \&Carp::carp, but you may want to change it to
  get the error strings. This is not exportable, so you must
  call it like:
  
      Archive::Zip::setErrorHandler( \&myErrorHandler );
  
  If myErrorHandler is undef, resets handler to default.
  Returns old error handler. Note that if you call Carp::carp
  or a similar routine or if you're chaining to the default
  error handler from your error handler, you may want to
  increment the number of caller levels that are skipped (do
  not just set it to a number):
  
      $Carp::CarpLevel++;
  
  =item Archive::Zip::tempFile( [ $tmpdir ] )
  
  =item Archive::Zip::tempFile( { tempDir => $tmpdir } )
  
  Create a uniquely named temp file. It will be returned open
  for read/write. If C<$tmpdir> is given, it is used as the
  name of a directory to create the file in. If not given,
  creates the file using C<File::Spec::tmpdir()>. Generally, you can
  override this choice using the
  
      $ENV{TMPDIR}
  
  environment variable. But see the L<File::Spec|File::Spec>
  documentation for your system. Note that on many systems, if you're
  running in taint mode, then you must make sure that C<$ENV{TMPDIR}> is
  untainted for it to be used.
  Will I<NOT> create C<$tmpdir> if it does not exist (this is a change
  from prior versions!). Returns file handle and name:
  
      my ($fh, $name) = Archive::Zip::tempFile();
      my ($fh, $name) = Archive::Zip::tempFile('myTempDir');
      my $fh = Archive::Zip::tempFile();  # if you don't need the name
  
  =back
  
  =head2 Zip Archive Accessors
  
  =over 4
  
  =item members()
  
  Return a copy of the members array
  
      my @members = $zip->members();
  
  =item numberOfMembers()
  
  Return the number of members I have
  
  =item memberNames()
  
  Return a list of the (internal) file names of the zip members
  
  =item memberNamed( $string )
  
  =item memberNamed( { zipName => $string } )
  
  Return ref to member whose filename equals given filename or
  undef. C<$string> must be in Zip (Unix) filename format.
  
  =item membersMatching( $regex )
  
  =item membersMatching( { regex => $regex } )
  
  Return array of members whose filenames match given regular
  expression in list context. Returns number of matching
  members in scalar context.
  
      my @textFileMembers = $zip->membersMatching( '.*\.txt' );
      # or
      my $numberOfTextFiles = $zip->membersMatching( '.*\.txt' );
  
  =item diskNumber()
  
  Return the disk that I start on. Not used for writing zips,
  but might be interesting if you read a zip in. This should be
  0, as Archive::Zip does not handle multi-volume archives.
  
  =item diskNumberWithStartOfCentralDirectory()
  
  Return the disk number that holds the beginning of the
  central directory. Not used for writing zips, but might be
  interesting if you read a zip in. This should be 0, as
  Archive::Zip does not handle multi-volume archives.
  
  =item numberOfCentralDirectoriesOnThisDisk()
  
  Return the number of CD structures in the zipfile last read in.
  Not used for writing zips, but might be interesting if you read a zip
  in.
  
  =item numberOfCentralDirectories()
  
  Return the number of CD structures in the zipfile last read in.
  Not used for writing zips, but might be interesting if you read a zip
  in.
  
  =item centralDirectorySize()
  
  Returns central directory size, as read from an external zip
  file. Not used for writing zips, but might be interesting if
  you read a zip in.
  
  =item centralDirectoryOffsetWRTStartingDiskNumber()
  
  Returns the offset into the zip file where the CD begins. Not
  used for writing zips, but might be interesting if you read a
  zip in.
  
  =item zipfileComment( [ $string ] )
  
  =item zipfileComment( [ { comment => $string } ] )
  
  Get or set the zipfile comment. Returns the old comment.
  
      print $zip->zipfileComment();
      $zip->zipfileComment( 'New Comment' );
  
  =item eocdOffset()
  
  Returns the (unexpected) number of bytes between where the
  EOCD was found and where it expected to be. This is normally
  0, but would be positive if something (a virus, perhaps) had
  added bytes somewhere before the EOCD. Not used for writing
  zips, but might be interesting if you read a zip in. Here is
  an example of how you can diagnose this:
  
    my $zip = Archive::Zip->new('somefile.zip');
    if ($zip->eocdOffset())
    {
      warn "A virus has added ", $zip->eocdOffset, " bytes of garbage\n";
    }
  
  The C<eocdOffset()> is used to adjust the starting position of member
  headers, if necessary.
  
  =item fileName()
  
  Returns the name of the file last read from. If nothing has
  been read yet, returns an empty string; if read from a file
  handle, returns the handle in string form.
  
  =back
  
  =head2 Zip Archive Member Operations
  
  Various operations on a zip file modify members. When a member is
  passed as an argument, you can either use a reference to the member
  itself, or the name of a member. Of course, using the name requires
  that names be unique within a zip (this is not enforced).
  
  =over 4
  
  =item removeMember( $memberOrName )
  
  =item removeMember( { memberOrZipName => $memberOrName } )
  
  Remove and return the given member, or match its name and
  remove it. Returns undef if member or name does not exist in this
  Zip. No-op if member does not belong to this zip.
  
  =item replaceMember( $memberOrName, $newMember )
  
  =item replaceMember( { memberOrZipName => $memberOrName,
      newMember => $newMember } )
  
  Remove and return the given member, or match its name and
  remove it. Replace with new member. Returns undef if member or
  name does not exist in this Zip, or if C<$newMember> is undefined.
  
  It is an (undiagnosed) error to provide a C<$newMember> that is a
  member of the zip being modified.
  
      my $member1 = $zip->removeMember( 'xyz' );
      my $member2 = $zip->replaceMember( 'abc', $member1 );
      # now, $member2 (named 'abc') is not in $zip,
      # and $member1 (named 'xyz') is, having taken $member2's place.
  
  =item extractMember( $memberOrName [, $extractedName ] )
  
  =item extractMember( { memberOrZipName => $memberOrName
      [, name => $extractedName ] } )
  
  Extract the given member, or match its name and extract it.
  Returns undef if member does not exist in this Zip. If
  optional second arg is given, use it as the name of the
  extracted member. Otherwise, the internal filename of the
  member is used as the name of the extracted file or
  directory.
  If you pass C<$extractedName>, it should be in the local file
  system's format.
  All necessary directories will be created. Returns C<AZ_OK>
  on success.
  
  =item extractMemberWithoutPaths( $memberOrName [, $extractedName ] )
  
  =item extractMemberWithoutPaths( { memberOrZipName => $memberOrName
      [, name => $extractedName ] } )
  
  Extract the given member, or match its name and extract it.
  Does not use path information (extracts into the current
  directory). Returns undef if member does not exist in this
  Zip.
  If optional second arg is given, use it as the name of the
  extracted member (its paths will be deleted too). Otherwise,
  the internal filename of the member (minus paths) is used as
  the name of the extracted file or directory. Returns C<AZ_OK>
  on success.
  
  =item addMember( $member )
  
  =item addMember( { member => $member } )
  
  Append a member (possibly from another zip file) to the zip
  file. Returns the new member. Generally, you will use
  addFile(), addDirectory(), addFileOrDirectory(), addString(),
  or read() to add members.
  
      # Move member named 'abc' to end of zip:
      my $member = $zip->removeMember( 'abc' );
      $zip->addMember( $member );
  
  =item updateMember( $memberOrName, $fileName )
  
  =item updateMember( { memberOrZipName => $memberOrName, name => $fileName } )
  
  Update a single member from the file or directory named C<$fileName>.
  Returns the (possibly added or updated) member, if any; C<undef> on
  errors.
  The comparison is based on C<lastModTime()> and (in the case of a
  non-directory) the size of the file.
  
  =item addFile( $fileName [, $newName, $compressionLevel ] )
  
  =item addFile( { filename => $fileName
      [, zipName => $newName, compressionLevel => $compressionLevel } ] )
  
  Append a member whose data comes from an external file,
  returning the member or undef. The member will have its file
  name set to the name of the external file, and its
  desiredCompressionMethod set to COMPRESSION_DEFLATED. The
  file attributes and last modification time will be set from
  the file.
  If the name given does not represent a readable plain file or
  symbolic link, undef will be returned. C<$fileName> must be
  in the format required for the local file system.
  The optional C<$newName> argument sets the internal file name
  to something different than the given $fileName. C<$newName>,
  if given, must be in Zip name format (i.e. Unix).
  The text mode bit will be set if the contents appears to be
  text (as returned by the C<-T> perl operator).
  
  
  I<NOTE> that you should not (generally) use absolute path names
  in zip member names, as this will cause problems with some zip
  tools as well as introduce a security hole and make the zip
  harder to use.
  
  =item addDirectory( $directoryName [, $fileName ] )
  
  =item addDirectory( { directoryName => $directoryName
      [, zipName => $fileName ] } )
  
  
  Append a member created from the given directory name. The
  directory name does not have to name an existing directory.
  If the named directory exists, the file modification time and
  permissions are set from the existing directory, otherwise
  they are set to now and permissive default permissions.
  C<$directoryName> must be in local file system format.
  The optional second argument sets the name of the archive
  member (which defaults to C<$directoryName>). If given, it
  must be in Zip (Unix) format.
  Returns the new member.
  
  =item addFileOrDirectory( $name [, $newName, $compressionLevel ] )
  
  =item addFileOrDirectory( { name => $name [, zipName => $newName,
      compressionLevel => $compressionLevel ] } )
  
  
  Append a member from the file or directory named $name. If
  $newName is given, use it for the name of the new member.
  Will add or remove trailing slashes from $newName as needed.
  C<$name> must be in local file system format.
  The optional second argument sets the name of the archive
  member (which defaults to C<$name>). If given, it must be in
  Zip (Unix) format.
  
  =item addString( $stringOrStringRef, $name, [$compressionLevel] )
  
  =item addString( { string => $stringOrStringRef [, zipName => $name,
      compressionLevel => $compressionLevel ] } )
  
  Append a member created from the given string or string
  reference. The name is given by the second argument.
  Returns the new member. The last modification time will be
  set to now, and the file attributes will be set to permissive
  defaults.
  
      my $member = $zip->addString( 'This is a test', 'test.txt' );
  
  =item contents( $memberOrMemberName [, $newContents ] )
  
  =item contents( { memberOrZipName => $memberOrMemberName
      [, contents => $newContents ] } )
  
  
  Returns the uncompressed data for a particular member, or
  undef.
  
      print "xyz.txt contains " . $zip->contents( 'xyz.txt' );
  
  Also can change the contents of a member:
  
      $zip->contents( 'xyz.txt', 'This is the new contents' );
  
  If called expecting an array as the return value, it will include
  the status as the second value in the array.
  
      ($content, $status) = $zip->contents( 'xyz.txt');
  
  =back
  
  =head2 Zip Archive I/O operations
  
  
  A Zip archive can be written to a file or file handle, or read from
  one.
  
  =over 4
  
  =item writeToFileNamed( $fileName )
  
  =item writeToFileNamed( { fileName => $fileName } )
  
  Write a zip archive to named file. Returns C<AZ_OK> on
  success.
  
      my $status = $zip->writeToFileNamed( 'xx.zip' );
      die "error somewhere" if $status != AZ_OK;
  
  Note that if you use the same name as an existing zip file
  that you read in, you will clobber ZipFileMembers. So
  instead, write to a different file name, then delete the
  original.
  If you use the C<overwrite()> or C<overwriteAs()> methods, you can
  re-write the original zip in this way.
  C<$fileName> should be a valid file name on your system.
  
  =item writeToFileHandle( $fileHandle [, $seekable] )
  
  Write a zip archive to a file handle. Return AZ_OK on
  success. The optional second arg tells whether or not to try
  to seek backwards to re-write headers. If not provided, it is
  set if the Perl C<-f> test returns true. This could fail on
  some operating systems, though.
  
      my $fh = IO::File->new( 'someFile.zip', 'w' );
      unless ( $zip->writeToFileHandle( $fh ) == AZ_OK ) {
          # error handling
      }
  
  If you pass a file handle that is not seekable (like if
  you're writing to a pipe or a socket), pass a false second
  argument:
  
      my $fh = IO::File->new( '| cat > somefile.zip', 'w' );
      $zip->writeToFileHandle( $fh, 0 );   # fh is not seekable
  
  If this method fails during the write of a member, that
  member and all following it will return false from
  C<wasWritten()>. See writeCentralDirectory() for a way to
  deal with this.
  If you want, you can write data to the file handle before
  passing it to writeToFileHandle(); this could be used (for
  instance) for making self-extracting archives. However, this
  only works reliably when writing to a real file (as opposed
  to STDOUT or some other possible non-file).
  
  See examples/selfex.pl for how to write a self-extracting
  archive.
  
  =item writeCentralDirectory( $fileHandle [, $offset ] )
  
  =item writeCentralDirectory( { fileHandle => $fileHandle
      [, offset => $offset ] } )
  
  Writes the central directory structure to the given file
  handle.
  
  Returns AZ_OK on success. If given an $offset, will
  seek to that point before writing. This can be used for
  recovery in cases where writeToFileHandle or writeToFileNamed
  returns an IO error because of running out of space on the
  destination file.
  
  You can truncate the zip by seeking backwards and then writing the
  directory:
  
      my $fh = IO::File->new( 'someFile.zip', 'w' );
          my $retval = $zip->writeToFileHandle( $fh );
      if ( $retval == AZ_IO_ERROR ) {
          my @unwritten = grep { not $_->wasWritten() } $zip->members();
          if (@unwritten) {
              $zip->removeMember( $member ) foreach my $member ( @unwritten );
              $zip->writeCentralDirectory( $fh,
              $unwritten[0]->writeLocalHeaderRelativeOffset());
          }
      }
  
  =item overwriteAs( $newName )
  
  =item overwriteAs( { filename => $newName } )
  
  Write the zip to the specified file, as safely as possible.
  This is done by first writing to a temp file, then renaming
  the original if it exists, then renaming the temp file, then
  deleting the renamed original if it exists. Returns AZ_OK if
  successful.
  
  =item overwrite()
  
  Write back to the original zip file. See overwriteAs() above.
  If the zip was not ever read from a file, this generates an
  error.
  
  =item read( $fileName )
  
  =item read( { filename => $fileName } )
  
  Read zipfile headers from a zip file, appending new members.
  Returns C<AZ_OK> or error code.
  
      my $zipFile = Archive::Zip->new();
      my $status = $zipFile->read( '/some/FileName.zip' );
  
  =item readFromFileHandle( $fileHandle, $filename )
  
  =item readFromFileHandle( { fileHandle => $fileHandle, filename => $filename } )
  
  Read zipfile headers from an already-opened file handle,
  appending new members. Does not close the file handle.
  Returns C<AZ_OK> or error code. Note that this requires a
  seekable file handle; reading from a stream is not yet
  supported, but using in-memory data is.
  
      my $fh = IO::File->new( '/some/FileName.zip', 'r' );
      my $zip1 = Archive::Zip->new();
      my $status = $zip1->readFromFileHandle( $fh );
      my $zip2 = Archive::Zip->new();
      $status = $zip2->readFromFileHandle( $fh );
  
  Read zip using in-memory data (recursable):
  
      open my $fh, "<", "archive.zip" or die $!;
      my $zip_data = do { local $.; <$fh> };
      my $zip = Archive::Zip->new;
      open my $dh, "+<", \$zip_data;
      $zip->readFromFileHandle ($dh);
  
  =back
  
  =head2 Zip Archive Tree operations
  
  These used to be in Archive::Zip::Tree but got moved into
  Archive::Zip. They enable operation on an entire tree of members or
  files.
  A usage example:
  
    use Archive::Zip;
    my $zip = Archive::Zip->new();
  
    # add all readable files and directories below . as xyz/*
    $zip->addTree( '.', 'xyz' );
  
    # add all readable plain files below /abc as def/*
    $zip->addTree( '/abc', 'def', sub { -f && -r } );
  
    # add all .c files below /tmp as stuff/*
    $zip->addTreeMatching( '/tmp', 'stuff', '\.c$' );
  
    # add all .o files below /tmp as stuff/* if they aren't writable
    $zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { ! -w } );
  
    # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
    $zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { -s < 200 } );
  
    # and write them into a file
    $zip->writeToFileNamed('xxx.zip');
  
    # now extract the same files into /tmpx
    $zip->extractTree( 'stuff', '/tmpx' );
  
  =over 4
  
  =item $zip->addTree( $root, $dest [, $pred, $compressionLevel ] ) -- Add tree of files to a zip
  
  =item $zip->addTree( { root => $root, zipName => $dest [, select => $pred,
      compressionLevel => $compressionLevel ] )
  
  C<$root> is the root of the tree of files and directories to be
  added. It is a valid directory name on your system. C<$dest> is
  the name for the root in the zip file (undef or blank means
  to use relative pathnames). It is a valid ZIP directory name
  (that is, it uses forward slashes (/) for separating
  directory components). C<$pred> is an optional subroutine
  reference to select files: it is passed the name of the
  prospective file or directory using C<$_>, and if it returns
  true, the file or directory will be included. The default is
  to add all readable files and directories. For instance,
  using
  
    my $pred = sub { /\.txt/ };
    $zip->addTree( '.', '', $pred );
  
  will add all the .txt files in and below the current
  directory, using relative names, and making the names
  identical in the zipfile:
  
    original name           zip member name
    ./xyz                   xyz
    ./a/                    a/
    ./a/b                   a/b
  
  To translate absolute to relative pathnames, just pass them
  in: $zip->addTree( '/c/d', 'a' );
  
    original name           zip member name
    /c/d/xyz                a/xyz
    /c/d/a/                 a/a/
    /c/d/a/b                a/a/b
  
  Returns AZ_OK on success. Note that this will not follow
  symbolic links to directories. Note also that this does not
  check for the validity of filenames.
  
  Note that you generally I<don't> want to make zip archive member names
  absolute.
  
  =item $zip->addTreeMatching( $root, $dest, $pattern [, $pred, $compressionLevel ] )
  
  =item $zip->addTreeMatching( { root => $root, zipName => $dest, pattern =>
      $pattern [, select => $pred, compressionLevel => $compressionLevel ] } )
  
  $root is the root of the tree of files and directories to be
  added $dest is the name for the root in the zip file (undef
  means to use relative pathnames) $pattern is a (non-anchored)
  regular expression for filenames to match $pred is an
  optional subroutine reference to select files: it is passed
  the name of the prospective file or directory in C<$_>, and
  if it returns true, the file or directory will be included.
  The default is to add all readable files and directories. To
  add all files in and below the current directory whose names
  end in C<.pl>, and make them extract into a subdirectory
  named C<xyz>, do this:
  
    $zip->addTreeMatching( '.', 'xyz', '\.pl$' )
  
  To add all I<writable> files in and below the directory named
  C</abc> whose names end in C<.pl>, and make them extract into
  a subdirectory named C<xyz>, do this:
  
    $zip->addTreeMatching( '/abc', 'xyz', '\.pl$', sub { -w } )
  
  Returns AZ_OK on success. Note that this will not follow
  symbolic links to directories.
  
  =item $zip->updateTree( $root [, $dest , $pred , $mirror, $compressionLevel ] );
  
  =item $zip->updateTree( { root => $root [, zipName => $dest, select => $pred,
      mirror => $mirror, compressionLevel => $compressionLevel ] } );
  
  Update a zip file from a directory tree.
  
  C<updateTree()> takes the same arguments as C<addTree()>, but first
  checks to see whether the file or directory already exists in the zip
  file, and whether it has been changed.
  
  If the fourth argument C<$mirror> is true, then delete all my members
  if corresponding files were not found.
  
  Returns an error code or AZ_OK if all is well.
  
  =item $zip->extractTree( [ $root, $dest, $volume } ] )
  
  =item $zip->extractTree( [ { root => $root, zipName => $dest, volume => $volume } ] )
  
  If you don't give any arguments at all, will extract all the
  files in the zip with their original names.
  
  If you supply one argument for C<$root>, C<extractTree> will extract
  all the members whose names start with C<$root> into the current
  directory, stripping off C<$root> first.
  C<$root> is in Zip (Unix) format.
  For instance,
  
    $zip->extractTree( 'a' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  a/x as ./x
  
  a/b/c as ./b/c
  
  If you give two arguments, C<extractTree> extracts all the members
  whose names start with C<$root>. It will translate C<$root> into
  C<$dest> to construct the destination file name.
  C<$root> and C<$dest> are in Zip (Unix) format.
  For instance,
  
     $zip->extractTree( 'a', 'd/e' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  a/x to d/e/x
  
  a/b/c to d/e/b/c and ignore ax/d/e and d/e
  
  If you give three arguments, C<extractTree> extracts all the members
  whose names start with C<$root>. It will translate C<$root> into
  C<$dest> to construct the destination file name, and then it will
  convert to local file system format, using C<$volume> as the name of
  the destination volume.
  
  C<$root> and C<$dest> are in Zip (Unix) format.
  
  C<$volume> is in local file system format.
  
  For instance, under Windows,
  
     $zip->extractTree( 'a', 'd/e', 'f:' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  a/x to f:d/e/x
  
  a/b/c to f:d/e/b/c and ignore ax/d/e and d/e
  
  If you want absolute paths (the prior example used paths relative to
  the current directory on the destination volume, you can specify these
  in C<$dest>:
  
     $zip->extractTree( 'a', '/d/e', 'f:' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  a/x to f:\d\e\x
  
  a/b/c to f:\d\e\b\c and ignore ax/d/e and d/e
  
  Returns an error code or AZ_OK if everything worked OK.
  
  =back
  
  =head1 Archive::Zip Global Variables
  
  =over 4
  
  =item $Archive::Zip::UNICODE
  
  This variable governs how Unicode file and directory names are added
  to or extracted from an archive. If set, file and directory names are considered
  to be UTF-8 encoded. This is I<EXPERIMENTAL AND BUGGY (there are some edge cases
  on Win32)>. Please report problems.
  
      {
          local $Archive::Zip::UNICODE = 1;
          $zip->addFile('Dj vu.txt');
      }
  
  =back
  
  =head1 MEMBER OPERATIONS
  
  =head2 Member Class Methods
  
  Several constructors allow you to construct members without adding
  them to a zip archive. These work the same as the addFile(),
  addDirectory(), and addString() zip instance methods described above,
  but they don't add the new members to a zip.
  
  =over 4
  
  =item Archive::Zip::Member->newFromString( $stringOrStringRef [, $fileName ] )
  
  =item Archive::Zip::Member->newFromString( { string => $stringOrStringRef
      [, zipName => $fileName ] )
  
  Construct a new member from the given string. Returns undef
  on error.
  
      my $member = Archive::Zip::Member->newFromString( 'This is a test',
  
  =item newFromFile( $fileName [, $zipName ] )
  
  =item newFromFile( { filename => $fileName [, zipName => $zipName ] } )
  
  Construct a new member from the given file. Returns undef on
  error.
  
      my $member = Archive::Zip::Member->newFromFile( 'xyz.txt' );
  
  =item newDirectoryNamed( $directoryName [, $zipname ] )
  
  =item newDirectoryNamed( { directoryName => $directoryName
      [, zipName => $zipname ] } )
  
  Construct a new member from the given directory.
  C<$directoryName> must be a valid name on your file system; it does not
  have to exist.
  
  If given, C<$zipname> will be the name of the zip member; it must be a
  valid Zip (Unix) name. If not given, it will be converted from
  C<$directoryName>.
  
  Returns undef on error.
  
      my $member = Archive::Zip::Member->newDirectoryNamed( 'CVS/' );
  
  =back
  
  =head2 Member Simple accessors
  
  These methods get (and/or set) member attribute values.
  
  =over 4
  
  =item versionMadeBy()
  
  Gets the field from the member header.
  
  =item fileAttributeFormat( [ $format ] )
  
  =item fileAttributeFormat( [ { format => $format ] } )
  
  Gets or sets the field from the member header. These are
  C<FA_*> values.
  
  =item versionNeededToExtract()
  
  Gets the field from the member header.
  
  =item bitFlag()
  
  Gets the general purpose bit field from the member header.
  This is where the C<GPBF_*> bits live.
  
  =item compressionMethod()
  
  Returns the member compression method. This is the method
  that is currently being used to compress the member data.
  This will be COMPRESSION_STORED for added string or file
  members, or any of the C<COMPRESSION_*> values for members
  from a zip file. However, this module can only handle members
  whose data is in COMPRESSION_STORED or COMPRESSION_DEFLATED
  format.
  
  =item desiredCompressionMethod( [ $method ] )
  
  =item desiredCompressionMethod( [ { compressionMethod => $method } ] )
  
  Get or set the member's C<desiredCompressionMethod>. This is
  the compression method that will be used when the member is
  written. Returns prior desiredCompressionMethod. Only
  COMPRESSION_DEFLATED or COMPRESSION_STORED are valid
  arguments. Changing to COMPRESSION_STORED will change the
  member desiredCompressionLevel to 0; changing to
  COMPRESSION_DEFLATED will change the member
  desiredCompressionLevel to COMPRESSION_LEVEL_DEFAULT.
  
  =item desiredCompressionLevel( [ $level ] )
  
  =item desiredCompressionLevel( [ { compressionLevel => $level } ] )
  
  Get or set the member's desiredCompressionLevel This is the
  method that will be used to write. Returns prior
  desiredCompressionLevel. Valid arguments are 0 through 9,
  COMPRESSION_LEVEL_NONE, COMPRESSION_LEVEL_DEFAULT,
  COMPRESSION_LEVEL_BEST_COMPRESSION, and
  COMPRESSION_LEVEL_FASTEST. 0 or COMPRESSION_LEVEL_NONE will
  change the desiredCompressionMethod to COMPRESSION_STORED.
  All other arguments will change the desiredCompressionMethod
  to COMPRESSION_DEFLATED.
  
  =item externalFileName()
  
  Return the member's external file name, if any, or undef.
  
  =item fileName()
  
  Get or set the member's internal filename. Returns the
  (possibly new) filename. Names will have backslashes
  converted to forward slashes, and will have multiple
  consecutive slashes converted to single ones.
  
  =item lastModFileDateTime()
  
  Return the member's last modification date/time stamp in
  MS-DOS format.
  
  =item lastModTime()
  
  Return the member's last modification date/time stamp,
  converted to unix localtime format.
  
      print "Mod Time: " . scalar( localtime( $member->lastModTime() ) );
  
  =item setLastModFileDateTimeFromUnix()
  
  Set the member's lastModFileDateTime from the given unix
  time.
  
      $member->setLastModFileDateTimeFromUnix( time() );
  
  =item internalFileAttributes()
  
  Return the internal file attributes field from the zip
  header. This is only set for members read from a zip file.
  
  =item externalFileAttributes()
  
  Return member attributes as read from the ZIP file. Note that
  these are NOT UNIX!
  
  =item unixFileAttributes( [ $newAttributes ] )
  
  =item unixFileAttributes( [ { attributes => $newAttributes } ] )
  
  Get or set the member's file attributes using UNIX file
  attributes. Returns old attributes.
  
      my $oldAttribs = $member->unixFileAttributes( 0666 );
  
  Note that the return value has more than just the file
  permissions, so you will have to mask off the lowest bits for
  comparisons.
  
  =item localExtraField( [ $newField ] )
  
  =item localExtraField( [ { field => $newField } ] )
  
  Gets or sets the extra field that was read from the local
  header. This is not set for a member from a zip file until
  after the member has been written out. The extra field must
  be in the proper format.
  
  =item cdExtraField( [ $newField ] )
  
  =item cdExtraField( [ { field => $newField } ] )
  
  Gets or sets the extra field that was read from the central
  directory header. The extra field must be in the proper
  format.
  
  =item extraFields()
  
  Return both local and CD extra fields, concatenated.
  
  =item fileComment( [ $newComment ] )
  
  =item fileComment( [ { comment => $newComment } ] )
  
  Get or set the member's file comment.
  
  =item hasDataDescriptor()
  
  Get or set the data descriptor flag. If this is set, the
  local header will not necessarily have the correct data
  sizes. Instead, a small structure will be stored at the end
  of the member data with these values. This should be
  transparent in normal operation.
  
  =item crc32()
  
  Return the CRC-32 value for this member. This will not be set
  for members that were constructed from strings or external
  files until after the member has been written.
  
  =item crc32String()
  
  Return the CRC-32 value for this member as an 8 character
  printable hex string. This will not be set for members that
  were constructed from strings or external files until after
  the member has been written.
  
  =item compressedSize()
  
  Return the compressed size for this member. This will not be
  set for members that were constructed from strings or
  external files until after the member has been written.
  
  =item uncompressedSize()
  
  Return the uncompressed size for this member.
  
  =item password( [ $password ] )
  
  Returns the password for this member to be used on decryption.
  If $password is given, it will set the password for the decryption.
  
  =item isEncrypted()
  
  Return true if this member is encrypted. The Archive::Zip
  module does not currently support creation of encrypted
  members. Decryption works more or less like this:
  
    my $zip = Archive::Zip->new;
    $zip->read ("encrypted.zip");
    for my $m (map { $zip->memberNamed ($_) } $zip->memberNames) {
        $m->password ("secret");
        $m->contents;  # is "" when password was wrong
  
  That shows that the password has to be set per member, and not per
  archive. This might change in the future.
  
  =item isTextFile( [ $flag ] )
  
  =item isTextFile( [ { flag => $flag } ] )
  
  Returns true if I am a text file. Also can set the status if
  given an argument (then returns old state). Note that this
  module does not currently do anything with this flag upon
  extraction or storage. That is, bytes are stored in native
  format whether or not they came from a text file.
  
  =item isBinaryFile()
  
  Returns true if I am a binary file. Also can set the status
  if given an argument (then returns old state). Note that this
  module does not currently do anything with this flag upon
  extraction or storage. That is, bytes are stored in native
  format whether or not they came from a text file.
  
  =item extractToFileNamed( $fileName )
  
  =item extractToFileNamed( { name => $fileName } )
  
  Extract me to a file with the given name. The file will be
  created with default modes. Directories will be created as
  needed.
  The C<$fileName> argument should be a valid file name on your
  file system.
  Returns AZ_OK on success.
  
  =item isDirectory()
  
  Returns true if I am a directory.
  
  =item writeLocalHeaderRelativeOffset()
  
  Returns the file offset in bytes the last time I was written.
  
  =item wasWritten()
  
  Returns true if I was successfully written. Reset at the
  beginning of a write attempt.
  
  =back
  
  =head2 Low-level member data reading
  
  It is possible to use lower-level routines to access member data
  streams, rather than the extract* methods and contents(). For
  instance, here is how to print the uncompressed contents of a member
  in chunks using these methods:
  
      my ( $member, $status, $bufferRef );
      $member = $zip->memberNamed( 'xyz.txt' );
      $member->desiredCompressionMethod( COMPRESSION_STORED );
      $status = $member->rewindData();
      die "error $status" unless $status == AZ_OK;
      while ( ! $member->readIsDone() )
      {
      ( $bufferRef, $status ) = $member->readChunk();
      die "error $status"
                  if $status != AZ_OK && $status != AZ_STREAM_END;
      # do something with $bufferRef:
      print $$bufferRef;
      }
      $member->endRead();
  
  =over 4
  
  =item readChunk( [ $chunkSize ] )
  
  =item readChunk( [ { chunkSize => $chunkSize } ] )
  
  This reads the next chunk of given size from the member's
  data stream and compresses or uncompresses it as necessary,
  returning a reference to the bytes read and a status. If size
  argument is not given, defaults to global set by
  Archive::Zip::setChunkSize. Status is AZ_OK on success until
  the last chunk, where it returns AZ_STREAM_END. Returns C<(
  \$bytes, $status)>.
  
      my ( $outRef, $status ) = $self->readChunk();
      print $$outRef if $status != AZ_OK && $status != AZ_STREAM_END;
  
  =item rewindData()
  
  Rewind data and set up for reading data streams or writing
  zip files. Can take options for C<inflateInit()> or
  C<deflateInit()>, but this is not likely to be necessary.
  Subclass overrides should call this method. Returns C<AZ_OK>
  on success.
  
  =item endRead()
  
  Reset the read variables and free the inflater or deflater.
  Must be called to close files, etc. Returns AZ_OK on success.
  
  =item readIsDone()
  
  Return true if the read has run out of data or encountered an error.
  
  =item contents()
  
  Return the entire uncompressed member data or undef in scalar
  context. When called in array context, returns C<( $string,
  $status )>; status will be AZ_OK on success:
  
      my $string = $member->contents();
      # or
      my ( $string, $status ) = $member->contents();
      die "error $status" unless $status == AZ_OK;
  
  Can also be used to set the contents of a member (this may
  change the class of the member):
  
      $member->contents( "this is my new contents" );
  
  =item extractToFileHandle( $fh )
  
  =item extractToFileHandle( { fileHandle => $fh } )
  
  Extract (and uncompress, if necessary) the member's contents
  to the given file handle. Return AZ_OK on success.
  
  =back
  
  =head1 Archive::Zip::FileMember methods
  
  The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the
  base class for both ZipFileMember and NewFileMember classes. This class adds
  an C<externalFileName> and an C<fh> member to keep track of the external
  file.
  
  =over 4
  
  =item externalFileName()
  
  Return the member's external filename.
  
  =item fh()
  
  Return the member's read file handle. Automatically opens file if
  necessary.
  
  =back
  
  =head1 Archive::Zip::ZipFileMember methods
  
  The Archive::Zip::ZipFileMember class represents members that have been read
  from external zip files.
  
  =over 4
  
  =item diskNumberStart()
  
  Returns the disk number that the member's local header resides in.
  Should be 0.
  
  =item localHeaderRelativeOffset()
  
  Returns the offset into the zip file where the member's local header
  is.
  
  =item dataOffset()
  
  Returns the offset from the beginning of the zip file to the member's
  data.
  
  =back
  
  =head1 REQUIRED MODULES
  
  L<Archive::Zip> requires several other modules:
  
  L<Carp>
  
  L<Compress::Raw::Zlib>
  
  L<Cwd>
  
  L<File::Basename>
  
  L<File::Copy>
  
  L<File::Find>
  
  L<File::Path>
  
  L<File::Spec>
  
  L<IO::File>
  
  L<IO::Seekable>
  
  L<Time::Local>
  
  =head1 BUGS AND CAVEATS
  
  =head2 When not to use Archive::Zip
  
  If you are just going to be extracting zips (and/or other archives) you
  are recommended to look at using L<Archive::Extract> instead, as it is much
  easier to use and factors out archive-specific functionality.
  
  =head2 Try to avoid IO::Scalar
  
  One of the most common ways to use Archive::Zip is to generate Zip files
  in-memory. Most people use L<IO::Scalar> for this purpose.
  
  Unfortunately, as of 1.11 this module no longer works with L<IO::Scalar>
  as it incorrectly implements seeking.
  
  Anybody using L<IO::Scalar> should consider porting to L<IO::String>,
  which is smaller, lighter, and is implemented to be perfectly compatible
  with regular seekable filehandles.
  
  Support for L<IO::Scalar> most likely will B<not> be restored in the
  future, as L<IO::Scalar> itself cannot change the way it is implemented
  due to back-compatibility issues.
  
  =head2 Wrong password for encrypted members
  
  When an encrypted member is read using the wrong password, you currently
  have to re-read the entire archive to try again with the correct password.
  
  =head1 TO DO
  
  * auto-choosing storing vs compression
  
  * extra field hooks (see notes.txt)
  
  * check for duplicates on addition/renaming?
  
  * Text file extraction (line end translation)
  
  * Reading zip files from non-seekable inputs
    (Perhaps by proxying through IO::String?)
  
  * separate unused constants into separate module
  
  * cookbook style docs
  
  * Handle tainted paths correctly
  
  * Work on better compatibility with other IO:: modules
  
  * Support encryption
  
  * More user-friendly decryption
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive-Zip>
  
  For other issues contact the maintainer
  
  =head1 AUTHOR
  
  Currently maintained by Fred Moyer <fred@redhotpenguin.com>
  
  Previously maintained by Adam Kennedy <adamk@cpan.org>
  
  Previously maintained by Steve Peters E<lt>steve@fisharerojo.orgE<gt>.
  
  File attributes code by Maurice Aubrey E<lt>maurice@lovelyfilth.comE<gt>.
  
  Originally by Ned Konz E<lt>nedkonz@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  Some parts copyright 2006 - 2012 Adam Kennedy.
  
  Some parts copyright 2005 Steve Peters.
  
  Original work copyright 2000 - 2004 Ned Konz.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  Look at L<Archive::Zip::MemberRead> which is a wrapper that allows one to
  read Zip archive members as if they were files.
  
  L<Compress::Raw::Zlib>, L<Archive::Tar>, L<Archive::Extract>
  
  =cut
ARCHIVE_ZIP

$fatpacked{"Archive/Zip/Archive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_ARCHIVE';
  package Archive::Zip::Archive;
  
  # Represents a generic ZIP archive
  
  use strict;
  use File::Path;
  use File::Find ();
  use File::Spec ();
  use File::Copy ();
  use File::Basename;
  use Cwd;
  use Encode qw(encode_utf8 decode_utf8);
  
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw( Archive::Zip );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
    :PKZIP_CONSTANTS
    :UTILITY_METHODS
  );
  
  our $UNICODE;
  
  # Note that this returns undef on read errors, else new zip object.
  
  sub new {
      my $class = shift;
      my $self  = bless(
          {
              'diskNumber'                            => 0,
              'diskNumberWithStartOfCentralDirectory' => 0,
              'numberOfCentralDirectoriesOnThisDisk' =>
                0,    # should be # of members
              'numberOfCentralDirectories' => 0,    # should be # of members
              'centralDirectorySize'       => 0,    # must re-compute on write
              'centralDirectoryOffsetWRTStartingDiskNumber' =>
                0,                                  # must re-compute
              'writeEOCDOffset'             => 0,
              'writeCentralDirectoryOffset' => 0,
              'zipfileComment'              => '',
              'eocdOffset'                  => 0,
              'fileName'                    => ''
          },
          $class
      );
      $self->{'members'} = [];
      my $fileName = (ref($_[0]) eq 'HASH') ? shift->{filename} : shift;
      if ($fileName) {
          my $status = $self->read($fileName);
          return $status == AZ_OK ? $self : undef;
      }
      return $self;
  }
  
  sub storeSymbolicLink {
      my $self = shift;
      $self->{'storeSymbolicLink'} = shift;
  }
  
  sub members {
      @{shift->{'members'}};
  }
  
  sub numberOfMembers {
      scalar(shift->members());
  }
  
  sub memberNames {
      my $self = shift;
      return map { $_->fileName() } $self->members();
  }
  
  # return ref to member with given name or undef
  sub memberNamed {
      my $self = shift;
      my $fileName = (ref($_[0]) eq 'HASH') ? shift->{zipName} : shift;
      foreach my $member ($self->members()) {
          return $member if $member->fileName() eq $fileName;
      }
      return undef;
  }
  
  sub membersMatching {
      my $self = shift;
      my $pattern = (ref($_[0]) eq 'HASH') ? shift->{regex} : shift;
      return grep { $_->fileName() =~ /$pattern/ } $self->members();
  }
  
  sub diskNumber {
      shift->{'diskNumber'};
  }
  
  sub diskNumberWithStartOfCentralDirectory {
      shift->{'diskNumberWithStartOfCentralDirectory'};
  }
  
  sub numberOfCentralDirectoriesOnThisDisk {
      shift->{'numberOfCentralDirectoriesOnThisDisk'};
  }
  
  sub numberOfCentralDirectories {
      shift->{'numberOfCentralDirectories'};
  }
  
  sub centralDirectorySize {
      shift->{'centralDirectorySize'};
  }
  
  sub centralDirectoryOffsetWRTStartingDiskNumber {
      shift->{'centralDirectoryOffsetWRTStartingDiskNumber'};
  }
  
  sub zipfileComment {
      my $self    = shift;
      my $comment = $self->{'zipfileComment'};
      if (@_) {
          my $new_comment = (ref($_[0]) eq 'HASH') ? shift->{comment} : shift;
          $self->{'zipfileComment'} = pack('C0a*', $new_comment);  # avoid Unicode
      }
      return $comment;
  }
  
  sub eocdOffset {
      shift->{'eocdOffset'};
  }
  
  # Return the name of the file last read.
  sub fileName {
      shift->{'fileName'};
  }
  
  sub removeMember {
      my $self = shift;
      my $member = (ref($_[0]) eq 'HASH') ? shift->{memberOrZipName} : shift;
      $member = $self->memberNamed($member) unless ref($member);
      return undef unless $member;
      my @newMembers = grep { $_ != $member } $self->members();
      $self->{'members'} = \@newMembers;
      return $member;
  }
  
  sub replaceMember {
      my $self = shift;
  
      my ($oldMember, $newMember);
      if (ref($_[0]) eq 'HASH') {
          $oldMember = $_[0]->{memberOrZipName};
          $newMember = $_[0]->{newMember};
      } else {
          ($oldMember, $newMember) = @_;
      }
  
      $oldMember = $self->memberNamed($oldMember) unless ref($oldMember);
      return undef unless $oldMember;
      return undef unless $newMember;
      my @newMembers =
        map { ($_ == $oldMember) ? $newMember : $_ } $self->members();
      $self->{'members'} = \@newMembers;
      return $oldMember;
  }
  
  sub extractMember {
      my $self = shift;
  
      my ($member, $name);
      if (ref($_[0]) eq 'HASH') {
          $member = $_[0]->{memberOrZipName};
          $name   = $_[0]->{name};
      } else {
          ($member, $name) = @_;
      }
  
      $member = $self->memberNamed($member) unless ref($member);
      return _error('member not found') unless $member;
      my $originalSize = $member->compressedSize();
      my ($volumeName, $dirName, $fileName);
      if (defined($name)) {
          ($volumeName, $dirName, $fileName) = File::Spec->splitpath($name);
          $dirName = File::Spec->catpath($volumeName, $dirName, '');
      } else {
          $name = $member->fileName();
          ($dirName = $name) =~ s{[^/]*$}{};
          $dirName = Archive::Zip::_asLocalName($dirName);
          $name    = Archive::Zip::_asLocalName($name);
      }
      if ($dirName && !-d $dirName) {
          mkpath($dirName);
          return _ioError("can't create dir $dirName") if (!-d $dirName);
      }
      my $rc = $member->extractToFileNamed($name, @_);
  
      # TODO refactor this fix into extractToFileNamed()
      $member->{'compressedSize'} = $originalSize;
      return $rc;
  }
  
  sub extractMemberWithoutPaths {
      my $self = shift;
  
      my ($member, $name);
      if (ref($_[0]) eq 'HASH') {
          $member = $_[0]->{memberOrZipName};
          $name   = $_[0]->{name};
      } else {
          ($member, $name) = @_;
      }
  
      $member = $self->memberNamed($member) unless ref($member);
      return _error('member not found') unless $member;
      my $originalSize = $member->compressedSize();
      return AZ_OK if $member->isDirectory();
      unless ($name) {
          $name = $member->fileName();
          $name =~ s{.*/}{};    # strip off directories, if any
          $name = Archive::Zip::_asLocalName($name);
      }
      my $rc = $member->extractToFileNamed($name, @_);
      $member->{'compressedSize'} = $originalSize;
      return $rc;
  }
  
  sub addMember {
      my $self = shift;
      my $newMember = (ref($_[0]) eq 'HASH') ? shift->{member} : shift;
      push(@{$self->{'members'}}, $newMember) if $newMember;
      if($newMember && ($newMember->{bitFlag} & 0x800) 
                    && !utf8::is_utf8($newMember->{fileName})){
          $newMember->{fileName} = Encode::decode_utf8( $newMember->{fileName} );
      }
      return $newMember;
  }
  
  sub addFile {
      my $self = shift;
  
      my ($fileName, $newName, $compressionLevel);
      if (ref($_[0]) eq 'HASH') {
          $fileName         = $_[0]->{filename};
          $newName          = $_[0]->{zipName};
          $compressionLevel = $_[0]->{compressionLevel};
      } else {
          ($fileName, $newName, $compressionLevel) = @_;
      }
  
      if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
          $fileName = Win32::GetANSIPathName($fileName);
      }
  
      my $newMember = Archive::Zip::Member->newFromFile($fileName, $newName);
      $newMember->desiredCompressionLevel($compressionLevel);
      if ($self->{'storeSymbolicLink'} && -l $fileName) {
          my $newMember =
            Archive::Zip::Member->newFromString(readlink $fileName, $newName);
  
    # For symbolic links, External File Attribute is set to 0xA1FF0000 by Info-ZIP
          $newMember->{'externalFileAttributes'} = 0xA1FF0000;
          $self->addMember($newMember);
      } else {
          $self->addMember($newMember);
      }
      
      return $newMember;
  }
  
  sub addString {
      my $self = shift;
  
      my ($stringOrStringRef, $name, $compressionLevel);
      if (ref($_[0]) eq 'HASH') {
          $stringOrStringRef = $_[0]->{string};
          $name              = $_[0]->{zipName};
          $compressionLevel  = $_[0]->{compressionLevel};
      } else {
          ($stringOrStringRef, $name, $compressionLevel) = @_;
      }
  
      my $newMember =
        Archive::Zip::Member->newFromString($stringOrStringRef, $name);
      $newMember->desiredCompressionLevel($compressionLevel);
      return $self->addMember($newMember);
  }
  
  sub addDirectory {
      my $self = shift;
  
      my ($name, $newName);
      if (ref($_[0]) eq 'HASH') {
          $name    = $_[0]->{directoryName};
          $newName = $_[0]->{zipName};
      } else {
          ($name, $newName) = @_;
      }
  
      if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
          $name = Win32::GetANSIPathName($name);
      }
  
      my $newMember = Archive::Zip::Member->newDirectoryNamed($name, $newName);
      if ($self->{'storeSymbolicLink'} && -l $name) {
          my $link = readlink $name;
          ($newName =~ s{/$}{}) if $newName;    # Strip trailing /
          my $newMember = Archive::Zip::Member->newFromString($link, $newName);
  
    # For symbolic links, External File Attribute is set to 0xA1FF0000 by Info-ZIP
          $newMember->{'externalFileAttributes'} = 0xA1FF0000;
          $self->addMember($newMember);
      } else {
          $self->addMember($newMember);
      }
      
      return $newMember;
  }
  
  # add either a file or a directory.
  
  sub addFileOrDirectory {
      my $self = shift;
  
      my ($name, $newName, $compressionLevel);
      if (ref($_[0]) eq 'HASH') {
          $name             = $_[0]->{name};
          $newName          = $_[0]->{zipName};
          $compressionLevel = $_[0]->{compressionLevel};
      } else {
          ($name, $newName, $compressionLevel) = @_;
      }
  
      if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
          $name = Win32::GetANSIPathName($name);
      }
  
      $name =~ s{/$}{};
      if ($newName) {
          $newName =~ s{/$}{};
      } else {
          $newName = $name;
      }
      if (-f $name) {
          return $self->addFile($name, $newName, $compressionLevel);
      } elsif (-d $name) {
          return $self->addDirectory($name, $newName);
      } else {
          return _error("$name is neither a file nor a directory");
      }
  }
  
  sub contents {
      my $self = shift;
  
      my ($member, $newContents);
      if (ref($_[0]) eq 'HASH') {
          $member      = $_[0]->{memberOrZipName};
          $newContents = $_[0]->{contents};
      } else {
          ($member, $newContents) = @_;
      }
  
      return _error('No member name given') unless $member;
      $member = $self->memberNamed($member) unless ref($member);
      return undef unless $member;
      return $member->contents($newContents);
  }
  
  sub writeToFileNamed {
      my $self = shift;
      my $fileName =
        (ref($_[0]) eq 'HASH') ? shift->{filename} : shift;    # local FS format
      foreach my $member ($self->members()) {
          if ($member->_usesFileNamed($fileName)) {
              return _error("$fileName is needed by member "
                    . $member->fileName()
                    . "; consider using overwrite() or overwriteAs() instead.");
          }
      }
      my ($status, $fh) = _newFileHandle($fileName, 'w');
      return _ioError("Can't open $fileName for write") unless $status;
      my $retval = $self->writeToFileHandle($fh, 1);
      $fh->close();
      $fh = undef;
  
      return $retval;
  }
  
  # It is possible to write data to the FH before calling this,
  # perhaps to make a self-extracting archive.
  sub writeToFileHandle {
      my $self = shift;
  
      my ($fh, $fhIsSeekable);
      if (ref($_[0]) eq 'HASH') {
          $fh = $_[0]->{fileHandle};
          $fhIsSeekable =
            exists($_[0]->{seek}) ? $_[0]->{seek} : _isSeekable($fh);
      } else {
          $fh = shift;
          $fhIsSeekable = @_ ? shift : _isSeekable($fh);
      }
  
      return _error('No filehandle given')   unless $fh;
      return _ioError('filehandle not open') unless $fh->opened();
      _binmode($fh);
  
      # Find out where the current position is.
      my $offset = $fhIsSeekable ? $fh->tell() : 0;
      $offset = 0 if $offset < 0;
  
      foreach my $member ($self->members()) {
          my $retval = $member->_writeToFileHandle($fh, $fhIsSeekable, $offset);
          $member->endRead();
          return $retval if $retval != AZ_OK;
          $offset += $member->_localHeaderSize() + $member->_writeOffset();
          $offset +=
            $member->hasDataDescriptor()
            ? DATA_DESCRIPTOR_LENGTH + SIGNATURE_LENGTH
            : 0;
  
          # changed this so it reflects the last successful position
          $self->{'writeCentralDirectoryOffset'} = $offset;
      }
      return $self->writeCentralDirectory($fh);
  }
  
  # Write zip back to the original file,
  # as safely as possible.
  # Returns AZ_OK if successful.
  sub overwrite {
      my $self = shift;
      return $self->overwriteAs($self->{'fileName'});
  }
  
  # Write zip to the specified file,
  # as safely as possible.
  # Returns AZ_OK if successful.
  sub overwriteAs {
      my $self = shift;
      my $zipName = (ref($_[0]) eq 'HASH') ? $_[0]->{filename} : shift;
      return _error("no filename in overwriteAs()") unless defined($zipName);
  
      my ($fh, $tempName) = Archive::Zip::tempFile();
      return _error("Can't open temp file", $!) unless $fh;
  
      (my $backupName = $zipName) =~ s{(\.[^.]*)?$}{.zbk};
  
      my $status = $self->writeToFileHandle($fh);
      $fh->close();
      $fh = undef;
  
      if ($status != AZ_OK) {
          unlink($tempName);
          _printError("Can't write to $tempName");
          return $status;
      }
  
      my $err;
  
      # rename the zip
      if (-f $zipName && !rename($zipName, $backupName)) {
          $err = $!;
          unlink($tempName);
          return _error("Can't rename $zipName as $backupName", $err);
      }
  
      # move the temp to the original name (possibly copying)
      unless (File::Copy::move($tempName, $zipName)
          || File::Copy::copy($tempName, $zipName)) {
          $err = $!;
          rename($backupName, $zipName);
          unlink($tempName);
          return _error("Can't move $tempName to $zipName", $err);
      }
  
      # unlink the backup
      if (-f $backupName && !unlink($backupName)) {
          $err = $!;
          return _error("Can't unlink $backupName", $err);
      }
  
      return AZ_OK;
  }
  
  # Used only during writing
  sub _writeCentralDirectoryOffset {
      shift->{'writeCentralDirectoryOffset'};
  }
  
  sub _writeEOCDOffset {
      shift->{'writeEOCDOffset'};
  }
  
  # Expects to have _writeEOCDOffset() set
  sub _writeEndOfCentralDirectory {
      my ($self, $fh) = @_;
  
      $self->_print($fh, END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING)
        or return _ioError('writing EOCD Signature');
      my $zipfileCommentLength = length($self->zipfileComment());
  
      my $header = pack(
          END_OF_CENTRAL_DIRECTORY_FORMAT,
          0,                          # {'diskNumber'},
          0,                          # {'diskNumberWithStartOfCentralDirectory'},
          $self->numberOfMembers(),   # {'numberOfCentralDirectoriesOnThisDisk'},
          $self->numberOfMembers(),   # {'numberOfCentralDirectories'},
          $self->_writeEOCDOffset() - $self->_writeCentralDirectoryOffset(),
          $self->_writeCentralDirectoryOffset(),
          $zipfileCommentLength
      );
      $self->_print($fh, $header)
        or return _ioError('writing EOCD header');
      if ($zipfileCommentLength) {
          $self->_print($fh, $self->zipfileComment())
            or return _ioError('writing zipfile comment');
      }
      return AZ_OK;
  }
  
  # $offset can be specified to truncate a zip file.
  sub writeCentralDirectory {
      my $self = shift;
  
      my ($fh, $offset);
      if (ref($_[0]) eq 'HASH') {
          $fh     = $_[0]->{fileHandle};
          $offset = $_[0]->{offset};
      } else {
          ($fh, $offset) = @_;
      }
  
      if (defined($offset)) {
          $self->{'writeCentralDirectoryOffset'} = $offset;
          $fh->seek($offset, IO::Seekable::SEEK_SET)
            or return _ioError('seeking to write central directory');
      } else {
          $offset = $self->_writeCentralDirectoryOffset();
      }
  
      foreach my $member ($self->members()) {
          my $status = $member->_writeCentralDirectoryFileHeader($fh);
          return $status if $status != AZ_OK;
          $offset += $member->_centralDirectoryHeaderSize();
          $self->{'writeEOCDOffset'} = $offset;
      }
      return $self->_writeEndOfCentralDirectory($fh);
  }
  
  sub read {
      my $self = shift;
      my $fileName = (ref($_[0]) eq 'HASH') ? shift->{filename} : shift;
      return _error('No filename given') unless $fileName;
      my ($status, $fh) = _newFileHandle($fileName, 'r');
      return _ioError("opening $fileName for read") unless $status;
  
      $status = $self->readFromFileHandle($fh, $fileName);
      return $status if $status != AZ_OK;
  
      $fh->close();
      $self->{'fileName'} = $fileName;
      return AZ_OK;
  }
  
  sub readFromFileHandle {
      my $self = shift;
  
      my ($fh, $fileName);
      if (ref($_[0]) eq 'HASH') {
          $fh       = $_[0]->{fileHandle};
          $fileName = $_[0]->{filename};
      } else {
          ($fh, $fileName) = @_;
      }
  
      $fileName = $fh unless defined($fileName);
      return _error('No filehandle given')   unless $fh;
      return _ioError('filehandle not open') unless $fh->opened();
  
      _binmode($fh);
      $self->{'fileName'} = "$fh";
  
      # TODO: how to support non-seekable zips?
      return _error('file not seekable')
        unless _isSeekable($fh);
  
      $fh->seek(0, 0);    # rewind the file
  
      my $status = $self->_findEndOfCentralDirectory($fh);
      return $status if $status != AZ_OK;
  
      my $eocdPosition = $fh->tell();
  
      $status = $self->_readEndOfCentralDirectory($fh);
      return $status if $status != AZ_OK;
  
      $fh->seek($eocdPosition - $self->centralDirectorySize(),
          IO::Seekable::SEEK_SET)
        or return _ioError("Can't seek $fileName");
  
      # Try to detect garbage at beginning of archives
      # This should be 0
      $self->{'eocdOffset'} = $eocdPosition - $self->centralDirectorySize() # here
        - $self->centralDirectoryOffsetWRTStartingDiskNumber();
  
      for (; ;) {
          my $newMember =
            Archive::Zip::Member->_newFromZipFile($fh, $fileName,
              $self->eocdOffset());
          my $signature;
          ($status, $signature) = _readSignature($fh, $fileName);
          return $status if $status != AZ_OK;
          last if $signature == END_OF_CENTRAL_DIRECTORY_SIGNATURE;
          $status = $newMember->_readCentralDirectoryFileHeader();
          return $status if $status != AZ_OK;
          $status = $newMember->endRead();
          return $status if $status != AZ_OK;
          $newMember->_becomeDirectoryIfNecessary();
  
          if(($newMember->{bitFlag} & 0x800) && !utf8::is_utf8($newMember->{fileName})){
              $newMember->{fileName} = Encode::decode_utf8($newMember->{fileName});
          }
          
          push(@{$self->{'members'}}, $newMember);
      }
  
      return AZ_OK;
  }
  
  # Read EOCD, starting from position before signature.
  # Return AZ_OK on success.
  sub _readEndOfCentralDirectory {
      my $self = shift;
      my $fh   = shift;
  
      # Skip past signature
      $fh->seek(SIGNATURE_LENGTH, IO::Seekable::SEEK_CUR)
        or return _ioError("Can't seek past EOCD signature");
  
      my $header = '';
      my $bytesRead = $fh->read($header, END_OF_CENTRAL_DIRECTORY_LENGTH);
      if ($bytesRead != END_OF_CENTRAL_DIRECTORY_LENGTH) {
          return _ioError("reading end of central directory");
      }
  
      my $zipfileCommentLength;
      (
          $self->{'diskNumber'},
          $self->{'diskNumberWithStartOfCentralDirectory'},
          $self->{'numberOfCentralDirectoriesOnThisDisk'},
          $self->{'numberOfCentralDirectories'},
          $self->{'centralDirectorySize'},
          $self->{'centralDirectoryOffsetWRTStartingDiskNumber'},
          $zipfileCommentLength
      ) = unpack(END_OF_CENTRAL_DIRECTORY_FORMAT, $header);
  
      if ($self->{'diskNumber'} == 0xFFFF ||
             $self->{'diskNumberWithStartOfCentralDirectory'} == 0xFFFF ||
             $self->{'numberOfCentralDirectoriesOnThisDisk'} == 0xFFFF ||
             $self->{'numberOfCentralDirectories'} == 0xFFFF ||
             $self->{'centralDirectorySize'} == 0xFFFFFFFF ||
             $self->{'centralDirectoryOffsetWRTStartingDiskNumber'} == 0xFFFFFFFF) {
          return _formatError("zip64 not supported" . Dumper($self));
      }
  use Data::Dumper;
      if ($zipfileCommentLength) {
          my $zipfileComment = '';
          $bytesRead = $fh->read($zipfileComment, $zipfileCommentLength);
          if ($bytesRead != $zipfileCommentLength) {
              return _ioError("reading zipfile comment");
          }
          $self->{'zipfileComment'} = $zipfileComment;
      }
  
      return AZ_OK;
  }
  
  # Seek in my file to the end, then read backwards until we find the
  # signature of the central directory record. Leave the file positioned right
  # before the signature. Returns AZ_OK if success.
  sub _findEndOfCentralDirectory {
      my $self = shift;
      my $fh   = shift;
      my $data = '';
      $fh->seek(0, IO::Seekable::SEEK_END)
        or return _ioError("seeking to end");
  
      my $fileLength = $fh->tell();
      if ($fileLength < END_OF_CENTRAL_DIRECTORY_LENGTH + 4) {
          return _formatError("file is too short");
      }
  
      my $seekOffset = 0;
      my $pos        = -1;
      for (; ;) {
          $seekOffset += 512;
          $seekOffset = $fileLength if ($seekOffset > $fileLength);
          $fh->seek(-$seekOffset, IO::Seekable::SEEK_END)
            or return _ioError("seek failed");
          my $bytesRead = $fh->read($data, $seekOffset);
          if ($bytesRead != $seekOffset) {
              return _ioError("read failed");
          }
          $pos = rindex($data, END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING);
          last
            if ( $pos >= 0
              or $seekOffset == $fileLength
              or $seekOffset >= $Archive::Zip::ChunkSize);
      }
  
      if ($pos >= 0) {
          $fh->seek($pos - $seekOffset, IO::Seekable::SEEK_CUR)
            or return _ioError("seeking to EOCD");
          return AZ_OK;
      } else {
          return _formatError("can't find EOCD signature");
      }
  }
  
  # Used to avoid taint problems when chdir'ing.
  # Not intended to increase security in any way; just intended to shut up the -T
  # complaints.  If your Cwd module is giving you unreliable returns from cwd()
  # you have bigger problems than this.
  sub _untaintDir {
      my $dir = shift;
      $dir =~ m/\A(.+)\z/s;
      return $1;
  }
  
  sub addTree {
      my $self = shift;
  
      my ($root, $dest, $pred, $compressionLevel);
      if (ref($_[0]) eq 'HASH') {
          $root             = $_[0]->{root};
          $dest             = $_[0]->{zipName};
          $pred             = $_[0]->{select};
          $compressionLevel = $_[0]->{compressionLevel};
      } else {
          ($root, $dest, $pred, $compressionLevel) = @_;
      }
  
      return _error("root arg missing in call to addTree()")
        unless defined($root);
      $dest = '' unless defined($dest);
      $pred = sub { -r }
        unless defined($pred);
  
      my @files;
      my $startDir = _untaintDir(cwd());
  
      return _error('undef returned by _untaintDir on cwd ', cwd())
        unless $startDir;
  
      # This avoids chdir'ing in Find, in a way compatible with older
      # versions of File::Find.
      my $wanted = sub {
          local $main::_ = $File::Find::name;
          my $dir = _untaintDir($File::Find::dir);
          chdir($startDir);
          if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
              push(@files, Win32::GetANSIPathName($File::Find::name)) if (&$pred);
              $dir = Win32::GetANSIPathName($dir);
          } else {
              push(@files, $File::Find::name) if (&$pred);
          }
          chdir($dir);
      };
  
      if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
          $root = Win32::GetANSIPathName($root);
      }
      File::Find::find($wanted, $root);
  
      my $rootZipName = _asZipDirName($root, 1);    # with trailing slash
      my $pattern = $rootZipName eq './' ? '^' : "^\Q$rootZipName\E";
  
      $dest = _asZipDirName($dest, 1);              # with trailing slash
  
      foreach my $fileName (@files) {
          my $isDir;
          if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
              $isDir = -d Win32::GetANSIPathName($fileName);
          } else {
              $isDir = -d $fileName;
          }
  
          # normalize, remove leading ./
          my $archiveName = _asZipDirName($fileName, $isDir);
          if ($archiveName eq $rootZipName) { $archiveName = $dest }
          else                              { $archiveName =~ s{$pattern}{$dest} }
          next if $archiveName =~ m{^\.?/?$};    # skip current dir
          my $member =
              $isDir
            ? $self->addDirectory($fileName, $archiveName)
            : $self->addFile($fileName, $archiveName);
          $member->desiredCompressionLevel($compressionLevel);
  
          return _error("add $fileName failed in addTree()") if !$member;
      }
      return AZ_OK;
  }
  
  sub addTreeMatching {
      my $self = shift;
  
      my ($root, $dest, $pattern, $pred, $compressionLevel);
      if (ref($_[0]) eq 'HASH') {
          $root             = $_[0]->{root};
          $dest             = $_[0]->{zipName};
          $pattern          = $_[0]->{pattern};
          $pred             = $_[0]->{select};
          $compressionLevel = $_[0]->{compressionLevel};
      } else {
          ($root, $dest, $pattern, $pred, $compressionLevel) = @_;
      }
  
      return _error("root arg missing in call to addTreeMatching()")
        unless defined($root);
      $dest = '' unless defined($dest);
      return _error("pattern missing in call to addTreeMatching()")
        unless defined($pattern);
      my $matcher =
        $pred ? sub { m{$pattern} && &$pred } : sub { m{$pattern} && -r };
      return $self->addTree($root, $dest, $matcher, $compressionLevel);
  }
  
  # $zip->extractTree( $root, $dest [, $volume] );
  #
  # $root and $dest are Unix-style.
  # $volume is in local FS format.
  #
  sub extractTree {
      my $self = shift;
  
      my ($root, $dest, $volume);
      if (ref($_[0]) eq 'HASH') {
          $root   = $_[0]->{root};
          $dest   = $_[0]->{zipName};
          $volume = $_[0]->{volume};
      } else {
          ($root, $dest, $volume) = @_;
      }
  
      $root = '' unless defined($root);
      if (defined $dest) {
          if ($dest !~ m{/$}) {
              $dest .= '/';
          }
      } else {
          $dest = './';
      }
  
      my $pattern = "^\Q$root";
      my @members = $self->membersMatching($pattern);
  
      foreach my $member (@members) {
          my $fileName = $member->fileName();    # in Unix format
          $fileName =~ s{$pattern}{$dest};       # in Unix format
                                                 # convert to platform format:
          $fileName = Archive::Zip::_asLocalName($fileName, $volume);
          my $status = $member->extractToFileNamed($fileName);
          return $status if $status != AZ_OK;
      }
      return AZ_OK;
  }
  
  # $zip->updateMember( $memberOrName, $fileName );
  # Returns (possibly updated) member, if any; undef on errors.
  
  sub updateMember {
      my $self = shift;
  
      my ($oldMember, $fileName);
      if (ref($_[0]) eq 'HASH') {
          $oldMember = $_[0]->{memberOrZipName};
          $fileName  = $_[0]->{name};
      } else {
          ($oldMember, $fileName) = @_;
      }
  
      if (!defined($fileName)) {
          _error("updateMember(): missing fileName argument");
          return undef;
      }
  
      my @newStat = stat($fileName);
      if (!@newStat) {
          _ioError("Can't stat $fileName");
          return undef;
      }
  
      my $isDir = -d _;
  
      my $memberName;
  
      if (ref($oldMember)) {
          $memberName = $oldMember->fileName();
      } else {
          $oldMember = $self->memberNamed($memberName = $oldMember)
            || $self->memberNamed($memberName =
                _asZipDirName($oldMember, $isDir));
      }
  
      unless (defined($oldMember)
          && $oldMember->lastModTime() == $newStat[9]
          && $oldMember->isDirectory() == $isDir
          && ($isDir || ($oldMember->uncompressedSize() == $newStat[7]))) {
  
          # create the new member
          my $newMember =
              $isDir
            ? Archive::Zip::Member->newDirectoryNamed($fileName, $memberName)
            : Archive::Zip::Member->newFromFile($fileName, $memberName);
  
          unless (defined($newMember)) {
              _error("creation of member $fileName failed in updateMember()");
              return undef;
          }
  
          # replace old member or append new one
          if (defined($oldMember)) {
              $self->replaceMember($oldMember, $newMember);
          } else {
              $self->addMember($newMember);
          }
  
          return $newMember;
      }
  
      return $oldMember;
  }
  
  # $zip->updateTree( $root, [ $dest, [ $pred [, $mirror]]] );
  #
  # This takes the same arguments as addTree, but first checks to see
  # whether the file or directory already exists in the zip file.
  #
  # If the fourth argument $mirror is true, then delete all my members
  # if corresponding files were not found.
  
  sub updateTree {
      my $self = shift;
  
      my ($root, $dest, $pred, $mirror, $compressionLevel);
      if (ref($_[0]) eq 'HASH') {
          $root             = $_[0]->{root};
          $dest             = $_[0]->{zipName};
          $pred             = $_[0]->{select};
          $mirror           = $_[0]->{mirror};
          $compressionLevel = $_[0]->{compressionLevel};
      } else {
          ($root, $dest, $pred, $mirror, $compressionLevel) = @_;
      }
  
      return _error("root arg missing in call to updateTree()")
        unless defined($root);
      $dest = '' unless defined($dest);
      $pred = sub { -r }
        unless defined($pred);
  
      $dest = _asZipDirName($dest, 1);
      my $rootZipName = _asZipDirName($root, 1);    # with trailing slash
      my $pattern = $rootZipName eq './' ? '^' : "^\Q$rootZipName\E";
  
      my @files;
      my $startDir = _untaintDir(cwd());
  
      return _error('undef returned by _untaintDir on cwd ', cwd())
        unless $startDir;
  
      # This avoids chdir'ing in Find, in a way compatible with older
      # versions of File::Find.
      my $wanted = sub {
          local $main::_ = $File::Find::name;
          my $dir = _untaintDir($File::Find::dir);
          chdir($startDir);
          push(@files, $File::Find::name) if (&$pred);
          chdir($dir);
      };
  
      File::Find::find($wanted, $root);
  
      # Now @files has all the files that I could potentially be adding to
      # the zip. Only add the ones that are necessary.
      # For each file (updated or not), add its member name to @done.
      my %done;
      foreach my $fileName (@files) {
          my @newStat = stat($fileName);
          my $isDir   = -d _;
  
          # normalize, remove leading ./
          my $memberName = _asZipDirName($fileName, $isDir);
          if ($memberName eq $rootZipName) { $memberName = $dest }
          else                             { $memberName =~ s{$pattern}{$dest} }
          next if $memberName =~ m{^\.?/?$};    # skip current dir
  
          $done{$memberName} = 1;
          my $changedMember = $self->updateMember($memberName, $fileName);
          $changedMember->desiredCompressionLevel($compressionLevel);
          return _error("updateTree failed to update $fileName")
            unless ref($changedMember);
      }
  
      # @done now has the archive names corresponding to all the found files.
      # If we're mirroring, delete all those members that aren't in @done.
      if ($mirror) {
          foreach my $member ($self->members()) {
              $self->removeMember($member)
                unless $done{$member->fileName()};
          }
      }
  
      return AZ_OK;
  }
  
  1;
ARCHIVE_ZIP_ARCHIVE

$fatpacked{"Archive/Zip/BufferedFileHandle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_BUFFEREDFILEHANDLE';
  package Archive::Zip::BufferedFileHandle;
  
  # File handle that uses a string internally and can seek
  # This is given as a demo for getting a zip file written
  # to a string.
  # I probably should just use IO::Scalar instead.
  # Ned Konz, March 2000
  
  use strict;
  use IO::File;
  use Carp;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '1.57';
      $VERSION = eval $VERSION;
  }
  
  sub new {
      my $class = shift || __PACKAGE__;
      $class = ref($class) || $class;
      my $self = bless(
          {
              content  => '',
              position => 0,
              size     => 0
          },
          $class
      );
      return $self;
  }
  
  # Utility method to read entire file
  sub readFromFile {
      my $self     = shift;
      my $fileName = shift;
      my $fh       = IO::File->new($fileName, "r");
      CORE::binmode($fh);
      if (!$fh) {
          Carp::carp("Can't open $fileName: $!\n");
          return undef;
      }
      local $/ = undef;
      $self->{content} = <$fh>;
      $self->{size}    = length($self->{content});
      return $self;
  }
  
  sub contents {
      my $self = shift;
      if (@_) {
          $self->{content} = shift;
          $self->{size}    = length($self->{content});
      }
      return $self->{content};
  }
  
  sub binmode { 1 }
  
  sub close { 1 }
  
  sub opened { 1 }
  
  sub eof {
      my $self = shift;
      return $self->{position} >= $self->{size};
  }
  
  sub seek {
      my $self   = shift;
      my $pos    = shift;
      my $whence = shift;
  
      # SEEK_SET
      if ($whence == 0) { $self->{position} = $pos; }
  
      # SEEK_CUR
      elsif ($whence == 1) { $self->{position} += $pos; }
  
      # SEEK_END
      elsif ($whence == 2) { $self->{position} = $self->{size} + $pos; }
      else                 { return 0; }
  
      return 1;
  }
  
  sub tell { return shift->{position}; }
  
  # Copy my data to given buffer
  sub read {
      my $self = shift;
      my $buf  = \($_[0]);
      shift;
      my $len = shift;
      my $offset = shift || 0;
  
      $$buf = '' if not defined($$buf);
      my $bytesRead =
          ($self->{position} + $len > $self->{size})
        ? ($self->{size} - $self->{position})
        : $len;
      substr($$buf, $offset, $bytesRead) =
        substr($self->{content}, $self->{position}, $bytesRead);
      $self->{position} += $bytesRead;
      return $bytesRead;
  }
  
  # Copy given buffer to me
  sub write {
      my $self = shift;
      my $buf  = \($_[0]);
      shift;
      my $len = shift;
      my $offset = shift || 0;
  
      $$buf = '' if not defined($$buf);
      my $bufLen = length($$buf);
      my $bytesWritten =
        ($offset + $len > $bufLen)
        ? $bufLen - $offset
        : $len;
      substr($self->{content}, $self->{position}, $bytesWritten) =
        substr($$buf, $offset, $bytesWritten);
      $self->{size} = length($self->{content});
      return $bytesWritten;
  }
  
  sub clearerr() { 1 }
  
  1;
ARCHIVE_ZIP_BUFFEREDFILEHANDLE

$fatpacked{"Archive/Zip/DirectoryMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_DIRECTORYMEMBER';
  package Archive::Zip::DirectoryMember;
  
  use strict;
  use File::Path;
  
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw( Archive::Zip::Member );
  }
  
  use Archive::Zip qw(
    :ERROR_CODES
    :UTILITY_METHODS
  );
  
  sub _newNamed {
      my $class    = shift;
      my $fileName = shift;    # FS name
      my $newName  = shift;    # Zip name
      $newName = _asZipDirName($fileName) unless $newName;
      my $self = $class->new(@_);
      $self->{'externalFileName'} = $fileName;
      $self->fileName($newName);
  
      if (-e $fileName) {
  
          # -e does NOT do a full stat, so we need to do one now
          if (-d _ ) {
              my @stat = stat(_);
              $self->unixFileAttributes($stat[2]);
              my $mod_t = $stat[9];
              if ($^O eq 'MSWin32' and !$mod_t) {
                  $mod_t = time();
              }
              $self->setLastModFileDateTimeFromUnix($mod_t);
  
          } else {    # hmm.. trying to add a non-directory?
              _error($fileName, ' exists but is not a directory');
              return undef;
          }
      } else {
          $self->unixFileAttributes($self->DEFAULT_DIRECTORY_PERMISSIONS);
          $self->setLastModFileDateTimeFromUnix(time());
      }
      return $self;
  }
  
  sub externalFileName {
      shift->{'externalFileName'};
  }
  
  sub isDirectory {
      return 1;
  }
  
  sub extractToFileNamed {
      my $self    = shift;
      my $name    = shift;                                 # local FS name
      my $attribs = $self->unixFileAttributes() & 07777;
      mkpath($name, 0, $attribs);                          # croaks on error
      utime($self->lastModTime(), $self->lastModTime(), $name);
      return AZ_OK;
  }
  
  sub fileName {
      my $self    = shift;
      my $newName = shift;
      $newName =~ s{/?$}{/} if defined($newName);
      return $self->SUPER::fileName($newName);
  }
  
  # So people don't get too confused. This way it looks like the problem
  # is in their code...
  sub contents {
      return wantarray ? (undef, AZ_OK) : undef;
  }
  
  1;
ARCHIVE_ZIP_DIRECTORYMEMBER

$fatpacked{"Archive/Zip/FileMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_FILEMEMBER';
  package Archive::Zip::FileMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw ( Archive::Zip::Member );
  }
  
  use Archive::Zip qw(
    :UTILITY_METHODS
  );
  
  sub externalFileName {
      shift->{'externalFileName'};
  }
  
  # Return true if I depend on the named file
  sub _usesFileNamed {
      my $self     = shift;
      my $fileName = shift;
      my $xfn      = $self->externalFileName();
      return undef if ref($xfn);
      return $xfn eq $fileName;
  }
  
  sub fh {
      my $self = shift;
      $self->_openFile()
        if !defined($self->{'fh'}) || !$self->{'fh'}->opened();
      return $self->{'fh'};
  }
  
  # opens my file handle from my file name
  sub _openFile {
      my $self = shift;
      my ($status, $fh) = _newFileHandle($self->externalFileName(), 'r');
      if (!$status) {
          _ioError("Can't open", $self->externalFileName());
          return undef;
      }
      $self->{'fh'} = $fh;
      _binmode($fh);
      return $fh;
  }
  
  # Make sure I close my file handle
  sub endRead {
      my $self = shift;
      undef $self->{'fh'};    # _closeFile();
      return $self->SUPER::endRead(@_);
  }
  
  sub _become {
      my $self     = shift;
      my $newClass = shift;
      return $self if ref($self) eq $newClass;
      delete($self->{'externalFileName'});
      delete($self->{'fh'});
      return $self->SUPER::_become($newClass);
  }
  
  1;
ARCHIVE_ZIP_FILEMEMBER

$fatpacked{"Archive/Zip/Member.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_MEMBER';
  package Archive::Zip::Member;
  
  # A generic member of an archive
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw( Archive::Zip );
  
      if ($^O eq 'MSWin32') {
          require Win32;
          require Encode;
          Encode->import(qw{ decode_utf8 });
      }
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :MISC_CONSTANTS
    :ERROR_CODES
    :PKZIP_CONSTANTS
    :UTILITY_METHODS
  );
  
  use Time::Local ();
  use Compress::Raw::Zlib qw( Z_OK Z_STREAM_END MAX_WBITS );
  use File::Path;
  use File::Basename;
  
  # Unix perms for default creation of files/dirs.
  use constant DEFAULT_DIRECTORY_PERMISSIONS => 040755;
  use constant DEFAULT_FILE_PERMISSIONS      => 0100666;
  use constant DIRECTORY_ATTRIB              => 040000;
  use constant FILE_ATTRIB                   => 0100000;
  
  # Returns self if successful, else undef
  # Assumes that fh is positioned at beginning of central directory file header.
  # Leaves fh positioned immediately after file header or EOCD signature.
  sub _newFromZipFile {
      my $class = shift;
      my $self  = Archive::Zip::ZipFileMember->_newFromZipFile(@_);
      return $self;
  }
  
  sub newFromString {
      my $class = shift;
  
      my ($stringOrStringRef, $fileName);
      if (ref($_[0]) eq 'HASH') {
          $stringOrStringRef = $_[0]->{string};
          $fileName          = $_[0]->{zipName};
      } else {
          ($stringOrStringRef, $fileName) = @_;
      }
  
      my $self =
        Archive::Zip::StringMember->_newFromString($stringOrStringRef, $fileName);
      return $self;
  }
  
  sub newFromFile {
      my $class = shift;
  
      my ($fileName, $zipName);
      if (ref($_[0]) eq 'HASH') {
          $fileName = $_[0]->{fileName};
          $zipName  = $_[0]->{zipName};
      } else {
          ($fileName, $zipName) = @_;
      }
  
      my $self =
        Archive::Zip::NewFileMember->_newFromFileNamed($fileName, $zipName);
      return $self;
  }
  
  sub newDirectoryNamed {
      my $class = shift;
  
      my ($directoryName, $newName);
      if (ref($_[0]) eq 'HASH') {
          $directoryName = $_[0]->{directoryName};
          $newName       = $_[0]->{zipName};
      } else {
          ($directoryName, $newName) = @_;
      }
  
      my $self =
        Archive::Zip::DirectoryMember->_newNamed($directoryName, $newName);
      return $self;
  }
  
  sub new {
      my $class = shift;
      my $self  = {
          'lastModFileDateTime'      => 0,
          'fileAttributeFormat'      => FA_UNIX,
          'versionMadeBy'            => 20,
          'versionNeededToExtract'   => 20,
          'bitFlag'                  => ($Archive::Zip::UNICODE ? 0x0800 : 0),
          'compressionMethod'        => COMPRESSION_STORED,
          'desiredCompressionMethod' => COMPRESSION_STORED,
          'desiredCompressionLevel'  => COMPRESSION_LEVEL_NONE,
          'internalFileAttributes'   => 0,
          'externalFileAttributes'   => 0,                        # set later
          'fileName'                 => '',
          'cdExtraField'             => '',
          'localExtraField'          => '',
          'fileComment'              => '',
          'crc32'                    => 0,
          'compressedSize'           => 0,
          'uncompressedSize'         => 0,
          'isSymbolicLink'           => 0,
          'password' => undef,    # password for encrypted data
          'crc32c'   => -1,       # crc for decrypted data
          @_
      };
      bless($self, $class);
      $self->unixFileAttributes($self->DEFAULT_FILE_PERMISSIONS);
      return $self;
  }
  
  sub _becomeDirectoryIfNecessary {
      my $self = shift;
      $self->_become('Archive::Zip::DirectoryMember')
        if $self->isDirectory();
      return $self;
  }
  
  # Morph into given class (do whatever cleanup I need to do)
  sub _become {
      return bless($_[0], $_[1]);
  }
  
  sub versionMadeBy {
      shift->{'versionMadeBy'};
  }
  
  sub fileAttributeFormat {
      my $self = shift;
  
      if (@_) {
          $self->{fileAttributeFormat} =
            (ref($_[0]) eq 'HASH') ? $_[0]->{format} : $_[0];
      } else {
          return $self->{fileAttributeFormat};
      }
  }
  
  sub versionNeededToExtract {
      shift->{'versionNeededToExtract'};
  }
  
  sub bitFlag {
      my $self = shift;
  
  # Set General Purpose Bit Flags according to the desiredCompressionLevel setting
      if (   $self->desiredCompressionLevel == 1
          || $self->desiredCompressionLevel == 2) {
          $self->{'bitFlag'} |= DEFLATING_COMPRESSION_FAST;
      } elsif ($self->desiredCompressionLevel == 3
          || $self->desiredCompressionLevel == 4
          || $self->desiredCompressionLevel == 5
          || $self->desiredCompressionLevel == 6
          || $self->desiredCompressionLevel == 7) {
          $self->{'bitFlag'} |= DEFLATING_COMPRESSION_NORMAL;
      } elsif ($self->desiredCompressionLevel == 8
          || $self->desiredCompressionLevel == 9) {
          $self->{'bitFlag'} |= DEFLATING_COMPRESSION_MAXIMUM;
      }
  
      if ($Archive::Zip::UNICODE) {
          $self->{'bitFlag'} |= 0x0800;
      }
      $self->{'bitFlag'};
  }
  
  sub password {
      my $self = shift;
      $self->{'password'} = shift if @_;
      $self->{'password'};
  }
  
  sub compressionMethod {
      shift->{'compressionMethod'};
  }
  
  sub desiredCompressionMethod {
      my $self = shift;
      my $newDesiredCompressionMethod =
        (ref($_[0]) eq 'HASH') ? shift->{compressionMethod} : shift;
      my $oldDesiredCompressionMethod = $self->{'desiredCompressionMethod'};
      if (defined($newDesiredCompressionMethod)) {
          $self->{'desiredCompressionMethod'} = $newDesiredCompressionMethod;
          if ($newDesiredCompressionMethod == COMPRESSION_STORED) {
              $self->{'desiredCompressionLevel'} = 0;
              $self->{'bitFlag'} &= ~GPBF_HAS_DATA_DESCRIPTOR_MASK
                  if $self->uncompressedSize() == 0;
          } elsif ($oldDesiredCompressionMethod == COMPRESSION_STORED) {
              $self->{'desiredCompressionLevel'} = COMPRESSION_LEVEL_DEFAULT;
          }
      }
      return $oldDesiredCompressionMethod;
  }
  
  sub desiredCompressionLevel {
      my $self = shift;
      my $newDesiredCompressionLevel =
        (ref($_[0]) eq 'HASH') ? shift->{compressionLevel} : shift;
      my $oldDesiredCompressionLevel = $self->{'desiredCompressionLevel'};
      if (defined($newDesiredCompressionLevel)) {
          $self->{'desiredCompressionLevel'}  = $newDesiredCompressionLevel;
          $self->{'desiredCompressionMethod'} = (
              $newDesiredCompressionLevel
              ? COMPRESSION_DEFLATED
              : COMPRESSION_STORED
          );
      }
      return $oldDesiredCompressionLevel;
  }
  
  sub fileName {
      my $self    = shift;
      my $newName = shift;
      if (defined $newName) {
          $newName =~ s{[\\/]+}{/}g;    # deal with dos/windoze problems
          $self->{'fileName'} = $newName;
      }
      return $self->{'fileName'};
  }
  
  sub fileNameAsBytes {
      my $self  = shift;
      my $bytes = $self->{'fileName'};
      if($self->{'bitFlag'} & 0x800){
          $bytes = Encode::encode_utf8($bytes);
      }
      return $bytes;
  }
  
  sub lastModFileDateTime {
      my $modTime = shift->{'lastModFileDateTime'};
      $modTime =~ m/^(\d+)$/;           # untaint
      return $1;
  }
  
  sub lastModTime {
      my $self = shift;
      return _dosToUnixTime($self->lastModFileDateTime());
  }
  
  sub setLastModFileDateTimeFromUnix {
      my $self   = shift;
      my $time_t = shift;
      $self->{'lastModFileDateTime'} = _unixToDosTime($time_t);
  }
  
  sub internalFileAttributes {
      shift->{'internalFileAttributes'};
  }
  
  sub externalFileAttributes {
      shift->{'externalFileAttributes'};
  }
  
  # Convert UNIX permissions into proper value for zip file
  # Usable as a function or a method
  sub _mapPermissionsFromUnix {
      my $self    = shift;
      my $mode    = shift;
      my $attribs = $mode << 16;
  
      # Microsoft Windows Explorer needs this bit set for directories
      if ($mode & DIRECTORY_ATTRIB) {
          $attribs |= 16;
      }
  
      return $attribs;
  
      # TODO: map more MS-DOS perms
  }
  
  # Convert ZIP permissions into Unix ones
  #
  # This was taken from Info-ZIP group's portable UnZip
  # zipfile-extraction program, version 5.50.
  # http://www.info-zip.org/pub/infozip/
  #
  # See the mapattr() function in unix/unix.c
  # See the attribute format constants in unzpriv.h
  #
  # XXX Note that there's one situation that is not implemented
  # yet that depends on the "extra field."
  sub _mapPermissionsToUnix {
      my $self = shift;
  
      my $format  = $self->{'fileAttributeFormat'};
      my $attribs = $self->{'externalFileAttributes'};
  
      my $mode = 0;
  
      if ($format == FA_AMIGA) {
          $attribs = $attribs >> 17 & 7;                         # Amiga RWE bits
          $mode    = $attribs << 6 | $attribs << 3 | $attribs;
          return $mode;
      }
  
      if ($format == FA_THEOS) {
          $attribs &= 0xF1FFFFFF;
          if (($attribs & 0xF0000000) != 0x40000000) {
              $attribs &= 0x01FFFFFF;    # not a dir, mask all ftype bits
          } else {
              $attribs &= 0x41FFFFFF;    # leave directory bit as set
          }
      }
  
      if (   $format == FA_UNIX
          || $format == FA_VAX_VMS
          || $format == FA_ACORN
          || $format == FA_ATARI_ST
          || $format == FA_BEOS
          || $format == FA_QDOS
          || $format == FA_TANDEM) {
          $mode = $attribs >> 16;
          return $mode if $mode != 0 or not $self->localExtraField;
  
          # warn("local extra field is: ", $self->localExtraField, "\n");
  
          # XXX This condition is not implemented
          # I'm just including the comments from the info-zip section for now.
  
          # Some (non-Info-ZIP) implementations of Zip for Unix and
          # VMS (and probably others ??) leave 0 in the upper 16-bit
          # part of the external_file_attributes field. Instead, they
          # store file permission attributes in some extra field.
          # As a work-around, we search for the presence of one of
          # these extra fields and fall back to the MSDOS compatible
          # part of external_file_attributes if one of the known
          # e.f. types has been detected.
          # Later, we might implement extraction of the permission
          # bits from the VMS extra field. But for now, the work-around
          # should be sufficient to provide "readable" extracted files.
          # (For ASI Unix e.f., an experimental remap from the e.f.
          # mode value IS already provided!)
      }
  
      # PKWARE's PKZip for Unix marks entries as FA_MSDOS, but stores the
      # Unix attributes in the upper 16 bits of the external attributes
      # field, just like Info-ZIP's Zip for Unix.  We try to use that
      # value, after a check for consistency with the MSDOS attribute
      # bits (see below).
      if ($format == FA_MSDOS) {
          $mode = $attribs >> 16;
      }
  
      # FA_MSDOS, FA_OS2_HPFS, FA_WINDOWS_NTFS, FA_MACINTOSH, FA_TOPS20
      $attribs = !($attribs & 1) << 1 | ($attribs & 0x10) >> 4;
  
      # keep previous $mode setting when its "owner"
      # part appears to be consistent with DOS attribute flags!
      return $mode if ($mode & 0700) == (0400 | $attribs << 6);
      $mode = 0444 | $attribs << 6 | $attribs << 3 | $attribs;
      return $mode;
  }
  
  sub unixFileAttributes {
      my $self     = shift;
      my $oldPerms = $self->_mapPermissionsToUnix;
  
      my $perms;
      if (@_) {
          $perms = (ref($_[0]) eq 'HASH') ? $_[0]->{attributes} : $_[0];
  
          if ($self->isDirectory) {
              $perms &= ~FILE_ATTRIB;
              $perms |= DIRECTORY_ATTRIB;
          } else {
              $perms &= ~DIRECTORY_ATTRIB;
              $perms |= FILE_ATTRIB;
          }
          $self->{externalFileAttributes} =
            $self->_mapPermissionsFromUnix($perms);
      }
  
      return $oldPerms;
  }
  
  sub localExtraField {
      my $self = shift;
  
      if (@_) {
          $self->{localExtraField} =
            (ref($_[0]) eq 'HASH') ? $_[0]->{field} : $_[0];
      } else {
          return $self->{localExtraField};
      }
  }
  
  sub cdExtraField {
      my $self = shift;
  
      if (@_) {
          $self->{cdExtraField} = (ref($_[0]) eq 'HASH') ? $_[0]->{field} : $_[0];
      } else {
          return $self->{cdExtraField};
      }
  }
  
  sub extraFields {
      my $self = shift;
      return $self->localExtraField() . $self->cdExtraField();
  }
  
  sub fileComment {
      my $self = shift;
  
      if (@_) {
          $self->{fileComment} =
            (ref($_[0]) eq 'HASH')
            ? pack('C0a*', $_[0]->{comment})
            : pack('C0a*', $_[0]);
      } else {
          return $self->{fileComment};
      }
  }
  
  sub hasDataDescriptor {
      my $self = shift;
      if (@_) {
          my $shouldHave = shift;
          if ($shouldHave) {
              $self->{'bitFlag'} |= GPBF_HAS_DATA_DESCRIPTOR_MASK;
          } else {
              $self->{'bitFlag'} &= ~GPBF_HAS_DATA_DESCRIPTOR_MASK;
          }
      }
      return $self->{'bitFlag'} & GPBF_HAS_DATA_DESCRIPTOR_MASK;
  }
  
  sub crc32 {
      shift->{'crc32'};
  }
  
  sub crc32String {
      sprintf("%08x", shift->{'crc32'});
  }
  
  sub compressedSize {
      shift->{'compressedSize'};
  }
  
  sub uncompressedSize {
      shift->{'uncompressedSize'};
  }
  
  sub isEncrypted {
      shift->{'bitFlag'} & GPBF_ENCRYPTED_MASK;
  }
  
  sub isTextFile {
      my $self = shift;
      my $bit  = $self->internalFileAttributes() & IFA_TEXT_FILE_MASK;
      if (@_) {
          my $flag = (ref($_[0]) eq 'HASH') ? shift->{flag} : shift;
          $self->{'internalFileAttributes'} &= ~IFA_TEXT_FILE_MASK;
          $self->{'internalFileAttributes'} |=
            ($flag ? IFA_TEXT_FILE : IFA_BINARY_FILE);
      }
      return $bit == IFA_TEXT_FILE;
  }
  
  sub isBinaryFile {
      my $self = shift;
      my $bit  = $self->internalFileAttributes() & IFA_TEXT_FILE_MASK;
      if (@_) {
          my $flag = shift;
          $self->{'internalFileAttributes'} &= ~IFA_TEXT_FILE_MASK;
          $self->{'internalFileAttributes'} |=
            ($flag ? IFA_BINARY_FILE : IFA_TEXT_FILE);
      }
      return $bit == IFA_BINARY_FILE;
  }
  
  sub extractToFileNamed {
      my $self = shift;
  
      # local FS name
      my $name = (ref($_[0]) eq 'HASH') ? $_[0]->{name} : $_[0];
      $self->{'isSymbolicLink'} = 0;
  
      # Check if the file / directory is a symbolic link or not
      if ($self->{'externalFileAttributes'} == 0xA1FF0000) {
          $self->{'isSymbolicLink'} = 1;
          $self->{'newName'}        = $name;
          my ($status, $fh) = _newFileHandle($name, 'r');
          my $retval = $self->extractToFileHandle($fh);
          $fh->close();
      } else {
  
          #return _writeSymbolicLink($self, $name) if $self->isSymbolicLink();
  
          my ($status, $fh);
          if ($^O eq 'MSWin32' && $Archive::Zip::UNICODE) {
              $name = decode_utf8(Win32::GetFullPathName($name));
              mkpath_win32($name);
              Win32::CreateFile($name);
              ($status, $fh) = _newFileHandle(Win32::GetANSIPathName($name), 'w');
          } else {
              mkpath(dirname($name));    # croaks on error
              ($status, $fh) = _newFileHandle($name, 'w');
          }
          return _ioError("Can't open file $name for write") unless $status;
          my $retval = $self->extractToFileHandle($fh);
          $fh->close();
          chmod($self->unixFileAttributes(), $name)
            or return _error("Can't chmod() ${name}: $!");
          utime($self->lastModTime(), $self->lastModTime(), $name);
          return $retval;
      }
  }
  
  sub mkpath_win32 {
      my $path = shift;
      use File::Spec;
  
      my ($volume, @path) = File::Spec->splitdir($path);
      $path = File::Spec->catfile($volume, shift @path);
      pop @path;
      while (@path) {
          $path = File::Spec->catfile($path, shift @path);
          Win32::CreateDirectory($path);
      }
  }
  
  sub _writeSymbolicLink {
      my $self      = shift;
      my $name      = shift;
      my $chunkSize = $Archive::Zip::ChunkSize;
  
      #my ( $outRef, undef ) = $self->readChunk($chunkSize);
      my $fh;
      my $retval = $self->extractToFileHandle($fh);
      my ($outRef, undef) = $self->readChunk(100);
  }
  
  sub isSymbolicLink {
      my $self = shift;
      if ($self->{'externalFileAttributes'} == 0xA1FF0000) {
          $self->{'isSymbolicLink'} = 1;
      } else {
          return 0;
      }
      1;
  }
  
  sub isDirectory {
      return 0;
  }
  
  sub externalFileName {
      return undef;
  }
  
  # The following are used when copying data
  sub _writeOffset {
      shift->{'writeOffset'};
  }
  
  sub _readOffset {
      shift->{'readOffset'};
  }
  
  sub writeLocalHeaderRelativeOffset {
      shift->{'writeLocalHeaderRelativeOffset'};
  }
  
  sub wasWritten { shift->{'wasWritten'} }
  
  sub _dataEnded {
      shift->{'dataEnded'};
  }
  
  sub _readDataRemaining {
      shift->{'readDataRemaining'};
  }
  
  sub _inflater {
      shift->{'inflater'};
  }
  
  sub _deflater {
      shift->{'deflater'};
  }
  
  # Return the total size of my local header
  sub _localHeaderSize {
      my $self = shift;
      {
          use bytes;
          return SIGNATURE_LENGTH +
            LOCAL_FILE_HEADER_LENGTH +
            length($self->fileName()) +
            length($self->localExtraField());
      }
  }
  
  # Return the total size of my CD header
  sub _centralDirectoryHeaderSize {
      my $self = shift;
      {
          use bytes;
          return SIGNATURE_LENGTH +
            CENTRAL_DIRECTORY_FILE_HEADER_LENGTH +
            length($self->fileName()) +
            length($self->cdExtraField()) +
            length($self->fileComment());
      }
  }
  
  # DOS date/time format
  # 0-4 (5) Second divided by 2
  # 5-10 (6) Minute (0-59)
  # 11-15 (5) Hour (0-23 on a 24-hour clock)
  # 16-20 (5) Day of the month (1-31)
  # 21-24 (4) Month (1 = January, 2 = February, etc.)
  # 25-31 (7) Year offset from 1980 (add 1980 to get actual year)
  
  # Convert DOS date/time format to unix time_t format
  # NOT AN OBJECT METHOD!
  sub _dosToUnixTime {
      my $dt = shift;
      return time() unless defined($dt);
  
      my $year = (($dt >> 25) & 0x7f) + 80;
      my $mon  = (($dt >> 21) & 0x0f) - 1;
      my $mday = (($dt >> 16) & 0x1f);
  
      my $hour = (($dt >> 11) & 0x1f);
      my $min  = (($dt >> 5) & 0x3f);
      my $sec  = (($dt << 1) & 0x3e);
  
      # catch errors
      my $time_t =
        eval { Time::Local::timelocal($sec, $min, $hour, $mday, $mon, $year); };
      return time() if ($@);
      return $time_t;
  }
  
  # Note, this is not exactly UTC 1980, it's 1980 + 12 hours and 1
  # minute so that nothing timezoney can muck us up.
  my $safe_epoch = 315576060;
  
  # convert a unix time to DOS date/time
  # NOT AN OBJECT METHOD!
  sub _unixToDosTime {
      my $time_t = shift;
      unless ($time_t) {
          _error("Tried to add member with zero or undef value for time");
          $time_t = $safe_epoch;
      }
      if ($time_t < $safe_epoch) {
          _ioError("Unsupported date before 1980 encountered, moving to 1980");
          $time_t = $safe_epoch;
      }
      my ($sec, $min, $hour, $mday, $mon, $year) = localtime($time_t);
      my $dt = 0;
      $dt += ($sec >> 1);
      $dt += ($min << 5);
      $dt += ($hour << 11);
      $dt += ($mday << 16);
      $dt += (($mon + 1) << 21);
      $dt += (($year - 80) << 25);
      return $dt;
  }
  
  sub head {
      my ($self, $mode) = (@_, 0);
  
      use bytes;
      return pack LOCAL_FILE_HEADER_FORMAT,
        $self->versionNeededToExtract(),
        $self->{'bitFlag'},
        $self->desiredCompressionMethod(),
        $self->lastModFileDateTime(), 
        $self->hasDataDescriptor() 
          ? (0,0,0) # crc, compr & uncompr all zero if data descriptor present
          : (
              $self->crc32(), 
              $mode
                ? $self->_writeOffset()       # compressed size
                : $self->compressedSize(),    # may need to be re-written later
              $self->uncompressedSize(),
            ),
        length($self->fileNameAsBytes()),
        length($self->localExtraField());
  }
  
  # Write my local header to a file handle.
  # Stores the offset to the start of the header in my
  # writeLocalHeaderRelativeOffset member.
  # Returns AZ_OK on success.
  sub _writeLocalFileHeader {
      my $self = shift;
      my $fh   = shift;
  
      my $signatureData = pack(SIGNATURE_FORMAT, LOCAL_FILE_HEADER_SIGNATURE);
      $self->_print($fh, $signatureData)
        or return _ioError("writing local header signature");
  
      my $header = $self->head(1);
  
      $self->_print($fh, $header) or return _ioError("writing local header");
  
      # Check for a valid filename or a filename equal to a literal `0'
      if ($self->fileName() || $self->fileName eq '0') {
          $self->_print($fh, $self->fileNameAsBytes())
            or return _ioError("writing local header filename");
      }
      if ($self->localExtraField()) {
          $self->_print($fh, $self->localExtraField())
            or return _ioError("writing local extra field");
      }
  
      return AZ_OK;
  }
  
  sub _writeCentralDirectoryFileHeader {
      my $self = shift;
      my $fh   = shift;
  
      my $sigData =
        pack(SIGNATURE_FORMAT, CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE);
      $self->_print($fh, $sigData)
        or return _ioError("writing central directory header signature");
  
      my ($fileNameLength, $extraFieldLength, $fileCommentLength);
      {
          use bytes;
          $fileNameLength    = length($self->fileNameAsBytes());
          $extraFieldLength  = length($self->cdExtraField());
          $fileCommentLength = length($self->fileComment());
      }
  
      my $header = pack(
          CENTRAL_DIRECTORY_FILE_HEADER_FORMAT,
          $self->versionMadeBy(),
          $self->fileAttributeFormat(),
          $self->versionNeededToExtract(),
          $self->bitFlag(),
          $self->desiredCompressionMethod(),
          $self->lastModFileDateTime(),
          $self->crc32(),            # these three fields should have been updated
          $self->_writeOffset(),     # by writing the data stream out
          $self->uncompressedSize(), #
          $fileNameLength,
          $extraFieldLength,
          $fileCommentLength,
          0,                         # {'diskNumberStart'},
          $self->internalFileAttributes(),
          $self->externalFileAttributes(),
          $self->writeLocalHeaderRelativeOffset());
  
      $self->_print($fh, $header)
        or return _ioError("writing central directory header");
      if ($fileNameLength) {
          $self->_print($fh, $self->fileNameAsBytes())
            or return _ioError("writing central directory header signature");
      }
      if ($extraFieldLength) {
          $self->_print($fh, $self->cdExtraField())
            or return _ioError("writing central directory extra field");
      }
      if ($fileCommentLength) {
          $self->_print($fh, $self->fileComment())
            or return _ioError("writing central directory file comment");
      }
  
      return AZ_OK;
  }
  
  # This writes a data descriptor to the given file handle.
  # Assumes that crc32, writeOffset, and uncompressedSize are
  # set correctly (they should be after a write).
  # Further, the local file header should have the
  # GPBF_HAS_DATA_DESCRIPTOR_MASK bit set.
  sub _writeDataDescriptor {
      my $self   = shift;
      my $fh     = shift;
      my $header = pack(
          SIGNATURE_FORMAT . DATA_DESCRIPTOR_FORMAT,
          DATA_DESCRIPTOR_SIGNATURE,
          $self->crc32(),
          $self->_writeOffset(),    # compressed size
          $self->uncompressedSize());
  
      $self->_print($fh, $header)
        or return _ioError("writing data descriptor");
      return AZ_OK;
  }
  
  # Re-writes the local file header with new crc32 and compressedSize fields.
  # To be called after writing the data stream.
  # Assumes that filename and extraField sizes didn't change since last written.
  sub _refreshLocalFileHeader {
      my $self = shift;
      my $fh   = shift;
  
      my $here = $fh->tell();
      $fh->seek($self->writeLocalHeaderRelativeOffset() + SIGNATURE_LENGTH,
          IO::Seekable::SEEK_SET)
        or return _ioError("seeking to rewrite local header");
  
      my $header = $self->head(1);
  
      $self->_print($fh, $header)
        or return _ioError("re-writing local header");
      $fh->seek($here, IO::Seekable::SEEK_SET)
        or return _ioError("seeking after rewrite of local header");
  
      return AZ_OK;
  }
  
  sub readChunk {
      my $self = shift;
      my $chunkSize = (ref($_[0]) eq 'HASH') ? $_[0]->{chunkSize} : $_[0];
  
      if ($self->readIsDone()) {
          $self->endRead();
          my $dummy = '';
          return (\$dummy, AZ_STREAM_END);
      }
  
      $chunkSize = $Archive::Zip::ChunkSize if not defined($chunkSize);
      $chunkSize = $self->_readDataRemaining()
        if $chunkSize > $self->_readDataRemaining();
  
      my $buffer = '';
      my $outputRef;
      my ($bytesRead, $status) = $self->_readRawChunk(\$buffer, $chunkSize);
      return (\$buffer, $status) unless $status == AZ_OK;
  
      $buffer && $self->isEncrypted and $buffer = $self->_decode($buffer);
      $self->{'readDataRemaining'} -= $bytesRead;
      $self->{'readOffset'} += $bytesRead;
  
      if ($self->compressionMethod() == COMPRESSION_STORED) {
          $self->{'crc32'} = $self->computeCRC32($buffer, $self->{'crc32'});
      }
  
      ($outputRef, $status) = &{$self->{'chunkHandler'}}($self, \$buffer);
      $self->{'writeOffset'} += length($$outputRef);
  
      $self->endRead()
        if $self->readIsDone();
  
      return ($outputRef, $status);
  }
  
  # Read the next raw chunk of my data. Subclasses MUST implement.
  #   my ( $bytesRead, $status) = $self->_readRawChunk( \$buffer, $chunkSize );
  sub _readRawChunk {
      my $self = shift;
      return $self->_subclassResponsibility();
  }
  
  # A place holder to catch rewindData errors if someone ignores
  # the error code.
  sub _noChunk {
      my $self = shift;
      return (\undef, _error("trying to copy chunk when init failed"));
  }
  
  # Basically a no-op so that I can have a consistent interface.
  # ( $outputRef, $status) = $self->_copyChunk( \$buffer );
  sub _copyChunk {
      my ($self, $dataRef) = @_;
      return ($dataRef, AZ_OK);
  }
  
  # ( $outputRef, $status) = $self->_deflateChunk( \$buffer );
  sub _deflateChunk {
      my ($self, $buffer) = @_;
      my ($status) = $self->_deflater()->deflate($buffer, my $out);
  
      if ($self->_readDataRemaining() == 0) {
          my $extraOutput;
          ($status) = $self->_deflater()->flush($extraOutput);
          $out .= $extraOutput;
          $self->endRead();
          return (\$out, AZ_STREAM_END);
      } elsif ($status == Z_OK) {
          return (\$out, AZ_OK);
      } else {
          $self->endRead();
          my $retval = _error('deflate error', $status);
          my $dummy = '';
          return (\$dummy, $retval);
      }
  }
  
  # ( $outputRef, $status) = $self->_inflateChunk( \$buffer );
  sub _inflateChunk {
      my ($self, $buffer) = @_;
      my ($status) = $self->_inflater()->inflate($buffer, my $out);
      my $retval;
      $self->endRead() unless $status == Z_OK;
      if ($status == Z_OK || $status == Z_STREAM_END) {
          $retval = ($status == Z_STREAM_END) ? AZ_STREAM_END : AZ_OK;
          return (\$out, $retval);
      } else {
          $retval = _error('inflate error', $status);
          my $dummy = '';
          return (\$dummy, $retval);
      }
  }
  
  sub rewindData {
      my $self = shift;
      my $status;
  
      # set to trap init errors
      $self->{'chunkHandler'} = $self->can('_noChunk');
  
      # Work around WinZip bug with 0-length DEFLATED files
      $self->desiredCompressionMethod(COMPRESSION_STORED)
        if $self->uncompressedSize() == 0;
  
      # assume that we're going to read the whole file, and compute the CRC anew.
      $self->{'crc32'} = 0
        if ($self->compressionMethod() == COMPRESSION_STORED);
  
      # These are the only combinations of methods we deal with right now.
      if (    $self->compressionMethod() == COMPRESSION_STORED
          and $self->desiredCompressionMethod() == COMPRESSION_DEFLATED) {
          ($self->{'deflater'}, $status) = Compress::Raw::Zlib::Deflate->new(
              '-Level'      => $self->desiredCompressionLevel(),
              '-WindowBits' => -MAX_WBITS(),                     # necessary magic
              '-Bufsize'    => $Archive::Zip::ChunkSize,
              @_
          );    # pass additional options
          return _error('deflateInit error:', $status)
            unless $status == Z_OK;
          $self->{'chunkHandler'} = $self->can('_deflateChunk');
      } elsif ($self->compressionMethod() == COMPRESSION_DEFLATED
          and $self->desiredCompressionMethod() == COMPRESSION_STORED) {
          ($self->{'inflater'}, $status) = Compress::Raw::Zlib::Inflate->new(
              '-WindowBits' => -MAX_WBITS(),               # necessary magic
              '-Bufsize'    => $Archive::Zip::ChunkSize,
              @_
          );    # pass additional options
          return _error('inflateInit error:', $status)
            unless $status == Z_OK;
          $self->{'chunkHandler'} = $self->can('_inflateChunk');
      } elsif ($self->compressionMethod() == $self->desiredCompressionMethod()) {
          $self->{'chunkHandler'} = $self->can('_copyChunk');
      } else {
          return _error(
              sprintf(
                  "Unsupported compression combination: read %d, write %d",
                  $self->compressionMethod(),
                  $self->desiredCompressionMethod()));
      }
  
      $self->{'readDataRemaining'} =
        ($self->compressionMethod() == COMPRESSION_STORED)
        ? $self->uncompressedSize()
        : $self->compressedSize();
      $self->{'dataEnded'}  = 0;
      $self->{'readOffset'} = 0;
  
      return AZ_OK;
  }
  
  sub endRead {
      my $self = shift;
      delete $self->{'inflater'};
      delete $self->{'deflater'};
      $self->{'dataEnded'}         = 1;
      $self->{'readDataRemaining'} = 0;
      return AZ_OK;
  }
  
  sub readIsDone {
      my $self = shift;
      return ($self->_dataEnded() or !$self->_readDataRemaining());
  }
  
  sub contents {
      my $self        = shift;
      my $newContents = shift;
  
      if (defined($newContents)) {
  
          # change our type and call the subclass contents method.
          $self->_become('Archive::Zip::StringMember');
          return $self->contents(pack('C0a*', $newContents)); # in case of Unicode
      } else {
          my $oldCompression =
            $self->desiredCompressionMethod(COMPRESSION_STORED);
          my $status = $self->rewindData(@_);
          if ($status != AZ_OK) {
              $self->endRead();
              return $status;
          }
          my $retval = '';
          while ($status == AZ_OK) {
              my $ref;
              ($ref, $status) = $self->readChunk($self->_readDataRemaining());
  
              # did we get it in one chunk?
              if (length($$ref) == $self->uncompressedSize()) {
                  $retval = $$ref;
              } else {
                  $retval .= $$ref
              }
          }
          $self->desiredCompressionMethod($oldCompression);
          $self->endRead();
          $status = AZ_OK if $status == AZ_STREAM_END;
          $retval = undef unless $status == AZ_OK;
          return wantarray ? ($retval, $status) : $retval;
      }
  }
  
  sub extractToFileHandle {
      my $self = shift;
      my $fh = (ref($_[0]) eq 'HASH') ? shift->{fileHandle} : shift;
      _binmode($fh);
      my $oldCompression = $self->desiredCompressionMethod(COMPRESSION_STORED);
      my $status         = $self->rewindData(@_);
      $status = $self->_writeData($fh) if $status == AZ_OK;
      $self->desiredCompressionMethod($oldCompression);
      $self->endRead();
      return $status;
  }
  
  # write local header and data stream to file handle
  sub _writeToFileHandle {
      my $self         = shift;
      my $fh           = shift;
      my $fhIsSeekable = shift;
      my $offset       = shift;
  
      return _error("no member name given for $self")
        if $self->fileName() eq '';
  
      $self->{'writeLocalHeaderRelativeOffset'} = $offset;
      $self->{'wasWritten'}                     = 0;
  
      # Determine if I need to write a data descriptor
      # I need to do this if I can't refresh the header
      # and I don't know compressed size or crc32 fields.
      my $headerFieldsUnknown = (
          ($self->uncompressedSize() > 0)
            and ($self->compressionMethod() == COMPRESSION_STORED
              or $self->desiredCompressionMethod() == COMPRESSION_DEFLATED));
  
      my $shouldWriteDataDescriptor =
        ($headerFieldsUnknown and not $fhIsSeekable);
  
      $self->hasDataDescriptor(1)
        if ($shouldWriteDataDescriptor);
  
      $self->{'writeOffset'} = 0;
  
      my $status = $self->rewindData();
      ($status = $self->_writeLocalFileHeader($fh))
        if $status == AZ_OK;
      ($status = $self->_writeData($fh))
        if $status == AZ_OK;
      if ($status == AZ_OK) {
          $self->{'wasWritten'} = 1;
          if ($self->hasDataDescriptor()) {
              $status = $self->_writeDataDescriptor($fh);
          } elsif ($headerFieldsUnknown) {
              $status = $self->_refreshLocalFileHeader($fh);
          }
      }
  
      return $status;
  }
  
  # Copy my (possibly compressed) data to given file handle.
  # Returns C<AZ_OK> on success
  sub _writeData {
      my $self    = shift;
      my $writeFh = shift;
  
  # If symbolic link, just create one if the operating system is Linux, Unix, BSD or VMS
  # TODO: Add checks for other operating systems
      if ($self->{'isSymbolicLink'} == 1 && $^O eq 'linux') {
          my $chunkSize = $Archive::Zip::ChunkSize;
          my ($outRef, $status) = $self->readChunk($chunkSize);
          symlink $$outRef, $self->{'newName'};
      } else {
          return AZ_OK if ($self->uncompressedSize() == 0);
          my $status;
          my $chunkSize = $Archive::Zip::ChunkSize;
          while ($self->_readDataRemaining() > 0) {
              my $outRef;
              ($outRef, $status) = $self->readChunk($chunkSize);
              return $status if ($status != AZ_OK and $status != AZ_STREAM_END);
  
              if (length($$outRef) > 0) {
                  $self->_print($writeFh, $$outRef)
                    or return _ioError("write error during copy");
              }
  
              last if $status == AZ_STREAM_END;
          }
      }
      return AZ_OK;
  }
  
  # Return true if I depend on the named file
  sub _usesFileNamed {
      return 0;
  }
  
  # ##############################################################################
  #
  # Decrypt section
  #
  # H.Merijn Brand (Tux) 2011-06-28
  #
  # ##############################################################################
  
  # This code is derived from the crypt source of unzip-6.0 dated 05 Jan 2007
  # Its license states:
  #
  # --8<---
  # Copyright (c) 1990-2007 Info-ZIP.  All rights reserved.
  
  # See the accompanying file LICENSE, version 2005-Feb-10 or later
  # (the contents of which are also included in (un)zip.h) for terms of use.
  # If, for some reason, all these files are missing, the Info-ZIP license
  # also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
  #
  # crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
  
  # The main encryption/decryption source code for Info-Zip software was
  # originally written in Europe.  To the best of our knowledge, it can
  # be freely distributed in both source and object forms from any country,
  # including the USA under License Exception TSU of the U.S. Export
  # Administration Regulations (section 740.13(e)) of 6 June 2002.
  
  # NOTE on copyright history:
  # Previous versions of this source package (up to version 2.8) were
  # not copyrighted and put in the public domain.  If you cannot comply
  # with the Info-Zip LICENSE, you may want to look for one of those
  # public domain versions.
  #
  # This encryption code is a direct transcription of the algorithm from
  # Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
  # file (appnote.txt) is distributed with the PKZIP program (even in the
  # version without encryption capabilities).
  # -->8---
  
  # As of January 2000, US export regulations were amended to allow export
  # of free encryption source code from the US.  As of June 2002, these
  # regulations were further relaxed to allow export of encryption binaries
  # associated with free encryption source code.  The Zip 2.31, UnZip 5.52
  # and Wiz 5.02 archives now include full crypto source code.  As of the
  # Zip 2.31 release, all official binaries include encryption support; the
  # former "zcr" archives ceased to exist.
  # (Note that restrictions may still exist in other countries, of course.)
  
  # For now, we just support the decrypt stuff
  # All below methods are supposed to be private
  
  # use Data::Peek;
  
  my @keys;
  my @crct = do {
      my $xor = 0xedb88320;
      my @crc = (0) x 1024;
  
      # generate a crc for every 8-bit value
      foreach my $n (0 .. 255) {
          my $c = $n;
          $c = $c & 1 ? $xor ^ ($c >> 1) : $c >> 1 for 1 .. 8;
          $crc[$n] = _revbe($c);
      }
  
      # generate crc for each value followed by one, two, and three zeros */
      foreach my $n (0 .. 255) {
          my $c = ($crc[($crc[$n] >> 24) ^ 0] ^ ($crc[$n] << 8)) & 0xffffffff;
          $crc[$_ * 256 + $n] = $c for 1 .. 3;
      }
      map { _revbe($crc[$_]) } 0 .. 1023;
  };
  
  sub _crc32 {
      my ($c, $b) = @_;
      return ($crct[($c ^ $b) & 0xff] ^ ($c >> 8));
  }    # _crc32
  
  sub _revbe {
      my $w = shift;
      return (($w >> 24) +
            (($w >> 8) & 0xff00) +
            (($w & 0xff00) << 8) +
            (($w & 0xff) << 24));
  }    # _revbe
  
  sub _update_keys {
      use integer;
      my $c = shift;    # signed int
      $keys[0] = _crc32($keys[0], $c);
      $keys[1] = (($keys[1] + ($keys[0] & 0xff)) * 0x08088405 + 1) & 0xffffffff;
      my $keyshift = $keys[1] >> 24;
      $keys[2] = _crc32($keys[2], $keyshift);
  }    # _update_keys
  
  sub _zdecode ($) {
      my $c = shift;
      my $t = ($keys[2] & 0xffff) | 2;
      _update_keys($c ^= ((($t * ($t ^ 1)) >> 8) & 0xff));
      return $c;
  }    # _zdecode
  
  sub _decode {
      my $self = shift;
      my $buff = shift;
  
      $self->isEncrypted or return $buff;
  
      my $pass = $self->password;
      defined $pass or return "";
  
      @keys = (0x12345678, 0x23456789, 0x34567890);
      _update_keys($_) for unpack "C*", $pass;
  
      # DDumper { uk => [ @keys ] };
  
      my $head = substr $buff, 0, 12, "";
      my @head = map { _zdecode($_) } unpack "C*", $head;
      my $x =
        $self->{externalFileAttributes}
        ? ($self->{lastModFileDateTime} >> 8) & 0xff
        : $self->{crc32} >> 24;
      $head[-1] == $x or return "";    # Password fail
  
      # Worth checking ...
      $self->{crc32c} = (unpack LOCAL_FILE_HEADER_FORMAT, pack "C*", @head)[3];
  
      # DHexDump ($buff);
      $buff = pack "C*" => map { _zdecode($_) } unpack "C*" => $buff;
  
      # DHexDump ($buff);
      return $buff;
  }    # _decode
  
  1;
ARCHIVE_ZIP_MEMBER

$fatpacked{"Archive/Zip/MemberRead.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_MEMBERREAD';
  package Archive::Zip::MemberRead;
  
  =head1 NAME
  
  Archive::Zip::MemberRead - A wrapper that lets you read Zip archive members as if they were files.
  
  =cut
  
  =head1 SYNOPSIS
  
    use Archive::Zip;
    use Archive::Zip::MemberRead;
    $zip = Archive::Zip->new("file.zip");
    $fh  = Archive::Zip::MemberRead->new($zip, "subdir/abc.txt");
    while (defined($line = $fh->getline()))
    {
        print $fh->input_line_number . "#: $line\n";
    }
  
    $read = $fh->read($buffer, 32*1024);
    print "Read $read bytes as :$buffer:\n";
  
  =head1 DESCRIPTION
  
  The Archive::Zip::MemberRead module lets you read Zip archive member data
  just like you read data from files.
  
  =head1 METHODS
  
  =over 4
  
  =cut
  
  use strict;
  
  use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
  
  use vars qw{$VERSION};
  
  my $nl;
  
  BEGIN {
      $VERSION = '1.57';
      $VERSION = eval $VERSION;
  
  # Requirement for newline conversion. Should check for e.g., DOS and OS/2 as well, but am too lazy.
      $nl = $^O eq 'MSWin32' ? "\r\n" : "\n";
  }
  
  =item Archive::Zip::Member::readFileHandle()
  
  You can get a C<Archive::Zip::MemberRead> from an archive member by
  calling C<readFileHandle()>:
  
    my $member = $zip->memberNamed('abc/def.c');
    my $fh = $member->readFileHandle();
    while (defined($line = $fh->getline()))
    {
        # ...
    }
    $fh->close();
  
  =cut
  
  sub Archive::Zip::Member::readFileHandle {
      return Archive::Zip::MemberRead->new(shift());
  }
  
  =item Archive::Zip::MemberRead->new($zip, $fileName)
  
  =item Archive::Zip::MemberRead->new($zip, $member)
  
  =item Archive::Zip::MemberRead->new($member)
  
  Construct a new Archive::Zip::MemberRead on the specified member.
  
    my $fh = Archive::Zip::MemberRead->new($zip, 'fred.c')
  
  =cut
  
  sub new {
      my ($class, $zip, $file) = @_;
      my ($self, $member);
  
      if ($zip && $file)    # zip and filename, or zip and member
      {
          $member = ref($file) ? $file : $zip->memberNamed($file);
      } elsif ($zip && !$file && ref($zip))    # just member
      {
          $member = $zip;
      } else {
          die(
              'Archive::Zip::MemberRead::new needs a zip and filename, zip and member, or member'
          );
      }
  
      $self = {};
      bless($self, $class);
      $self->set_member($member);
      return $self;
  }
  
  sub set_member {
      my ($self, $member) = @_;
  
      $self->{member} = $member;
      $self->set_compression(COMPRESSION_STORED);
      $self->rewind();
  }
  
  sub set_compression {
      my ($self, $compression) = @_;
      $self->{member}->desiredCompressionMethod($compression) if $self->{member};
  }
  
  =item setLineEnd(expr)
  
  Set the line end character to use. This is set to \n by default
  except on Windows systems where it is set to \r\n. You will
  only need to set this on systems which are not Windows or Unix
  based and require a line end different from \n.
  This is a class method so call as C<Archive::Zip::MemberRead>->C<setLineEnd($nl)>
  
  =cut
  
  sub setLineEnd {
      shift;
      $nl = shift;
  }
  
  =item rewind()
  
  Rewinds an C<Archive::Zip::MemberRead> so that you can read from it again
  starting at the beginning.
  
  =cut
  
  sub rewind {
      my $self = shift;
  
      $self->_reset_vars();
      $self->{member}->rewindData() if $self->{member};
  }
  
  sub _reset_vars {
      my $self = shift;
  
      $self->{line_no} = 0;
      $self->{at_end}  = 0;
  
      delete $self->{buffer};
  }
  
  =item input_record_separator(expr)
  
  If the argument is given, input_record_separator for this
  instance is set to it. The current setting (which may be
  the global $/) is always returned.
  
  =cut
  
  sub input_record_separator {
      my $self = shift;
      if (@_) {
          $self->{sep} = shift;
          $self->{sep_re} =
            _sep_as_re($self->{sep});    # Cache the RE as an optimization
      }
      return exists $self->{sep} ? $self->{sep} : $/;
  }
  
  # Return the input_record_separator in use as an RE fragment
  # Note that if we have a per-instance input_record_separator
  # we can just return the already converted value. Otherwise,
  # the conversion must be done on $/ every time since we cannot
  # know whether it has changed or not.
  sub _sep_re {
      my $self = shift;
  
      # Important to phrase this way: sep's value may be undef.
      return exists $self->{sep} ? $self->{sep_re} : _sep_as_re($/);
  }
  
  # Convert the input record separator into an RE and return it.
  sub _sep_as_re {
      my $sep = shift;
      if (defined $sep) {
          if ($sep eq '') {
              return "(?:$nl){2,}";
          } else {
              $sep =~ s/\n/$nl/og;
              return quotemeta $sep;
          }
      } else {
          return undef;
      }
  }
  
  =item input_line_number()
  
  Returns the current line number, but only if you're using C<getline()>.
  Using C<read()> will not update the line number.
  
  =cut
  
  sub input_line_number {
      my $self = shift;
      return $self->{line_no};
  }
  
  =item close()
  
  Closes the given file handle.
  
  =cut
  
  sub close {
      my $self = shift;
  
      $self->_reset_vars();
      $self->{member}->endRead();
  }
  
  =item buffer_size([ $size ])
  
  Gets or sets the buffer size used for reads.
  Default is the chunk size used by Archive::Zip.
  
  =cut
  
  sub buffer_size {
      my ($self, $size) = @_;
  
      if (!$size) {
          return $self->{chunkSize} || Archive::Zip::chunkSize();
      } else {
          $self->{chunkSize} = $size;
      }
  }
  
  =item getline()
  
  Returns the next line from the currently open member.
  Makes sense only for text files.
  A read error is considered fatal enough to die.
  Returns undef on eof. All subsequent calls would return undef,
  unless a rewind() is called.
  Note: The line returned has the input_record_separator (default: newline) removed.
  
  =item getline( { preserve_line_ending => 1 } )
  
  Returns the next line including the line ending.
  
  =cut
  
  sub getline {
      my ($self, $argref) = @_;
  
      my $size = $self->buffer_size();
      my $sep  = $self->_sep_re();
  
      my $preserve_line_ending;
      if (ref $argref eq 'HASH') {
          $preserve_line_ending = $argref->{'preserve_line_ending'};
          $sep =~ s/\\([^A-Za-z_0-9])+/$1/g;
      }
  
      for (; ;) {
          if (   $sep
              && defined($self->{buffer})
              && $self->{buffer} =~ s/^(.*?)$sep//s) {
              my $line = $1;
              $self->{line_no}++;
              if ($preserve_line_ending) {
                  return $line . $sep;
              } else {
                  return $line;
              }
          } elsif ($self->{at_end}) {
              $self->{line_no}++ if $self->{buffer};
              return delete $self->{buffer};
          }
          my ($temp, $status) = $self->{member}->readChunk($size);
          if ($status != AZ_OK && $status != AZ_STREAM_END) {
              die "ERROR: Error reading chunk from archive - $status";
          }
          $self->{at_end} = $status == AZ_STREAM_END;
          $self->{buffer} .= $$temp;
      }
  }
  
  =item read($buffer, $num_bytes_to_read)
  
  Simulates a normal C<read()> system call.
  Returns the no. of bytes read. C<undef> on error, 0 on eof, I<e.g.>:
  
    $fh = Archive::Zip::MemberRead->new($zip, "sreeji/secrets.bin");
    while (1)
    {
      $read = $fh->read($buffer, 1024);
      die "FATAL ERROR reading my secrets !\n" if (!defined($read));
      last if (!$read);
      # Do processing.
      ....
     }
  
  =cut
  
  #
  # All these $_ are required to emulate read().
  #
  sub read {
      my $self = $_[0];
      my $size = $_[2];
      my ($temp, $status, $ret);
  
      ($temp, $status) = $self->{member}->readChunk($size);
      if ($status != AZ_OK && $status != AZ_STREAM_END) {
          $_[1] = undef;
          $ret = undef;
      } else {
          $_[1] = $$temp;
          $ret = length($$temp);
      }
      return $ret;
  }
  
  1;
  
  =back
  
  =head1 AUTHOR
  
  Sreeji K. Das E<lt>sreeji_k@yahoo.comE<gt>
  
  See L<Archive::Zip> by Ned Konz without which this module does not make
  any sense! 
  
  Minor mods by Ned Konz.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Sreeji K. Das.
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
  
  =cut
ARCHIVE_ZIP_MEMBERREAD

$fatpacked{"Archive/Zip/MockFileHandle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_MOCKFILEHANDLE';
  package Archive::Zip::MockFileHandle;
  
  # Output file handle that calls a custom write routine
  # Ned Konz, March 2000
  # This is provided to help with writing zip files
  # when you have to process them a chunk at a time.
  
  use strict;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '1.57';
      $VERSION = eval $VERSION;
  }
  
  sub new {
      my $class = shift || __PACKAGE__;
      $class = ref($class) || $class;
      my $self = bless(
          {
              'position' => 0,
              'size'     => 0
          },
          $class
      );
      return $self;
  }
  
  sub eof {
      my $self = shift;
      return $self->{'position'} >= $self->{'size'};
  }
  
  # Copy given buffer to me
  sub print {
      my $self         = shift;
      my $bytes        = join('', @_);
      my $bytesWritten = $self->writeHook($bytes);
      if ($self->{'position'} + $bytesWritten > $self->{'size'}) {
          $self->{'size'} = $self->{'position'} + $bytesWritten;
      }
      $self->{'position'} += $bytesWritten;
      return $bytesWritten;
  }
  
  # Called on each write.
  # Override in subclasses.
  # Return number of bytes written (0 on error).
  sub writeHook {
      my $self  = shift;
      my $bytes = shift;
      return length($bytes);
  }
  
  sub binmode { 1 }
  
  sub close { 1 }
  
  sub clearerr { 1 }
  
  # I'm write-only!
  sub read { 0 }
  
  sub tell { return shift->{'position'} }
  
  sub opened { 1 }
  
  1;
ARCHIVE_ZIP_MOCKFILEHANDLE

$fatpacked{"Archive/Zip/NewFileMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_NEWFILEMEMBER';
  package Archive::Zip::NewFileMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw ( Archive::Zip::FileMember );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
    :UTILITY_METHODS
  );
  
  # Given a file name, set up for eventual writing.
  sub _newFromFileNamed {
      my $class    = shift;
      my $fileName = shift;    # local FS format
      my $newName  = shift;
      $newName = _asZipDirName($fileName) unless defined($newName);
      return undef unless (stat($fileName) && -r _ && !-d _ );
      my $self = $class->new(@_);
      $self->{'fileName'}          = $newName;
      $self->{'externalFileName'}  = $fileName;
      $self->{'compressionMethod'} = COMPRESSION_STORED;
      my @stat = stat(_);
      $self->{'compressedSize'} = $self->{'uncompressedSize'} = $stat[7];
      $self->desiredCompressionMethod(
          ($self->compressedSize() > 0)
          ? COMPRESSION_DEFLATED
          : COMPRESSION_STORED
      );
      $self->unixFileAttributes($stat[2]);
      $self->setLastModFileDateTimeFromUnix($stat[9]);
      $self->isTextFile(-T _ );
      return $self;
  }
  
  sub rewindData {
      my $self = shift;
  
      my $status = $self->SUPER::rewindData(@_);
      return $status unless $status == AZ_OK;
  
      return AZ_IO_ERROR unless $self->fh();
      $self->fh()->clearerr();
      $self->fh()->seek(0, IO::Seekable::SEEK_SET)
        or return _ioError("rewinding", $self->externalFileName());
      return AZ_OK;
  }
  
  # Return bytes read. Note that first parameter is a ref to a buffer.
  # my $data;
  # my ( $bytesRead, $status) = $self->readRawChunk( \$data, $chunkSize );
  sub _readRawChunk {
      my ($self, $dataRef, $chunkSize) = @_;
      return (0, AZ_OK) unless $chunkSize;
      my $bytesRead = $self->fh()->read($$dataRef, $chunkSize)
        or return (0, _ioError("reading data"));
      return ($bytesRead, AZ_OK);
  }
  
  # If I already exist, extraction is a no-op.
  sub extractToFileNamed {
      my $self = shift;
      my $name = shift;    # local FS name
      if (File::Spec->rel2abs($name) eq
          File::Spec->rel2abs($self->externalFileName()) and -r $name) {
          return AZ_OK;
      } else {
          return $self->SUPER::extractToFileNamed($name, @_);
      }
  }
  
  1;
ARCHIVE_ZIP_NEWFILEMEMBER

$fatpacked{"Archive/Zip/StringMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_STRINGMEMBER';
  package Archive::Zip::StringMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw( Archive::Zip::Member );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
  );
  
  # Create a new string member. Default is COMPRESSION_STORED.
  # Can take a ref to a string as well.
  sub _newFromString {
      my $class  = shift;
      my $string = shift;
      my $name   = shift;
      my $self   = $class->new(@_);
      $self->contents($string);
      $self->fileName($name) if defined($name);
  
      # Set the file date to now
      $self->setLastModFileDateTimeFromUnix(time());
      $self->unixFileAttributes($self->DEFAULT_FILE_PERMISSIONS);
      return $self;
  }
  
  sub _become {
      my $self     = shift;
      my $newClass = shift;
      return $self if ref($self) eq $newClass;
      delete($self->{'contents'});
      return $self->SUPER::_become($newClass);
  }
  
  # Get or set my contents. Note that we do not call the superclass
  # version of this, because it calls us.
  sub contents {
      my $self   = shift;
      my $string = shift;
      if (defined($string)) {
          $self->{'contents'} =
            pack('C0a*', (ref($string) eq 'SCALAR') ? $$string : $string);
          $self->{'uncompressedSize'} = $self->{'compressedSize'} =
            length($self->{'contents'});
          $self->{'compressionMethod'} = COMPRESSION_STORED;
      }
      return $self->{'contents'};
  }
  
  # Return bytes read. Note that first parameter is a ref to a buffer.
  # my $data;
  # my ( $bytesRead, $status) = $self->readRawChunk( \$data, $chunkSize );
  sub _readRawChunk {
      my ($self, $dataRef, $chunkSize) = @_;
      $$dataRef = substr($self->contents(), $self->_readOffset(), $chunkSize);
      return (length($$dataRef), AZ_OK);
  }
  
  1;
ARCHIVE_ZIP_STRINGMEMBER

$fatpacked{"Archive/Zip/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_TREE';
  package Archive::Zip::Tree;
  
  use strict;
  use vars qw{$VERSION};
  
  BEGIN {
  	$VERSION = '1.57';
  }
  
  use Archive::Zip;
  
  warn(
      "Archive::Zip::Tree is deprecated; its methods have been moved into Archive::Zip."
  ) if $^W;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Archive::Zip::Tree - (DEPRECATED) methods for adding/extracting trees using Archive::Zip
  
  =head1 DESCRIPTION
  
  This module is deprecated, because all its methods were moved into the main
  Archive::Zip module.
  
  It is included in the distribution merely to avoid breaking old code.
  
  See L<Archive::Zip>.
  
  =head1 AUTHOR
  
  Ned Konz, perl@bike-nomad.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2000-2002 Ned Konz. All rights reserved.  This program is free
  software; you can redistribute it and/or modify it under the same terms
  as Perl itself.
  
  =head1 SEE ALSO
  
  L<Archive::Zip>
  
  =cut
  
ARCHIVE_ZIP_TREE

$fatpacked{"Archive/Zip/ZipFileMember.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ARCHIVE_ZIP_ZIPFILEMEMBER';
  package Archive::Zip::ZipFileMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.57';
      @ISA     = qw ( Archive::Zip::FileMember );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
    :PKZIP_CONSTANTS
    :UTILITY_METHODS
  );
  
  # Create a new Archive::Zip::ZipFileMember
  # given a filename and optional open file handle
  #
  sub _newFromZipFile {
      my $class              = shift;
      my $fh                 = shift;
      my $externalFileName   = shift;
      my $possibleEocdOffset = shift;    # normally 0
  
      my $self = $class->new(
          'crc32'                     => 0,
          'diskNumberStart'           => 0,
          'localHeaderRelativeOffset' => 0,
          'dataOffset' => 0,    # localHeaderRelativeOffset + header length
          @_
      );
      $self->{'externalFileName'}   = $externalFileName;
      $self->{'fh'}                 = $fh;
      $self->{'possibleEocdOffset'} = $possibleEocdOffset;
      return $self;
  }
  
  sub isDirectory {
      my $self = shift;
      return (substr($self->fileName, -1, 1) eq '/'
            and $self->uncompressedSize == 0);
  }
  
  # Seek to the beginning of the local header, just past the signature.
  # Verify that the local header signature is in fact correct.
  # Update the localHeaderRelativeOffset if necessary by adding the possibleEocdOffset.
  # Returns status.
  
  sub _seekToLocalHeader {
      my $self          = shift;
      my $where         = shift;    # optional
      my $previousWhere = shift;    # optional
  
      $where = $self->localHeaderRelativeOffset() unless defined($where);
  
      # avoid loop on certain corrupt files (from Julian Field)
      return _formatError("corrupt zip file")
        if defined($previousWhere) && $where == $previousWhere;
  
      my $status;
      my $signature;
  
      $status = $self->fh()->seek($where, IO::Seekable::SEEK_SET);
      return _ioError("seeking to local header") unless $status;
  
      ($status, $signature) =
        _readSignature($self->fh(), $self->externalFileName(),
          LOCAL_FILE_HEADER_SIGNATURE);
      return $status if $status == AZ_IO_ERROR;
  
      # retry with EOCD offset if any was given.
      if ($status == AZ_FORMAT_ERROR && $self->{'possibleEocdOffset'}) {
          $status = $self->_seekToLocalHeader(
              $self->localHeaderRelativeOffset() + $self->{'possibleEocdOffset'},
              $where
          );
          if ($status == AZ_OK) {
              $self->{'localHeaderRelativeOffset'} +=
                $self->{'possibleEocdOffset'};
              $self->{'possibleEocdOffset'} = 0;
          }
      }
  
      return $status;
  }
  
  # Because I'm going to delete the file handle, read the local file
  # header if the file handle is seekable. If it is not, I assume that
  # I've already read the local header.
  # Return ( $status, $self )
  
  sub _become {
      my $self     = shift;
      my $newClass = shift;
      return $self if ref($self) eq $newClass;
  
      my $status = AZ_OK;
  
      if (_isSeekable($self->fh())) {
          my $here = $self->fh()->tell();
          $status = $self->_seekToLocalHeader();
          $status = $self->_readLocalFileHeader() if $status == AZ_OK;
          $self->fh()->seek($here, IO::Seekable::SEEK_SET);
          return $status unless $status == AZ_OK;
      }
  
      delete($self->{'eocdCrc32'});
      delete($self->{'diskNumberStart'});
      delete($self->{'localHeaderRelativeOffset'});
      delete($self->{'dataOffset'});
  
      return $self->SUPER::_become($newClass);
  }
  
  sub diskNumberStart {
      shift->{'diskNumberStart'};
  }
  
  sub localHeaderRelativeOffset {
      shift->{'localHeaderRelativeOffset'};
  }
  
  sub dataOffset {
      shift->{'dataOffset'};
  }
  
  # Skip local file header, updating only extra field stuff.
  # Assumes that fh is positioned before signature.
  sub _skipLocalFileHeader {
      my $self = shift;
      my $header;
      my $bytesRead = $self->fh()->read($header, LOCAL_FILE_HEADER_LENGTH);
      if ($bytesRead != LOCAL_FILE_HEADER_LENGTH) {
          return _ioError("reading local file header");
      }
      my $fileNameLength;
      my $extraFieldLength;
      my $bitFlag;
      (
          undef,    # $self->{'versionNeededToExtract'},
          $bitFlag,
          undef,    # $self->{'compressionMethod'},
          undef,    # $self->{'lastModFileDateTime'},
          undef,    # $crc32,
          undef,    # $compressedSize,
          undef,    # $uncompressedSize,
          $fileNameLength,
          $extraFieldLength
      ) = unpack(LOCAL_FILE_HEADER_FORMAT, $header);
  
      if ($fileNameLength) {
          $self->fh()->seek($fileNameLength, IO::Seekable::SEEK_CUR)
            or return _ioError("skipping local file name");
      }
  
      if ($extraFieldLength) {
          $bytesRead =
            $self->fh()->read($self->{'localExtraField'}, $extraFieldLength);
          if ($bytesRead != $extraFieldLength) {
              return _ioError("reading local extra field");
          }
      }
  
      $self->{'dataOffset'} = $self->fh()->tell();
  
      if ($bitFlag & GPBF_HAS_DATA_DESCRIPTOR_MASK) {
  
          # Read the crc32, compressedSize, and uncompressedSize from the
          # extended data descriptor, which directly follows the compressed data.
          #
          # Skip over the compressed file data (assumes that EOCD compressedSize
          # was correct)
          $self->fh()->seek($self->{'compressedSize'}, IO::Seekable::SEEK_CUR)
            or return _ioError("seeking to extended local header");
  
          # these values should be set correctly from before.
          my $oldCrc32            = $self->{'eocdCrc32'};
          my $oldCompressedSize   = $self->{'compressedSize'};
          my $oldUncompressedSize = $self->{'uncompressedSize'};
  
          my $status = $self->_readDataDescriptor();
          return $status unless $status == AZ_OK;
  
          # The buffer withe encrypted data is prefixed with a new
          # encrypted 12 byte header. The size only changes when
          # the buffer is also compressed
          $self->isEncrypted && $oldUncompressedSize > $self->{uncompressedSize}
            and $oldUncompressedSize -= DATA_DESCRIPTOR_LENGTH;
  
          return _formatError(
              "CRC or size mismatch while skipping data descriptor")
            if ( $oldCrc32 != $self->{'crc32'}
              || $oldUncompressedSize != $self->{'uncompressedSize'});
  
          $self->{'crc32'} = 0 
              if $self->compressionMethod() == COMPRESSION_STORED ; 
      }
  
      return AZ_OK;
  }
  
  # Read from a local file header into myself. Returns AZ_OK if successful.
  # Assumes that fh is positioned after signature.
  # Note that crc32, compressedSize, and uncompressedSize will be 0 if
  # GPBF_HAS_DATA_DESCRIPTOR_MASK is set in the bitFlag.
  
  sub _readLocalFileHeader {
      my $self = shift;
      my $header;
      my $bytesRead = $self->fh()->read($header, LOCAL_FILE_HEADER_LENGTH);
      if ($bytesRead != LOCAL_FILE_HEADER_LENGTH) {
          return _ioError("reading local file header");
      }
      my $fileNameLength;
      my $crc32;
      my $compressedSize;
      my $uncompressedSize;
      my $extraFieldLength;
      (
          $self->{'versionNeededToExtract'}, $self->{'bitFlag'},
          $self->{'compressionMethod'},      $self->{'lastModFileDateTime'},
          $crc32,                            $compressedSize,
          $uncompressedSize,                 $fileNameLength,
          $extraFieldLength
      ) = unpack(LOCAL_FILE_HEADER_FORMAT, $header);
  
      if ($fileNameLength) {
          my $fileName;
          $bytesRead = $self->fh()->read($fileName, $fileNameLength);
          if ($bytesRead != $fileNameLength) {
              return _ioError("reading local file name");
          }
          $self->fileName($fileName);
      }
  
      if ($extraFieldLength) {
          $bytesRead =
            $self->fh()->read($self->{'localExtraField'}, $extraFieldLength);
          if ($bytesRead != $extraFieldLength) {
              return _ioError("reading local extra field");
          }
      }
  
      $self->{'dataOffset'} = $self->fh()->tell();
  
      if ($self->hasDataDescriptor()) {
  
          # Read the crc32, compressedSize, and uncompressedSize from the
          # extended data descriptor.
          # Skip over the compressed file data (assumes that EOCD compressedSize
          # was correct)
          $self->fh()->seek($self->{'compressedSize'}, IO::Seekable::SEEK_CUR)
            or return _ioError("seeking to extended local header");
  
          my $status = $self->_readDataDescriptor();
          return $status unless $status == AZ_OK;
      } else {
          return _formatError(
              "CRC or size mismatch after reading data descriptor")
            if ( $self->{'crc32'} != $crc32
              || $self->{'uncompressedSize'} != $uncompressedSize);
      }
  
      return AZ_OK;
  }
  
  # This will read the data descriptor, which is after the end of compressed file
  # data in members that have GPBF_HAS_DATA_DESCRIPTOR_MASK set in their bitFlag.
  # The only reliable way to find these is to rely on the EOCD compressedSize.
  # Assumes that file is positioned immediately after the compressed data.
  # Returns status; sets crc32, compressedSize, and uncompressedSize.
  sub _readDataDescriptor {
      my $self = shift;
      my $signatureData;
      my $header;
      my $crc32;
      my $compressedSize;
      my $uncompressedSize;
  
      my $bytesRead = $self->fh()->read($signatureData, SIGNATURE_LENGTH);
      return _ioError("reading header signature")
        if $bytesRead != SIGNATURE_LENGTH;
      my $signature = unpack(SIGNATURE_FORMAT, $signatureData);
  
      # unfortunately, the signature appears to be optional.
      if ($signature == DATA_DESCRIPTOR_SIGNATURE
          && ($signature != $self->{'crc32'})) {
          $bytesRead = $self->fh()->read($header, DATA_DESCRIPTOR_LENGTH);
          return _ioError("reading data descriptor")
            if $bytesRead != DATA_DESCRIPTOR_LENGTH;
  
          ($crc32, $compressedSize, $uncompressedSize) =
            unpack(DATA_DESCRIPTOR_FORMAT, $header);
      } else {
          $bytesRead = $self->fh()->read($header, DATA_DESCRIPTOR_LENGTH_NO_SIG);
          return _ioError("reading data descriptor")
            if $bytesRead != DATA_DESCRIPTOR_LENGTH_NO_SIG;
  
          $crc32 = $signature;
          ($compressedSize, $uncompressedSize) =
            unpack(DATA_DESCRIPTOR_FORMAT_NO_SIG, $header);
      }
  
      $self->{'eocdCrc32'} = $self->{'crc32'}
        unless defined($self->{'eocdCrc32'});
      $self->{'crc32'}            = $crc32;
      $self->{'compressedSize'}   = $compressedSize;
      $self->{'uncompressedSize'} = $uncompressedSize;
  
      return AZ_OK;
  }
  
  # Read a Central Directory header. Return AZ_OK on success.
  # Assumes that fh is positioned right after the signature.
  
  sub _readCentralDirectoryFileHeader {
      my $self      = shift;
      my $fh        = $self->fh();
      my $header    = '';
      my $bytesRead = $fh->read($header, CENTRAL_DIRECTORY_FILE_HEADER_LENGTH);
      if ($bytesRead != CENTRAL_DIRECTORY_FILE_HEADER_LENGTH) {
          return _ioError("reading central dir header");
      }
      my ($fileNameLength, $extraFieldLength, $fileCommentLength);
      (
          $self->{'versionMadeBy'},
          $self->{'fileAttributeFormat'},
          $self->{'versionNeededToExtract'},
          $self->{'bitFlag'},
          $self->{'compressionMethod'},
          $self->{'lastModFileDateTime'},
          $self->{'crc32'},
          $self->{'compressedSize'},
          $self->{'uncompressedSize'},
          $fileNameLength,
          $extraFieldLength,
          $fileCommentLength,
          $self->{'diskNumberStart'},
          $self->{'internalFileAttributes'},
          $self->{'externalFileAttributes'},
          $self->{'localHeaderRelativeOffset'}
      ) = unpack(CENTRAL_DIRECTORY_FILE_HEADER_FORMAT, $header);
  
      $self->{'eocdCrc32'} = $self->{'crc32'};
  
      if ($fileNameLength) {
          $bytesRead = $fh->read($self->{'fileName'}, $fileNameLength);
          if ($bytesRead != $fileNameLength) {
              _ioError("reading central dir filename");
          }
      }
      if ($extraFieldLength) {
          $bytesRead = $fh->read($self->{'cdExtraField'}, $extraFieldLength);
          if ($bytesRead != $extraFieldLength) {
              return _ioError("reading central dir extra field");
          }
      }
      if ($fileCommentLength) {
          $bytesRead = $fh->read($self->{'fileComment'}, $fileCommentLength);
          if ($bytesRead != $fileCommentLength) {
              return _ioError("reading central dir file comment");
          }
      }
  
      # NK 10/21/04: added to avoid problems with manipulated headers
      if (    $self->{'uncompressedSize'} != $self->{'compressedSize'}
          and $self->{'compressionMethod'} == COMPRESSION_STORED) {
          $self->{'uncompressedSize'} = $self->{'compressedSize'};
      }
  
      $self->desiredCompressionMethod($self->compressionMethod());
  
      return AZ_OK;
  }
  
  sub rewindData {
      my $self = shift;
  
      my $status = $self->SUPER::rewindData(@_);
      return $status unless $status == AZ_OK;
  
      return AZ_IO_ERROR unless $self->fh();
  
      $self->fh()->clearerr();
  
      # Seek to local file header.
      # The only reason that I'm doing this this way is that the extraField
      # length seems to be different between the CD header and the LF header.
      $status = $self->_seekToLocalHeader();
      return $status unless $status == AZ_OK;
  
      # skip local file header
      $status = $self->_skipLocalFileHeader();
      return $status unless $status == AZ_OK;
  
      # Seek to beginning of file data
      $self->fh()->seek($self->dataOffset(), IO::Seekable::SEEK_SET)
        or return _ioError("seeking to beginning of file data");
  
      return AZ_OK;
  }
  
  # Return bytes read. Note that first parameter is a ref to a buffer.
  # my $data;
  # my ( $bytesRead, $status) = $self->readRawChunk( \$data, $chunkSize );
  sub _readRawChunk {
      my ($self, $dataRef, $chunkSize) = @_;
      return (0, AZ_OK) unless $chunkSize;
      my $bytesRead = $self->fh()->read($$dataRef, $chunkSize)
        or return (0, _ioError("reading data"));
      return ($bytesRead, AZ_OK);
  }
  
  1;
ARCHIVE_ZIP_ZIPFILEMEMBER

$fatpacked{"Crypt/RC4.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_RC4';
  #--------------------------------------------------------------------#
  # Crypt::RC4
  #       Date Written:   07-Jun-2000 04:15:55 PM
  #       Last Modified:  13-Dec-2001 03:33:49 PM 
  #       Author:         Kurt Kincaid (sifukurt@yahoo.com)
  #       Copyright (c) 2001, Kurt Kincaid
  #           All Rights Reserved.
  #
  #       This is free software and may be modified and/or
  #       redistributed under the same terms as Perl itself.
  #--------------------------------------------------------------------#
  
  package Crypt::RC4;
  
  use strict;
  use vars qw( $VERSION @ISA @EXPORT $MAX_CHUNK_SIZE );
  
  $MAX_CHUNK_SIZE = 1024 unless $MAX_CHUNK_SIZE;
  
  require Exporter;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(RC4);
  $VERSION = '2.02';
  
  sub new {
      my ( $class, $key )  = @_;
      my $self = bless {}, $class;
      $self->{state} = Setup( $key );
      $self->{x} = 0;
      $self->{y} = 0;
      $self;
  }
  
  sub RC4 {
      my $self;
      my( @state, $x, $y );
      if ( ref $_[0] ) {
          $self = shift;
      @state = @{ $self->{state} };
      $x = $self->{x};
      $y = $self->{y};
      } else {
          @state = Setup( shift );
      $x = $y = 0;
      }
      my $message = shift;
      my $num_pieces = do {
      my $num = length($message) / $MAX_CHUNK_SIZE;
      my $int = int $num;
      $int == $num ? $int : $int+1;
      };
      for my $piece ( 0..$num_pieces - 1 ) {
      my @message = unpack "C*", substr($message, $piece * $MAX_CHUNK_SIZE, $MAX_CHUNK_SIZE);
      for ( @message ) {
          $x = 0 if ++$x > 255;
          $y -= 256 if ($y += $state[$x]) > 255;
          @state[$x, $y] = @state[$y, $x];
          $_ ^= $state[( $state[$x] + $state[$y] ) % 256];
      }
      substr($message, $piece * $MAX_CHUNK_SIZE, $MAX_CHUNK_SIZE) = pack "C*", @message;
      }
      if ($self) {
      $self->{state} = \@state;
      $self->{x} = $x;
      $self->{y} = $y;
      }
      $message;
  }
  
  sub Setup {
      my @k = unpack( 'C*', shift );
      my @state = 0..255;
      my $y = 0;
      for my $x (0..255) {
      $y = ( $k[$x % @k] + $state[$x] + $y ) % 256;
      @state[$x, $y] = @state[$y, $x];
      }
      wantarray ? @state : \@state;
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Crypt::RC4 - Perl implementation of the RC4 encryption algorithm
  
  =head1 SYNOPSIS
  
  # Functional Style
    use Crypt::RC4;
    $encrypted = RC4( $passphrase, $plaintext );
    $decrypt = RC4( $passphrase, $encrypted );
    
  # OO Style
    use Crypt::RC4;
    $ref = Crypt::RC4->new( $passphrase );
    $encrypted = $ref->RC4( $plaintext );
  
    $ref2 = Crypt::RC4->new( $passphrase );
    $decrypted = $ref2->RC4( $encrypted );
  
  # process an entire file, one line at a time
  # (Warning: Encrypted file leaks line lengths.)
    $ref3 = Crypt::RC4->new( $passphrase );
    while (<FILE>) {
        chomp;
        print $ref3->RC4($_), "\n";
    }
  
  =head1 DESCRIPTION
  
  A simple implementation of the RC4 algorithm, developed by RSA Security, Inc. Here is the description
  from RSA's website:
  
  RC4 is a stream cipher designed by Rivest for RSA Data Security (now RSA Security). It is a variable
  key-size stream cipher with byte-oriented operations. The algorithm is based on the use of a random
  permutation. Analysis shows that the period of the cipher is overwhelmingly likely to be greater than
  10100. Eight to sixteen machine operations are required per output byte, and the cipher can be
  expected to run very quickly in software. Independent analysts have scrutinized the algorithm and it
  is considered secure.
  
  Based substantially on the "RC4 in 3 lines of perl" found at http://www.cypherspace.org
  
  A major bug in v1.0 was fixed by David Hook (dgh@wumpus.com.au).  Thanks, David.
  
  =head1 AUTHOR
  
  Kurt Kincaid (sifukurt@yahoo.com)
  Ronald Rivest for RSA Security, Inc.
  
  =head1 BUGS
  
  Disclaimer: Strictly speaking, this module uses the "alleged" RC4
  algorithm. The Algorithm known as "RC4" is a trademark of RSA Security
  Inc., and this document makes no claims one way or another that this
  is the correct algorithm, and further, make no claims about the
  quality of the source code nor any licensing requirements for
  commercial use.
  
  There's nothing preventing you from using this module in an insecure
  way which leaks information. For example, encrypting multilple
  messages with the same passphrase may allow an attacker to decode all of
  them with little effort, even though they'll appear to be secured. If
  serious crypto is your goal, be careful. Be very careful.
  
  It's a pure-Perl implementation, so that rating of "Eight
  to sixteen machine operations" is good for nothing but a good laugh.
  If encryption and decryption are a bottleneck for you, please re-write
  this module to use native code wherever practical.
  
  =head1 LICENSE
  
  This is free software and may be modified and/or
  redistributed under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<perl>, L<http://www.cypherspace.org>, L<http://www.rsasecurity.com>, 
  L<http://www.achtung.com/crypto/rc4.html>, 
  L<http://www.columbia.edu/~ariel/ssleay/rrc4.html>
  
  =cut
CRYPT_RC4

$fatpacked{"Digest/Perl/MD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIGEST_PERL_MD5';
  package Digest::Perl::MD5;
  use strict;
  use integer;
  use Exporter;
  use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);
  
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  @ISA = 'Exporter';
  $VERSION = '1.9';
  
  # I-Vektor
  sub A() { 0x67_45_23_01 }
  sub B() { 0xef_cd_ab_89 }
  sub C() { 0x98_ba_dc_fe }
  sub D() { 0x10_32_54_76 }
  
  # for internal use
  sub MAX() { 0xFFFFFFFF }
  
  # pad a message to a multiple of 64
  sub padding {
      my $l = length (my $msg = shift() . chr(128));    
      $msg .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  }
  
  
  sub rotate_left($$) {
  	#$_[0] << $_[1] | $_[0] >> (32 - $_[1]);
  	#my $right = $_[0] >> (32 - $_[1]);
  	#my $rmask = (1 << $_[1]) - 1;
  	($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));
  	#$_[0] << $_[1] | (($_[0]>> (32 - $_[1])) & (1 << (32 - $_[1])) - 1);
  }
  
  sub gen_code {
    # Discard upper 32 bits on 64 bit archs.
    my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';
  #	FF => "X0=rotate_left(((X1&X2)|(~X1&X3))+X0+X4+X6$MSK,X5)+X1$MSK;",
  #	GG => "X0=rotate_left(((X1&X3)|(X2&(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    my %f = (
  	FF => "X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	GG => "X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	HH => "X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",
  	II => "X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    );
    #unless ( (1 << 16) << 16) { %f = %{$CODES{'32bit'}} }
    #else { %f = %{$CODES{'64bit'}} }
  
    my %s = (  # shift lengths
  	S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,
  	S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,
  	S43 => 15, S44 => 21
    );
  
    my $insert = "\n";
    while(defined( my $data = <DATA> )) {
  	chomp $data;
  	next unless $data =~ /^[FGHI]/;
  	my ($func,@x) = split /,/, $data;
  	my $c = $f{$func};
  	$c =~ s/X(\d)/$x[$1]/g;
  	$c =~ s/(S\d{2})/$s{$1}/;
  	$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;
  
  	my $su = 32 - $3;
  	my $sh = (1 << $3) - 1;
  
  	$c = "$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";
  
  	#my $rotate = "(($2 << $3) || (($2 >> (32 - $3)) & (1 << $2) - 1)))"; 
  	# $c = "\$r = $2;
  	# $1 = ((\$r << $3) | ((\$r >> (32 - $3))  & ((1 << $3) - 1))) + $4";
  	$insert .= "\t$c\n";
    }
    close DATA;
    
    my $dump = '
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' . $insert . '
  	$_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK . 
          ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';
    }';
    eval $dump;
    # print "$dump\n";
    # exit 0;
  }
  
  gen_code();
  
  #########################################
  # Private output converter functions:
  sub _encode_hex { unpack 'H*', $_[0] }
  sub _encode_base64 {
  	my $res;
  	while ($_[0] =~ /(.{1,45})/gs) {
  		$res .= substr pack('u', $1), 1;
  		chop $res;
  	}
  	$res =~ tr|` -_|AA-Za-z0-9+/|;#`
  	chop $res; chop $res;
  	$res
  }
  
  #########################################
  # OOP interface:
  sub new {
  	my $proto = shift;
  	my $class = ref $proto || $proto;
  	my $self = {};
  	bless $self, $class;
  	$self->reset();
  	$self
  }
  
  sub reset {
  	my $self = shift;
  	delete $self->{_data};
  	$self->{_state} = [A,B,C,D];
  	$self->{_length} = 0;
  	$self
  }
  
  sub add {
  	my $self = shift;
  	$self->{_data} .= join '', @_ if @_;
  	my ($i,$c);
  	for $i (0 .. (length $self->{_data})/64-1) {
  		my @X = unpack 'V16', substr $self->{_data}, $i*64, 64;
  		@{$self->{_state}} = round(@{$self->{_state}},@X);
  		++$c;
  	}
  	if ($c) {
  		substr ($self->{_data}, 0, $c*64) = '';
  		$self->{_length} += $c*64;
  	}
  	$self
  }
  
  sub finalize {
  	my $self = shift;
  	$self->{_data} .= chr(128);
      my $l = $self->{_length} + length $self->{_data};
      $self->{_data} .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $self->{_data} .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  	$self->add();
  	$self
  }
  
  sub addfile {
    	my ($self,$fh) = @_;
  	if (!ref($fh) && ref(\$fh) ne "GLOB") {
  	    require Symbol;
  	    $fh = Symbol::qualify($fh, scalar caller);
  	}
  	# $self->{_data} .= do{local$/;<$fh>};
  	my $read = 0;
  	my $buffer = '';
  	$self->add($buffer) while $read = read $fh, $buffer, 8192;
  	die __PACKAGE__, " read failed: $!" unless defined $read;
  	$self
  }
  
  sub add_bits {
  	my $self = shift;
  	return $self->add( pack 'B*', shift ) if @_ == 1;
  	my ($b,$n) = @_;
  	die __PACKAGE__, " Invalid number of bits\n" if $n%8;
  	$self->add( substr $b, 0, $n/8 )
  }
  
  sub digest {
  	my $self = shift;
  	$self->finalize();
  	my $res = pack 'V4', @{$self->{_state}};
  	$self->reset();
  	$res
  }
  
  sub hexdigest {
  	_encode_hex($_[0]->digest)
  }
  
  sub b64digest {
  	_encode_base64($_[0]->digest)
  }
  
  sub clone {
  	my $self = shift;
  	my $clone = { 
  		_state => [@{$self->{_state}}],
  		_length => $self->{_length},
  		_data => $self->{_data}
  	};
  	bless $clone, ref $self || $self;
  }
  
  #########################################
  # Procedural interface:
  sub md5 {
  	my $message = padding(join'',@_);
  	my ($a,$b,$c,$d) = (A,B,C,D);
  	my $i;
  	for $i (0 .. (length $message)/64-1) {
  		my @X = unpack 'V16', substr $message,$i*64,64;	
  		($a,$b,$c,$d) = round($a,$b,$c,$d,@X);
  	}
  	pack 'V4',$a,$b,$c,$d;
  }
  sub md5_hex { _encode_hex &md5 } 
  sub md5_base64 { _encode_base64 &md5 }
  
  
  1;
  
  =head1 NAME
  
  Digest::MD5::Perl - Perl implementation of Ron Rivests MD5 Algorithm
  
  =head1 DISCLAIMER
  
  This is B<not> an interface (like C<Digest::MD5>) but a Perl implementation of MD5.
  It is written in perl only and because of this it is slow but it works without C-Code.
  You should use C<Digest::MD5> instead of this module if it is available.
  This module is only useful for
  
  =over 4
  
  =item
  
  computers where you cannot install C<Digest::MD5> (e.g. lack of a C-Compiler)
  
  =item
  
  encrypting only small amounts of data (less than one million bytes). I use it to
  hash passwords.
  
  =item
  
  educational purposes
  
  =back
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5  qw(md5 md5_hex md5_base64);
  
   $hash = md5 $data;
   $hash = md5_hex $data;
   $hash = md5_base64 $data;
      
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile(*FILE);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  This modules has the same interface as the much faster C<Digest::MD5>. So you can
  easily exchange them, e.g.
  
  	BEGIN {
  	  eval {
  	    require Digest::MD5;
  	    import Digest::MD5 'md5_hex'
  	  };
  	  if ($@) { # ups, no Digest::MD5
  	    require Digest::Perl::MD5;
  	    import Digest::Perl::MD5 'md5_hex'
  	  }		
  	}
  
  If the C<Digest::MD5> module is available it is used and if not you take
  C<Digest::Perl::MD5>.
  
  You can also install the Perl part of Digest::MD5 together with Digest::Perl::MD5
  and use Digest::MD5 as normal, it falls back to Digest::Perl::MD5 if it
  cannot load its object files.
  
  For a detailed Documentation see the C<Digest::MD5> module.
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::Perl::MD5 'md5_hex';
      print 'Digest is ', md5_hex('foobarbaz'), "\n";
  
  The above example would print out the message
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  provided that the implementation is working correctly.  The same
  checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  The digest methods are destructive. That means you can only call them
  once and the $md5 objects is reset after use. You can make a copy with clone:
  
  	$md5->clone->hexdigest
  
  =head1 LIMITATIONS
  
  This implementation of the MD5 algorithm has some limitations:
  
  =over 4
  
  =item
  
  It's slow, very slow. I've done my very best but Digest::MD5 is still about 100 times faster.
  You can only encrypt Data up to one million bytes in an acceptable time. But it's very useful
  for encrypting small amounts of data like passwords.
  
  =item
  
  You can only encrypt up to 2^32 bits = 512 MB on 32bit archs. But You should
  use C<Digest::MD5> for those amounts of data anyway.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest::MD5>
  
  L<md5(1)>
  
  RFC 1321
  
  tools/md5: a small BSD compatible md5 tool written in pure perl.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 2000 Christian Lackas, Imperia Software Solutions
   Copyright 1998-1999 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. The basic C code
  implementing the algorithm is derived from that in the RFC and is
  covered by the following copyright:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-1992, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original MD5 interface was written by Neil Winton
  (<N.Winton (at) axion.bt.co.uk>).
  
  C<Digest::MD5> was made by Gisle Aas <gisle (at) aas.no> (I took his Interface
  and part of the documentation).
  
  Thanks to Guido Flohr for his 'use integer'-hint.
  
  This release was made by Christian Lackas <delta (at) lackas.net>.
  
  =cut
  
  __DATA__
  FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

$fatpacked{"Excel/Writer/XLSX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX';
  package Excel::Writer::XLSX;
  
  ###############################################################################
  #
  # Excel::Writer::XLSX - Create a new file in the Excel 2007+ XLSX format.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use 5.008002;
  use strict;
  use warnings;
  use Exporter;
  
  use strict;
  use Excel::Writer::XLSX::Workbook;
  
  our @ISA     = qw(Excel::Writer::XLSX::Workbook Exporter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Workbook->new( @_ );
  
      # Check for file creation failures before re-blessing
      bless $self, $class if defined $self;
  
      return $self;
  }
  
  
  1;
  
  
  __END__
  
  
  
  =head1 NAME
  
  Excel::Writer::XLSX - Create a new file in the Excel 2007+ XLSX format.
  
  =head1 VERSION
  
  This document refers to version 0.89 of Excel::Writer::XLSX, released April 16, 2016.
  
  
  
  
  =head1 SYNOPSIS
  
  To write a string, a formatted string, a number and a formula to the first worksheet in an Excel workbook called perl.xlsx:
  
      use Excel::Writer::XLSX;
  
      # Create a new Excel workbook
      my $workbook = Excel::Writer::XLSX->new( 'perl.xlsx' );
  
      # Add a worksheet
      $worksheet = $workbook->add_worksheet();
  
      #  Add and define a format
      $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color( 'red' );
      $format->set_align( 'center' );
  
      # Write a formatted and unformatted string, row and column notation.
      $col = $row = 0;
      $worksheet->write( $row, $col, 'Hi Excel!', $format );
      $worksheet->write( 1, $col, 'Hi Excel!' );
  
      # Write a number and a formula using A1 notation
      $worksheet->write( 'A3', 1.2345 );
      $worksheet->write( 'A4', '=SIN(PI()/4)' );
  
  
  
  
  =head1 DESCRIPTION
  
  The C<Excel::Writer::XLSX> module can be used to create an Excel file in the 2007+ XLSX format.
  
  The XLSX format is the Office Open XML (OOXML) format used by Excel 2007 and later.
  
  Multiple worksheets can be added to a workbook and formatting can be applied to cells. Text, numbers, and formulas can be written to the cells.
  
  This module cannot, as yet, be used to write to an existing Excel XLSX file.
  
  
  
  
  =head1 Excel::Writer::XLSX and Spreadsheet::WriteExcel
  
  C<Excel::Writer::XLSX> uses the same interface as the L<Spreadsheet::WriteExcel> module which produces an Excel file in binary XLS format.
  
  Excel::Writer::XLSX supports all of the features of Spreadsheet::WriteExcel and in some cases has more functionality. For more details see L</Compatibility with Spreadsheet::WriteExcel>.
  
  The main advantage of the XLSX format over the XLS format is that it allows a larger number of rows and columns in a worksheet. The XLSX file format also produces much smaller files than the XLS file format.
  
  
  
  
  =head1 QUICK START
  
  Excel::Writer::XLSX tries to provide an interface to as many of Excel's features as possible. As a result there is a lot of documentation to accompany the interface and it can be difficult at first glance to see what it important and what is not. So for those of you who prefer to assemble Ikea furniture first and then read the instructions, here are three easy steps:
  
  1. Create a new Excel I<workbook> (i.e. file) using C<new()>.
  
  2. Add a worksheet to the new workbook using C<add_worksheet()>.
  
  3. Write to the worksheet using C<write()>.
  
  Like this:
  
      use Excel::Writer::XLSX;                                   # Step 0
  
      my $workbook = Excel::Writer::XLSX->new( 'perl.xlsx' );    # Step 1
      $worksheet = $workbook->add_worksheet();                   # Step 2
      $worksheet->write( 'A1', 'Hi Excel!' );                    # Step 3
  
  This will create an Excel file called C<perl.xlsx> with a single worksheet and the text C<'Hi Excel!'> in the relevant cell. And that's it. Okay, so there is actually a zeroth step as well, but C<use module> goes without saying. There are many examples that come with the distribution and which you can use to get you started. See L</EXAMPLES>.
  
  Those of you who read the instructions first and assemble the furniture afterwards will know how to proceed. ;-)
  
  
  
  
  =head1 WORKBOOK METHODS
  
  The Excel::Writer::XLSX module provides an object oriented interface to a new Excel workbook. The following methods are available through a new workbook.
  
      new()
      add_worksheet()
      add_format()
      add_chart()
      add_shape()
      add_vba_project()
      set_vba_name()
      close()
      set_properties()
      define_name()
      set_tempdir()
      set_custom_color()
      sheets()
      set_1904()
      set_optimization()
      set_calc_mode()
  
  If you are unfamiliar with object oriented interfaces or the way that they are implemented in Perl have a look at C<perlobj> and C<perltoot> in the main Perl documentation.
  
  
  
  
  =head2 new()
  
  A new Excel workbook is created using the C<new()> constructor which accepts either a filename or a filehandle as a parameter. The following example creates a new Excel file based on a filename:
  
      my $workbook  = Excel::Writer::XLSX->new( 'filename.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      $worksheet->write( 0, 0, 'Hi Excel!' );
  
  Here are some other examples of using C<new()> with filenames:
  
      my $workbook1 = Excel::Writer::XLSX->new( $filename );
      my $workbook2 = Excel::Writer::XLSX->new( '/tmp/filename.xlsx' );
      my $workbook3 = Excel::Writer::XLSX->new( "c:\\tmp\\filename.xlsx" );
      my $workbook4 = Excel::Writer::XLSX->new( 'c:\tmp\filename.xlsx' );
  
  The last two examples demonstrates how to create a file on DOS or Windows where it is necessary to either escape the directory separator C<\> or to use single quotes to ensure that it isn't interpolated. For more information see C<perlfaq5: Why can't I use "C:\temp\foo" in DOS paths?>.
  
  It is recommended that the filename uses the extension C<.xlsx> rather than C<.xls> since the latter causes an Excel warning when used with the XLSX format.
  
  The C<new()> constructor returns a Excel::Writer::XLSX object that you can use to add worksheets and store data. It should be noted that although C<my> is not specifically required it defines the scope of the new workbook variable and, in the majority of cases, ensures that the workbook is closed properly without explicitly calling the C<close()> method.
  
  If the file cannot be created, due to file permissions or some other reason,  C<new> will return C<undef>. Therefore, it is good practice to check the return value of C<new> before proceeding. As usual the Perl variable C<$!> will be set if there is a file creation error. You will also see one of the warning messages detailed in L</DIAGNOSTICS>:
  
      my $workbook = Excel::Writer::XLSX->new( 'protected.xlsx' );
      die "Problems creating new Excel file: $!" unless defined $workbook;
  
  You can also pass a valid filehandle to the C<new()> constructor. For example in a CGI program you could do something like this:
  
      binmode( STDOUT );
      my $workbook = Excel::Writer::XLSX->new( \*STDOUT );
  
  The requirement for C<binmode()> is explained below.
  
  See also, the C<cgi.pl> program in the C<examples> directory of the distro.
  
  In C<mod_perl> programs where you will have to do something like the following:
  
      # mod_perl 1
      ...
      tie *XLSX, 'Apache';
      binmode( XLSX );
      my $workbook = Excel::Writer::XLSX->new( \*XLSX );
      ...
  
      # mod_perl 2
      ...
      tie *XLSX => $r;    # Tie to the Apache::RequestRec object
      binmode( *XLSX );
      my $workbook = Excel::Writer::XLSX->new( \*XLSX );
      ...
  
  See also, the C<mod_perl1.pl> and C<mod_perl2.pl> programs in the C<examples> directory of the distro.
  
  Filehandles can also be useful if you want to stream an Excel file over a socket or if you want to store an Excel file in a scalar.
  
  For example here is a way to write an Excel file to a scalar:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      open my $fh, '>', \my $str or die "Failed to open filehandle: $!";
  
      my $workbook  = Excel::Writer::XLSX->new( $fh );
      my $worksheet = $workbook->add_worksheet();
  
      $worksheet->write( 0, 0, 'Hi Excel!' );
  
      $workbook->close();
  
      # The Excel file in now in $str. Remember to binmode() the output
      # filehandle before printing it.
      binmode STDOUT;
      print $str;
  
  See also the C<write_to_scalar.pl> and C<filehandle.pl> programs in the C<examples> directory of the distro.
  
  B<Note about the requirement for> C<binmode()>. An Excel file is comprised of binary data. Therefore, if you are using a filehandle you should ensure that you C<binmode()> it prior to passing it to C<new()>.You should do this regardless of whether you are on a Windows platform or not.
  
  You don't have to worry about C<binmode()> if you are using filenames instead of filehandles. Excel::Writer::XLSX performs the C<binmode()> internally when it converts the filename to a filehandle. For more information about C<binmode()> see C<perlfunc> and C<perlopentut> in the main Perl documentation.
  
  
  
  
  
  =head2 add_worksheet( $sheetname )
  
  At least one worksheet should be added to a new workbook. A worksheet is used to write data into cells:
  
      $worksheet1 = $workbook->add_worksheet();               # Sheet1
      $worksheet2 = $workbook->add_worksheet( 'Foglio2' );    # Foglio2
      $worksheet3 = $workbook->add_worksheet( 'Data' );       # Data
      $worksheet4 = $workbook->add_worksheet();               # Sheet4
  
  If C<$sheetname> is not specified the default Excel convention will be followed, i.e. Sheet1, Sheet2, etc.
  
  The worksheet name must be a valid Excel worksheet name, i.e. it cannot contain any of the following characters, C<[ ] : * ? / \> and it must be less than 32 characters. In addition, you cannot use the same, case insensitive, C<$sheetname> for more than one worksheet.
  
  
  
  
  =head2 add_format( %properties )
  
  The C<add_format()> method can be used to create new Format objects which are used to apply formatting to a cell. You can either define the properties at creation time via a hash of property values or later via method calls.
  
      $format1 = $workbook->add_format( %props );    # Set properties at creation
      $format2 = $workbook->add_format();            # Set properties later
  
  See the L</CELL FORMATTING> section for more details about Format properties and how to set them.
  
  
  
  
  =head2 add_chart( %properties )
  
  This method is use to create a new chart either as a standalone worksheet (the default) or as an embeddable object that can be inserted into a worksheet via the C<insert_chart()> Worksheet method.
  
      my $chart = $workbook->add_chart( type => 'column' );
  
  The properties that can be set are:
  
      type     (required)
      subtype  (optional)
      name     (optional)
      embedded (optional)
  
  =over
  
  =item * C<type>
  
  This is a required parameter. It defines the type of chart that will be created.
  
      my $chart = $workbook->add_chart( type => 'line' );
  
  The available types are:
  
      area
      bar
      column
      line
      pie
      doughnut
      scatter
      stock
  
  =item * C<subtype>
  
  Used to define a chart subtype where available.
  
      my $chart = $workbook->add_chart( type => 'bar', subtype => 'stacked' );
  
  See the L<Excel::Writer::XLSX::Chart> documentation for a list of available chart subtypes.
  
  =item * C<name>
  
  Set the name for the chart sheet. The name property is optional and if it isn't supplied will default to C<Chart1 .. n>. The name must be a valid Excel worksheet name. See C<add_worksheet()> for more details on valid sheet names. The C<name> property can be omitted for embedded charts.
  
      my $chart = $workbook->add_chart( type => 'line', name => 'Results Chart' );
  
  =item * C<embedded>
  
  Specifies that the Chart object will be inserted in a worksheet via the C<insert_chart()> Worksheet method. It is an error to try insert a Chart that doesn't have this flag set.
  
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the chart.
      ...
  
      # Insert the chart into the a worksheet.
      $worksheet->insert_chart( 'E2', $chart );
  
  =back
  
  See Excel::Writer::XLSX::Chart for details on how to configure the chart object once it is created. See also the C<chart_*.pl> programs in the examples directory of the distro.
  
  
  
  =head2 add_shape( %properties )
  
  The C<add_shape()> method can be used to create new shapes that may be inserted into a worksheet.
  
  You can either define the properties at creation time via a hash of property values or later via method calls.
  
      # Set properties at creation.
      $plus = $workbook->add_shape(
          type   => 'plus',
          id     => 3,
          width  => $pw,
          height => $ph
      );
  
  
      # Default rectangle shape. Set properties later.
      $rect =  $workbook->add_shape();
  
  See L<Excel::Writer::XLSX::Shape> for details on how to configure the shape object once it is created.
  
  See also the C<shape*.pl> programs in the examples directory of the distro.
  
  
  
  =head2 add_vba_project( 'vbaProject.bin' )
  
  The C<add_vba_project()> method can be used to add macros or functions to an Excel::Writer::XLSX file using a binary VBA project file that has been extracted from an existing Excel C<xlsm> file.
  
      my $workbook  = Excel::Writer::XLSX->new( 'file.xlsm' );
  
      $workbook->add_vba_project( './vbaProject.bin' );
  
  The supplied C<extract_vba> utility can be used to extract the required C<vbaProject.bin> file from an existing Excel file:
  
      $ extract_vba file.xlsm
      Extracted 'vbaProject.bin' successfully
  
  Macros can be tied to buttons using the worksheet C<insert_button()> method (see the L</WORKSHEET METHODS> section for details):
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro' } );
  
  Note, Excel uses the file extension C<xlsm> instead of C<xlsx> for files that contain macros. It is advisable to follow the same convention.
  
  See also the C<macros.pl> example file and the L<WORKING WITH VBA MACROS>.
  
  
  
  =head2 set_vba_name()
  
  The C<set_vba_name()> method can be used to set the VBA codename for the workbook. This is sometimes required when a C<vbaProject macro> included via C<add_vba_project()> refers to the workbook. The default Excel VBA name of C<ThisWorkbook> is used if a user defined name isn't specified. See also L<WORKING WITH VBA MACROS>.
  
  
  =head2 close()
  
  In general your Excel file will be closed automatically when your program ends or when the Workbook object goes out of scope, however the C<close()> method can be used to explicitly close an Excel file.
  
      $workbook->close();
  
  An explicit C<close()> is required if the file must be closed prior to performing some external action on it such as copying it, reading its size or attaching it to an email.
  
  In addition, C<close()> may be required to prevent perl's garbage collector from disposing of the Workbook, Worksheet and Format objects in the wrong order. Situations where this can occur are:
  
  =over 4
  
  =item *
  
  If C<my()> was not used to declare the scope of a workbook variable created using C<new()>.
  
  =item *
  
  If the C<new()>, C<add_worksheet()> or C<add_format()> methods are called in subroutines.
  
  =back
  
  The reason for this is that Excel::Writer::XLSX relies on Perl's C<DESTROY> mechanism to trigger destructor methods in a specific sequence. This may not happen in cases where the Workbook, Worksheet and Format variables are not lexically scoped or where they have different lexical scopes.
  
  In general, if you create a file with a size of 0 bytes or you fail to create a file you need to call C<close()>.
  
  The return value of C<close()> is the same as that returned by perl when it closes the file created by C<new()>. This allows you to handle error conditions in the usual way:
  
      $workbook->close() or die "Error closing file: $!";
  
  
  
  
  =head2 set_properties()
  
  The C<set_properties> method can be used to set the document properties of the Excel file created by C<Excel::Writer::XLSX>. These properties are visible when you use the C<< Office Button -> Prepare -> Properties >> option in Excel and are also available to external applications that read or index windows files.
  
  The properties should be passed in hash format as follows:
  
      $workbook->set_properties(
          title    => 'This is an example spreadsheet',
          author   => 'John McNamara',
          comments => 'Created with Perl and Excel::Writer::XLSX',
      );
  
  The properties that can be set are:
  
      title
      subject
      author
      manager
      company
      category
      keywords
      comments
      status
      hyperlink_base
  
  See also the C<properties.pl> program in the examples directory of the distro.
  
  
  
  
  =head2 define_name()
  
  This method is used to defined a name that can be used to represent a value, a single cell or a range of cells in a workbook.
  
  For example to set a global/workbook name:
  
      # Global/workbook names.
      $workbook->define_name( 'Exchange_rate', '=0.96' );
      $workbook->define_name( 'Sales',         '=Sheet1!$G$1:$H$10' );
  
  It is also possible to define a local/worksheet name by prefixing the name with the sheet name using the syntax C<sheetname!definedname>:
  
      # Local/worksheet name.
      $workbook->define_name( 'Sheet2!Sales',  '=Sheet2!$G$1:$G$10' );
  
  If the sheet name contains spaces or special characters you must enclose it in single quotes like in Excel:
  
      $workbook->define_name( "'New Data'!Sales",  '=Sheet2!$G$1:$G$10' );
  
  See the defined_name.pl program in the examples dir of the distro.
  
  Refer to the following to see Excel's syntax rules for defined names: L<http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx#BMsyntax_rules_for_names>
  
  
  
  
  =head2 set_tempdir()
  
  C<Excel::Writer::XLSX> stores worksheet data in temporary files prior to assembling the final workbook.
  
  The C<File::Temp> module is used to create these temporary files. File::Temp uses C<File::Spec> to determine an appropriate location for these files such as C</tmp> or C<c:\windows\temp>. You can find out which directory is used on your system as follows:
  
      perl -MFile::Spec -le "print File::Spec->tmpdir()"
  
  If the default temporary file directory isn't accessible to your application, or doesn't contain enough space, you can specify an alternative location using the C<set_tempdir()> method:
  
      $workbook->set_tempdir( '/tmp/writeexcel' );
      $workbook->set_tempdir( 'c:\windows\temp\writeexcel' );
  
  The directory for the temporary file must exist, C<set_tempdir()> will not create a new directory.
  
  
  
  
  
  =head2 set_custom_color( $index, $red, $green, $blue )
  
  The method is maintained for backward compatibility with Spreadsheet::WriteExcel. Excel::Writer::XLSX programs don't require this method and colours can be specified using a Html style C<#RRGGBB> value, see L</WORKING WITH COLOURS>.
  
  
  
  
  =head2 sheets( 0, 1, ... )
  
  The C<sheets()> method returns a list, or a sliced list, of the worksheets in a workbook.
  
  If no arguments are passed the method returns a list of all the worksheets in the workbook. This is useful if you want to repeat an operation on each worksheet:
  
      for $worksheet ( $workbook->sheets() ) {
          print $worksheet->get_name();
      }
  
  
  You can also specify a slice list to return one or more worksheet objects:
  
      $worksheet = $workbook->sheets( 0 );
      $worksheet->write( 'A1', 'Hello' );
  
  
  Or since the return value from C<sheets()> is a reference to a worksheet object you can write the above example as:
  
      $workbook->sheets( 0 )->write( 'A1', 'Hello' );
  
  
  The following example returns the first and last worksheet in a workbook:
  
      for $worksheet ( $workbook->sheets( 0, -1 ) ) {
          # Do something
      }
  
  
  Array slices are explained in the C<perldata> manpage.
  
  
  
  
  =head2 set_1904()
  
  Excel stores dates as real numbers where the integer part stores the number of days since the epoch and the fractional part stores the percentage of the day. The epoch can be either 1900 or 1904. Excel for Windows uses 1900 and Excel for Macintosh uses 1904. However, Excel on either platform will convert automatically between one system and the other.
  
  Excel::Writer::XLSX stores dates in the 1900 format by default. If you wish to change this you can call the C<set_1904()> workbook method. You can query the current value by calling the C<get_1904()> workbook method. This returns 0 for 1900 and 1 for 1904.
  
  See also L</DATES AND TIME IN EXCEL> for more information about working with Excel's date system.
  
  In general you probably won't need to use C<set_1904()>.
  
  
  
  
  =head2 set_optimization()
  
  The C<set_optimization()> method is used to turn on optimizations in the Excel::Writer::XLSX module. Currently there is only one optimization available and that is to reduce memory usage.
  
      $workbook->set_optimization();
  
  
  See L</SPEED AND MEMORY USAGE> for more background information.
  
  Note, that with this optimization turned on a row of data is written and then discarded when a cell in a new row is added via one of the Worksheet C<write_*()> methods. As such data should be written in sequential row order once the optimization is turned on.
  
  This method must be called before any calls to C<add_worksheet()>.
  
  
  
  =head2 set_calc_mode( $mode )
  
  Set the calculation mode for formulas in the workbook. This is mainly of use for workbooks with slow formulas where you want to allow the user to calculate them manually.
  
  The mode parameter can be one of the following strings:
  
  =over
  
  =item C<auto>
  
  The default. Excel will re-calculate formulas when a formula or a value affecting the formula changes.
  
  =item C<manual>
  
  Only re-calculate formulas when the user requires it. Generally by pressing F9.
  
  =item C<auto_except_tables>
  
  Excel will automatically re-calculate formulas except for tables.
  
  =back
  
  =head1 WORKSHEET METHODS
  
  A new worksheet is created by calling the C<add_worksheet()> method from a workbook object:
  
      $worksheet1 = $workbook->add_worksheet();
      $worksheet2 = $workbook->add_worksheet();
  
  The following methods are available through a new worksheet:
  
      write()
      write_number()
      write_string()
      write_rich_string()
      keep_leading_zeros()
      write_blank()
      write_row()
      write_col()
      write_date_time()
      write_url()
      write_url_range()
      write_formula()
      write_boolean()
      write_comment()
      show_comments()
      set_comments_author()
      add_write_handler()
      insert_image()
      insert_chart()
      insert_shape()
      insert_button()
      data_validation()
      conditional_formatting()
      add_sparkline()
      add_table()
      get_name()
      activate()
      select()
      hide()
      set_first_sheet()
      protect()
      set_selection()
      set_row()
      set_default_row()
      set_column()
      outline_settings()
      freeze_panes()
      split_panes()
      merge_range()
      merge_range_type()
      set_zoom()
      right_to_left()
      hide_zero()
      set_tab_color()
      autofilter()
      filter_column()
      filter_column_list()
      set_vba_name()
  
  
  
  =head2 Cell notation
  
  Excel::Writer::XLSX supports two forms of notation to designate the position of cells: Row-column notation and A1 notation.
  
  Row-column notation uses a zero based index for both row and column while A1 notation uses the standard Excel alphanumeric sequence of column letter and 1-based row. For example:
  
      (0, 0)      # The top left cell in row-column notation.
      ('A1')      # The top left cell in A1 notation.
  
      (1999, 29)  # Row-column notation.
      ('AD2000')  # The same cell in A1 notation.
  
  Row-column notation is useful if you are referring to cells programmatically:
  
      for my $i ( 0 .. 9 ) {
          $worksheet->write( $i, 0, 'Hello' );    # Cells A1 to A10
      }
  
  A1 notation is useful for setting up a worksheet manually and for working with formulas:
  
      $worksheet->write( 'H1', 200 );
      $worksheet->write( 'H2', '=H1+1' );
  
  In formulas and applicable methods you can also use the C<A:A> column notation:
  
      $worksheet->write( 'A1', '=SUM(B:B)' );
  
  The C<Excel::Writer::XLSX::Utility> module that is included in the distro contains helper functions for dealing with A1 notation, for example:
  
      use Excel::Writer::XLSX::Utility;
  
      ( $row, $col ) = xl_cell_to_rowcol( 'C2' );    # (1, 2)
      $str           = xl_rowcol_to_cell( 1, 2 );    # C2
  
  For simplicity, the parameter lists for the worksheet method calls in the following sections are given in terms of row-column notation. In all cases it is also possible to use A1 notation.
  
  Note: in Excel it is also possible to use a R1C1 notation. This is not supported by Excel::Writer::XLSX.
  
  
  
  
  =head2 write( $row, $column, $token, $format )
  
  Excel makes a distinction between data types such as strings, numbers, blanks, formulas and hyperlinks. To simplify the process of writing data the C<write()> method acts as a general alias for several more specific methods:
  
      write_string()
      write_number()
      write_blank()
      write_formula()
      write_url()
      write_row()
      write_col()
  
  The general rule is that if the data looks like a I<something> then a I<something> is written. Here are some examples in both row-column and A1 notation:
  
                                                          # Same as:
      $worksheet->write( 0, 0, 'Hello'                 ); # write_string()
      $worksheet->write( 1, 0, 'One'                   ); # write_string()
      $worksheet->write( 2, 0,  2                      ); # write_number()
      $worksheet->write( 3, 0,  3.00001                ); # write_number()
      $worksheet->write( 4, 0,  ""                     ); # write_blank()
      $worksheet->write( 5, 0,  ''                     ); # write_blank()
      $worksheet->write( 6, 0,  undef                  ); # write_blank()
      $worksheet->write( 7, 0                          ); # write_blank()
      $worksheet->write( 8, 0,  'http://www.perl.com/' ); # write_url()
      $worksheet->write( 'A9',  'ftp://ftp.cpan.org/'  ); # write_url()
      $worksheet->write( 'A10', 'internal:Sheet1!A1'   ); # write_url()
      $worksheet->write( 'A11', 'external:c:\foo.xlsx' ); # write_url()
      $worksheet->write( 'A12', '=A3 + 3*A4'           ); # write_formula()
      $worksheet->write( 'A13', '=SIN(PI()/4)'         ); # write_formula()
      $worksheet->write( 'A14', \@array                ); # write_row()
      $worksheet->write( 'A15', [\@array]              ); # write_col()
  
      # And if the keep_leading_zeros property is set:
      $worksheet->write( 'A16', '2'                    ); # write_number()
      $worksheet->write( 'A17', '02'                   ); # write_string()
      $worksheet->write( 'A18', '00002'                ); # write_string()
  
      # Write an array formula. Not available in Spreadsheet::WriteExcel.
      $worksheet->write( 'A19', '{=SUM(A1:B1*A2:B2)}'  ); # write_formula()
  
  
  The "looks like" rule is defined by regular expressions:
  
  C<write_number()> if C<$token> is a number based on the following regex: C<$token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/>.
  
  C<write_string()> if C<keep_leading_zeros()> is set and C<$token> is an integer with leading zeros based on the following regex: C<$token =~ /^0\d+$/>.
  
  C<write_blank()> if C<$token> is undef or a blank string: C<undef>, C<""> or C<''>.
  
  C<write_url()> if C<$token> is a http, https, ftp or mailto URL based on the following regexes: C<$token =~ m|^[fh]tt?ps?://|> or C<$token =~ m|^mailto:|>.
  
  C<write_url()> if C<$token> is an internal or external sheet reference based on the following regex: C<$token =~ m[^(in|ex)ternal:]>.
  
  C<write_formula()> if the first character of C<$token> is C<"=">.
  
  C<write_array_formula()> if the C<$token> matches C</^{=.*}$/>.
  
  C<write_row()> if C<$token> is an array ref.
  
  C<write_col()> if C<$token> is an array ref of array refs.
  
  C<write_string()> if none of the previous conditions apply.
  
  The C<$format> parameter is optional. It should be a valid Format object, see L</CELL FORMATTING>:
  
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color( 'red' );
      $format->set_align( 'center' );
  
      $worksheet->write( 4, 0, 'Hello', $format );    # Formatted string
  
  The write() method will ignore empty strings or C<undef> tokens unless a format is also supplied. As such you needn't worry about special handling for empty or C<undef> values in your data. See also the C<write_blank()> method.
  
  One problem with the C<write()> method is that occasionally data looks like a number but you don't want it treated as a number. For example, zip codes or ID numbers often start with a leading zero. If you write this data as a number then the leading zero(s) will be stripped. You can change this default behaviour by using the C<keep_leading_zeros()> method. While this property is in place any integers with leading zeros will be treated as strings and the zeros will be preserved. See the C<keep_leading_zeros()> section for a full discussion of this issue.
  
  You can also add your own data handlers to the C<write()> method using C<add_write_handler()>.
  
  The C<write()> method will also handle Unicode strings in C<UTF-8> format.
  
  The C<write> methods return:
  
      0 for success.
     -1 for insufficient number of arguments.
     -2 for row or column out of bounds.
     -3 for string too long.
  
  
  
  
  =head2 write_number( $row, $column, $number, $format )
  
  Write an integer or a float to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_number( 0, 0, 123456 );
      $worksheet->write_number( 'A2', 2.3451 );
  
  See the note about L</Cell notation>. The C<$format> parameter is optional.
  
  In general it is sufficient to use the C<write()> method.
  
  B<Note>: some versions of Excel 2007 do not display the calculated values of formulas written by Excel::Writer::XLSX. Applying all available Service Packs to Excel should fix this.
  
  
  
  =head2 write_string( $row, $column, $string, $format )
  
  Write a string to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_string( 0, 0, 'Your text here' );
      $worksheet->write_string( 'A2', 'or here' );
  
  The maximum string size is 32767 characters. However the maximum string segment that Excel can display in a cell is 1000. All 32767 characters can be displayed in the formula bar.
  
  The C<$format> parameter is optional.
  
  The C<write()> method will also handle strings in C<UTF-8> format. See also the C<unicode_*.pl> programs in the examples directory of the distro.
  
  In general it is sufficient to use the C<write()> method. However, you may sometimes wish to use the C<write_string()> method to write data that looks like a number but that you don't want treated as a number. For example, zip codes or phone numbers:
  
      # Write as a plain string
      $worksheet->write_string( 'A1', '01209' );
  
  However, if the user edits this string Excel may convert it back to a number. To get around this you can use the Excel text format C<@>:
  
      # Format as a string. Doesn't change to a number when edited
      my $format1 = $workbook->add_format( num_format => '@' );
      $worksheet->write_string( 'A2', '01209', $format1 );
  
  See also the note about L</Cell notation>.
  
  
  
  
  =head2 write_rich_string( $row, $column, $format, $string, ..., $cell_format )
  
  The C<write_rich_string()> method is used to write strings with multiple formats. For example to write the string "This is B<bold> and this is I<italic>" you would use the following:
  
      my $bold   = $workbook->add_format( bold   => 1 );
      my $italic = $workbook->add_format( italic => 1 );
  
      $worksheet->write_rich_string( 'A1',
          'This is ', $bold, 'bold', ' and this is ', $italic, 'italic' );
  
  The basic rule is to break the string into fragments and put a C<$format> object before the fragment that you want to format. For example:
  
      # Unformatted string.
        'This is an example string'
  
      # Break it into fragments.
        'This is an ', 'example', ' string'
  
      # Add formatting before the fragments you want formatted.
        'This is an ', $format, 'example', ' string'
  
      # In Excel::Writer::XLSX.
      $worksheet->write_rich_string( 'A1',
          'This is an ', $format, 'example', ' string' );
  
  String fragments that don't have a format are given a default format. So for example when writing the string "Some B<bold> text" you would use the first example below but it would be equivalent to the second:
  
      # With default formatting:
      my $bold    = $workbook->add_format( bold => 1 );
  
      $worksheet->write_rich_string( 'A1',
          'Some ', $bold, 'bold', ' text' );
  
      # Or more explicitly:
      my $bold    = $workbook->add_format( bold => 1 );
      my $default = $workbook->add_format();
  
      $worksheet->write_rich_string( 'A1',
          $default, 'Some ', $bold, 'bold', $default, ' text' );
  
  As with Excel, only the font properties of the format such as font name, style, size, underline, color and effects are applied to the string fragments. Other features such as border, background, text wrap and alignment must be applied to the cell.
  
  The C<write_rich_string()> method allows you to do this by using the last argument as a cell format (if it is a format object). The following example centers a rich string in the cell:
  
      my $bold   = $workbook->add_format( bold  => 1 );
      my $center = $workbook->add_format( align => 'center' );
  
      $worksheet->write_rich_string( 'A5',
          'Some ', $bold, 'bold text', ' centered', $center );
  
  See the C<rich_strings.pl> example in the distro for more examples.
  
      my $bold   = $workbook->add_format( bold        => 1 );
      my $italic = $workbook->add_format( italic      => 1 );
      my $red    = $workbook->add_format( color       => 'red' );
      my $blue   = $workbook->add_format( color       => 'blue' );
      my $center = $workbook->add_format( align       => 'center' );
      my $super  = $workbook->add_format( font_script => 1 );
  
  
      # Write some strings with multiple formats.
      $worksheet->write_rich_string( 'A1',
          'This is ', $bold, 'bold', ' and this is ', $italic, 'italic' );
  
      $worksheet->write_rich_string( 'A3',
          'This is ', $red, 'red', ' and this is ', $blue, 'blue' );
  
      $worksheet->write_rich_string( 'A5',
          'Some ', $bold, 'bold text', ' centered', $center );
  
      $worksheet->write_rich_string( 'A7',
          $italic, 'j = k', $super, '(n-1)', $center );
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/rich_strings.jpg" width="640" height="420" alt="Output from rich_strings.pl" /></center></p>
  
  =end html
  
  As with C<write_sting()> the maximum string size is 32767 characters. See also the note about L</Cell notation>.
  
  
  
  
  =head2 keep_leading_zeros()
  
  This method changes the default handling of integers with leading zeros when using the C<write()> method.
  
  The C<write()> method uses regular expressions to determine what type of data to write to an Excel worksheet. If the data looks like a number it writes a number using C<write_number()>. One problem with this approach is that occasionally data looks like a number but you don't want it treated as a number.
  
  Zip codes and ID numbers, for example, often start with a leading zero. If you write this data as a number then the leading zero(s) will be stripped. This is the also the default behaviour when you enter data manually in Excel.
  
  To get around this you can use one of three options. Write a formatted number, write the number as a string or use the C<keep_leading_zeros()> method to change the default behaviour of C<write()>:
  
      # Implicitly write a number, the leading zero is removed: 1209
      $worksheet->write( 'A1', '01209' );
  
      # Write a zero padded number using a format: 01209
      my $format1 = $workbook->add_format( num_format => '00000' );
      $worksheet->write( 'A2', '01209', $format1 );
  
      # Write explicitly as a string: 01209
      $worksheet->write_string( 'A3', '01209' );
  
      # Write implicitly as a string: 01209
      $worksheet->keep_leading_zeros();
      $worksheet->write( 'A4', '01209' );
  
  
  The above code would generate a worksheet that looked like the following:
  
       -----------------------------------------------------------
      |   |     A     |     B     |     C     |     D     | ...
       -----------------------------------------------------------
      | 1 |      1209 |           |           |           | ...
      | 2 |     01209 |           |           |           | ...
      | 3 | 01209     |           |           |           | ...
      | 4 | 01209     |           |           |           | ...
  
  
  The examples are on different sides of the cells due to the fact that Excel displays strings with a left justification and numbers with a right justification by default. You can change this by using a format to justify the data, see L</CELL FORMATTING>.
  
  It should be noted that if the user edits the data in examples C<A3> and C<A4> the strings will revert back to numbers. Again this is Excel's default behaviour. To avoid this you can use the text format C<@>:
  
      # Format as a string (01209)
      my $format2 = $workbook->add_format( num_format => '@' );
      $worksheet->write_string( 'A5', '01209', $format2 );
  
  The C<keep_leading_zeros()> property is off by default. The C<keep_leading_zeros()> method takes 0 or 1 as an argument. It defaults to 1 if an argument isn't specified:
  
      $worksheet->keep_leading_zeros();       # Set on
      $worksheet->keep_leading_zeros( 1 );    # Set on
      $worksheet->keep_leading_zeros( 0 );    # Set off
  
  See also the C<add_write_handler()> method.
  
  
  =head2 write_blank( $row, $column, $format )
  
  Write a blank cell specified by C<$row> and C<$column>:
  
      $worksheet->write_blank( 0, 0, $format );
  
  This method is used to add formatting to a cell which doesn't contain a string or number value.
  
  Excel differentiates between an "Empty" cell and a "Blank" cell. An "Empty" cell is a cell which doesn't contain data whilst a "Blank" cell is a cell which doesn't contain data but does contain formatting. Excel stores "Blank" cells but ignores "Empty" cells.
  
  As such, if you write an empty cell without formatting it is ignored:
  
      $worksheet->write( 'A1', undef, $format );    # write_blank()
      $worksheet->write( 'A2', undef );             # Ignored
  
  This seemingly uninteresting fact means that you can write arrays of data without special treatment for C<undef> or empty string values.
  
  See the note about L</Cell notation>.
  
  
  
  
  =head2 write_row( $row, $column, $array_ref, $format )
  
  The C<write_row()> method can be used to write a 1D or 2D array of data in one go. This is useful for converting the results of a database query into an Excel worksheet. You must pass a reference to the array of data rather than the array itself. The C<write()> method is then called for each element of the data. For example:
  
      @array = ( 'awk', 'gawk', 'mawk' );
      $array_ref = \@array;
  
      $worksheet->write_row( 0, 0, $array_ref );
  
      # The above example is equivalent to:
      $worksheet->write( 0, 0, $array[0] );
      $worksheet->write( 0, 1, $array[1] );
      $worksheet->write( 0, 2, $array[2] );
  
  
  Note: For convenience the C<write()> method behaves in the same way as C<write_row()> if it is passed an array reference. Therefore the following two method calls are equivalent:
  
      $worksheet->write_row( 'A1', $array_ref );    # Write a row of data
      $worksheet->write(     'A1', $array_ref );    # Same thing
  
  As with all of the write methods the C<$format> parameter is optional. If a format is specified it is applied to all the elements of the data array.
  
  Array references within the data will be treated as columns. This allows you to write 2D arrays of data in one go. For example:
  
      @eec =  (
                  ['maggie', 'milly', 'molly', 'may'  ],
                  [13,       14,      15,      16     ],
                  ['shell',  'star',  'crab',  'stone']
              );
  
      $worksheet->write_row( 'A1', \@eec );
  
  
  Would produce a worksheet as follows:
  
       -----------------------------------------------------------
      |   |    A    |    B    |    C    |    D    |    E    | ...
       -----------------------------------------------------------
      | 1 | maggie  | 13      | shell   | ...     |  ...    | ...
      | 2 | milly   | 14      | star    | ...     |  ...    | ...
      | 3 | molly   | 15      | crab    | ...     |  ...    | ...
      | 4 | may     | 16      | stone   | ...     |  ...    | ...
      | 5 | ...     | ...     | ...     | ...     |  ...    | ...
      | 6 | ...     | ...     | ...     | ...     |  ...    | ...
  
  
  To write the data in a row-column order refer to the C<write_col()> method below.
  
  Any C<undef> values in the data will be ignored unless a format is applied to the data, in which case a formatted blank cell will be written. In either case the appropriate row or column value will still be incremented.
  
  To find out more about array references refer to C<perlref> and C<perlreftut> in the main Perl documentation. To find out more about 2D arrays or "lists of lists" refer to C<perllol>.
  
  The C<write_row()> method returns the first error encountered when writing the elements of the data or zero if no errors were encountered. See the return values described for the C<write()> method above.
  
  See also the C<write_arrays.pl> program in the C<examples> directory of the distro.
  
  The C<write_row()> method allows the following idiomatic conversion of a text file to an Excel file:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'file.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      open INPUT, 'file.txt' or die "Couldn't open file: $!";
  
      $worksheet->write( $. -1, 0, [split] ) while <INPUT>;
  
  
  
  
  =head2 write_col( $row, $column, $array_ref, $format )
  
  The C<write_col()> method can be used to write a 1D or 2D array of data in one go. This is useful for converting the results of a database query into an Excel worksheet. You must pass a reference to the array of data rather than the array itself. The C<write()> method is then called for each element of the data. For example:
  
      @array = ( 'awk', 'gawk', 'mawk' );
      $array_ref = \@array;
  
      $worksheet->write_col( 0, 0, $array_ref );
  
      # The above example is equivalent to:
      $worksheet->write( 0, 0, $array[0] );
      $worksheet->write( 1, 0, $array[1] );
      $worksheet->write( 2, 0, $array[2] );
  
  As with all of the write methods the C<$format> parameter is optional. If a format is specified it is applied to all the elements of the data array.
  
  Array references within the data will be treated as rows. This allows you to write 2D arrays of data in one go. For example:
  
      @eec =  (
                  ['maggie', 'milly', 'molly', 'may'  ],
                  [13,       14,      15,      16     ],
                  ['shell',  'star',  'crab',  'stone']
              );
  
      $worksheet->write_col( 'A1', \@eec );
  
  
  Would produce a worksheet as follows:
  
       -----------------------------------------------------------
      |   |    A    |    B    |    C    |    D    |    E    | ...
       -----------------------------------------------------------
      | 1 | maggie  | milly   | molly   | may     |  ...    | ...
      | 2 | 13      | 14      | 15      | 16      |  ...    | ...
      | 3 | shell   | star    | crab    | stone   |  ...    | ...
      | 4 | ...     | ...     | ...     | ...     |  ...    | ...
      | 5 | ...     | ...     | ...     | ...     |  ...    | ...
      | 6 | ...     | ...     | ...     | ...     |  ...    | ...
  
  
  To write the data in a column-row order refer to the C<write_row()> method above.
  
  Any C<undef> values in the data will be ignored unless a format is applied to the data, in which case a formatted blank cell will be written. In either case the appropriate row or column value will still be incremented.
  
  As noted above the C<write()> method can be used as a synonym for C<write_row()> and C<write_row()> handles nested array refs as columns. Therefore, the following two method calls are equivalent although the more explicit call to C<write_col()> would be preferable for maintainability:
  
      $worksheet->write_col( 'A1', $array_ref     ); # Write a column of data
      $worksheet->write(     'A1', [ $array_ref ] ); # Same thing
  
  To find out more about array references refer to C<perlref> and C<perlreftut> in the main Perl documentation. To find out more about 2D arrays or "lists of lists" refer to C<perllol>.
  
  The C<write_col()> method returns the first error encountered when writing the elements of the data or zero if no errors were encountered. See the return values described for the C<write()> method above.
  
  See also the C<write_arrays.pl> program in the C<examples> directory of the distro.
  
  
  
  
  =head2 write_date_time( $row, $col, $date_string, $format )
  
  The C<write_date_time()> method can be used to write a date or time to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_date_time( 'A1', '2004-05-13T23:20', $date_format );
  
  The C<$date_string> should be in the following format:
  
      yyyy-mm-ddThh:mm:ss.sss
  
  This conforms to an ISO8601 date but it should be noted that the full range of ISO8601 formats are not supported.
  
  The following variations on the C<$date_string> parameter are permitted:
  
      yyyy-mm-ddThh:mm:ss.sss         # Standard format
      yyyy-mm-ddT                     # No time
                Thh:mm:ss.sss         # No date
      yyyy-mm-ddThh:mm:ss.sssZ        # Additional Z (but not time zones)
      yyyy-mm-ddThh:mm:ss             # No fractional seconds
      yyyy-mm-ddThh:mm                # No seconds
  
  Note that the C<T> is required in all cases.
  
  A date should always have a C<$format>, otherwise it will appear as a number, see L</DATES AND TIME IN EXCEL> and L</CELL FORMATTING>. Here is a typical example:
  
      my $date_format = $workbook->add_format( num_format => 'mm/dd/yy' );
      $worksheet->write_date_time( 'A1', '2004-05-13T23:20', $date_format );
  
  Valid dates should be in the range 1900-01-01 to 9999-12-31, for the 1900 epoch and 1904-01-01 to 9999-12-31, for the 1904 epoch. As with Excel, dates outside these ranges will be written as a string.
  
  See also the date_time.pl program in the C<examples> directory of the distro.
  
  
  
  
  =head2 write_url( $row, $col, $url, $format, $label )
  
  Write a hyperlink to a URL in the cell specified by C<$row> and C<$column>. The hyperlink is comprised of two elements: the visible label and the invisible link. The visible label is the same as the link unless an alternative label is specified. The C<$label> parameter is optional. The label is written using the C<write()> method. Therefore it is possible to write strings, numbers or formulas as labels.
  
  The C<$format> parameter is also optional, however, without a format the link won't look like a link.
  
  The suggested format is:
  
      my $format = $workbook->add_format( color => 'blue', underline => 1 );
  
  B<Note>, this behaviour is different from Spreadsheet::WriteExcel which provides a default hyperlink format if one isn't specified by the user.
  
  There are four web style URI's supported: C<http://>, C<https://>, C<ftp://> and C<mailto:>:
  
      $worksheet->write_url( 0, 0, 'ftp://www.perl.org/',       $format );
      $worksheet->write_url( 'A3', 'http://www.perl.com/',      $format );
      $worksheet->write_url( 'A4', 'mailto:jmcnamara@cpan.org', $format );
  
  You can display an alternative string using the C<$label> parameter:
  
      $worksheet->write_url( 1, 0, 'http://www.perl.com/', $format, 'Perl' );
  
  If you wish to have some other cell data such as a number or a formula you can overwrite the cell using another call to C<write_*()>:
  
      $worksheet->write_url( 'A1', 'http://www.perl.com/' );
  
      # Overwrite the URL string with a formula. The cell is still a link.
      $worksheet->write_formula( 'A1', '=1+1', $format );
  
  There are two local URIs supported: C<internal:> and C<external:>. These are used for hyperlinks to internal worksheet references or external workbook and worksheet references:
  
      $worksheet->write_url( 'A6',  'internal:Sheet2!A1',              $format );
      $worksheet->write_url( 'A7',  'internal:Sheet2!A1',              $format );
      $worksheet->write_url( 'A8',  'internal:Sheet2!A1:B2',           $format );
      $worksheet->write_url( 'A9',  q{internal:'Sales Data'!A1},       $format );
      $worksheet->write_url( 'A10', 'external:c:\temp\foo.xlsx',       $format );
      $worksheet->write_url( 'A11', 'external:c:\foo.xlsx#Sheet2!A1',  $format );
      $worksheet->write_url( 'A12', 'external:..\foo.xlsx',            $format );
      $worksheet->write_url( 'A13', 'external:..\foo.xlsx#Sheet2!A1',  $format );
      $worksheet->write_url( 'A13', 'external:\\\\NET\share\foo.xlsx', $format );
  
  All of the these URI types are recognised by the C<write()> method, see above.
  
  Worksheet references are typically of the form C<Sheet1!A1>. You can also refer to a worksheet range using the standard Excel notation: C<Sheet1!A1:B2>.
  
  In external links the workbook and worksheet name must be separated by the C<#> character: C<external:Workbook.xlsx#Sheet1!A1'>.
  
  You can also link to a named range in the target worksheet. For example say you have a named range called C<my_name> in the workbook C<c:\temp\foo.xlsx> you could link to it as follows:
  
      $worksheet->write_url( 'A14', 'external:c:\temp\foo.xlsx#my_name' );
  
  Excel requires that worksheet names containing spaces or non alphanumeric characters are single quoted as follows C<'Sales Data'!A1>. If you need to do this in a single quoted string then you can either escape the single quotes C<\'> or use the quote operator C<q{}> as described in C<perlop> in the main Perl documentation.
  
  Links to network files are also supported. MS/Novell Network files normally begin with two back slashes as follows C<\\NETWORK\etc>. In order to generate this in a single or double quoted string you will have to escape the backslashes,  C<'\\\\NETWORK\etc'>.
  
  If you are using double quote strings then you should be careful to escape anything that looks like a metacharacter. For more information see C<perlfaq5: Why can't I use "C:\temp\foo" in DOS paths?>.
  
  Finally, you can avoid most of these quoting problems by using forward slashes. These are translated internally to backslashes:
  
      $worksheet->write_url( 'A14', "external:c:/temp/foo.xlsx" );
      $worksheet->write_url( 'A15', 'external://NETWORK/share/foo.xlsx' );
  
  Note: Excel::Writer::XLSX will escape the following characters in URLs as required by Excel: C<< \s " < > \ [  ] ` ^ { } >> unless the URL already contains C<%xx> style escapes. In which case it is assumed that the URL was escaped correctly by the user and will by passed directly to Excel.
  
  Excel limits hyperlink links and anchor/locations to 255 characters each.
  
  See also, the note about L</Cell notation>.
  
  
  
  
  =head2 write_formula( $row, $column, $formula, $format, $value )
  
  Write a formula or function to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_formula( 0, 0, '=$B$3 + B4' );
      $worksheet->write_formula( 1, 0, '=SIN(PI()/4)' );
      $worksheet->write_formula( 2, 0, '=SUM(B1:B5)' );
      $worksheet->write_formula( 'A4', '=IF(A3>1,"Yes", "No")' );
      $worksheet->write_formula( 'A5', '=AVERAGE(1, 2, 3, 4)' );
      $worksheet->write_formula( 'A6', '=DATEVALUE("1-Jan-2001")' );
  
  Array formulas are also supported:
  
      $worksheet->write_formula( 'A7', '{=SUM(A1:B1*A2:B2)}' );
  
  See also the C<write_array_formula()> method below.
  
  See the note about L</Cell notation>. For more information about writing Excel formulas see L</FORMULAS AND FUNCTIONS IN EXCEL>
  
  If required, it is also possible to specify the calculated value of the formula. This is occasionally necessary when working with non-Excel applications that don't calculate the value of the formula. The calculated C<$value> is added at the end of the argument list:
  
      $worksheet->write( 'A1', '=2+2', $format, 4 );
  
  However, this probably isn't something that you will ever need to do. If you do use this feature then do so with care.
  
  
  
  
  =head2 write_array_formula($first_row, $first_col, $last_row, $last_col, $formula, $format, $value)
  
  Write an array formula to a cell range. In Excel an array formula is a formula that performs a calculation on a set of values. It can return a single value or a range of values.
  
  An array formula is indicated by a pair of braces around the formula: C<{=SUM(A1:B1*A2:B2)}>.  If the array formula returns a single value then the C<$first_> and C<$last_> parameters should be the same:
  
      $worksheet->write_array_formula('A1:A1', '{=SUM(B1:C1*B2:C2)}');
  
  It this case however it is easier to just use the C<write_formula()> or C<write()> methods:
  
      # Same as above but more concise.
      $worksheet->write( 'A1', '{=SUM(B1:C1*B2:C2)}' );
      $worksheet->write_formula( 'A1', '{=SUM(B1:C1*B2:C2)}' );
  
  For array formulas that return a range of values you must specify the range that the return values will be written to:
  
      $worksheet->write_array_formula( 'A1:A3',    '{=TREND(C1:C3,B1:B3)}' );
      $worksheet->write_array_formula( 0, 0, 2, 0, '{=TREND(C1:C3,B1:B3)}' );
  
  If required, it is also possible to specify the calculated value of the formula. This is occasionally necessary when working with non-Excel applications that don't calculate the value of the formula. However, using this parameter only writes a single value to the upper left cell in the result array. For a multi-cell array formula where the results are required, the other result values can be specified by using C<write_number()> to write to the appropriate cell:
  
      # Specify the result for a single cell range.
      $worksheet->write_array_formula( 'A1:A3', '{=SUM(B1:C1*B2:C2)}, $format, 2005 );
  
      # Specify the results for a multi cell range.
      $worksheet->write_array_formula( 'A1:A3', '{=TREND(C1:C3,B1:B3)}', $format, 105 );
      $worksheet->write_number( 'A2', 12, format );
      $worksheet->write_number( 'A3', 14, format );
  
  In addition, some early versions of Excel 2007 don't calculate the values of array formulas when they aren't supplied. Installing the latest Office Service Pack should fix this issue.
  
  See also the C<array_formula.pl> program in the C<examples> directory of the distro.
  
  Note: Array formulas are not supported by Spreadsheet::WriteExcel.
  
  
  
  
  =head2 write_boolean( $row, $column, $value, $format )
  
  Write an Excel boolean value to the cell specified by C<$row> and C<$column>:
  
      $worksheet->write_boolean( 'A1', 1          );  # TRUE
      $worksheet->write_boolean( 'A2', 0          );  # FALSE
      $worksheet->write_boolean( 'A3', undef      );  # FALSE
      $worksheet->write_boolean( 'A3', 0, $format );  # FALSE, with format.
  
  A C<$value> that is true or false using Perl's rules will be written as an Excel boolean C<TRUE> or C<FALSE> value.
  
  See the note about L</Cell notation>.
  
  
  
  
  =head2 store_formula( $formula )
  
  Deprecated. This is a Spreadsheet::WriteExcel method that is no longer required by Excel::Writer::XLSX. See below.
  
  
  
  
  =head2 repeat_formula( $row, $col, $formula, $format )
  
  Deprecated. This is a Spreadsheet::WriteExcel method that is no longer required by Excel::Writer::XLSX.
  
  In Spreadsheet::WriteExcel it was computationally expensive to write formulas since they were parsed by a recursive descent parser. The C<store_formula()> and C<repeat_formula()> methods were used as a way of avoiding the overhead of repeated formulas by reusing a pre-parsed formula.
  
  In Excel::Writer::XLSX this is no longer necessary since it is just as quick to write a formula as it is to write a string or a number.
  
  The methods remain for backward compatibility but new Excel::Writer::XLSX programs shouldn't use them.
  
  
  
  
  
  =head2 write_comment( $row, $column, $string, ... )
  
  The C<write_comment()> method is used to add a comment to a cell. A cell comment is indicated in Excel by a small red triangle in the upper right-hand corner of the cell. Moving the cursor over the red triangle will reveal the comment.
  
  The following example shows how to add a comment to a cell:
  
      $worksheet->write        ( 2, 2, 'Hello' );
      $worksheet->write_comment( 2, 2, 'This is a comment.' );
  
  As usual you can replace the C<$row> and C<$column> parameters with an C<A1> cell reference. See the note about L</Cell notation>.
  
      $worksheet->write        ( 'C3', 'Hello');
      $worksheet->write_comment( 'C3', 'This is a comment.' );
  
  The C<write_comment()> method will also handle strings in C<UTF-8> format.
  
      $worksheet->write_comment( 'C3', "\x{263a}" );       # Smiley
      $worksheet->write_comment( 'C4', 'Comment ca va?' );
  
  In addition to the basic 3 argument form of C<write_comment()> you can pass in several optional key/value pairs to control the format of the comment. For example:
  
      $worksheet->write_comment( 'C3', 'Hello', visible => 1, author => 'Perl' );
  
  Most of these options are quite specific and in general the default comment behaves will be all that you need. However, should you need greater control over the format of the cell comment the following options are available:
  
      author
      visible
      x_scale
      width
      y_scale
      height
      color
      start_cell
      start_row
      start_col
      x_offset
      y_offset
  
  
  =over 4
  
  =item Option: author
  
  This option is used to indicate who is the author of the cell comment. Excel displays the author of the comment in the status bar at the bottom of the worksheet. This is usually of interest in corporate environments where several people might review and provide comments to a workbook.
  
      $worksheet->write_comment( 'C3', 'Atonement', author => 'Ian McEwan' );
  
  The default author for all cell comments can be set using the C<set_comments_author()> method (see below).
  
      $worksheet->set_comments_author( 'Perl' );
  
  
  =item Option: visible
  
  This option is used to make a cell comment visible when the worksheet is opened. The default behaviour in Excel is that comments are initially hidden. However, it is also possible in Excel to make individual or all comments visible. In Excel::Writer::XLSX individual comments can be made visible as follows:
  
      $worksheet->write_comment( 'C3', 'Hello', visible => 1 );
  
  It is possible to make all comments in a worksheet visible using the C<show_comments()> worksheet method (see below). Alternatively, if all of the cell comments have been made visible you can hide individual comments:
  
      $worksheet->write_comment( 'C3', 'Hello', visible => 0 );
  
  
  =item Option: x_scale
  
  This option is used to set the width of the cell comment box as a factor of the default width.
  
      $worksheet->write_comment( 'C3', 'Hello', x_scale => 2 );
      $worksheet->write_comment( 'C4', 'Hello', x_scale => 4.2 );
  
  
  =item Option: width
  
  This option is used to set the width of the cell comment box explicitly in pixels.
  
      $worksheet->write_comment( 'C3', 'Hello', width => 200 );
  
  
  =item Option: y_scale
  
  This option is used to set the height of the cell comment box as a factor of the default height.
  
      $worksheet->write_comment( 'C3', 'Hello', y_scale => 2 );
      $worksheet->write_comment( 'C4', 'Hello', y_scale => 4.2 );
  
  
  =item Option: height
  
  This option is used to set the height of the cell comment box explicitly in pixels.
  
      $worksheet->write_comment( 'C3', 'Hello', height => 200 );
  
  
  =item Option: color
  
  This option is used to set the background colour of cell comment box. You can use one of the named colours recognised by Excel::Writer::XLSX or a Html style C<#RRGGBB> colour. See L</WORKING WITH COLOURS>.
  
      $worksheet->write_comment( 'C3', 'Hello', color => 'green' );
      $worksheet->write_comment( 'C4', 'Hello', color => '#FF6600' ); # Orange
  
  
  =item Option: start_cell
  
  This option is used to set the cell in which the comment will appear. By default Excel displays comments one cell to the right and one cell above the cell to which the comment relates. However, you can change this behaviour if you wish. In the following example the comment which would appear by default in cell C<D2> is moved to C<E2>.
  
      $worksheet->write_comment( 'C3', 'Hello', start_cell => 'E2' );
  
  
  =item Option: start_row
  
  This option is used to set the row in which the comment will appear. See the C<start_cell> option above. The row is zero indexed.
  
      $worksheet->write_comment( 'C3', 'Hello', start_row => 0 );
  
  
  =item Option: start_col
  
  This option is used to set the column in which the comment will appear. See the C<start_cell> option above. The column is zero indexed.
  
      $worksheet->write_comment( 'C3', 'Hello', start_col => 4 );
  
  
  =item Option: x_offset
  
  This option is used to change the x offset, in pixels, of a comment within a cell:
  
      $worksheet->write_comment( 'C3', $comment, x_offset => 30 );
  
  
  =item Option: y_offset
  
  This option is used to change the y offset, in pixels, of a comment within a cell:
  
      $worksheet->write_comment('C3', $comment, x_offset => 30);
  
  
  =back
  
  You can apply as many of these options as you require.
  
  B<Note about using options that adjust the position of the cell comment such as start_cell, start_row, start_col, x_offset and y_offset>: Excel only displays offset cell comments when they are displayed as "visible". Excel does B<not> display hidden cells as moved when you mouse over them.
  
  B<Note about row height and comments>. If you specify the height of a row that contains a comment then Excel::Writer::XLSX will adjust the height of the comment to maintain the default or user specified dimensions. However, the height of a row can also be adjusted automatically by Excel if the text wrap property is set or large fonts are used in the cell. This means that the height of the row is unknown to the module at run time and thus the comment box is stretched with the row. Use the C<set_row()> method to specify the row height explicitly and avoid this problem.
  
  
  
  
  =head2 show_comments()
  
  This method is used to make all cell comments visible when a worksheet is opened.
  
      $worksheet->show_comments();
  
  Individual comments can be made visible using the C<visible> parameter of the C<write_comment> method (see above):
  
      $worksheet->write_comment( 'C3', 'Hello', visible => 1 );
  
  If all of the cell comments have been made visible you can hide individual comments as follows:
  
      $worksheet->show_comments();
      $worksheet->write_comment( 'C3', 'Hello', visible => 0 );
  
  
  
  =head2 set_comments_author()
  
  This method is used to set the default author of all cell comments.
  
      $worksheet->set_comments_author( 'Perl' );
  
  Individual comment authors can be set using the C<author> parameter of the C<write_comment> method (see above).
  
  The default comment author is an empty string, C<''>, if no author is specified.
  
  
  
  
  =head2 add_write_handler( $re, $code_ref )
  
  This method is used to extend the Excel::Writer::XLSX write() method to handle user defined data.
  
  If you refer to the section on C<write()> above you will see that it acts as an alias for several more specific C<write_*> methods. However, it doesn't always act in exactly the way that you would like it to.
  
  One solution is to filter the input data yourself and call the appropriate C<write_*> method. Another approach is to use the C<add_write_handler()> method to add your own automated behaviour to C<write()>.
  
  The C<add_write_handler()> method take two arguments, C<$re>, a regular expression to match incoming data and C<$code_ref> a callback function to handle the matched data:
  
      $worksheet->add_write_handler( qr/^\d\d\d\d$/, \&my_write );
  
  (In the these examples the C<qr> operator is used to quote the regular expression strings, see L<perlop> for more details).
  
  The method is used as follows. say you wished to write 7 digit ID numbers as a string so that any leading zeros were preserved*, you could do something like the following:
  
      $worksheet->add_write_handler( qr/^\d{7}$/, \&write_my_id );
  
  
      sub write_my_id {
          my $worksheet = shift;
          return $worksheet->write_string( @_ );
      }
  
  * You could also use the C<keep_leading_zeros()> method for this.
  
  Then if you call C<write()> with an appropriate string it will be handled automatically:
  
      # Writes 0000000. It would normally be written as a number; 0.
      $worksheet->write( 'A1', '0000000' );
  
  The callback function will receive a reference to the calling worksheet and all of the other arguments that were passed to C<write()>. The callback will see an C<@_> argument list that looks like the following:
  
      $_[0]   A ref to the calling worksheet. *
      $_[1]   Zero based row number.
      $_[2]   Zero based column number.
      $_[3]   A number or string or token.
      $_[4]   A format ref if any.
      $_[5]   Any other arguments.
      ...
  
      *  It is good style to shift this off the list so the @_ is the same
         as the argument list seen by write().
  
  Your callback should C<return()> the return value of the C<write_*> method that was called or C<undef> to indicate that you rejected the match and want C<write()> to continue as normal.
  
  So for example if you wished to apply the previous filter only to ID values that occur in the first column you could modify your callback function as follows:
  
  
      sub write_my_id {
          my $worksheet = shift;
          my $col       = $_[1];
  
          if ( $col == 0 ) {
              return $worksheet->write_string( @_ );
          }
          else {
              # Reject the match and return control to write()
              return undef;
          }
      }
  
  Now, you will get different behaviour for the first column and other columns:
  
      $worksheet->write( 'A1', '0000000' );    # Writes 0000000
      $worksheet->write( 'B1', '0000000' );    # Writes 0
  
  
  You may add more than one handler in which case they will be called in the order that they were added.
  
  Note, the C<add_write_handler()> method is particularly suited for handling dates.
  
  See the C<write_handler 1-4> programs in the C<examples> directory for further examples.
  
  
  
  
  =head2 insert_image( $row, $col, $filename, $x, $y, $x_scale, $y_scale )
  
  This method can be used to insert a image into a worksheet. The image can be in PNG, JPEG or BMP format. The C<$x>, C<$y>, C<$x_scale> and C<$y_scale> parameters are optional.
  
      $worksheet1->insert_image( 'A1', 'perl.bmp' );
      $worksheet2->insert_image( 'A1', '../images/perl.bmp' );
      $worksheet3->insert_image( 'A1', '.c:\images\perl.bmp' );
  
  The parameters C<$x> and C<$y> can be used to specify an offset from the top left hand corner of the cell specified by C<$row> and C<$col>. The offset values are in pixels.
  
      $worksheet1->insert_image('A1', 'perl.bmp', 32, 10);
  
  The offsets can be greater than the width or height of the underlying cell. This can be occasionally useful if you wish to align two or more images relative to the same cell.
  
  The parameters C<$x_scale> and C<$y_scale> can be used to scale the inserted image horizontally and vertically:
  
      # Scale the inserted image: width x 2.0, height x 0.8
      $worksheet->insert_image( 'A1', 'perl.bmp', 0, 0, 2, 0.8 );
  
  Note: you must call C<set_row()> or C<set_column()> before C<insert_image()> if you wish to change the default dimensions of any of the rows or columns that the image occupies. The height of a row can also change if you use a font that is larger than the default. This in turn will affect the scaling of your image. To avoid this you should explicitly set the height of the row using C<set_row()> if it contains a font size that will change the row height.
  
  BMP images must be 24 bit, true colour, bitmaps. In general it is best to avoid BMP images since they aren't compressed.
  
  
  
  
  =head2 insert_chart( $row, $col, $chart, $x, $y, $x_scale, $y_scale )
  
  This method can be used to insert a Chart object into a worksheet. The Chart must be created by the C<add_chart()> Workbook method and it must have the C<embedded> option set.
  
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the chart.
      ...
  
      # Insert the chart into the a worksheet.
      $worksheet->insert_chart( 'E2', $chart );
  
  See C<add_chart()> for details on how to create the Chart object and L<Excel::Writer::XLSX::Chart> for details on how to configure it. See also the C<chart_*.pl> programs in the examples directory of the distro.
  
  The C<$x>, C<$y>, C<$x_scale> and C<$y_scale> parameters are optional.
  
  The parameters C<$x> and C<$y> can be used to specify an offset from the top left hand corner of the cell specified by C<$row> and C<$col>. The offset values are in pixels.
  
      $worksheet1->insert_chart( 'E2', $chart, 3, 3 );
  
  The parameters C<$x_scale> and C<$y_scale> can be used to scale the inserted chart horizontally and vertically:
  
      # Scale the width by 120% and the height by 150%
      $worksheet->insert_chart( 'E2', $chart, 0, 0, 1.2, 1.5 );
  
  =head2 insert_shape( $row, $col, $shape, $x, $y, $x_scale, $y_scale )
  
  This method can be used to insert a Shape object into a worksheet. The Shape must be created by the C<add_shape()> Workbook method.
  
      my $shape = $workbook->add_shape( name => 'My Shape', type => 'plus' );
  
      # Configure the shape.
      $shape->set_text('foo');
      ...
  
      # Insert the shape into the a worksheet.
      $worksheet->insert_shape( 'E2', $shape );
  
  See C<add_shape()> for details on how to create the Shape object and L<Excel::Writer::XLSX::Shape> for details on how to configure it.
  
  The C<$x>, C<$y>, C<$x_scale> and C<$y_scale> parameters are optional.
  
  The parameters C<$x> and C<$y> can be used to specify an offset from the top left hand corner of the cell specified by C<$row> and C<$col>. The offset values are in pixels.
  
      $worksheet1->insert_shape( 'E2', $chart, 3, 3 );
  
  The parameters C<$x_scale> and C<$y_scale> can be used to scale the inserted shape horizontally and vertically:
  
      # Scale the width by 120% and the height by 150%
      $worksheet->insert_shape( 'E2', $shape, 0, 0, 1.2, 1.5 );
  
  See also the C<shape*.pl> programs in the examples directory of the distro.
  
  
  
  
  =head2 insert_button( $row, $col, { %properties })
  
  The C<insert_button()> method can be used to insert an Excel form button into a worksheet.
  
  This method is generally only useful when used in conjunction with the Workbook C<add_vba_project()> method to tie the button to a macro from an embedded VBA project:
  
      my $workbook  = Excel::Writer::XLSX->new( 'file.xlsm' );
      ...
      $workbook->add_vba_project( './vbaProject.bin' );
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro' } );
  
  The properties of the button that can be set are:
  
      macro
      caption
      width
      height
      x_scale
      y_scale
      x_offset
      y_offset
  
  
  =over
  
  =item Option: macro
  
  This option is used to set the macro that the button will invoke when the user clicks on it. The macro should be included using the Workbook C<add_vba_project()> method shown above.
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro' } );
  
  The default macro is C<ButtonX_Click> where X is the button number.
  
  =item Option: caption
  
  This option is used to set the caption on the button. The default is C<Button X> where X is the button number.
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro', caption => 'Hello' } );
  
  =item Option: width
  
  This option is used to set the width of the button in pixels.
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro', width => 128 } );
  
  The default button width is 64 pixels which is the width of a default cell.
  
  =item Option: height
  
  This option is used to set the height of the button in pixels.
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro', height => 40 } );
  
  The default button height is 20 pixels which is the height of a default cell.
  
  =item Option: x_scale
  
  This option is used to set the width of the button as a factor of the default width.
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro', x_scale => 2.0 );
  
  =item Option: y_scale
  
  This option is used to set the height of the button as a factor of the default height.
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro', y_scale => 2.0 );
  
  
  =item Option: x_offset
  
  This option is used to change the x offset, in pixels, of a button within a cell:
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro', x_offset => 2 );
  
  =item Option: y_offset
  
  This option is used to change the y offset, in pixels, of a comment within a cell.
  
  =back
  
  
  Note: Button is the only Excel form element that is available in Excel::Writer::XLSX. Form elements represent a lot of work to implement and the underlying VML syntax isn't very much fun.
  
  
  
  
  =head2 data_validation()
  
  The C<data_validation()> method is used to construct an Excel data validation or to limit the user input to a dropdown list of values.
  
  
      $worksheet->data_validation('B3',
          {
              validate => 'integer',
              criteria => '>',
              value    => 100,
          });
  
      $worksheet->data_validation('B5:B9',
          {
              validate => 'list',
              value    => ['open', 'high', 'close'],
          });
  
  This method contains a lot of parameters and is described in detail in a separate section L</DATA VALIDATION IN EXCEL>.
  
  
  See also the C<data_validate.pl> program in the examples directory of the distro
  
  
  
  
  =head2 conditional_formatting()
  
  The C<conditional_formatting()> method is used to add formatting to a cell or range of cells based on user defined criteria.
  
      $worksheet->conditional_formatting( 'A1:J10',
          {
              type     => 'cell',
              criteria => '>=',
              value    => 50,
              format   => $format1,
          }
      );
  
  This method contains a lot of parameters and is described in detail in a separate section L<CONDITIONAL FORMATTING IN EXCEL>.
  
  See also the C<conditional_format.pl> program in the examples directory of the distro
  
  
  
  
  =head2 add_sparkline()
  
  The C<add_sparkline()> worksheet method is used to add sparklines to a cell or a range of cells.
  
      $worksheet->add_sparkline(
          {
              location => 'F2',
              range    => 'Sheet1!A2:E2',
              type     => 'column',
              style    => 12,
          }
      );
  
  This method contains a lot of parameters and is described in detail in a separate section L</SPARKLINES IN EXCEL>.
  
  See also the C<sparklines1.pl> and C<sparklines2.pl> example programs in the C<examples> directory of the distro.
  
  B<Note:> Sparklines are a feature of Excel 2010+ only. You can write them to an XLSX file that can be read by Excel 2007 but they won't be displayed.
  
  
  
  
  =head2 add_table()
  
  The C<add_table()> method is used to group a range of cells into an Excel Table.
  
      $worksheet->add_table( 'B3:F7', { ... } );
  
  This method contains a lot of parameters and is described in detail in a separate section L<TABLES IN EXCEL>.
  
  See also the C<tables.pl> program in the examples directory of the distro
  
  
  
  =head2 get_name()
  
  The C<get_name()> method is used to retrieve the name of a worksheet. For example:
  
      for my $sheet ( $workbook->sheets() ) {
          print $sheet->get_name();
      }
  
  For reasons related to the design of Excel::Writer::XLSX and to the internals of Excel there is no C<set_name()> method. The only way to set the worksheet name is via the C<add_worksheet()> method.
  
  
  
  
  =head2 activate()
  
  The C<activate()> method is used to specify which worksheet is initially visible in a multi-sheet workbook:
  
      $worksheet1 = $workbook->add_worksheet( 'To' );
      $worksheet2 = $workbook->add_worksheet( 'the' );
      $worksheet3 = $workbook->add_worksheet( 'wind' );
  
      $worksheet3->activate();
  
  This is similar to the Excel VBA activate method. More than one worksheet can be selected via the C<select()> method, see below, however only one worksheet can be active.
  
  The default active worksheet is the first worksheet.
  
  
  
  
  =head2 select()
  
  The C<select()> method is used to indicate that a worksheet is selected in a multi-sheet workbook:
  
      $worksheet1->activate();
      $worksheet2->select();
      $worksheet3->select();
  
  A selected worksheet has its tab highlighted. Selecting worksheets is a way of grouping them together so that, for example, several worksheets could be printed in one go. A worksheet that has been activated via the C<activate()> method will also appear as selected.
  
  
  
  
  =head2 hide()
  
  The C<hide()> method is used to hide a worksheet:
  
      $worksheet2->hide();
  
  You may wish to hide a worksheet in order to avoid confusing a user with intermediate data or calculations.
  
  A hidden worksheet can not be activated or selected so this method is mutually exclusive with the C<activate()> and C<select()> methods. In addition, since the first worksheet will default to being the active worksheet, you cannot hide the first worksheet without activating another sheet:
  
      $worksheet2->activate();
      $worksheet1->hide();
  
  
  
  
  =head2 set_first_sheet()
  
  The C<activate()> method determines which worksheet is initially selected. However, if there are a large number of worksheets the selected worksheet may not appear on the screen. To avoid this you can select which is the leftmost visible worksheet using C<set_first_sheet()>:
  
      for ( 1 .. 20 ) {
          $workbook->add_worksheet;
      }
  
      $worksheet21 = $workbook->add_worksheet();
      $worksheet22 = $workbook->add_worksheet();
  
      $worksheet21->set_first_sheet();
      $worksheet22->activate();
  
  This method is not required very often. The default value is the first worksheet.
  
  
  
  
  =head2 protect( $password, \%options )
  
  The C<protect()> method is used to protect a worksheet from modification:
  
      $worksheet->protect();
  
  The C<protect()> method also has the effect of enabling a cell's C<locked> and C<hidden> properties if they have been set. A I<locked> cell cannot be edited and this property is on by default for all cells. A I<hidden> cell will display the results of a formula but not the formula itself.
  
  See the C<protection.pl> program in the examples directory of the distro for an illustrative example and the C<set_locked> and C<set_hidden> format methods in L</CELL FORMATTING>.
  
  You can optionally add a password to the worksheet protection:
  
      $worksheet->protect( 'drowssap' );
  
  Passing the empty string C<''> is the same as turning on protection without a password.
  
  Note, the worksheet level password in Excel provides very weak protection. It does not encrypt your data and is very easy to deactivate. Full workbook encryption is not supported by C<Excel::Writer::XLSX> since it requires a completely different file format and would take several man months to implement.
  
  You can specify which worksheet elements you wish to protect by passing a hash_ref with any or all of the following keys:
  
      # Default shown.
      %options = (
          objects               => 0,
          scenarios             => 0,
          format_cells          => 0,
          format_columns        => 0,
          format_rows           => 0,
          insert_columns        => 0,
          insert_rows           => 0,
          insert_hyperlinks     => 0,
          delete_columns        => 0,
          delete_rows           => 0,
          select_locked_cells   => 1,
          sort                  => 0,
          autofilter            => 0,
          pivot_tables          => 0,
          select_unlocked_cells => 1,
      );
  
  The default boolean values are shown above. Individual elements can be protected as follows:
  
      $worksheet->protect( 'drowssap', { insert_rows => 1 } );
  
  
  
  
  =head2 set_selection( $first_row, $first_col, $last_row, $last_col )
  
  This method can be used to specify which cell or cells are selected in a worksheet. The most common requirement is to select a single cell, in which case C<$last_row> and C<$last_col> can be omitted. The active cell within a selected range is determined by the order in which C<$first> and C<$last> are specified. It is also possible to specify a cell or a range using A1 notation. See the note about L</Cell notation>.
  
  Examples:
  
      $worksheet1->set_selection( 3, 3 );          # 1. Cell D4.
      $worksheet2->set_selection( 3, 3, 6, 6 );    # 2. Cells D4 to G7.
      $worksheet3->set_selection( 6, 6, 3, 3 );    # 3. Cells G7 to D4.
      $worksheet4->set_selection( 'D4' );          # Same as 1.
      $worksheet5->set_selection( 'D4:G7' );       # Same as 2.
      $worksheet6->set_selection( 'G7:D4' );       # Same as 3.
  
  The default cell selections is (0, 0), 'A1'.
  
  
  
  
  =head2 set_row( $row, $height, $format, $hidden, $level, $collapsed )
  
  This method can be used to change the default properties of a row. All parameters apart from C<$row> are optional.
  
  The most common use for this method is to change the height of a row:
  
      $worksheet->set_row( 0, 20 );    # Row 1 height set to 20
  
  If you wish to set the format without changing the height you can pass C<undef> as the height parameter:
  
      $worksheet->set_row( 0, undef, $format );
  
  The C<$format> parameter will be applied to any cells in the row that don't have a format. For example
  
      $worksheet->set_row( 0, undef, $format1 );    # Set the format for row 1
      $worksheet->write( 'A1', 'Hello' );           # Defaults to $format1
      $worksheet->write( 'B1', 'Hello', $format2 ); # Keeps $format2
  
  If you wish to define a row format in this way you should call the method before any calls to C<write()>. Calling it afterwards will overwrite any format that was previously specified.
  
  The C<$hidden> parameter should be set to 1 if you wish to hide a row. This can be used, for example, to hide intermediary steps in a complicated calculation:
  
      $worksheet->set_row( 0, 20,    $format, 1 );
      $worksheet->set_row( 1, undef, undef,   1 );
  
  The C<$level> parameter is used to set the outline level of the row. Outlines are described in L</OUTLINES AND GROUPING IN EXCEL>. Adjacent rows with the same outline level are grouped together into a single outline.
  
  The following example sets an outline level of 1 for rows 1 and 2 (zero-indexed):
  
      $worksheet->set_row( 1, undef, undef, 0, 1 );
      $worksheet->set_row( 2, undef, undef, 0, 1 );
  
  The C<$hidden> parameter can also be used to hide collapsed outlined rows when used in conjunction with the C<$level> parameter.
  
      $worksheet->set_row( 1, undef, undef, 1, 1 );
      $worksheet->set_row( 2, undef, undef, 1, 1 );
  
  For collapsed outlines you should also indicate which row has the collapsed C<+> symbol using the optional C<$collapsed> parameter.
  
      $worksheet->set_row( 3, undef, undef, 0, 0, 1 );
  
  For a more complete example see the C<outline.pl> and C<outline_collapsed.pl> programs in the examples directory of the distro.
  
  Excel allows up to 7 outline levels. Therefore the C<$level> parameter should be in the range C<0 E<lt>= $level E<lt>= 7>.
  
  
  
  
  =head2 set_column( $first_col, $last_col, $width, $format, $hidden, $level, $collapsed )
  
  This method can be used to change the default properties of a single column or a range of columns. All parameters apart from C<$first_col> and C<$last_col> are optional.
  
  If C<set_column()> is applied to a single column the value of C<$first_col> and C<$last_col> should be the same. In the case where C<$last_col> is zero it is set to the same value as C<$first_col>.
  
  It is also possible, and generally clearer, to specify a column range using the form of A1 notation used for columns. See the note about L</Cell notation>.
  
  Examples:
  
      $worksheet->set_column( 0, 0, 20 );    # Column  A   width set to 20
      $worksheet->set_column( 1, 3, 30 );    # Columns B-D width set to 30
      $worksheet->set_column( 'E:E', 20 );   # Column  E   width set to 20
      $worksheet->set_column( 'F:H', 30 );   # Columns F-H width set to 30
  
  The width corresponds to the column width value that is specified in Excel. It is approximately equal to the length of a string in the default font of Calibri 11. Unfortunately, there is no way to specify "AutoFit" for a column in the Excel file format. This feature is only available at runtime from within Excel.
  
  As usual the C<$format> parameter is optional, for additional information, see L</CELL FORMATTING>. If you wish to set the format without changing the width you can pass C<undef> as the width parameter:
  
      $worksheet->set_column( 0, 0, undef, $format );
  
  The C<$format> parameter will be applied to any cells in the column that don't have a format. For example
  
      $worksheet->set_column( 'A:A', undef, $format1 );    # Set format for col 1
      $worksheet->write( 'A1', 'Hello' );                  # Defaults to $format1
      $worksheet->write( 'A2', 'Hello', $format2 );        # Keeps $format2
  
  If you wish to define a column format in this way you should call the method before any calls to C<write()>. If you call it afterwards it won't have any effect.
  
  A default row format takes precedence over a default column format
  
      $worksheet->set_row( 0, undef, $format1 );           # Set format for row 1
      $worksheet->set_column( 'A:A', undef, $format2 );    # Set format for col 1
      $worksheet->write( 'A1', 'Hello' );                  # Defaults to $format1
      $worksheet->write( 'A2', 'Hello' );                  # Defaults to $format2
  
  The C<$hidden> parameter should be set to 1 if you wish to hide a column. This can be used, for example, to hide intermediary steps in a complicated calculation:
  
      $worksheet->set_column( 'D:D', 20,    $format, 1 );
      $worksheet->set_column( 'E:E', undef, undef,   1 );
  
  The C<$level> parameter is used to set the outline level of the column. Outlines are described in L</OUTLINES AND GROUPING IN EXCEL>. Adjacent columns with the same outline level are grouped together into a single outline.
  
  The following example sets an outline level of 1 for columns B to G:
  
      $worksheet->set_column( 'B:G', undef, undef, 0, 1 );
  
  The C<$hidden> parameter can also be used to hide collapsed outlined columns when used in conjunction with the C<$level> parameter.
  
      $worksheet->set_column( 'B:G', undef, undef, 1, 1 );
  
  For collapsed outlines you should also indicate which row has the collapsed C<+> symbol using the optional C<$collapsed> parameter.
  
      $worksheet->set_column( 'H:H', undef, undef, 0, 0, 1 );
  
  For a more complete example see the C<outline.pl> and C<outline_collapsed.pl> programs in the examples directory of the distro.
  
  Excel allows up to 7 outline levels. Therefore the C<$level> parameter should be in the range C<0 E<lt>= $level E<lt>= 7>.
  
  
  
  
  =head2 set_default_row( $height, $hide_unused_rows )
  
  The C<set_default_row()> method is used to set the limited number of default row properties allowed by Excel. These are the default height and the option to hide unused rows.
  
      $worksheet->set_default_row( 24 );  # Set the default row height to 24.
  
  The option to hide unused rows is used by Excel as an optimisation so that the user can hide a large number of rows without generating a very large file with an entry for each hidden row.
  
      $worksheet->set_default_row( undef, 1 );
  
  See the C<hide_row_col.pl> example program.
  
  
  
  
  =head2 outline_settings( $visible, $symbols_below, $symbols_right, $auto_style )
  
  The C<outline_settings()> method is used to control the appearance of outlines in Excel. Outlines are described in L</OUTLINES AND GROUPING IN EXCEL>.
  
  The C<$visible> parameter is used to control whether or not outlines are visible. Setting this parameter to 0 will cause all outlines on the worksheet to be hidden. They can be unhidden in Excel by means of the "Show Outline Symbols" command button. The default setting is 1 for visible outlines.
  
      $worksheet->outline_settings( 0 );
  
  The C<$symbols_below> parameter is used to control whether the row outline symbol will appear above or below the outline level bar. The default setting is 1 for symbols to appear below the outline level bar.
  
  The C<$symbols_right> parameter is used to control whether the column outline symbol will appear to the left or the right of the outline level bar. The default setting is 1 for symbols to appear to the right of the outline level bar.
  
  The C<$auto_style> parameter is used to control whether the automatic outline generator in Excel uses automatic styles when creating an outline. This has no effect on a file generated by C<Excel::Writer::XLSX> but it does have an effect on how the worksheet behaves after it is created. The default setting is 0 for "Automatic Styles" to be turned off.
  
  The default settings for all of these parameters correspond to Excel's default parameters.
  
  
  The worksheet parameters controlled by C<outline_settings()> are rarely used.
  
  
  
  
  =head2 freeze_panes( $row, $col, $top_row, $left_col )
  
  This method can be used to divide a worksheet into horizontal or vertical regions known as panes and to also "freeze" these panes so that the splitter bars are not visible. This is the same as the C<Window-E<gt>Freeze Panes> menu command in Excel
  
  The parameters C<$row> and C<$col> are used to specify the location of the split. It should be noted that the split is specified at the top or left of a cell and that the method uses zero based indexing. Therefore to freeze the first row of a worksheet it is necessary to specify the split at row 2 (which is 1 as the zero-based index). This might lead you to think that you are using a 1 based index but this is not the case.
  
  You can set one of the C<$row> and C<$col> parameters as zero if you do not want either a vertical or horizontal split.
  
  Examples:
  
      $worksheet->freeze_panes( 1, 0 );    # Freeze the first row
      $worksheet->freeze_panes( 'A2' );    # Same using A1 notation
      $worksheet->freeze_panes( 0, 1 );    # Freeze the first column
      $worksheet->freeze_panes( 'B1' );    # Same using A1 notation
      $worksheet->freeze_panes( 1, 2 );    # Freeze first row and first 2 columns
      $worksheet->freeze_panes( 'C2' );    # Same using A1 notation
  
  The parameters C<$top_row> and C<$left_col> are optional. They are used to specify the top-most or left-most visible row or column in the scrolling region of the panes. For example to freeze the first row and to have the scrolling region begin at row twenty:
  
      $worksheet->freeze_panes( 1, 0, 20, 0 );
  
  You cannot use A1 notation for the C<$top_row> and C<$left_col> parameters.
  
  
  See also the C<panes.pl> program in the C<examples> directory of the distribution.
  
  
  
  
  =head2 split_panes( $y, $x, $top_row, $left_col )
  
  
  This method can be used to divide a worksheet into horizontal or vertical regions known as panes. This method is different from the C<freeze_panes()> method in that the splits between the panes will be visible to the user and each pane will have its own scroll bars.
  
  The parameters C<$y> and C<$x> are used to specify the vertical and horizontal position of the split. The units for C<$y> and C<$x> are the same as those used by Excel to specify row height and column width. However, the vertical and horizontal units are different from each other. Therefore you must specify the C<$y> and C<$x> parameters in terms of the row heights and column widths that you have set or the default values which are C<15> for a row and C<8.43> for a column.
  
  You can set one of the C<$y> and C<$x> parameters as zero if you do not want either a vertical or horizontal split. The parameters C<$top_row> and C<$left_col> are optional. They are used to specify the top-most or left-most visible row or column in the bottom-right pane.
  
  Example:
  
      $worksheet->split_panes( 15, 0,   );    # First row
      $worksheet->split_panes( 0,  8.43 );    # First column
      $worksheet->split_panes( 15, 8.43 );    # First row and column
  
  You cannot use A1 notation with this method.
  
  See also the C<freeze_panes()> method and the C<panes.pl> program in the C<examples> directory of the distribution.
  
  
  
  
  =head2 merge_range( $first_row, $first_col, $last_row, $last_col, $token, $format )
  
  The C<merge_range()> method allows you to merge cells that contain other types of alignment in addition to the merging:
  
      my $format = $workbook->add_format(
          border => 6,
          valign => 'vcenter',
          align  => 'center',
      );
  
      $worksheet->merge_range( 'B3:D4', 'Vertical and horizontal', $format );
  
  C<merge_range()> writes its C<$token> argument using the worksheet C<write()> method. Therefore it will handle numbers, strings, formulas or urls as required. If you need to specify the required C<write_*()> method use the C<merge_range_type()> method, see below.
  
  The full possibilities of this method are shown in the C<merge3.pl> to C<merge6.pl> programs in the C<examples> directory of the distribution.
  
  
  
  
  =head2 merge_range_type( $type, $first_row, $first_col, $last_row, $last_col, ... )
  
  The C<merge_range()> method, see above, uses C<write()> to insert the required data into to a merged range. However, there may be times where this isn't what you require so as an alternative the C<merge_range_type ()> method allows you to specify the type of data you wish to write. For example:
  
      $worksheet->merge_range_type( 'number',  'B2:C2', 123,    $format1 );
      $worksheet->merge_range_type( 'string',  'B4:C4', 'foo',  $format2 );
      $worksheet->merge_range_type( 'formula', 'B6:C6', '=1+2', $format3 );
  
  The C<$type> must be one of the following, which corresponds to a C<write_*()> method:
  
      'number'
      'string'
      'formula'
      'array_formula'
      'blank'
      'rich_string'
      'date_time'
      'url'
  
  Any arguments after the range should be whatever the appropriate method accepts:
  
      $worksheet->merge_range_type( 'rich_string', 'B8:C8',
                                    'This is ', $bold, 'bold', $format4 );
  
  Note, you must always pass a C<$format> object as an argument, even if it is a default format.
  
  
  
  
  =head2 set_zoom( $scale )
  
  Set the worksheet zoom factor in the range C<10 E<lt>= $scale E<lt>= 400>:
  
      $worksheet1->set_zoom( 50 );
      $worksheet2->set_zoom( 75 );
      $worksheet3->set_zoom( 300 );
      $worksheet4->set_zoom( 400 );
  
  The default zoom factor is 100. You cannot zoom to "Selection" because it is calculated by Excel at run-time.
  
  Note, C<set_zoom()> does not affect the scale of the printed page. For that you should use C<set_print_scale()>.
  
  
  
  
  =head2 right_to_left()
  
  The C<right_to_left()> method is used to change the default direction of the worksheet from left-to-right, with the A1 cell in the top left, to right-to-left, with the A1 cell in the top right.
  
      $worksheet->right_to_left();
  
  This is useful when creating Arabic, Hebrew or other near or far eastern worksheets that use right-to-left as the default direction.
  
  
  
  
  =head2 hide_zero()
  
  The C<hide_zero()> method is used to hide any zero values that appear in cells.
  
      $worksheet->hide_zero();
  
  In Excel this option is found under Tools->Options->View.
  
  
  
  
  =head2 set_tab_color()
  
  The C<set_tab_color()> method is used to change the colour of the worksheet tab. You can use one of the standard colour names provided by the Format object or a Html style C<#RRGGBB> colour. See L</WORKING WITH COLOURS>.
  
      $worksheet1->set_tab_color( 'red' );
      $worksheet2->set_tab_color( '#FF6600' );
  
  See the C<tab_colors.pl> program in the examples directory of the distro.
  
  
  
  
  =head2 autofilter( $first_row, $first_col, $last_row, $last_col )
  
  This method allows an autofilter to be added to a worksheet. An autofilter is a way of adding drop down lists to the headers of a 2D range of worksheet data. This allows users to filter the data based on simple criteria so that some data is shown and some is hidden.
  
  To add an autofilter to a worksheet:
  
      $worksheet->autofilter( 0, 0, 10, 3 );
      $worksheet->autofilter( 'A1:D11' );    # Same as above in A1 notation.
  
  Filter conditions can be applied using the C<filter_column()> or C<filter_column_list()> method.
  
  See the C<autofilter.pl> program in the examples directory of the distro for a more detailed example.
  
  
  
  
  =head2 filter_column( $column, $expression )
  
  The C<filter_column> method can be used to filter columns in a autofilter range based on simple conditions.
  
  B<NOTE:> It isn't sufficient to just specify the filter condition. You must also hide any rows that don't match the filter condition. Rows are hidden using the C<set_row()> C<visible> parameter. C<Excel::Writer::XLSX> cannot do this automatically since it isn't part of the file format. See the C<autofilter.pl> program in the examples directory of the distro for an example.
  
  The conditions for the filter are specified using simple expressions:
  
      $worksheet->filter_column( 'A', 'x > 2000' );
      $worksheet->filter_column( 'B', 'x > 2000 and x < 5000' );
  
  The C<$column> parameter can either be a zero indexed column number or a string column name.
  
  The following operators are available:
  
      Operator        Synonyms
         ==           =   eq  =~
         !=           <>  ne  !=
         >
         <
         >=
         <=
  
         and          &&
         or           ||
  
  The operator synonyms are just syntactic sugar to make you more comfortable using the expressions. It is important to remember that the expressions will be interpreted by Excel and not by perl.
  
  An expression can comprise a single statement or two statements separated by the C<and> and C<or> operators. For example:
  
      'x <  2000'
      'x >  2000'
      'x == 2000'
      'x >  2000 and x <  5000'
      'x == 2000 or  x == 5000'
  
  Filtering of blank or non-blank data can be achieved by using a value of C<Blanks> or C<NonBlanks> in the expression:
  
      'x == Blanks'
      'x == NonBlanks'
  
  Excel also allows some simple string matching operations:
  
      'x =~ b*'   # begins with b
      'x !~ b*'   # doesn't begin with b
      'x =~ *b'   # ends with b
      'x !~ *b'   # doesn't end with b
      'x =~ *b*'  # contains b
      'x !~ *b*'  # doesn't contains b
  
  You can also use C<*> to match any character or number and C<?> to match any single character or number. No other regular expression quantifier is supported by Excel's filters. Excel's regular expression characters can be escaped using C<~>.
  
  The placeholder variable C<x> in the above examples can be replaced by any simple string. The actual placeholder name is ignored internally so the following are all equivalent:
  
      'x     < 2000'
      'col   < 2000'
      'Price < 2000'
  
  Also, note that a filter condition can only be applied to a column in a range specified by the C<autofilter()> Worksheet method.
  
  See the C<autofilter.pl> program in the examples directory of the distro for a more detailed example.
  
  B<Note> L<Spreadsheet::WriteExcel> supports Top 10 style filters. These aren't currently supported by Excel::Writer::XLSX but may be added later.
  
  
  =head2 filter_column_list( $column, @matches )
  
  Prior to Excel 2007 it was only possible to have either 1 or 2 filter conditions such as the ones shown above in the C<filter_column> method.
  
  Excel 2007 introduced a new list style filter where it is possible to specify 1 or more 'or' style criteria. For example if your column contained data for the first six months the initial data would be displayed as all selected as shown on the left. Then if you selected 'March', 'April' and 'May' they would be displayed as shown on the right.
  
      No criteria selected      Some criteria selected.
  
      [/] (Select all)          [X] (Select all)
      [/] January               [ ] January
      [/] February              [ ] February
      [/] March                 [/] March
      [/] April                 [/] April
      [/] May                   [/] May
      [/] June                  [ ] June
  
  The C<filter_column_list()> method can be used to represent these types of filters:
  
      $worksheet->filter_column_list( 'A', 'March', 'April', 'May' );
  
  The C<$column> parameter can either be a zero indexed column number or a string column name.
  
  One or more criteria can be selected:
  
      $worksheet->filter_column_list( 0, 'March' );
      $worksheet->filter_column_list( 1, 100, 110, 120, 130 );
  
  B<NOTE:> It isn't sufficient to just specify the filter condition. You must also hide any rows that don't match the filter condition. Rows are hidden using the C<set_row()> C<visible> parameter. C<Excel::Writer::XLSX> cannot do this automatically since it isn't part of the file format. See the C<autofilter.pl> program in the examples directory of the distro for an example.
  
  
  
  
  =head2 convert_date_time( $date_string )
  
  The C<convert_date_time()> method is used internally by the C<write_date_time()> method to convert date strings to a number that represents an Excel date and time.
  
  It is exposed as a public method for utility purposes.
  
  The C<$date_string> format is detailed in the C<write_date_time()> method.
  
  =head2 Worksheet set_vba_name()
  
  The Worksheet C<set_vba_name()> method can be used to set the VBA codename for the
  worksheet (there is a similar method for the workbook VBA name). This is sometimes required when a C<vbaProject> macro included via C<add_vba_project()> refers to the worksheet. The default Excel VBA name of C<Sheet1>, etc., is used if a user defined name isn't specified.
  
  See also L<WORKING WITH VBA MACROS>.
  
  
  
  =head1 PAGE SET-UP METHODS
  
  Page set-up methods affect the way that a worksheet looks when it is printed. They control features such as page headers and footers and margins. These methods are really just standard worksheet methods. They are documented here in a separate section for the sake of clarity.
  
  The following methods are available for page set-up:
  
      set_landscape()
      set_portrait()
      set_page_view()
      set_paper()
      center_horizontally()
      center_vertically()
      set_margins()
      set_header()
      set_footer()
      repeat_rows()
      repeat_columns()
      hide_gridlines()
      print_row_col_headers()
      print_area()
      print_across()
      fit_to_pages()
      set_start_page()
      set_print_scale()
      print_black_and_white()
      set_h_pagebreaks()
      set_v_pagebreaks()
  
  A common requirement when working with Excel::Writer::XLSX is to apply the same page set-up features to all of the worksheets in a workbook. To do this you can use the C<sheets()> method of the C<workbook> class to access the array of worksheets in a workbook:
  
      for $worksheet ( $workbook->sheets() ) {
          $worksheet->set_landscape();
      }
  
  
  
  
  =head2 set_landscape()
  
  This method is used to set the orientation of a worksheet's printed page to landscape:
  
      $worksheet->set_landscape();    # Landscape mode
  
  
  
  
  =head2 set_portrait()
  
  This method is used to set the orientation of a worksheet's printed page to portrait. The default worksheet orientation is portrait, so you won't generally need to call this method.
  
      $worksheet->set_portrait();    # Portrait mode
  
  
  
  =head2 set_page_view()
  
  This method is used to display the worksheet in "Page View/Layout" mode.
  
      $worksheet->set_page_view();
  
  
  
  =head2 set_paper( $index )
  
  This method is used to set the paper format for the printed output of a worksheet. The following paper styles are available:
  
      Index   Paper format            Paper size
      =====   ============            ==========
        0     Printer default         -
        1     Letter                  8 1/2 x 11 in
        2     Letter Small            8 1/2 x 11 in
        3     Tabloid                 11 x 17 in
        4     Ledger                  17 x 11 in
        5     Legal                   8 1/2 x 14 in
        6     Statement               5 1/2 x 8 1/2 in
        7     Executive               7 1/4 x 10 1/2 in
        8     A3                      297 x 420 mm
        9     A4                      210 x 297 mm
       10     A4 Small                210 x 297 mm
       11     A5                      148 x 210 mm
       12     B4                      250 x 354 mm
       13     B5                      182 x 257 mm
       14     Folio                   8 1/2 x 13 in
       15     Quarto                  215 x 275 mm
       16     -                       10x14 in
       17     -                       11x17 in
       18     Note                    8 1/2 x 11 in
       19     Envelope  9             3 7/8 x 8 7/8
       20     Envelope 10             4 1/8 x 9 1/2
       21     Envelope 11             4 1/2 x 10 3/8
       22     Envelope 12             4 3/4 x 11
       23     Envelope 14             5 x 11 1/2
       24     C size sheet            -
       25     D size sheet            -
       26     E size sheet            -
       27     Envelope DL             110 x 220 mm
       28     Envelope C3             324 x 458 mm
       29     Envelope C4             229 x 324 mm
       30     Envelope C5             162 x 229 mm
       31     Envelope C6             114 x 162 mm
       32     Envelope C65            114 x 229 mm
       33     Envelope B4             250 x 353 mm
       34     Envelope B5             176 x 250 mm
       35     Envelope B6             176 x 125 mm
       36     Envelope                110 x 230 mm
       37     Monarch                 3.875 x 7.5 in
       38     Envelope                3 5/8 x 6 1/2 in
       39     Fanfold                 14 7/8 x 11 in
       40     German Std Fanfold      8 1/2 x 12 in
       41     German Legal Fanfold    8 1/2 x 13 in
  
  
  Note, it is likely that not all of these paper types will be available to the end user since it will depend on the paper formats that the user's printer supports. Therefore, it is best to stick to standard paper types.
  
      $worksheet->set_paper( 1 );    # US Letter
      $worksheet->set_paper( 9 );    # A4
  
  If you do not specify a paper type the worksheet will print using the printer's default paper.
  
  
  
  
  =head2 center_horizontally()
  
  Center the worksheet data horizontally between the margins on the printed page:
  
      $worksheet->center_horizontally();
  
  
  
  
  =head2 center_vertically()
  
  Center the worksheet data vertically between the margins on the printed page:
  
      $worksheet->center_vertically();
  
  
  
  
  =head2 set_margins( $inches )
  
  There are several methods available for setting the worksheet margins on the printed page:
  
      set_margins()        # Set all margins to the same value
      set_margins_LR()     # Set left and right margins to the same value
      set_margins_TB()     # Set top and bottom margins to the same value
      set_margin_left();   # Set left margin
      set_margin_right();  # Set right margin
      set_margin_top();    # Set top margin
      set_margin_bottom(); # Set bottom margin
  
  All of these methods take a distance in inches as a parameter. Note: 1 inch = 25.4mm. C<;-)> The default left and right margin is 0.7 inch. The default top and bottom margin is 0.75 inch. Note, these defaults are different from the defaults used in the binary file format by Spreadsheet::WriteExcel.
  
  
  
  =head2 set_header( $string, $margin )
  
  Headers and footers are generated using a C<$string> which is a combination of plain text and control characters. The C<$margin> parameter is optional.
  
  The available control character are:
  
      Control             Category            Description
      =======             ========            ===========
      &L                  Justification       Left
      &C                                      Center
      &R                                      Right
  
      &P                  Information         Page number
      &N                                      Total number of pages
      &D                                      Date
      &T                                      Time
      &F                                      File name
      &A                                      Worksheet name
      &Z                                      Workbook path
  
      &fontsize           Font                Font size
      &"font,style"                           Font name and style
      &U                                      Single underline
      &E                                      Double underline
      &S                                      Strikethrough
      &X                                      Superscript
      &Y                                      Subscript
  
      &[Picture]          Images              Image placeholder
      &G                                      Same as &[Picture]
  
      &&                  Miscellaneous       Literal ampersand &
  
  
  Text in headers and footers can be justified (aligned) to the left, center and right by prefixing the text with the control characters C<&L>, C<&C> and C<&R>.
  
  For example (with ASCII art representation of the results):
  
      $worksheet->set_header('&LHello');
  
       ---------------------------------------------------------------
      |                                                               |
      | Hello                                                         |
      |                                                               |
  
  
      $worksheet->set_header('&CHello');
  
       ---------------------------------------------------------------
      |                                                               |
      |                          Hello                                |
      |                                                               |
  
  
      $worksheet->set_header('&RHello');
  
       ---------------------------------------------------------------
      |                                                               |
      |                                                         Hello |
      |                                                               |
  
  
  For simple text, if you do not specify any justification the text will be centred. However, you must prefix the text with C<&C> if you specify a font name or any other formatting:
  
      $worksheet->set_header('Hello');
  
       ---------------------------------------------------------------
      |                                                               |
      |                          Hello                                |
      |                                                               |
  
  
  You can have text in each of the justification regions:
  
      $worksheet->set_header('&LCiao&CBello&RCielo');
  
       ---------------------------------------------------------------
      |                                                               |
      | Ciao                     Bello                          Cielo |
      |                                                               |
  
  
  The information control characters act as variables that Excel will update as the workbook or worksheet changes. Times and dates are in the users default format:
  
      $worksheet->set_header('&CPage &P of &N');
  
       ---------------------------------------------------------------
      |                                                               |
      |                        Page 1 of 6                            |
      |                                                               |
  
  
      $worksheet->set_header('&CUpdated at &T');
  
       ---------------------------------------------------------------
      |                                                               |
      |                    Updated at 12:30 PM                        |
      |                                                               |
  
  
  Images can be inserted using the options shown below. Each image must have a placeholder in header string using the C<&[Picture]> or C<&G> control characters:
  
      $worksheet->set_header( '&L&G', 0.3, { image_left => 'logo.jpg' });
  
  
  
  You can specify the font size of a section of the text by prefixing it with the control character C<&n> where C<n> is the font size:
  
      $worksheet1->set_header( '&C&30Hello Big' );
      $worksheet2->set_header( '&C&10Hello Small' );
  
  You can specify the font of a section of the text by prefixing it with the control sequence C<&"font,style"> where C<fontname> is a font name such as "Courier New" or "Times New Roman" and C<style> is one of the standard Windows font descriptions: "Regular", "Italic", "Bold" or "Bold Italic":
  
      $worksheet1->set_header( '&C&"Courier New,Italic"Hello' );
      $worksheet2->set_header( '&C&"Courier New,Bold Italic"Hello' );
      $worksheet3->set_header( '&C&"Times New Roman,Regular"Hello' );
  
  It is possible to combine all of these features together to create sophisticated headers and footers. As an aid to setting up complicated headers and footers you can record a page set-up as a macro in Excel and look at the format strings that VBA produces. Remember however that VBA uses two double quotes C<""> to indicate a single double quote. For the last example above the equivalent VBA code looks like this:
  
      .LeftHeader   = ""
      .CenterHeader = "&""Times New Roman,Regular""Hello"
      .RightHeader  = ""
  
  
  To include a single literal ampersand C<&> in a header or footer you should use a double ampersand C<&&>:
  
      $worksheet1->set_header('&CCuriouser && Curiouser - Attorneys at Law');
  
  As stated above the margin parameter is optional. As with the other margins the value should be in inches. The default header and footer margin is 0.3 inch. Note, the default margin is different from the default used in the binary file format by Spreadsheet::WriteExcel. The header and footer margin size can be set as follows:
  
      $worksheet->set_header( '&CHello', 0.75 );
  
  The header and footer margins are independent of the top and bottom margins.
  
  The available options are:
  
  =over
  
  =item * C<image_left> The path to the image. Requires a C<&G> or C<&[Picture]> placeholder.
  
  =item * C<image_center> Same as above.
  
  =item * C<image_right> Same as above.
  
  =item * C<scale_with_doc> Scale header with document. Defaults to true.
  
  =item * C<align_with_margins> Align header to margins. Defaults to true.
  
  =back
  
  The image options must have an accompanying C<&[Picture]> or C<&G> control
  character in the header string:
  
      $worksheet->set_header(
          '&L&[Picture]&C&[Picture]&R&[Picture]',
          undef, # If you don't want to change the margin.
          {
              image_left   => 'red.jpg',
              image_center => 'blue.jpg',
              image_right  => 'yellow.jpg'
          }
        );
  
  
  Note, the header or footer string must be less than 255 characters. Strings longer than this will not be written and a warning will be generated.
  
  The C<set_header()> method can also handle Unicode strings in C<UTF-8> format.
  
      $worksheet->set_header( "&C\x{263a}" )
  
  
  See, also the C<headers.pl> program in the C<examples> directory of the distribution.
  
  
  
  
  =head2 set_footer( $string, $margin )
  
  The syntax of the C<set_footer()> method is the same as C<set_header()>,  see above.
  
  
  
  
  =head2 repeat_rows( $first_row, $last_row )
  
  Set the number of rows to repeat at the top of each printed page.
  
  For large Excel documents it is often desirable to have the first row or rows of the worksheet print out at the top of each page. This can be achieved by using the C<repeat_rows()> method. The parameters C<$first_row> and C<$last_row> are zero based. The C<$last_row> parameter is optional if you only wish to specify one row:
  
      $worksheet1->repeat_rows( 0 );    # Repeat the first row
      $worksheet2->repeat_rows( 0, 1 ); # Repeat the first two rows
  
  
  
  
  =head2 repeat_columns( $first_col, $last_col )
  
  Set the columns to repeat at the left hand side of each printed page.
  
  For large Excel documents it is often desirable to have the first column or columns of the worksheet print out at the left hand side of each page. This can be achieved by using the C<repeat_columns()> method. The parameters C<$first_column> and C<$last_column> are zero based. The C<$last_column> parameter is optional if you only wish to specify one column. You can also specify the columns using A1 column notation, see the note about L</Cell notation>.
  
      $worksheet1->repeat_columns( 0 );        # Repeat the first column
      $worksheet2->repeat_columns( 0, 1 );     # Repeat the first two columns
      $worksheet3->repeat_columns( 'A:A' );    # Repeat the first column
      $worksheet4->repeat_columns( 'A:B' );    # Repeat the first two columns
  
  
  
  
  =head2 hide_gridlines( $option )
  
  This method is used to hide the gridlines on the screen and printed page. Gridlines are the lines that divide the cells on a worksheet. Screen and printed gridlines are turned on by default in an Excel worksheet. If you have defined your own cell borders you may wish to hide the default gridlines.
  
      $worksheet->hide_gridlines();
  
  The following values of C<$option> are valid:
  
      0 : Don't hide gridlines
      1 : Hide printed gridlines only
      2 : Hide screen and printed gridlines
  
  If you don't supply an argument or use C<undef> the default option is 1, i.e. only the printed gridlines are hidden.
  
  
  
  
  =head2 print_row_col_headers()
  
  Set the option to print the row and column headers on the printed page.
  
  An Excel worksheet looks something like the following;
  
       ------------------------------------------
      |   |   A   |   B   |   C   |   D   |  ...
       ------------------------------------------
      | 1 |       |       |       |       |  ...
      | 2 |       |       |       |       |  ...
      | 3 |       |       |       |       |  ...
      | 4 |       |       |       |       |  ...
      |...|  ...  |  ...  |  ...  |  ...  |  ...
  
  The headers are the letters and numbers at the top and the left of the worksheet. Since these headers serve mainly as a indication of position on the worksheet they generally do not appear on the printed page. If you wish to have them printed you can use the C<print_row_col_headers()> method :
  
      $worksheet->print_row_col_headers();
  
  Do not confuse these headers with page headers as described in the C<set_header()> section above.
  
  
  
  
  =head2 print_area( $first_row, $first_col, $last_row, $last_col )
  
  This method is used to specify the area of the worksheet that will be printed. All four parameters must be specified. You can also use A1 notation, see the note about L</Cell notation>.
  
  
      $worksheet1->print_area( 'A1:H20' );    # Cells A1 to H20
      $worksheet2->print_area( 0, 0, 19, 7 ); # The same
      $worksheet2->print_area( 'A:H' );       # Columns A to H if rows have data
  
  
  
  
  =head2 print_across()
  
  The C<print_across> method is used to change the default print direction. This is referred to by Excel as the sheet "page order".
  
      $worksheet->print_across();
  
  The default page order is shown below for a worksheet that extends over 4 pages. The order is called "down then across":
  
      [1] [3]
      [2] [4]
  
  However, by using the C<print_across> method the print order will be changed to "across then down":
  
      [1] [2]
      [3] [4]
  
  
  
  
  =head2 fit_to_pages( $width, $height )
  
  The C<fit_to_pages()> method is used to fit the printed area to a specific number of pages both vertically and horizontally. If the printed area exceeds the specified number of pages it will be scaled down to fit. This guarantees that the printed area will always appear on the specified number of pages even if the page size or margins change.
  
      $worksheet1->fit_to_pages( 1, 1 );    # Fit to 1x1 pages
      $worksheet2->fit_to_pages( 2, 1 );    # Fit to 2x1 pages
      $worksheet3->fit_to_pages( 1, 2 );    # Fit to 1x2 pages
  
  The print area can be defined using the C<print_area()> method as described above.
  
  A common requirement is to fit the printed output to I<n> pages wide but have the height be as long as necessary. To achieve this set the C<$height> to zero:
  
      $worksheet1->fit_to_pages( 1, 0 );    # 1 page wide and as long as necessary
  
  Note that although it is valid to use both C<fit_to_pages()> and C<set_print_scale()> on the same worksheet only one of these options can be active at a time. The last method call made will set the active option.
  
  Note that C<fit_to_pages()> will override any manual page breaks that are defined in the worksheet.
  
  Note: When using C<fit_to_pages()> it may also be required to set the printer paper size using C<set_paper()> or else Excel will default to "US Letter".
  
  
  =head2 set_start_page( $start_page )
  
  The C<set_start_page()> method is used to set the number of the starting page when the worksheet is printed out. The default value is 1.
  
      $worksheet->set_start_page( 2 );
  
  
  
  
  =head2 set_print_scale( $scale )
  
  Set the scale factor of the printed page. Scale factors in the range C<10 E<lt>= $scale E<lt>= 400> are valid:
  
      $worksheet1->set_print_scale( 50 );
      $worksheet2->set_print_scale( 75 );
      $worksheet3->set_print_scale( 300 );
      $worksheet4->set_print_scale( 400 );
  
  The default scale factor is 100. Note, C<set_print_scale()> does not affect the scale of the visible page in Excel. For that you should use C<set_zoom()>.
  
  Note also that although it is valid to use both C<fit_to_pages()> and C<set_print_scale()> on the same worksheet only one of these options can be active at a time. The last method call made will set the active option.
  
  
  
  
  =head2 print_black_and_white()
  
  Set the option to print the worksheet in black and white:
  
      $worksheet->print_black_and_white();
  
  
  
  
  =head2 set_h_pagebreaks( @breaks )
  
  Add horizontal page breaks to a worksheet. A page break causes all the data that follows it to be printed on the next page. Horizontal page breaks act between rows. To create a page break between rows 20 and 21 you must specify the break at row 21. However in zero index notation this is actually row 20. So you can pretend for a small while that you are using 1 index notation:
  
      $worksheet1->set_h_pagebreaks( 20 );    # Break between row 20 and 21
  
  The C<set_h_pagebreaks()> method will accept a list of page breaks and you can call it more than once:
  
      $worksheet2->set_h_pagebreaks( 20,  40,  60,  80,  100 );    # Add breaks
      $worksheet2->set_h_pagebreaks( 120, 140, 160, 180, 200 );    # Add some more
  
  Note: If you specify the "fit to page" option via the C<fit_to_pages()> method it will override all manual page breaks.
  
  There is a silent limitation of about 1000 horizontal page breaks per worksheet in line with an Excel internal limitation.
  
  
  
  
  =head2 set_v_pagebreaks( @breaks )
  
  Add vertical page breaks to a worksheet. A page break causes all the data that follows it to be printed on the next page. Vertical page breaks act between columns. To create a page break between columns 20 and 21 you must specify the break at column 21. However in zero index notation this is actually column 20. So you can pretend for a small while that you are using 1 index notation:
  
      $worksheet1->set_v_pagebreaks(20); # Break between column 20 and 21
  
  The C<set_v_pagebreaks()> method will accept a list of page breaks and you can call it more than once:
  
      $worksheet2->set_v_pagebreaks( 20,  40,  60,  80,  100 );    # Add breaks
      $worksheet2->set_v_pagebreaks( 120, 140, 160, 180, 200 );    # Add some more
  
  Note: If you specify the "fit to page" option via the C<fit_to_pages()> method it will override all manual page breaks.
  
  
  
  
  =head1 CELL FORMATTING
  
  This section describes the methods and properties that are available for formatting cells in Excel. The properties of a cell that can be formatted include: fonts, colours, patterns, borders, alignment and number formatting.
  
  
  =head2 Creating and using a Format object
  
  Cell formatting is defined through a Format object. Format objects are created by calling the workbook C<add_format()> method as follows:
  
      my $format1 = $workbook->add_format();            # Set properties later
      my $format2 = $workbook->add_format( %props );    # Set at creation
  
  The format object holds all the formatting properties that can be applied to a cell, a row or a column. The process of setting these properties is discussed in the next section.
  
  Once a Format object has been constructed and its properties have been set it can be passed as an argument to the worksheet C<write> methods as follows:
  
      $worksheet->write( 0, 0, 'One', $format );
      $worksheet->write_string( 1, 0, 'Two', $format );
      $worksheet->write_number( 2, 0, 3, $format );
      $worksheet->write_blank( 3, 0, $format );
  
  Formats can also be passed to the worksheet C<set_row()> and C<set_column()> methods to define the default property for a row or column.
  
      $worksheet->set_row( 0, 15, $format );
      $worksheet->set_column( 0, 0, 15, $format );
  
  
  
  
  =head2 Format methods and Format properties
  
  The following table shows the Excel format categories, the formatting properties that can be applied and the equivalent object method:
  
  
      Category   Description       Property        Method Name
      --------   -----------       --------        -----------
      Font       Font type         font            set_font()
                 Font size         size            set_size()
                 Font color        color           set_color()
                 Bold              bold            set_bold()
                 Italic            italic          set_italic()
                 Underline         underline       set_underline()
                 Strikeout         font_strikeout  set_font_strikeout()
                 Super/Subscript   font_script     set_font_script()
                 Outline           font_outline    set_font_outline()
                 Shadow            font_shadow     set_font_shadow()
  
      Number     Numeric format    num_format      set_num_format()
  
      Protection Lock cells        locked          set_locked()
                 Hide formulas     hidden          set_hidden()
  
      Alignment  Horizontal align  align           set_align()
                 Vertical align    valign          set_align()
                 Rotation          rotation        set_rotation()
                 Text wrap         text_wrap       set_text_wrap()
                 Justify last      text_justlast   set_text_justlast()
                 Center across     center_across   set_center_across()
                 Indentation       indent          set_indent()
                 Shrink to fit     shrink          set_shrink()
  
      Pattern    Cell pattern      pattern         set_pattern()
                 Background color  bg_color        set_bg_color()
                 Foreground color  fg_color        set_fg_color()
  
      Border     Cell border       border          set_border()
                 Bottom border     bottom          set_bottom()
                 Top border        top             set_top()
                 Left border       left            set_left()
                 Right border      right           set_right()
                 Border color      border_color    set_border_color()
                 Bottom color      bottom_color    set_bottom_color()
                 Top color         top_color       set_top_color()
                 Left color        left_color      set_left_color()
                 Right color       right_color     set_right_color()
                 Diagonal type     diag_type       set_diag_type()
                 Diagonal border   diag_border     set_diag_border()
                 Diagonal color    diag_color      set_diag_color()
  
  There are two ways of setting Format properties: by using the object method interface or by setting the property directly. For example, a typical use of the method interface would be as follows:
  
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color( 'red' );
  
  By comparison the properties can be set directly by passing a hash of properties to the Format constructor:
  
      my $format = $workbook->add_format( bold => 1, color => 'red' );
  
  or after the Format has been constructed by means of the C<set_format_properties()> method as follows:
  
      my $format = $workbook->add_format();
      $format->set_format_properties( bold => 1, color => 'red' );
  
  You can also store the properties in one or more named hashes and pass them to the required method:
  
      my %font = (
          font  => 'Calibri',
          size  => 12,
          color => 'blue',
          bold  => 1,
      );
  
      my %shading = (
          bg_color => 'green',
          pattern  => 1,
      );
  
  
      my $format1 = $workbook->add_format( %font );            # Font only
      my $format2 = $workbook->add_format( %font, %shading );  # Font and shading
  
  
  The provision of two ways of setting properties might lead you to wonder which is the best way. The method mechanism may be better if you prefer setting properties via method calls (which the author did when the code was first written) otherwise passing properties to the constructor has proved to be a little more flexible and self documenting in practice. An additional advantage of working with property hashes is that it allows you to share formatting between workbook objects as shown in the example above.
  
  The Perl/Tk style of adding properties is also supported:
  
      my %font = (
          -font  => 'Calibri',
          -size  => 12,
          -color => 'blue',
          -bold  => 1,
      );
  
  
  
  
  =head2 Working with formats
  
  The default format is Calibri 11 with all other properties off.
  
  Each unique format in Excel::Writer::XLSX must have a corresponding Format object. It isn't possible to use a Format with a write() method and then redefine the Format for use at a later stage. This is because a Format is applied to a cell not in its current state but in its final state. Consider the following example:
  
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color( 'red' );
      $worksheet->write( 'A1', 'Cell A1', $format );
      $format->set_color( 'green' );
      $worksheet->write( 'B1', 'Cell B1', $format );
  
  Cell A1 is assigned the Format C<$format> which is initially set to the colour red. However, the colour is subsequently set to green. When Excel displays Cell A1 it will display the final state of the Format which in this case will be the colour green.
  
  In general a method call without an argument will turn a property on, for example:
  
      my $format1 = $workbook->add_format();
      $format1->set_bold();       # Turns bold on
      $format1->set_bold( 1 );    # Also turns bold on
      $format1->set_bold( 0 );    # Turns bold off
  
  
  
  
  =head1 FORMAT METHODS
  
  The Format object methods are described in more detail in the following sections. In addition, there is a Perl program called C<formats.pl> in the C<examples> directory of the WriteExcel distribution. This program creates an Excel workbook called C<formats.xlsx> which contains examples of almost all the format types.
  
  The following Format methods are available:
  
      set_font()
      set_size()
      set_color()
      set_bold()
      set_italic()
      set_underline()
      set_font_strikeout()
      set_font_script()
      set_font_outline()
      set_font_shadow()
      set_num_format()
      set_locked()
      set_hidden()
      set_align()
      set_rotation()
      set_text_wrap()
      set_text_justlast()
      set_center_across()
      set_indent()
      set_shrink()
      set_pattern()
      set_bg_color()
      set_fg_color()
      set_border()
      set_bottom()
      set_top()
      set_left()
      set_right()
      set_border_color()
      set_bottom_color()
      set_top_color()
      set_left_color()
      set_right_color()
      set_diag_type()
      set_diag_border()
      set_diag_color()
  
  
  The above methods can also be applied directly as properties. For example C<< $format->set_bold() >> is equivalent to C<< $workbook->add_format(bold => 1) >>.
  
  
  =head2 set_format_properties( %properties )
  
  The properties of an existing Format object can be also be set by means of C<set_format_properties()>:
  
      my $format = $workbook->add_format();
      $format->set_format_properties( bold => 1, color => 'red' );
  
  However, this method is here mainly for legacy reasons. It is preferable to set the properties in the format constructor:
  
      my $format = $workbook->add_format( bold => 1, color => 'red' );
  
  
  =head2 set_font( $fontname )
  
      Default state:      Font is Calibri
      Default action:     None
      Valid args:         Any valid font name
  
  Specify the font used:
  
      $format->set_font('Times New Roman');
  
  Excel can only display fonts that are installed on the system that it is running on. Therefore it is best to use the fonts that come as standard such as 'Calibri', 'Times New Roman' and 'Courier New'. See also the Fonts worksheet created by formats.pl
  
  
  
  
  =head2 set_size()
  
      Default state:      Font size is 10
      Default action:     Set font size to 1
      Valid args:         Integer values from 1 to as big as your screen.
  
  
  Set the font size. Excel adjusts the height of a row to accommodate the largest font size in the row. You can also explicitly specify the height of a row using the set_row() worksheet method.
  
      my $format = $workbook->add_format();
      $format->set_size( 30 );
  
  
  
  
  
  =head2 set_color()
  
      Default state:      Excels default color, usually black
      Default action:     Set the default color
      Valid args:         Integers from 8..63 or the following strings:
                          'black'
                          'blue'
                          'brown'
                          'cyan'
                          'gray'
                          'green'
                          'lime'
                          'magenta'
                          'navy'
                          'orange'
                          'pink'
                          'purple'
                          'red'
                          'silver'
                          'white'
                          'yellow'
  
  Set the font colour. The C<set_color()> method is used as follows:
  
      my $format = $workbook->add_format();
      $format->set_color( 'red' );
      $worksheet->write( 0, 0, 'wheelbarrow', $format );
  
  Note: The C<set_color()> method is used to set the colour of the font in a cell. To set the colour of a cell use the C<set_bg_color()> and C<set_pattern()> methods.
  
  For additional examples see the 'Named colors' and 'Standard colors' worksheets created by formats.pl in the examples directory.
  
  See also L</WORKING WITH COLOURS>.
  
  
  
  
  =head2 set_bold()
  
      Default state:      bold is off
      Default action:     Turn bold on
      Valid args:         0, 1
  
  Set the bold property of the font:
  
      $format->set_bold();  # Turn bold on
  
  
  
  
  =head2 set_italic()
  
      Default state:      Italic is off
      Default action:     Turn italic on
      Valid args:         0, 1
  
  Set the italic property of the font:
  
      $format->set_italic();  # Turn italic on
  
  
  
  
  =head2 set_underline()
  
      Default state:      Underline is off
      Default action:     Turn on single underline
      Valid args:         0  = No underline
                          1  = Single underline
                          2  = Double underline
                          33 = Single accounting underline
                          34 = Double accounting underline
  
  Set the underline property of the font.
  
      $format->set_underline();   # Single underline
  
  
  
  
  =head2 set_font_strikeout()
  
      Default state:      Strikeout is off
      Default action:     Turn strikeout on
      Valid args:         0, 1
  
  Set the strikeout property of the font.
  
  
  
  
  =head2 set_font_script()
  
      Default state:      Super/Subscript is off
      Default action:     Turn Superscript on
      Valid args:         0  = Normal
                          1  = Superscript
                          2  = Subscript
  
  Set the superscript/subscript property of the font.
  
  
  
  
  =head2 set_font_outline()
  
      Default state:      Outline is off
      Default action:     Turn outline on
      Valid args:         0, 1
  
  Macintosh only.
  
  
  
  
  =head2 set_font_shadow()
  
      Default state:      Shadow is off
      Default action:     Turn shadow on
      Valid args:         0, 1
  
  Macintosh only.
  
  
  
  
  =head2 set_num_format()
  
      Default state:      General format
      Default action:     Format index 1
      Valid args:         See the following table
  
  This method is used to define the numerical format of a number in Excel. It controls whether a number is displayed as an integer, a floating point number, a date, a currency value or some other user defined format.
  
  The numerical format of a cell can be specified by using a format string or an index to one of Excel's built-in formats:
  
      my $format1 = $workbook->add_format();
      my $format2 = $workbook->add_format();
      $format1->set_num_format( 'd mmm yyyy' );    # Format string
      $format2->set_num_format( 0x0f );            # Format index
  
      $worksheet->write( 0, 0, 36892.521, $format1 );    # 1 Jan 2001
      $worksheet->write( 0, 0, 36892.521, $format2 );    # 1-Jan-01
  
  
  Using format strings you can define very sophisticated formatting of numbers.
  
      $format01->set_num_format( '0.000' );
      $worksheet->write( 0, 0, 3.1415926, $format01 );    # 3.142
  
      $format02->set_num_format( '#,##0' );
      $worksheet->write( 1, 0, 1234.56, $format02 );      # 1,235
  
      $format03->set_num_format( '#,##0.00' );
      $worksheet->write( 2, 0, 1234.56, $format03 );      # 1,234.56
  
      $format04->set_num_format( '$0.00' );
      $worksheet->write( 3, 0, 49.99, $format04 );        # $49.99
  
      # Note you can use other currency symbols such as the pound or yen as well.
      # Other currencies may require the use of Unicode.
  
      $format07->set_num_format( 'mm/dd/yy' );
      $worksheet->write( 6, 0, 36892.521, $format07 );    # 01/01/01
  
      $format08->set_num_format( 'mmm d yyyy' );
      $worksheet->write( 7, 0, 36892.521, $format08 );    # Jan 1 2001
  
      $format09->set_num_format( 'd mmmm yyyy' );
      $worksheet->write( 8, 0, 36892.521, $format09 );    # 1 January 2001
  
      $format10->set_num_format( 'dd/mm/yyyy hh:mm AM/PM' );
      $worksheet->write( 9, 0, 36892.521, $format10 );    # 01/01/2001 12:30 AM
  
      $format11->set_num_format( '0 "dollar and" .00 "cents"' );
      $worksheet->write( 10, 0, 1.87, $format11 );        # 1 dollar and .87 cents
  
      # Conditional numerical formatting.
      $format12->set_num_format( '[Green]General;[Red]-General;General' );
      $worksheet->write( 11, 0, 123, $format12 );         # > 0 Green
      $worksheet->write( 12, 0, -45, $format12 );         # < 0 Red
      $worksheet->write( 13, 0, 0,   $format12 );         # = 0 Default colour
  
      # Zip code
      $format13->set_num_format( '00000' );
      $worksheet->write( 14, 0, '01209', $format13 );
  
  
  The number system used for dates is described in L</DATES AND TIME IN EXCEL>.
  
  The colour format should have one of the following values:
  
      [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]
  
  Alternatively you can specify the colour based on a colour index as follows: C<[Color n]>, where n is a standard Excel colour index - 7. See the 'Standard colors' worksheet created by formats.pl.
  
  For more information refer to the documentation on formatting in the C<docs> directory of the Excel::Writer::XLSX distro, the Excel on-line help or L<http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx>.
  
  You should ensure that the format string is valid in Excel prior to using it in WriteExcel.
  
  Excel's built-in formats are shown in the following table:
  
      Index   Index   Format String
      0       0x00    General
      1       0x01    0
      2       0x02    0.00
      3       0x03    #,##0
      4       0x04    #,##0.00
      5       0x05    ($#,##0_);($#,##0)
      6       0x06    ($#,##0_);[Red]($#,##0)
      7       0x07    ($#,##0.00_);($#,##0.00)
      8       0x08    ($#,##0.00_);[Red]($#,##0.00)
      9       0x09    0%
      10      0x0a    0.00%
      11      0x0b    0.00E+00
      12      0x0c    # ?/?
      13      0x0d    # ??/??
      14      0x0e    m/d/yy
      15      0x0f    d-mmm-yy
      16      0x10    d-mmm
      17      0x11    mmm-yy
      18      0x12    h:mm AM/PM
      19      0x13    h:mm:ss AM/PM
      20      0x14    h:mm
      21      0x15    h:mm:ss
      22      0x16    m/d/yy h:mm
      ..      ....    ...........
      37      0x25    (#,##0_);(#,##0)
      38      0x26    (#,##0_);[Red](#,##0)
      39      0x27    (#,##0.00_);(#,##0.00)
      40      0x28    (#,##0.00_);[Red](#,##0.00)
      41      0x29    _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
      42      0x2a    _($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)
      43      0x2b    _(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)
      44      0x2c    _($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)
      45      0x2d    mm:ss
      46      0x2e    [h]:mm:ss
      47      0x2f    mm:ss.0
      48      0x30    ##0.0E+0
      49      0x31    @
  
  
  For examples of these formatting codes see the 'Numerical formats' worksheet created by formats.pl. See also the number_formats1.html and the number_formats2.html documents in the C<docs> directory of the distro.
  
  Note 1. Numeric formats 23 to 36 are not documented by Microsoft and may differ in international versions.
  
  Note 2. The dollar sign appears as the defined local currency symbol.
  
  
  
  
  =head2 set_locked()
  
      Default state:      Cell locking is on
      Default action:     Turn locking on
      Valid args:         0, 1
  
  This property can be used to prevent modification of a cells contents. Following Excel's convention, cell locking is turned on by default. However, it only has an effect if the worksheet has been protected, see the worksheet C<protect()> method.
  
      my $locked = $workbook->add_format();
      $locked->set_locked( 1 );    # A non-op
  
      my $unlocked = $workbook->add_format();
      $locked->set_locked( 0 );
  
      # Enable worksheet protection
      $worksheet->protect();
  
      # This cell cannot be edited.
      $worksheet->write( 'A1', '=1+2', $locked );
  
      # This cell can be edited.
      $worksheet->write( 'A2', '=1+2', $unlocked );
  
  Note: This offers weak protection even with a password, see the note in relation to the C<protect()> method.
  
  
  
  
  =head2 set_hidden()
  
      Default state:      Formula hiding is off
      Default action:     Turn hiding on
      Valid args:         0, 1
  
  This property is used to hide a formula while still displaying its result. This is generally used to hide complex calculations from end users who are only interested in the result. It only has an effect if the worksheet has been protected, see the worksheet C<protect()> method.
  
      my $hidden = $workbook->add_format();
      $hidden->set_hidden();
  
      # Enable worksheet protection
      $worksheet->protect();
  
      # The formula in this cell isn't visible
      $worksheet->write( 'A1', '=1+2', $hidden );
  
  
  Note: This offers weak protection even with a password, see the note in relation to the C<protect()> method.
  
  
  
  
  =head2 set_align()
  
      Default state:      Alignment is off
      Default action:     Left alignment
      Valid args:         'left'              Horizontal
                          'center'
                          'right'
                          'fill'
                          'justify'
                          'center_across'
  
                          'top'               Vertical
                          'vcenter'
                          'bottom'
                          'vjustify'
  
  This method is used to set the horizontal and vertical text alignment within a cell. Vertical and horizontal alignments can be combined. The method is used as follows:
  
      my $format = $workbook->add_format();
      $format->set_align( 'center' );
      $format->set_align( 'vcenter' );
      $worksheet->set_row( 0, 30 );
      $worksheet->write( 0, 0, 'X', $format );
  
  Text can be aligned across two or more adjacent cells using the C<center_across> property. However, for genuine merged cells it is better to use the C<merge_range()> worksheet method.
  
  The C<vjustify> (vertical justify) option can be used to provide automatic text wrapping in a cell. The height of the cell will be adjusted to accommodate the wrapped text. To specify where the text wraps use the C<set_text_wrap()> method.
  
  
  For further examples see the 'Alignment' worksheet created by formats.pl.
  
  
  
  
  =head2 set_center_across()
  
      Default state:      Center across selection is off
      Default action:     Turn center across on
      Valid args:         1
  
  Text can be aligned across two or more adjacent cells using the C<set_center_across()> method. This is an alias for the C<set_align('center_across')> method call.
  
  Only one cell should contain the text, the other cells should be blank:
  
      my $format = $workbook->add_format();
      $format->set_center_across();
  
      $worksheet->write( 1, 1, 'Center across selection', $format );
      $worksheet->write_blank( 1, 2, $format );
  
  See also the C<merge1.pl> to C<merge6.pl> programs in the C<examples> directory and the C<merge_range()> method.
  
  
  
  =head2 set_text_wrap()
  
      Default state:      Text wrap is off
      Default action:     Turn text wrap on
      Valid args:         0, 1
  
  
  Here is an example using the text wrap property, the escape character C<\n> is used to indicate the end of line:
  
      my $format = $workbook->add_format();
      $format->set_text_wrap();
      $worksheet->write( 0, 0, "It's\na bum\nwrap", $format );
  
  Excel will adjust the height of the row to accommodate the wrapped text. A similar effect can be obtained without newlines using the C<set_align('vjustify')> method. See the C<textwrap.pl> program in the C<examples> directory.
  
  
  
  
  =head2 set_rotation()
  
      Default state:      Text rotation is off
      Default action:     None
      Valid args:         Integers in the range -90 to 90 and 270
  
  Set the rotation of the text in a cell. The rotation can be any angle in the range -90 to 90 degrees.
  
      my $format = $workbook->add_format();
      $format->set_rotation( 30 );
      $worksheet->write( 0, 0, 'This text is rotated', $format );
  
  
  The angle 270 is also supported. This indicates text where the letters run from top to bottom.
  
  
  
  =head2 set_indent()
  
      Default state:      Text indentation is off
      Default action:     Indent text 1 level
      Valid args:         Positive integers
  
  
  This method can be used to indent text. The argument, which should be an integer, is taken as the level of indentation:
  
  
      my $format = $workbook->add_format();
      $format->set_indent( 2 );
      $worksheet->write( 0, 0, 'This text is indented', $format );
  
  
  Indentation is a horizontal alignment property. It will override any other horizontal properties but it can be used in conjunction with vertical properties.
  
  
  
  
  =head2 set_shrink()
  
      Default state:      Text shrinking is off
      Default action:     Turn "shrink to fit" on
      Valid args:         1
  
  
  This method can be used to shrink text so that it fits in a cell.
  
  
      my $format = $workbook->add_format();
      $format->set_shrink();
      $worksheet->write( 0, 0, 'Honey, I shrunk the text!', $format );
  
  
  
  
  =head2 set_text_justlast()
  
      Default state:      Justify last is off
      Default action:     Turn justify last on
      Valid args:         0, 1
  
  
  Only applies to Far Eastern versions of Excel.
  
  
  
  
  =head2 set_pattern()
  
      Default state:      Pattern is off
      Default action:     Solid fill is on
      Valid args:         0 .. 18
  
  Set the background pattern of a cell.
  
  Examples of the available patterns are shown in the 'Patterns' worksheet created by formats.pl. However, it is unlikely that you will ever need anything other than Pattern 1 which is a solid fill of the background color.
  
  
  
  
  =head2 set_bg_color()
  
      Default state:      Color is off
      Default action:     Solid fill.
      Valid args:         See set_color()
  
  The C<set_bg_color()> method can be used to set the background colour of a pattern. Patterns are defined via the C<set_pattern()> method. If a pattern hasn't been defined then a solid fill pattern is used as the default.
  
  Here is an example of how to set up a solid fill in a cell:
  
      my $format = $workbook->add_format();
  
      $format->set_pattern();    # This is optional when using a solid fill
  
      $format->set_bg_color( 'green' );
      $worksheet->write( 'A1', 'Ray', $format );
  
  For further examples see the 'Patterns' worksheet created by formats.pl.
  
  
  
  
  =head2 set_fg_color()
  
      Default state:      Color is off
      Default action:     Solid fill.
      Valid args:         See set_color()
  
  
  The C<set_fg_color()> method can be used to set the foreground colour of a pattern.
  
  For further examples see the 'Patterns' worksheet created by formats.pl.
  
  
  
  
  =head2 set_border()
  
      Also applies to:    set_bottom()
                          set_top()
                          set_left()
                          set_right()
  
      Default state:      Border is off
      Default action:     Set border type 1
      Valid args:         0-13, See below.
  
  A cell border is comprised of a border on the bottom, top, left and right. These can be set to the same value using C<set_border()> or individually using the relevant method calls shown above.
  
  The following shows the border styles sorted by Excel::Writer::XLSX index number:
  
      Index   Name            Weight   Style
      =====   =============   ======   ===========
      0       None            0
      1       Continuous      1        -----------
      2       Continuous      2        -----------
      3       Dash            1        - - - - - -
      4       Dot             1        . . . . . .
      5       Continuous      3        -----------
      6       Double          3        ===========
      7       Continuous      0        -----------
      8       Dash            2        - - - - - -
      9       Dash Dot        1        - . - . - .
      10      Dash Dot        2        - . - . - .
      11      Dash Dot Dot    1        - . . - . .
      12      Dash Dot Dot    2        - . . - . .
      13      SlantDash Dot   2        / - . / - .
  
  
  The following shows the borders sorted by style:
  
      Name            Weight   Style         Index
      =============   ======   ===========   =====
      Continuous      0        -----------   7
      Continuous      1        -----------   1
      Continuous      2        -----------   2
      Continuous      3        -----------   5
      Dash            1        - - - - - -   3
      Dash            2        - - - - - -   8
      Dash Dot        1        - . - . - .   9
      Dash Dot        2        - . - . - .   10
      Dash Dot Dot    1        - . . - . .   11
      Dash Dot Dot    2        - . . - . .   12
      Dot             1        . . . . . .   4
      Double          3        ===========   6
      None            0                      0
      SlantDash Dot   2        / - . / - .   13
  
  
  The following shows the borders in the order shown in the Excel Dialog.
  
      Index   Style             Index   Style
      =====   =====             =====   =====
      0       None              12      - . . - . .
      7       -----------       13      / - . / - .
      4       . . . . . .       10      - . - . - .
      11      - . . - . .       8       - - - - - -
      9       - . - . - .       2       -----------
      3       - - - - - -       5       -----------
      1       -----------       6       ===========
  
  
  Examples of the available border styles are shown in the 'Borders' worksheet created by formats.pl.
  
  
  
  
  =head2 set_border_color()
  
      Also applies to:    set_bottom_color()
                          set_top_color()
                          set_left_color()
                          set_right_color()
  
      Default state:      Color is off
      Default action:     Undefined
      Valid args:         See set_color()
  
  
  Set the colour of the cell borders. A cell border is comprised of a border on the bottom, top, left and right. These can be set to the same colour using C<set_border_color()> or individually using the relevant method calls shown above. Examples of the border styles and colours are shown in the 'Borders' worksheet created by formats.pl.
  
  
  =head2 set_diag_type()
  
      Default state:      Diagonal border is off.
      Default action:     None.
      Valid args:         1-3, See below.
  
  Set the diagonal border type for the cell. Three types of diagonal borders are available in Excel:
  
     1: From bottom left to top right.
     2: From top left to bottom right.
     3: Same as 1 and 2 combined.
  
  For example:
  
      $format->set_diag_type( 3 );
  
  
  
  =head2 set_diag_border()
  
      Default state:      Border is off
      Default action:     Set border type 1
      Valid args:         0-13, See below.
  
  Set the diagonal border style. Same as the parameter to C<set_border()> above.
  
  
  
  
  =head2 set_diag_color()
  
      Default state:      Color is off
      Default action:     Undefined
      Valid args:         See set_color()
  
  
  Set the colour of the diagonal cell border:
  
      $format->set_diag_type( 3 );
      $format->set_diag_border( 7 );
      $format->set_diag_color( 'red' );
  
  
  
  =head2 copy( $format )
  
  This method is used to copy all of the properties from one Format object to another:
  
      my $lorry1 = $workbook->add_format();
      $lorry1->set_bold();
      $lorry1->set_italic();
      $lorry1->set_color( 'red' );    # lorry1 is bold, italic and red
  
      my $lorry2 = $workbook->add_format();
      $lorry2->copy( $lorry1 );
      $lorry2->set_color( 'yellow' );    # lorry2 is bold, italic and yellow
  
  The C<copy()> method is only useful if you are using the method interface to Format properties. It generally isn't required if you are setting Format properties directly using hashes.
  
  
  Note: this is not a copy constructor, both objects must exist prior to copying.
  
  
  
  
  =head1 UNICODE IN EXCEL
  
  The following is a brief introduction to handling Unicode in C<Excel::Writer::XLSX>.
  
  I<For a more general introduction to Unicode handling in Perl see> L<perlunitut> and L<perluniintro>.
  
  Excel::Writer::XLSX writer differs from Spreadsheet::WriteExcel in that it only handles Unicode data in C<UTF-8> format and doesn't try to handle legacy UTF-16 Excel formats.
  
  If the data is in C<UTF-8> format then Excel::Writer::XLSX will handle it automatically.
  
  If you are dealing with non-ASCII characters that aren't in C<UTF-8> then perl provides useful tools in the guise of the C<Encode> module to help you to convert to the required format. For example:
  
      use Encode 'decode';
  
      my $string = 'some string with koi8-r characters';
         $string = decode('koi8-r', $string); # koi8-r to utf8
  
  Alternatively you can read data from an encoded file and convert it to C<UTF-8> as you read it in:
  
  
      my $file = 'unicode_koi8r.txt';
      open FH, '<:encoding(koi8-r)', $file or die "Couldn't open $file: $!\n";
  
      my $row = 0;
      while ( <FH> ) {
          # Data read in is now in utf8 format.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
  
  These methodologies are explained in more detail in L<perlunitut>, L<perluniintro> and L<perlunicode>.
  
  If the program contains UTF-8 text then you will also need to add C<use utf8> to the includes:
  
      use utf8;
  
      ...
  
      $worksheet->write( 'A1', 'Some UTF-8 string' );
  
  
  See also the C<unicode_*.pl> programs in the examples directory of the distro.
  
  
  
  
  =head1 WORKING WITH COLOURS
  
  Throughout Excel::Writer::XLSX colours can be specified using a Html style C<#RRGGBB> value. For example with a Format object:
  
      $format->set_font_color( '#FF0000' );
  
  For backward compatibility a limited number of color names are supported:
  
      $format->set_font_color( 'red' );
  
  The color names supported are:
  
      black
      blue
      brown
      cyan
      gray
      green
      lime
      magenta
      navy
      orange
      pink
      purple
      red
      silver
      white
      yellow
  
  See also C<colors.pl> in the C<examples> directory.
  
  
  =head1 DATES AND TIME IN EXCEL
  
  There are two important things to understand about dates and times in Excel:
  
  =over 4
  
  =item 1 A date/time in Excel is a real number plus an Excel number format.
  
  =item 2 Excel::Writer::XLSX doesn't automatically convert date/time strings in C<write()> to an Excel date/time.
  
  =back
  
  These two points are explained in more detail below along with some suggestions on how to convert times and dates to the required format.
  
  
  =head2 An Excel date/time is a number plus a format
  
  If you write a date string with C<write()> then all you will get is a string:
  
      $worksheet->write( 'A1', '02/03/04' );   # !! Writes a string not a date. !!
  
  Dates and times in Excel are represented by real numbers, for example "Jan 1 2001 12:30 AM" is represented by the number 36892.521.
  
  The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day.
  
  A date or time in Excel is just like any other number. To have the number display as a date you must apply an Excel number format to it. Here are some examples.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'date_examples.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      $worksheet->set_column( 'A:A', 30 );    # For extra visibility.
  
      my $number = 39506.5;
  
      $worksheet->write( 'A1', $number );             #   39506.5
  
      my $format2 = $workbook->add_format( num_format => 'dd/mm/yy' );
      $worksheet->write( 'A2', $number, $format2 );    #  28/02/08
  
      my $format3 = $workbook->add_format( num_format => 'mm/dd/yy' );
      $worksheet->write( 'A3', $number, $format3 );    #  02/28/08
  
      my $format4 = $workbook->add_format( num_format => 'd-m-yyyy' );
      $worksheet->write( 'A4', $number, $format4 );    #  28-2-2008
  
      my $format5 = $workbook->add_format( num_format => 'dd/mm/yy hh:mm' );
      $worksheet->write( 'A5', $number, $format5 );    #  28/02/08 12:00
  
      my $format6 = $workbook->add_format( num_format => 'd mmm yyyy' );
      $worksheet->write( 'A6', $number, $format6 );    # 28 Feb 2008
  
      my $format7 = $workbook->add_format( num_format => 'mmm d yyyy hh:mm AM/PM' );
      $worksheet->write('A7', $number , $format7);     #  Feb 28 2008 12:00 PM
  
  
  =head2 Excel::Writer::XLSX doesn't automatically convert date/time strings
  
  Excel::Writer::XLSX doesn't automatically convert input date strings into Excel's formatted date numbers due to the large number of possible date formats and also due to the possibility of misinterpretation.
  
  For example, does C<02/03/04> mean March 2 2004, February 3 2004 or even March 4 2002.
  
  Therefore, in order to handle dates you will have to convert them to numbers and apply an Excel format. Some methods for converting dates are listed in the next section.
  
  The most direct way is to convert your dates to the ISO8601 C<yyyy-mm-ddThh:mm:ss.sss> date format and use the C<write_date_time()> worksheet method:
  
      $worksheet->write_date_time( 'A2', '2001-01-01T12:20', $format );
  
  See the C<write_date_time()> section of the documentation for more details.
  
  A general methodology for handling date strings with C<write_date_time()> is:
  
      1. Identify incoming date/time strings with a regex.
      2. Extract the component parts of the date/time using the same regex.
      3. Convert the date/time to the ISO8601 format.
      4. Write the date/time using write_date_time() and a number format.
  
  Here is an example:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'example.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # Set the default format for dates.
      my $date_format = $workbook->add_format( num_format => 'mmm d yyyy' );
  
      # Increase column width to improve visibility of data.
      $worksheet->set_column( 'A:C', 20 );
  
      # Simulate reading from a data source.
      my $row = 0;
  
      while ( <DATA> ) {
          chomp;
  
          my $col  = 0;
          my @data = split ' ';
  
          for my $item ( @data ) {
  
              # Match dates in the following formats: d/m/yy, d/m/yyyy
              if ( $item =~ qr[^(\d{1,2})/(\d{1,2})/(\d{4})$] ) {
  
                  # Change to the date format required by write_date_time().
                  my $date = sprintf "%4d-%02d-%02dT", $3, $2, $1;
  
                  $worksheet->write_date_time( $row, $col++, $date,
                      $date_format );
              }
              else {
  
                  # Just plain data
                  $worksheet->write( $row, $col++, $item );
              }
          }
          $row++;
      }
  
      __DATA__
      Item    Cost    Date
      Book    10      1/9/2007
      Beer    4       12/9/2007
      Bed     500     5/10/2007
  
  For a slightly more advanced solution you can modify the C<write()> method to handle date formats of your choice via the C<add_write_handler()> method. See the C<add_write_handler()> section of the docs and the write_handler3.pl and write_handler4.pl programs in the examples directory of the distro.
  
  
  =head2 Converting dates and times to an Excel date or time
  
  The C<write_date_time()> method above is just one way of handling dates and times.
  
  You can also use the C<convert_date_time()> worksheet method to convert from an ISO8601 style date string to an Excel date and time number.
  
  The L<Excel::Writer::XLSX::Utility> module which is included in the distro has date/time handling functions:
  
      use Excel::Writer::XLSX::Utility;
  
      $date           = xl_date_list(2002, 1, 1);         # 37257
      $date           = xl_parse_date("11 July 1997");    # 35622
      $time           = xl_parse_time('3:21:36 PM');      # 0.64
      $date           = xl_decode_date_EU("13 May 2002"); # 37389
  
  Note: some of these functions require additional CPAN modules.
  
  For date conversions using the CPAN C<DateTime> framework see L<DateTime::Format::Excel> L<http://search.cpan.org/search?dist=DateTime-Format-Excel>.
  
  
  
  
  =head1 OUTLINES AND GROUPING IN EXCEL
  
  
  Excel allows you to group rows or columns so that they can be hidden or displayed with a single mouse click. This feature is referred to as outlines.
  
  Outlines can reduce complex data down to a few salient sub-totals or summaries.
  
  This feature is best viewed in Excel but the following is an ASCII representation of what a worksheet with three outlines might look like. Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at level 1. The lines at the left hand side are called outline level bars.
  
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |  _  | 2 |   B   |       |       |       |  ...
       | |   | 3 |  (C)  |       |       |       |  ...
       | |   | 4 |  (D)  |       |       |       |  ...
       | -   | 5 |   E   |       |       |       |  ...
       |  _  | 6 |   F   |       |       |       |  ...
       | |   | 7 |  (G)  |       |       |       |  ...
       | |   | 8 |  (H)  |       |       |       |  ...
       | -   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking the minus sign on each of the level 2 outlines will collapse and hide the data as shown in the next figure. The minus sign changes to a plus sign to indicate that the data in the outline is hidden.
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |     | 2 |   B   |       |       |       |  ...
       | +   | 5 |   E   |       |       |       |  ...
       |     | 6 |   F   |       |       |       |  ...
       | +   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking on the minus sign on the level 1 outline will collapse the remaining rows as follows:
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
             | 1 |   A   |       |       |       |  ...
       +     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Grouping in C<Excel::Writer::XLSX> is achieved by setting the outline level via the C<set_row()> and C<set_column()> worksheet methods:
  
      set_row( $row, $height, $format, $hidden, $level, $collapsed )
      set_column( $first_col, $last_col, $width, $format, $hidden, $level, $collapsed )
  
  The following example sets an outline level of 1 for rows 1 and 2 (zero-indexed) and columns B to G. The parameters C<$height> and C<$XF> are assigned default values since they are undefined:
  
      $worksheet->set_row( 1, undef, undef, 0, 1 );
      $worksheet->set_row( 2, undef, undef, 0, 1 );
      $worksheet->set_column( 'B:G', undef, undef, 0, 1 );
  
  Excel allows up to 7 outline levels. Therefore the C<$level> parameter should be in the range C<0 E<lt>= $level E<lt>= 7>.
  
  Rows and columns can be collapsed by setting the C<$hidden> flag for the hidden rows/columns and setting the C<$collapsed> flag for the row/column that has the collapsed C<+> symbol:
  
      $worksheet->set_row( 1, undef, undef, 1, 1 );
      $worksheet->set_row( 2, undef, undef, 1, 1 );
      $worksheet->set_row( 3, undef, undef, 0, 0, 1 );          # Collapsed flag.
  
      $worksheet->set_column( 'B:G', undef, undef, 1, 1 );
      $worksheet->set_column( 'H:H', undef, undef, 0, 0, 1 );   # Collapsed flag.
  
  Note: Setting the C<$collapsed> flag is particularly important for compatibility with OpenOffice.org and Gnumeric.
  
  For a more complete example see the C<outline.pl> and C<outline_collapsed.pl> programs in the examples directory of the distro.
  
  Some additional outline properties can be set via the C<outline_settings()> worksheet method, see above.
  
  
  
  
  =head1 DATA VALIDATION IN EXCEL
  
  Data validation is a feature of Excel which allows you to restrict the data that a users enters in a cell and to display help and warning messages. It also allows you to restrict input to values in a drop down list.
  
  A typical use case might be to restrict data in a cell to integer values in a certain range, to provide a help message to indicate the required value and to issue a warning if the input data doesn't meet the stated criteria. In Excel::Writer::XLSX we could do that as follows:
  
      $worksheet->data_validation('B3',
          {
              validate        => 'integer',
              criteria        => 'between',
              minimum         => 1,
              maximum         => 100,
              input_title     => 'Input an integer:',
              input_message   => 'Between 1 and 100',
              error_message   => 'Sorry, try again.',
          });
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/validation_example.jpg" alt="The output from the above example"/></center></p>
  
  =end html
  
  For more information on data validation see the following Microsoft support article "Description and examples of data validation in Excel": L<http://support.microsoft.com/kb/211485>.
  
  The following sections describe how to use the C<data_validation()> method and its various options.
  
  
  =head2 data_validation( $row, $col, { parameter => 'value', ... } )
  
  The C<data_validation()> method is used to construct an Excel data validation.
  
  It can be applied to a single cell or a range of cells. You can pass 3 parameters such as C<($row, $col, {...})> or 5 parameters such as C<($first_row, $first_col, $last_row, $last_col, {...})>. You can also use C<A1> style notation. For example:
  
      $worksheet->data_validation( 0, 0,       {...} );
      $worksheet->data_validation( 0, 0, 4, 1, {...} );
  
      # Which are the same as:
  
      $worksheet->data_validation( 'A1',       {...} );
      $worksheet->data_validation( 'A1:B5',    {...} );
  
  See also the note about L</Cell notation> for more information.
  
  
  The last parameter in C<data_validation()> must be a hash ref containing the parameters that describe the type and style of the data validation. The allowable parameters are:
  
      validate
      criteria
      value | minimum | source
      maximum
      ignore_blank
      dropdown
  
      input_title
      input_message
      show_input
  
      error_title
      error_message
      error_type
      show_error
  
  These parameters are explained in the following sections. Most of the parameters are optional, however, you will generally require the three main options C<validate>, C<criteria> and C<value>.
  
      $worksheet->data_validation('B3',
          {
              validate => 'integer',
              criteria => '>',
              value    => 100,
          });
  
  The C<data_validation> method returns:
  
       0 for success.
      -1 for insufficient number of arguments.
      -2 for row or column out of bounds.
      -3 for incorrect parameter or value.
  
  
  =head2 validate
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<validate> parameter is used to set the type of data that you wish to validate. It is always required and it has no default value. Allowable values are:
  
      any
      integer
      decimal
      list
      date
      time
      length
      custom
  
  =over
  
  =item * B<any> is used to specify that the type of data is unrestricted. This is useful to display an input message without restricting the data that can be entered.
  
  =item * B<integer> restricts the cell to integer values. Excel refers to this as 'whole number'.
  
      validate => 'integer',
      criteria => '>',
      value    => 100,
  
  =item * B<decimal> restricts the cell to decimal values.
  
      validate => 'decimal',
      criteria => '>',
      value    => 38.6,
  
  =item * B<list> restricts the cell to a set of user specified values. These can be passed in an array ref or as a cell range (named ranges aren't currently supported):
  
      validate => 'list',
      value    => ['open', 'high', 'close'],
      # Or like this:
      value    => 'B1:B3',
  
  Excel requires that range references are only to cells on the same worksheet.
  
  =item * B<date> restricts the cell to date values. Dates in Excel are expressed as integer values but you can also pass an ISO8601 style string as used in C<write_date_time()>. See also L</DATES AND TIME IN EXCEL> for more information about working with Excel's dates.
  
      validate => 'date',
      criteria => '>',
      value    => 39653, # 24 July 2008
      # Or like this:
      value    => '2008-07-24T',
  
  =item * B<time> restricts the cell to time values. Times in Excel are expressed as decimal values but you can also pass an ISO8601 style string as used in C<write_date_time()>. See also L</DATES AND TIME IN EXCEL> for more information about working with Excel's times.
  
      validate => 'time',
      criteria => '>',
      value    => 0.5, # Noon
      # Or like this:
      value    => 'T12:00:00',
  
  =item * B<length> restricts the cell data based on an integer string length. Excel refers to this as 'Text length'.
  
      validate => 'length',
      criteria => '>',
      value    => 10,
  
  =item * B<custom> restricts the cell based on an external Excel formula that returns a C<TRUE/FALSE> value.
  
      validate => 'custom',
      value    => '=IF(A10>B10,TRUE,FALSE)',
  
  =back
  
  
  =head2 criteria
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<criteria> parameter is used to set the criteria by which the data in the cell is validated. It is almost always required except for the C<list> and C<custom> validate options. It has no default value. Allowable values are:
  
      'between'
      'not between'
      'equal to'                  |  '=='  |  '='
      'not equal to'              |  '!='  |  '<>'
      'greater than'              |  '>'
      'less than'                 |  '<'
      'greater than or equal to'  |  '>='
      'less than or equal to'     |  '<='
  
  You can either use Excel's textual description strings, in the first column above, or the more common symbolic alternatives. The following are equivalent:
  
      validate => 'integer',
      criteria => 'greater than',
      value    => 100,
  
      validate => 'integer',
      criteria => '>',
      value    => 100,
  
  The C<list> and C<custom> validate options don't require a C<criteria>. If you specify one it will be ignored.
  
      validate => 'list',
      value    => ['open', 'high', 'close'],
  
      validate => 'custom',
      value    => '=IF(A10>B10,TRUE,FALSE)',
  
  
  =head2 value | minimum | source
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<value> parameter is used to set the limiting value to which the C<criteria> is applied. It is always required and it has no default value. You can also use the synonyms C<minimum> or C<source> to make the validation a little clearer and closer to Excel's description of the parameter:
  
      # Use 'value'
      validate => 'integer',
      criteria => '>',
      value    => 100,
  
      # Use 'minimum'
      validate => 'integer',
      criteria => 'between',
      minimum  => 1,
      maximum  => 100,
  
      # Use 'source'
      validate => 'list',
      source   => '$B$1:$B$3',
  
  
  =head2 maximum
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<maximum> parameter is used to set the upper limiting value when the C<criteria> is either C<'between'> or C<'not between'>:
  
      validate => 'integer',
      criteria => 'between',
      minimum  => 1,
      maximum  => 100,
  
  
  =head2 ignore_blank
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<ignore_blank> parameter is used to toggle on and off the 'Ignore blank' option in the Excel data validation dialog. When the option is on the data validation is not applied to blank data in the cell. It is on by default.
  
      ignore_blank => 0,  # Turn the option off
  
  
  =head2 dropdown
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<dropdown> parameter is used to toggle on and off the 'In-cell dropdown' option in the Excel data validation dialog. When the option is on a dropdown list will be shown for C<list> validations. It is on by default.
  
      dropdown => 0,      # Turn the option off
  
  
  =head2 input_title
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<input_title> parameter is used to set the title of the input message that is displayed when a cell is entered. It has no default value and is only displayed if the input message is displayed. See the C<input_message> parameter below.
  
      input_title   => 'This is the input title',
  
  The maximum title length is 32 characters.
  
  
  =head2 input_message
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<input_message> parameter is used to set the input message that is displayed when a cell is entered. It has no default value.
  
      validate      => 'integer',
      criteria      => 'between',
      minimum       => 1,
      maximum       => 100,
      input_title   => 'Enter the applied discount:',
      input_message => 'between 1 and 100',
  
  The message can be split over several lines using newlines, C<"\n"> in double quoted strings.
  
      input_message => "This is\na test.",
  
  The maximum message length is 255 characters.
  
  
  =head2 show_input
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<show_input> parameter is used to toggle on and off the 'Show input message when cell is selected' option in the Excel data validation dialog. When the option is off an input message is not displayed even if it has been set using C<input_message>. It is on by default.
  
      show_input => 0,      # Turn the option off
  
  
  =head2 error_title
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<error_title> parameter is used to set the title of the error message that is displayed when the data validation criteria is not met. The default error title is 'Microsoft Excel'.
  
      error_title   => 'Input value is not valid',
  
  The maximum title length is 32 characters.
  
  
  =head2 error_message
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<error_message> parameter is used to set the error message that is displayed when a cell is entered. The default error message is "The value you entered is not valid.\nA user has restricted values that can be entered into the cell.".
  
      validate      => 'integer',
      criteria      => 'between',
      minimum       => 1,
      maximum       => 100,
      error_title   => 'Input value is not valid',
      error_message => 'It should be an integer between 1 and 100',
  
  The message can be split over several lines using newlines, C<"\n"> in double quoted strings.
  
      input_message => "This is\na test.",
  
  The maximum message length is 255 characters.
  
  
  =head2 error_type
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<error_type> parameter is used to specify the type of error dialog that is displayed. There are 3 options:
  
      'stop'
      'warning'
      'information'
  
  The default is C<'stop'>.
  
  
  =head2 show_error
  
  This parameter is passed in a hash ref to C<data_validation()>.
  
  The C<show_error> parameter is used to toggle on and off the 'Show error alert after invalid data is entered' option in the Excel data validation dialog. When the option is off an error message is not displayed even if it has been set using C<error_message>. It is on by default.
  
      show_error => 0,      # Turn the option off
  
  =head2 Data Validation Examples
  
  Example 1. Limiting input to an integer greater than a fixed value.
  
      $worksheet->data_validation('A1',
          {
              validate        => 'integer',
              criteria        => '>',
              value           => 0,
          });
  
  Example 2. Limiting input to an integer greater than a fixed value where the value is referenced from a cell.
  
      $worksheet->data_validation('A2',
          {
              validate        => 'integer',
              criteria        => '>',
              value           => '=E3',
          });
  
  Example 3. Limiting input to a decimal in a fixed range.
  
      $worksheet->data_validation('A3',
          {
              validate        => 'decimal',
              criteria        => 'between',
              minimum         => 0.1,
              maximum         => 0.5,
          });
  
  Example 4. Limiting input to a value in a dropdown list.
  
      $worksheet->data_validation('A4',
          {
              validate        => 'list',
              source          => ['open', 'high', 'close'],
          });
  
  Example 5. Limiting input to a value in a dropdown list where the list is specified as a cell range.
  
      $worksheet->data_validation('A5',
          {
              validate        => 'list',
              source          => '=$E$4:$G$4',
          });
  
  Example 6. Limiting input to a date in a fixed range.
  
      $worksheet->data_validation('A6',
          {
              validate        => 'date',
              criteria        => 'between',
              minimum         => '2008-01-01T',
              maximum         => '2008-12-12T',
          });
  
  Example 7. Displaying a message when the cell is selected.
  
      $worksheet->data_validation('A7',
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
          });
  
  See also the C<data_validate.pl> program in the examples directory of the distro.
  
  
  
  
  =head1 CONDITIONAL FORMATTING IN EXCEL
  
  Conditional formatting is a feature of Excel which allows you to apply a format to a cell or a range of cells based on a certain criteria.
  
  For example the following criteria is used to highlight cells >= 50 in red in the C<conditional_format.pl> example from the distro:
  
      # Write a conditional format over a range.
      $worksheet->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '>=',
              value    => 50,
              format   => $format1,
          }
      );
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/conditional_example.jpg" alt="The output from the above example"/></center></p>
  
  =end html
  
  
  
  =head2 conditional_formatting( $row, $col, { parameter => 'value', ... } )
  
  The C<conditional_formatting()> method is used to apply formatting  based on user defined criteria to an Excel::Writer::XLSX file.
  
  It can be applied to a single cell or a range of cells. You can pass 3 parameters such as C<($row, $col, {...})> or 5 parameters such as C<($first_row, $first_col, $last_row, $last_col, {...})>. You can also use C<A1> style notation. For example:
  
      $worksheet->conditional_formatting( 0, 0,       {...} );
      $worksheet->conditional_formatting( 0, 0, 4, 1, {...} );
  
      # Which are the same as:
  
      $worksheet->conditional_formatting( 'A1',       {...} );
      $worksheet->conditional_formatting( 'A1:B5',    {...} );
  
  See also the note about L</Cell notation> for more information.
  
  Using C<A1> style notation is also possible to specify non-contiguous ranges, separated by a comma. For example:
  
      $worksheet->conditional_formatting( 'A1:D5,A8:D12', {...} );
  
  The last parameter in C<conditional_formatting()> must be a hash ref containing the parameters that describe the type and style of the data validation. The main parameters are:
  
      type
      format
      criteria
      value
      minimum
      maximum
  
  Other, less commonly used parameters are:
  
      min_type
      mid_type
      max_type
      min_value
      mid_value
      max_value
      min_color
      mid_color
      max_color
      bar_color
      stop_if_true
  
  Additional parameters which are used for specific conditional format types are shown in the relevant sections below.
  
  =head2 type
  
  This parameter is passed in a hash ref to C<conditional_formatting()>.
  
  The C<type> parameter is used to set the type of conditional formatting that you wish to apply. It is always required and it has no default value. Allowable C<type> values and their associated parameters are:
  
      Type            Parameters
      ====            ==========
      cell            criteria
                      value
                      minimum
                      maximum
  
      date            criteria
                      value
                      minimum
                      maximum
  
      time_period     criteria
  
      text            criteria
                      value
  
      average         criteria
  
      duplicate       (none)
  
      unique          (none)
  
      top             criteria
                      value
  
      bottom          criteria
                      value
  
      blanks          (none)
  
      no_blanks       (none)
  
      errors          (none)
  
      no_errors       (none)
  
      2_color_scale   (none)
  
      3_color_scale   (none)
  
      data_bar        (none)
  
      formula         criteria
  
  
  All conditional formatting types have a C<format> parameter, see below. Other types and parameters such as icon sets will be added in time.
  
  =head2 type => 'cell'
  
  This is the most common conditional formatting type. It is used when a format is applied to a cell based on a simple criterion. For example:
  
      $worksheet->conditional_formatting( 'A1',
          {
              type     => 'cell',
              criteria => 'greater than',
              value    => 5,
              format   => $red_format,
          }
      );
  
  Or, using the C<between> criteria:
  
      $worksheet->conditional_formatting( 'C1:C4',
          {
              type     => 'cell',
              criteria => 'between',
              minimum  => 20,
              maximum  => 30,
              format   => $green_format,
          }
      );
  
  
  =head2 criteria
  
  The C<criteria> parameter is used to set the criteria by which the cell data will be evaluated. It has no default value. The most common criteria as applied to C<< { type => 'cell' } >> are:
  
      'between'
      'not between'
      'equal to'                  |  '=='  |  '='
      'not equal to'              |  '!='  |  '<>'
      'greater than'              |  '>'
      'less than'                 |  '<'
      'greater than or equal to'  |  '>='
      'less than or equal to'     |  '<='
  
  You can either use Excel's textual description strings, in the first column above, or the more common symbolic alternatives.
  
  Additional criteria which are specific to other conditional format types are shown in the relevant sections below.
  
  
  =head2 value
  
  The C<value> is generally used along with the C<criteria> parameter to set the rule by which the cell data  will be evaluated.
  
      type     => 'cell',
      criteria => '>',
      value    => 5
      format   => $format,
  
  The C<value> property can also be an cell reference.
  
      type     => 'cell',
      criteria => '>',
      value    => '$C$1',
      format   => $format,
  
  
  =head2 format
  
  The C<format> parameter is used to specify the format that will be applied to the cell when the conditional formatting criterion is met. The format is created using the C<add_format()> method in the same way as cell formats:
  
      $format = $workbook->add_format( bold => 1, italic => 1 );
  
      $worksheet->conditional_formatting( 'A1',
          {
              type     => 'cell',
              criteria => '>',
              value    => 5
              format   => $format,
          }
      );
  
  The conditional format follows the same rules as in Excel: it is superimposed over the existing cell format and not all font and border properties can be modified. Font properties that can't be modified are font name, font size, superscript and subscript. The border property that cannot be modified is diagonal borders.
  
  Excel specifies some default formats to be used with conditional formatting. You can replicate them using the following Excel::Writer::XLSX formats:
  
      # Light red fill with dark red text.
  
      my $format1 = $workbook->add_format(
          bg_color => '#FFC7CE',
          color    => '#9C0006',
      );
  
      # Light yellow fill with dark yellow text.
  
      my $format2 = $workbook->add_format(
          bg_color => '#FFEB9C',
          color    => '#9C6500',
      );
  
      # Green fill with dark green text.
  
      my $format3 = $workbook->add_format(
          bg_color => '#C6EFCE',
          color    => '#006100',
      );
  
  
  =head2 minimum
  
  The C<minimum> parameter is used to set the lower limiting value when the C<criteria> is either C<'between'> or C<'not between'>:
  
      validate => 'integer',
      criteria => 'between',
      minimum  => 1,
      maximum  => 100,
  
  
  =head2 maximum
  
  The C<maximum> parameter is used to set the upper limiting value when the C<criteria> is either C<'between'> or C<'not between'>. See the previous example.
  
  
  =head2 type => 'date'
  
  The C<date> type is the same as the C<cell> type and uses the same criteria and values. However it allows the C<value>, C<minimum> and C<maximum> properties to be specified in the ISO8601 C<yyyy-mm-ddThh:mm:ss.sss> date format which is detailed in the C<write_date_time()> method.
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'date',
              criteria => 'greater than',
              value    => '2011-01-01T',
              format   => $format,
          }
      );
  
  
  =head2 type => 'time_period'
  
  The C<time_period> type is used to specify Excel's "Dates Occurring" style conditional format.
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'time_period',
              criteria => 'yesterday',
              format   => $format,
          }
      );
  
  The period is set in the C<criteria> and can have one of the following values:
  
          criteria => 'yesterday',
          criteria => 'today',
          criteria => 'last 7 days',
          criteria => 'last week',
          criteria => 'this week',
          criteria => 'next week',
          criteria => 'last month',
          criteria => 'this month',
          criteria => 'next month'
  
  
  =head2 type => 'text'
  
  The C<text> type is used to specify Excel's "Specific Text" style conditional format. It is used to do simple string matching using the C<criteria> and C<value> parameters:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'text',
              criteria => 'containing',
              value    => 'foo',
              format   => $format,
          }
      );
  
  The C<criteria> can have one of the following values:
  
      criteria => 'containing',
      criteria => 'not containing',
      criteria => 'begins with',
      criteria => 'ends with',
  
  The C<value> parameter should be a string or single character.
  
  
  =head2 type => 'average'
  
  The C<average> type is used to specify Excel's "Average" style conditional format.
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'average',
              criteria => 'above',
              format   => $format,
          }
      );
  
  The type of average for the conditional format range is specified by the C<criteria>:
  
      criteria => 'above',
      criteria => 'below',
      criteria => 'equal or above',
      criteria => 'equal or below',
      criteria => '1 std dev above',
      criteria => '1 std dev below',
      criteria => '2 std dev above',
      criteria => '2 std dev below',
      criteria => '3 std dev above',
      criteria => '3 std dev below',
  
  
  
  =head2 type => 'duplicate'
  
  The C<duplicate> type is used to highlight duplicate cells in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'duplicate',
              format   => $format,
          }
      );
  
  
  =head2 type => 'unique'
  
  The C<unique> type is used to highlight unique cells in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'unique',
              format   => $format,
          }
      );
  
  
  =head2 type => 'top'
  
  The C<top> type is used to specify the top C<n> values by number or percentage in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'top',
              value    => 10,
              format   => $format,
          }
      );
  
  The C<criteria> can be used to indicate that a percentage condition is required:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'top',
              value    => 10,
              criteria => '%',
              format   => $format,
          }
      );
  
  
  =head2 type => 'bottom'
  
  The C<bottom> type is used to specify the bottom C<n> values by number or percentage in a range.
  
  It takes the same parameters as C<top>, see above.
  
  
  =head2 type => 'blanks'
  
  The C<blanks> type is used to highlight blank cells in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'blanks',
              format   => $format,
          }
      );
  
  
  =head2 type => 'no_blanks'
  
  The C<no_blanks> type is used to highlight non blank cells in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'no_blanks',
              format   => $format,
          }
      );
  
  
  =head2 type => 'errors'
  
  The C<errors> type is used to highlight error cells in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'errors',
              format   => $format,
          }
      );
  
  
  =head2 type => 'no_errors'
  
  The C<no_errors> type is used to highlight non error cells in a range:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'no_errors',
              format   => $format,
          }
      );
  
  
  =head2 type => '2_color_scale'
  
  The C<2_color_scale> type is used to specify Excel's "2 Color Scale" style conditional format.
  
      $worksheet->conditional_formatting( 'A1:A12',
          {
              type  => '2_color_scale',
          }
      );
  
  This conditional type can be modified with C<min_type>, C<max_type>, C<min_value>, C<max_value>, C<min_color> and C<max_color>, see below.
  
  
  =head2 type => '3_color_scale'
  
  The C<3_color_scale> type is used to specify Excel's "3 Color Scale" style conditional format.
  
      $worksheet->conditional_formatting( 'A1:A12',
          {
              type  => '3_color_scale',
          }
      );
  
  This conditional type can be modified with C<min_type>, C<mid_type>, C<max_type>, C<min_value>, C<mid_value>, C<max_value>, C<min_color>, C<mid_color> and C<max_color>, see below.
  
  
  =head2 type => 'data_bar'
  
  The C<data_bar> type is used to specify Excel's "Data Bar" style conditional format.
  
      $worksheet->conditional_formatting( 'A1:A12',
          {
              type  => 'data_bar',
          }
      );
  
  This conditional type can be modified with C<min_type>, C<max_type>, C<min_value>, C<max_value> and C<bar_color>, see below.
  
  
  
  =head2 type => 'formula'
  
  The C<formula> type is used to specify a conditional format based on a user defined formula:
  
      $worksheet->conditional_formatting( 'A1:A4',
          {
              type     => 'formula',
              criteria => '=$A$1 > 5',
              format   => $format,
          }
      );
  
  The formula is specified in the C<criteria>.
  
  
  =head2 min_type, mid_type, max_type
  
  The C<min_type> and C<max_type> properties are available when the conditional formatting type is C<2_color_scale>, C<3_color_scale> or C<data_bar>. The C<mid_type> is available for C<3_color_scale>. The properties are used as follows:
  
      $worksheet->conditional_formatting( 'A1:A12',
          {
              type      => '2_color_scale',
              min_type  => 'percent',
              max_type  => 'percent',
          }
      );
  
  The available min/mid/max types are:
  
      min        (for min_type only)
      num
      percent
      percentile
      formula
      max        (for max_type only)
  
  
  =head2 min_value, mid_value, max_value
  
  The C<min_value> and C<max_value> properties are available when the conditional formatting type is C<2_color_scale>, C<3_color_scale> or C<data_bar>. The C<mid_value> is available for C<3_color_scale>. The properties are used as follows:
  
      $worksheet->conditional_formatting( 'A1:A12',
          {
              type       => '2_color_scale',
              min_value  => 10,
              max_value  => 90,
          }
      );
  
  =head2 min_color, mid_color,  max_color, bar_color
  
  The C<min_color> and C<max_color> properties are available when the conditional formatting type is C<2_color_scale>, C<3_color_scale> or C<data_bar>. The C<mid_color> is available for C<3_color_scale>. The properties are used as follows:
  
      $worksheet->conditional_formatting( 'A1:A12',
          {
              type      => '2_color_scale',
              min_color => "#C5D9F1",
              max_color => "#538ED5",
          }
      );
  
  The color can be specifies as an Excel::Writer::XLSX color index or, more usefully, as a HTML style RGB hex number, as shown above.
  
  
  =head2 stop_if_true
  
  The C<stop_if_true> parameter, if set to a true value, will enable the "stop if true" feature on the conditional formatting rule, so that subsequent rules are not examined for any cell on which the conditions for this rule are met.
  
  
  =head2 Conditional Formatting Examples
  
  Example 1. Highlight cells greater than an integer value.
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'cell',
              criteria => 'greater than',
              value    => 5,
              format   => $format,
          }
      );
  
  Example 2. Highlight cells greater than a value in a reference cell.
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'cell',
              criteria => 'greater than',
              value    => '$H$1',
              format   => $format,
          }
      );
  
  Example 3. Highlight cells greater than a certain date:
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'date',
              criteria => 'greater than',
              value    => '2011-01-01T',
              format   => $format,
          }
      );
  
  Example 4. Highlight cells with a date in the last seven days:
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'time_period',
              criteria => 'last 7 days',
              format   => $format,
          }
      );
  
  Example 5. Highlight cells with strings starting with the letter C<b>:
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'text',
              criteria => 'begins with',
              value    => 'b',
              format   => $format,
          }
      );
  
  Example 6. Highlight cells that are 1 std deviation above the average for the range:
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'average',
              format   => $format,
          }
      );
  
  Example 7. Highlight duplicate cells in a range:
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'duplicate',
              format   => $format,
          }
      );
  
  Example 8. Highlight unique cells in a range.
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'unique',
              format   => $format,
          }
      );
  
  Example 9. Highlight the top 10 cells.
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'top',
              value    => 10,
              format   => $format,
          }
      );
  
  
  Example 10. Highlight blank cells.
  
      $worksheet->conditional_formatting( 'A1:F10',
          {
              type     => 'blanks',
              format   => $format,
          }
      );
  
  
  See also the C<conditional_format.pl> example program in C<EXAMPLES>.
  
  
  
  
  =head1 SPARKLINES IN EXCEL
  
  Sparklines are a feature of Excel 2010+ which allows you to add small charts to worksheet cells. These are useful for showing visual trends in data in a compact format.
  
  In Excel::Writer::XLSX Sparklines can be added to cells using the C<add_sparkline()> worksheet method:
  
      $worksheet->add_sparkline(
          {
              location => 'F2',
              range    => 'Sheet1!A2:E2',
              type     => 'column',
              style    => 12,
          }
      );
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/sparklines1.jpg" alt="Sparklines example."/></center></p>
  
  =end html
  
  B<Note:> Sparklines are a feature of Excel 2010+ only. You can write them to an XLSX file that can be read by Excel 2007 but they won't be displayed.
  
  
  =head2 add_sparkline( { parameter => 'value', ... } )
  
  The C<add_sparkline()> worksheet method is used to add sparklines to a cell or a range of cells.
  
  The parameters to C<add_sparkline()> must be passed in a hash ref. The main sparkline parameters are:
  
      location        (required)
      range           (required)
      type
      style
  
      markers
      negative_points
      axis
      reverse
  
  Other, less commonly used parameters are:
  
      high_point
      low_point
      first_point
      last_point
      max
      min
      empty_cells
      show_hidden
      date_axis
      weight
  
      series_color
      negative_color
      markers_color
      first_color
      last_color
      high_color
      low_color
  
  These parameters are explained in the sections below:
  
  =head2 location
  
  This is the cell where the sparkline will be displayed:
  
      location => 'F1'
  
  The C<location> should be a single cell. (For multiple cells see L<Grouped Sparklines> below).
  
  To specify the location in row-column notation use the C<xl_rowcol_to_cell()> function from the L<Excel::Writer::XLSX::Utility> module.
  
      use Excel::Writer::XLSX::Utility ':rowcol';
      ...
      location => xl_rowcol_to_cell( 0, 5 ), # F1
  
  
  =head2 range
  
  This specifies the cell data range that the sparkline will plot:
  
      $worksheet->add_sparkline(
          {
              location => 'F1',
              range    => 'A1:E1',
          }
      );
  
  The C<range> should be a 2D array. (For 3D arrays of cells see L<Grouped Sparklines> below).
  
  If C<range> is not on the same worksheet you can specify its location using the usual Excel notation:
  
              range => 'Sheet1!A1:E1',
  
  If the worksheet contains spaces or special characters you should quote the worksheet name in the same way that Excel does:
  
              range => q('Monthly Data'!A1:E1),
  
  To specify the location in row-column notation use the C<xl_range()> or C<xl_range_formula()> functions from the L<Excel::Writer::XLSX::Utility> module.
  
      use Excel::Writer::XLSX::Utility ':rowcol';
      ...
      range => xl_range( 1, 1,  0, 4 ),                   # 'A1:E1'
      range => xl_range_formula( 'Sheet1', 0, 0,  0, 4 ), # 'Sheet1!A2:E2'
  
  =head2 type
  
  Specifies the type of sparkline. There are 3 available sparkline types:
  
      line    (default)
      column
      win_loss
  
  For example:
  
      {
          location => 'F1',
          range    => 'A1:E1',
          type     => 'column',
      }
  
  
  =head2 style
  
  Excel provides 36 built-in Sparkline styles in 6 groups of 6. The C<style> parameter can be used to replicate these and should be a corresponding number from 1 .. 36.
  
      {
          location => 'A14',
          range    => 'Sheet2!A2:J2',
          style    => 3,
      }
  
  The style number starts in the top left of the style grid and runs left to right. The default style is 1. It is possible to override colour elements of the sparklines using the C<*_color> parameters below.
  
  =head2 markers
  
  Turn on the markers for C<line> style sparklines.
  
      {
          location => 'A6',
          range    => 'Sheet2!A1:J1',
          markers  => 1,
      }
  
  Markers aren't shown in Excel for C<column> and C<win_loss> sparklines.
  
  =head2 negative_points
  
  Highlight negative values in a sparkline range. This is usually required with C<win_loss> sparklines.
  
      {
          location        => 'A21',
          range           => 'Sheet2!A3:J3',
          type            => 'win_loss',
          negative_points => 1,
      }
  
  =head2 axis
  
  Display a horizontal axis in the sparkline:
  
      {
          location => 'A10',
          range    => 'Sheet2!A1:J1',
          axis     => 1,
      }
  
  =head2 reverse
  
  Plot the data from right-to-left instead of the default left-to-right:
  
      {
          location => 'A24',
          range    => 'Sheet2!A4:J4',
          type     => 'column',
          reverse  => 1,
      }
  
  =head2 weight
  
  Adjust the default line weight (thickness) for C<line> style sparklines.
  
       weight => 0.25,
  
  The weight value should be one of the following values allowed by Excel:
  
      0.25  0.5   0.75
      1     1.25
      2.25
      3
      4.25
      6
  
  =head2 high_point, low_point, first_point, last_point
  
  Highlight points in a sparkline range.
  
          high_point  => 1,
          low_point   => 1,
          first_point => 1,
          last_point  => 1,
  
  
  =head2 max, min
  
  Specify the maximum and minimum vertical axis values:
  
          max         => 0.5,
          min         => -0.5,
  
  As a special case you can set the maximum and minimum to be for a group of sparklines rather than one:
  
          max         => 'group',
  
  See L<Grouped Sparklines> below.
  
  =head2 empty_cells
  
  Define how empty cells are handled in a sparkline.
  
      empty_cells => 'zero',
  
  The available options are:
  
      gaps   : show empty cells as gaps (the default).
      zero   : plot empty cells as 0.
      connect: Connect points with a line ("line" type  sparklines only).
  
  =head2 show_hidden
  
  Plot data in hidden rows and columns:
  
      show_hidden => 1,
  
  Note, this option is off by default.
  
  =head2 date_axis
  
  Specify an alternative date axis for the sparkline. This is useful if the data being plotted isn't at fixed width intervals:
  
      {
          location  => 'F3',
          range     => 'A3:E3',
          date_axis => 'A4:E4',
      }
  
  The number of cells in the date range should correspond to the number of cells in the data range.
  
  
  =head2 series_color
  
  It is possible to override the colour of a sparkline style using the following parameters:
  
      series_color
      negative_color
      markers_color
      first_color
      last_color
      high_color
      low_color
  
  The color should be specified as a HTML style C<#rrggbb> hex value:
  
      {
          location     => 'A18',
          range        => 'Sheet2!A2:J2',
          type         => 'column',
          series_color => '#E965E0',
      }
  
  =head2 Grouped Sparklines
  
  The C<add_sparkline()> worksheet method can be used multiple times to write as many sparklines as are required in a worksheet.
  
  However, it is sometimes necessary to group contiguous sparklines so that changes that are applied to one are applied to all. In Excel this is achieved by selecting a 3D range of cells for the data C<range> and a 2D range of cells for the C<location>.
  
  In Excel::Writer::XLSX, you can simulate this by passing an array refs of values to C<location> and C<range>:
  
      {
          location => [ 'A27',          'A28',          'A29'          ],
          range    => [ 'Sheet2!A5:J5', 'Sheet2!A6:J6', 'Sheet2!A7:J7' ],
          markers  => 1,
      }
  
  =head2 Sparkline examples
  
  See the C<sparklines1.pl> and C<sparklines2.pl> example programs in the C<examples> directory of the distro.
  
  
  
  
  =head1 TABLES IN EXCEL
  
  Tables in Excel are a way of grouping a range of cells into a single entity that has common formatting or that can be referenced from formulas. Tables can have column headers, autofilters, total rows, column formulas and default formatting.
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/tables.jpg" width="640" height="420" alt="Output from tables.pl" /></center></p>
  
  =end html
  
  
  For more information see "An Overview of Excel Tables" L<http://office.microsoft.com/en-us/excel-help/overview-of-excel-tables-HA010048546.aspx>.
  
  Note, tables don't work in Excel::Writer::XLSX when C<set_optimization()> mode in on.
  
  
  =head2 add_table( $row1, $col1, $row2, $col2, { parameter => 'value', ... })
  
  Tables are added to a worksheet using the C<add_table()> method:
  
      $worksheet->add_table( 'B3:F7', { %parameters } );
  
  The data range can be specified in 'A1' or 'row/col' notation (see also the note about L</Cell notation> for more information):
  
  
      $worksheet->add_table( 'B3:F7' );
      # Same as:
      $worksheet->add_table(  2, 1, 6, 5 );
  
  The last parameter in C<add_table()> should be a hash ref containing the parameters that describe the table options and data. The available parameters are:
  
          data
          autofilter
          header_row
          banded_columns
          banded_rows
          first_column
          last_column
          style
          total_row
          columns
          name
  
  The table parameters are detailed below. There are no required parameters and the hash ref isn't required if no options are specified.
  
  
  
  =head2 data
  
  The C<data> parameter can be used to specify the data in the cells of the table.
  
      my $data = [
          [ 'Apples',  10000, 5000, 8000, 6000 ],
          [ 'Pears',   2000,  3000, 4000, 5000 ],
          [ 'Bananas', 6000,  6000, 6500, 6000 ],
          [ 'Oranges', 500,   300,  200,  700 ],
  
      ];
  
      $worksheet->add_table( 'B3:F7', { data => $data } );
  
  Table data can also be written separately, as an array or individual cells.
  
      # These two statements are the same as the single statement above.
      $worksheet->add_table( 'B3:F7' );
      $worksheet->write_col( 'B4', $data );
  
  Writing the cell data separately is occasionally required when you need to control the C<write_*()> method used to populate the cells or if you wish to tweak the cell formatting.
  
  The C<data> structure should be an array ref of array refs holding row data as shown above.
  
  =head2 header_row
  
  The C<header_row> parameter can be used to turn on or off the header row in the table. It is on by default.
  
      $worksheet->add_table( 'B4:F7', { header_row => 0 } ); # Turn header off.
  
  The header row will contain default captions such as C<Column 1>, C<Column 2>,  etc. These captions can be overridden using the C<columns> parameter below.
  
  
  =head2 autofilter
  
  The C<autofilter> parameter can be used to turn on or off the autofilter in the header row. It is on by default.
  
      $worksheet->add_table( 'B3:F7', { autofilter => 0 } ); # Turn autofilter off.
  
  The C<autofilter> is only shown if the C<header_row> is on. Filters within the table are not supported.
  
  
  =head2 banded_rows
  
  The C<banded_rows> parameter can be used to used to create rows of alternating colour in the table. It is on by default.
  
      $worksheet->add_table( 'B3:F7', { banded_rows => 0 } );
  
  
  =head2 banded_columns
  
  The C<banded_columns> parameter can be used to used to create columns of alternating colour in the table. It is off by default.
  
      $worksheet->add_table( 'B3:F7', { banded_columns => 1 } );
  
  
  =head2 first_column
  
  The C<first_column> parameter can be used to highlight the first column of the table. The type of highlighting will depend on the C<style> of the table. It may be bold text or a different colour. It is off by default.
  
      $worksheet->add_table( 'B3:F7', { first_column => 1 } );
  
  
  =head2 last_column
  
  The C<last_column> parameter can be used to highlight the last column of the table. The type of highlighting will depend on the C<style> of the table. It may be bold text or a different colour. It is off by default.
  
      $worksheet->add_table( 'B3:F7', { last_column => 1 } );
  
  
  =head2 style
  
  The C<style> parameter can be used to set the style of the table. Standard Excel table format names should be used (with matching capitalisation):
  
      $worksheet11->add_table(
          'B3:F7',
          {
              data      => $data,
              style     => 'Table Style Light 11',
          }
      );
  
  The default table style is 'Table Style Medium 9'.
  
  
  =head2 name
  
  By default tables are named C<Table1>, C<Table2>, etc. The C<name> parameter can be used to set the name of the table:
  
      $worksheet->add_table( 'B3:F7', { name => 'SalesData' } );
  
  If you override the table name you must ensure that it doesn't clash with an existing table name and that it follows Excel's requirements for table names L<http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx#BMsyntax_rules_for_names>.
  
  If you need to know the name of the table, for example to use it in a formula, you can get it as follows:
  
      my $table      = $worksheet2->add_table( 'B3:F7' );
      my $table_name = $table->{_name};
  
  
  =head2 total_row
  
  The C<total_row> parameter can be used to turn on the total row in the last row of a table. It is distinguished from the other rows by a different formatting and also with dropdown C<SUBTOTAL> functions.
  
      $worksheet->add_table( 'B3:F7', { total_row => 1 } );
  
  The default total row doesn't have any captions or functions. These must by specified via the C<columns> parameter below.
  
  =head2 columns
  
  The C<columns> parameter can be used to set properties for columns within the table.
  
  The sub-properties that can be set are:
  
      header
      formula
      total_string
      total_function
      total_value
      format
      header_format
  
  The column data must be specified as an array ref of hash refs. For example to override the default 'Column n' style table headers:
  
      $worksheet->add_table(
          'B3:F7',
          {
              data    => $data,
              columns => [
                  { header => 'Product' },
                  { header => 'Quarter 1' },
                  { header => 'Quarter 2' },
                  { header => 'Quarter 3' },
                  { header => 'Quarter 4' },
              ]
          }
      );
  
  If you don't wish to specify properties for a specific column you pass an empty hash ref and the defaults will be applied:
  
              ...
              columns => [
                  { header => 'Product' },
                  { header => 'Quarter 1' },
                  { },                        # Defaults to 'Column 3'.
                  { header => 'Quarter 3' },
                  { header => 'Quarter 4' },
              ]
              ...
  
  
  Column formulas can by applied using the C<formula> column property:
  
      $worksheet8->add_table(
          'B3:G7',
          {
              data    => $data,
              columns => [
                  { header => 'Product' },
                  { header => 'Quarter 1' },
                  { header => 'Quarter 2' },
                  { header => 'Quarter 3' },
                  { header => 'Quarter 4' },
                  {
                      header  => 'Year',
                      formula => '=SUM(Table8[@[Quarter 1]:[Quarter 4]])'
                  },
              ]
          }
      );
  
  The Excel 2007 C<[#This Row]> and Excel 2010 C<@> structural references are supported within the formula.
  
  As stated above the C<total_row> table parameter turns on the "Total" row in the table but it doesn't populate it with any defaults. Total captions and functions must be specified via the C<columns> property and the C<total_string>, C<total_function> and C<total_value> sub properties:
  
      $worksheet10->add_table(
          'B3:F8',
          {
              data      => $data,
              total_row => 1,
              columns   => [
                  { header => 'Product',   total_string   => 'Totals' },
                  { header => 'Quarter 1', total_function => 'sum' },
                  { header => 'Quarter 2', total_function => 'sum' },
                  { header => 'Quarter 3', total_function => 'sum' },
                  { header => 'Quarter 4', total_function => 'sum' },
              ]
          }
      );
  
  The supported totals row C<SUBTOTAL> functions are:
  
          average
          count_nums
          count
          max
          min
          std_dev
          sum
          var
  
  User defined functions or formulas aren't supported.
  
  It is also possible to set a calculated value for the C<total_function> using the C<total_value> sub property. This is only necessary when creating workbooks for applications that cannot calculate the value of formulas automatically. This is similar to setting the C<value> optional property in C<write_formula()>:
  
      $worksheet10->add_table(
          'B3:F8',
          {
              data      => $data,
              total_row => 1,
              columns   => [
                  { total_string   => 'Totals' },
                  { total_function => 'sum', total_value => 100 },
                  { total_function => 'sum', total_value => 200 },
                  { total_function => 'sum', total_value => 100 },
                  { total_function => 'sum', total_value => 400 },
              ]
          }
      );
  
  
  
  
  Formatting can also be applied to columns, to the column data using C<format> and to the header using C<header_format>:
  
      my $currency_format = $workbook->add_format( num_format => '$#,##0' );
  
      $worksheet->add_table(
          'B3:D8',
          {
              data      => $data,
              total_row => 1,
              columns   => [
                  { header => 'Product', total_string => 'Totals' },
                  {
                      header         => 'Quarter 1',
                      total_function => 'sum',
                      format         => $currency_format,
                  },
                  {
                      header         => 'Quarter 2',
                      header_format  => $bold,
                      total_function => 'sum',
                      format         => $currency_format,
                  },
              ]
          }
      );
  
  Standard Excel::Writer::XLSX format objects can be used. However, they should be limited to numerical formats for the columns and simple formatting like text wrap for the headers. Overriding other table formatting may produce inconsistent results.
  
  
  
  =head1 FORMULAS AND FUNCTIONS IN EXCEL
  
  
  
  
  =head2 Introduction
  
  The following is a brief introduction to formulas and functions in Excel and Excel::Writer::XLSX.
  
  A formula is a string that begins with an equals sign:
  
      '=A1+B1'
      '=AVERAGE(1, 2, 3)'
  
  The formula can contain numbers, strings, boolean values, cell references, cell ranges and functions. Named ranges are not supported. Formulas should be written as they appear in Excel, that is cells and functions must be in uppercase.
  
  Cells in Excel are referenced using the A1 notation system where the column is designated by a letter and the row by a number. Columns range from A to XFD i.e. 0 to 16384, rows range from 1 to 1048576. The C<Excel::Writer::XLSX::Utility> module that is included in the distro contains helper functions for dealing with A1 notation, for example:
  
      use Excel::Writer::XLSX::Utility;
  
      ( $row, $col ) = xl_cell_to_rowcol( 'C2' );    # (1, 2)
      $str = xl_rowcol_to_cell( 1, 2 );              # C2
  
  The Excel C<$> notation in cell references is also supported. This allows you to specify whether a row or column is relative or absolute. This only has an effect if the cell is copied. The following examples show relative and absolute values.
  
      '=A1'   # Column and row are relative
      '=$A1'  # Column is absolute and row is relative
      '=A$1'  # Column is relative and row is absolute
      '=$A$1' # Column and row are absolute
  
  Formulas can also refer to cells in other worksheets of the current workbook. For example:
  
      '=Sheet2!A1'
      '=Sheet2!A1:A5'
      '=Sheet2:Sheet3!A1'
      '=Sheet2:Sheet3!A1:A5'
      q{='Test Data'!A1}
      q{='Test Data1:Test Data2'!A1}
  
  The sheet reference and the cell reference are separated by C<!> the exclamation mark symbol. If worksheet names contain spaces, commas or parentheses then Excel requires that the name is enclosed in single quotes as shown in the last two examples above. In order to avoid using a lot of escape characters you can use the quote operator C<q{}> to protect the quotes. See C<perlop> in the main Perl documentation. Only valid sheet names that have been added using the C<add_worksheet()> method can be used in formulas. You cannot reference external workbooks.
  
  
  The following table lists the operators that are available in Excel's formulas. The majority of the operators are the same as Perl's, differences are indicated:
  
      Arithmetic operators:
      =====================
      Operator  Meaning                   Example
         +      Addition                  1+2
         -      Subtraction               2-1
         *      Multiplication            2*3
         /      Division                  1/4
         ^      Exponentiation            2^3      # Equivalent to **
         -      Unary minus               -(1+2)
         %      Percent (Not modulus)     13%
  
  
      Comparison operators:
      =====================
      Operator  Meaning                   Example
          =     Equal to                  A1 =  B1 # Equivalent to ==
          <>    Not equal to              A1 <> B1 # Equivalent to !=
          >     Greater than              A1 >  B1
          <     Less than                 A1 <  B1
          >=    Greater than or equal to  A1 >= B1
          <=    Less than or equal to     A1 <= B1
  
  
      String operator:
      ================
      Operator  Meaning                   Example
          &     Concatenation             "Hello " & "World!" # [1]
  
  
      Reference operators:
      ====================
      Operator  Meaning                   Example
          :     Range operator            A1:A4               # [2]
          ,     Union operator            SUM(1, 2+2, B3)     # [3]
  
  
      Notes:
      [1]: Equivalent to "Hello " . "World!" in Perl.
      [2]: This range is equivalent to cells A1, A2, A3 and A4.
      [3]: The comma behaves like the list separator in Perl.
  
  The range and comma operators can have different symbols in non-English versions of Excel, see below.
  
  For a general introduction to Excel's formulas and an explanation of the syntax of the function refer to the Excel help files or the following: L<http://office.microsoft.com/en-us/assistance/CH062528031033.aspx>.
  
  In most cases a formula in Excel can be used directly in the C<write_formula> method. However, there are a few potential issues and differences that the user should be aware of. These are explained in the following sections.
  
  
  =head2 Non US Excel functions and syntax
  
  
  Excel stores formulas in the format of the US English version, regardless of the language or locale of the end-user's version of Excel. Therefore all formula function names written using Excel::Writer::XLSX must be in English:
  
      worksheet->write_formula('A1', '=SUM(1, 2, 3)');   # OK
      worksheet->write_formula('A2', '=SOMME(1, 2, 3)'); # French. Error on load.
  
  Also, formulas must be written with the US style separator/range operator which is a comma (not semi-colon). Therefore a formula with multiple values should be written as follows:
  
      worksheet->write_formula('A1', '=SUM(1, 2, 3)'); # OK
      worksheet->write_formula('A2', '=SUM(1; 2; 3)'); # Semi-colon. Error on load.
  
  If you have a non-English version of Excel you can use the following multi-lingual Formula Translator (L<http://en.excel-translator.de/language/>) to help you convert the formula. It can also replace semi-colons with commas.
  
  
  =head2 Formulas added in Excel 2010 and later
  
  Excel 2010 and later added functions which weren't defined in the original file specification. These functions are referred to by Microsoft as I<future> functions. Examples of these functions are C<ACOT>, C<CHISQ.DIST.RT> , C<CONFIDENCE.NORM>, C<STDEV.P>, C<STDEV.S> and C<WORKDAY.INTL>.
  
  When written using C<write_formula()> these functions need to be fully qualified with a C<_xlfn.> (or other) prefix as they are shown the list below. For example:
  
      worksheet->write_formula('A1', '=_xlfn.STDEV.S(B1:B10)')
  
  They will appear without the prefix in Excel.
  
  The following list is taken from the MS XLSX extensions documentation on future functions: L<http://msdn.microsoft.com/en-us/library/dd907480%28v=office.12%29.aspx>:
  
      _xlfn.ACOT
      _xlfn.ACOTH
      _xlfn.AGGREGATE
      _xlfn.ARABIC
      _xlfn.BASE
      _xlfn.BETA.DIST
      _xlfn.BETA.INV
      _xlfn.BINOM.DIST
      _xlfn.BINOM.DIST.RANGE
      _xlfn.BINOM.INV
      _xlfn.BITAND
      _xlfn.BITLSHIFT
      _xlfn.BITOR
      _xlfn.BITRSHIFT
      _xlfn.BITXOR
      _xlfn.CEILING.MATH
      _xlfn.CEILING.PRECISE
      _xlfn.CHISQ.DIST
      _xlfn.CHISQ.DIST.RT
      _xlfn.CHISQ.INV
      _xlfn.CHISQ.INV.RT
      _xlfn.CHISQ.TEST
      _xlfn.COMBINA
      _xlfn.CONFIDENCE.NORM
      _xlfn.CONFIDENCE.T
      _xlfn.COT
      _xlfn.COTH
      _xlfn.COVARIANCE.P
      _xlfn.COVARIANCE.S
      _xlfn.CSC
      _xlfn.CSCH
      _xlfn.DAYS
      _xlfn.DECIMAL
      ECMA.CEILING
      _xlfn.ERF.PRECISE
      _xlfn.ERFC.PRECISE
      _xlfn.EXPON.DIST
      _xlfn.F.DIST
      _xlfn.F.DIST.RT
      _xlfn.F.INV
      _xlfn.F.INV.RT
      _xlfn.F.TEST
      _xlfn.FILTERXML
      _xlfn.FLOOR.MATH
      _xlfn.FLOOR.PRECISE
      _xlfn.FORECAST.ETS
      _xlfn.FORECAST.ETS.CONFINT
      _xlfn.FORECAST.ETS.SEASONALITY
      _xlfn.FORECAST.ETS.STAT
      _xlfn.FORECAST.LINEAR
      _xlfn.FORMULATEXT
      _xlfn.GAMMA
      _xlfn.GAMMA.DIST
      _xlfn.GAMMA.INV
      _xlfn.GAMMALN.PRECISE
      _xlfn.GAUSS
      _xlfn.HYPGEOM.DIST
      _xlfn.IFNA
      _xlfn.IMCOSH
      _xlfn.IMCOT
      _xlfn.IMCSC
      _xlfn.IMCSCH
      _xlfn.IMSEC
      _xlfn.IMSECH
      _xlfn.IMSINH
      _xlfn.IMTAN
      _xlfn.ISFORMULA
      ISO.CEILING
      _xlfn.ISOWEEKNUM
      _xlfn.LOGNORM.DIST
      _xlfn.LOGNORM.INV
      _xlfn.MODE.MULT
      _xlfn.MODE.SNGL
      _xlfn.MUNIT
      _xlfn.NEGBINOM.DIST
      NETWORKDAYS.INTL
      _xlfn.NORM.DIST
      _xlfn.NORM.INV
      _xlfn.NORM.S.DIST
      _xlfn.NORM.S.INV
      _xlfn.NUMBERVALUE
      _xlfn.PDURATION
      _xlfn.PERCENTILE.EXC
      _xlfn.PERCENTILE.INC
      _xlfn.PERCENTRANK.EXC
      _xlfn.PERCENTRANK.INC
      _xlfn.PERMUTATIONA
      _xlfn.PHI
      _xlfn.POISSON.DIST
      _xlfn.QUARTILE.EXC
      _xlfn.QUARTILE.INC
      _xlfn.QUERYSTRING
      _xlfn.RANK.AVG
      _xlfn.RANK.EQ
      _xlfn.RRI
      _xlfn.SEC
      _xlfn.SECH
      _xlfn.SHEET
      _xlfn.SHEETS
      _xlfn.SKEW.P
      _xlfn.STDEV.P
      _xlfn.STDEV.S
      _xlfn.T.DIST
      _xlfn.T.DIST.2T
      _xlfn.T.DIST.RT
      _xlfn.T.INV
      _xlfn.T.INV.2T
      _xlfn.T.TEST
      _xlfn.UNICHAR
      _xlfn.UNICODE
      _xlfn.VAR.P
      _xlfn.VAR.S
      _xlfn.WEBSERVICE
      _xlfn.WEIBULL.DIST
      WORKDAY.INTL
      _xlfn.XOR
      _xlfn.Z.TEST
  
  
  =head2 Using Tables in Formulas
  
  Worksheet tables can be added with Excel::Writer::XLSX using the C<add_table()> method:
  
      worksheet->add_table('B3:F7', {options});
  
  By default tables are named C<Table1>, C<Table2>, etc., in the order that they are added. However it can also be set by the user using the C<name> parameter:
  
      worksheet->add_table('B3:F7', {'name': 'SalesData'});
  
  If you need to know the name of the table, for example to use it in a formula,
  you can get it as follows:
  
      table = worksheet->add_table('B3:F7');
      table_name = table->{_name};
  
  When used in a formula a table name such as C<TableX> should be referred to as C<TableX[]> (like a Perl array):
  
      worksheet->write_formula('A5', '=VLOOKUP("Sales", Table1[], 2, FALSE');
  
  
  =head2 Dealing with #NAME? errors
  
  If there is an error in the syntax of a formula it is usually displayed in
  Excel as C<#NAME?>. If you encounter an error like this you can debug it as
  follows:
  
  =over
  
  =item 1. Ensure the formula is valid in Excel by copying and pasting it into a cell. Note, this should be done in Excel and not other applications such as OpenOffice or LibreOffice since they may have slightly different syntax.
  
  =item 2. Ensure the formula is using comma separators instead of semi-colons, see L<Non US Excel functions and syntax> above.
  
  =item 3. Ensure the formula is in English, see L<Non US Excel functions and syntax> above.
  
  =item 4. Ensure that the formula doesn't contain an Excel 2010+ future function as listed in L<Formulas added in Excel 2010 and later> above. If it does then ensure that the correct prefix is used.
  
  =back
  
  Finally if you have completed all the previous steps and still get a C<#NAME?> error you can examine a valid Excel file to see what the correct syntax should be. To do this you should create a valid formula in Excel and save the file. You can then examine the XML in the unzipped file.
  
  The following shows how to do that using Linux C<unzip> and libxml's xmllint
  L<http://xmlsoft.org/xmllint.html> to format the XML for clarity:
  
      $ unzip myfile.xlsx -d myfile
      $ xmllint --format myfile/xl/worksheets/sheet1.xml | grep '<f>'
  
              <f>SUM(1, 2, 3)</f>
  
  
  =head2 Formula Results
  
  Excel::Writer::XLSX doesn't calculate the result of a formula and instead stores the value 0 as the formula result. It then sets a global flag in the XLSX file to say that all formulas and functions should be recalculated when the file is opened.
  
  This is the method recommended in the Excel documentation and in general it works fine with spreadsheet applications. However, applications that don't have a facility to calculate formulas will only display the 0 results. Examples of such applications are Excel Viewer, PDF Converters, and some mobile device applications.
  
  If required, it is also possible to specify the calculated result of the
  formula using the optional last C<value> parameter in C<write_formula>:
  
      worksheet->write_formula('A1', '=2+2', num_format, 4);
  
  The C<value> parameter can be a number, a string, a boolean sting (C<'TRUE'> or C<'FALSE'>) or one of the following Excel error codes:
  
      #DIV/0!
      #N/A
      #NAME?
      #NULL!
      #NUM!
      #REF!
      #VALUE!
  
  It is also possible to specify the calculated result of an array formula created with C<write_array_formula>:
  
      # Specify the result for a single cell range.
      worksheet->write_array_formula('A1:A1', '{=SUM(B1:C1*B2:C2)}', format, 2005);
  
  However, using this parameter only writes a single value to the upper left cell in the result array. For a multi-cell array formula where the results are required, the other result values can be specified by using C<write_number()> to write to the appropriate cell:
  
      # Specify the results for a multi cell range.
      worksheet->write_array_formula('A1:A3', '{=TREND(C1:C3,B1:B3)}', format, 15);
      worksheet->write_number('A2', 12, format);
      worksheet->write_number('A3', 14, format);
  
  
  
  
  =head1 WORKING WITH VBA MACROS
  
  An Excel C<xlsm> file is exactly the same as a C<xlsx> file except that is includes an additional C<vbaProject.bin> file which contains functions and/or macros. Excel uses a different extension to differentiate between the two file formats since files containing macros are usually subject to additional security checks.
  
  The C<vbaProject.bin> file is a binary OLE COM container. This was the format used in older C<xls> versions of Excel prior to Excel 2007. Unlike all of the other components of an xlsx/xlsm file the data isn't stored in XML format. Instead the functions and macros as stored as pre-parsed binary format. As such it wouldn't be feasible to define macros and create a C<vbaProject.bin> file from scratch (at least not in the remaining lifespan and interest levels of the author).
  
  Instead a workaround is used to extract C<vbaProject.bin> files from existing xlsm files and then add these to Excel::Writer::XLSX files.
  
  
  =head2 The extract_vba utility
  
  The C<extract_vba> utility is used to extract the C<vbaProject.bin> binary from an Excel 2007+ xlsm file. The utility is included in the Excel::Writer::XLSX bin directory and is also installed as a standalone executable file:
  
      $ extract_vba macro_file.xlsm
      Extracted: vbaProject.bin
  
  
  =head2 Adding the VBA macros to a Excel::Writer::XLSX file
  
  Once the C<vbaProject.bin> file has been extracted it can be added to the Excel::Writer::XLSX workbook using the C<add_vba_project()> method:
  
      $workbook->add_vba_project( './vbaProject.bin' );
  
  If the VBA file contains functions you can then refer to them in calculations using C<write_formula>:
  
      $worksheet->write_formula( 'A1', '=MyMortgageCalc(200000, 25)' );
  
  Excel files that contain functions and macros should use an C<xlsm> extension or else Excel will complain and possibly not open the file:
  
      my $workbook  = Excel::Writer::XLSX->new( 'file.xlsm' );
  
  It is also possible to assign a macro to a button that is inserted into a
  worksheet using the C<insert_button()> method:
  
      my $workbook  = Excel::Writer::XLSX->new( 'file.xlsm' );
      ...
      $workbook->add_vba_project( './vbaProject.bin' );
  
      $worksheet->insert_button( 'C2', { macro => 'my_macro' } );
  
  
  It may be necessary to specify a more explicit macro name prefixed by the workbook VBA name as follows:
  
      $worksheet->insert_button( 'C2', { macro => 'ThisWorkbook.my_macro' } );
  
  See the C<macros.pl> from the examples directory for a working example.
  
  Note: Button is the only VBA Control supported by Excel::Writer::XLSX. Due to the large effort in implementation (1+ man months) it is unlikely that any other form elements will be added in the future.
  
  
  =head2 Setting the VBA codenames
  
  VBA macros generally refer to workbook and worksheet objects. If the VBA codenames aren't specified then Excel::Writer::XLSX will use the Excel defaults of C<ThisWorkbook> and C<Sheet1>, C<Sheet2> etc.
  
  If the macro uses other codenames you can set them using the workbook and worksheet C<set_vba_name()> methods as follows:
  
        $workbook->set_vba_name( 'MyWorkbook' );
        $worksheet->set_vba_name( 'MySheet' );
  
  You can find the names that are used in the VBA editor or by unzipping the C<xlsm> file and grepping the files. The following shows how to do that using libxml's xmllint L<http://xmlsoft.org/xmllint.html> to format the XML for clarity:
  
      $ unzip myfile.xlsm -d myfile
      $ xmllint --format `find myfile -name "*.xml" | xargs` | grep "Pr.*codeName"
  
        <workbookPr codeName="MyWorkbook" defaultThemeVersion="124226"/>
        <sheetPr codeName="MySheet"/>
  
  
  Note: This step is particularly important for macros created with non-English versions of Excel.
  
  
  
  =head2 What to do if it doesn't work
  
  This feature should be considered experimental and there is no guarantee that it will work in all cases. Some effort may be required and some knowledge of VBA will certainly help. If things don't work out here are some things to try:
  
  =over
  
  =item *
  
  Start with a simple macro file, ensure that it works and then add complexity.
  
  =item *
  
  Try to extract the macros from an Excel 2007 file. The method should work with macros from later versions (it was also tested with Excel 2010 macros). However there may be features in the macro files of more recent version of Excel that aren't backward compatible.
  
  =item *
  
  Check the code names that macros use to refer to the workbook and worksheets (see the previous section above). In general VBA uses a code name of C<ThisWorkbook> to refer to the current workbook and the sheet name (such as C<Sheet1>) to refer to the worksheets. These are the defaults used by Excel::Writer::XLSX. If the macro uses other names then you can specify these using the workbook and worksheet C<set_vba_name()> methods:
  
        $workbook>set_vba_name( 'MyWorkbook' );
        $worksheet->set_vba_name( 'MySheet' );
  
  =back
  
  
  =head1 EXAMPLES
  
  See L<Excel::Writer::XLSX::Examples> for a full list of examples.
  
  
  =head2 Example 1
  
  The following example shows some of the basic features of Excel::Writer::XLSX.
  
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      # Create a new workbook called simple.xlsx and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'simple.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # The general syntax is write($row, $column, $token). Note that row and
      # column are zero indexed
  
      # Write some text
      $worksheet->write( 0, 0, 'Hi Excel!' );
  
  
      # Write some numbers
      $worksheet->write( 2, 0, 3 );
      $worksheet->write( 3, 0, 3.00000 );
      $worksheet->write( 4, 0, 3.00001 );
      $worksheet->write( 5, 0, 3.14159 );
  
  
      # Write some formulas
      $worksheet->write( 7, 0, '=A3 + A6' );
      $worksheet->write( 8, 0, '=IF(A5>3,"Yes", "No")' );
  
  
      # Write a hyperlink
      my $hyperlink_format = $workbook->add_format(
          color     => 'blue',
          underline => 1,
      );
  
      $worksheet->write( 10, 0, 'http://www.perl.com/', $hyperlink_format );
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/a_simple.jpg" width="640" height="420" alt="Output from a_simple.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 2
  
  The following is a general example which demonstrates some features of working with multiple worksheets.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      # Create a new Excel workbook
      my $workbook = Excel::Writer::XLSX->new( 'regions.xlsx' );
  
      # Add some worksheets
      my $north = $workbook->add_worksheet( 'North' );
      my $south = $workbook->add_worksheet( 'South' );
      my $east  = $workbook->add_worksheet( 'East' );
      my $west  = $workbook->add_worksheet( 'West' );
  
      # Add a Format
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color( 'blue' );
  
      # Add a caption to each worksheet
      for my $worksheet ( $workbook->sheets() ) {
          $worksheet->write( 0, 0, 'Sales', $format );
      }
  
      # Write some data
      $north->write( 0, 1, 200000 );
      $south->write( 0, 1, 100000 );
      $east->write( 0, 1, 150000 );
      $west->write( 0, 1, 100000 );
  
      # Set the active worksheet
      $south->activate();
  
      # Set the width of the first column
      $south->set_column( 0, 0, 20 );
  
      # Set the active cell
      $south->set_selection( 0, 1 );
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/regions.jpg" width="640" height="420" alt="Output from regions.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 3
  
  Example of how to add conditional formatting to an Excel::Writer::XLSX file. The example below highlights cells that have a value greater than or equal to 50 in red and cells below that value in green.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'conditional_format.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
  
      # This example below highlights cells that have a value greater than or
      # equal to 50 in red and cells below that value in green.
  
      # Light red fill with dark red text.
      my $format1 = $workbook->add_format(
          bg_color => '#FFC7CE',
          color    => '#9C0006',
  
      );
  
      # Green fill with dark green text.
      my $format2 = $workbook->add_format(
          bg_color => '#C6EFCE',
          color    => '#006100',
  
      );
  
      # Some sample data to run the conditional formatting against.
      my $data = [
          [ 34, 72,  38, 30, 75, 48, 75, 66, 84, 86 ],
          [ 6,  24,  1,  84, 54, 62, 60, 3,  26, 59 ],
          [ 28, 79,  97, 13, 85, 93, 93, 22, 5,  14 ],
          [ 27, 71,  40, 17, 18, 79, 90, 93, 29, 47 ],
          [ 88, 25,  33, 23, 67, 1,  59, 79, 47, 36 ],
          [ 24, 100, 20, 88, 29, 33, 38, 54, 54, 88 ],
          [ 6,  57,  88, 28, 10, 26, 37, 7,  41, 48 ],
          [ 52, 78,  1,  96, 26, 45, 47, 33, 96, 36 ],
          [ 60, 54,  81, 66, 81, 90, 80, 93, 12, 55 ],
          [ 70, 5,   46, 14, 71, 19, 66, 36, 41, 21 ],
      ];
  
      my $caption = 'Cells with values >= 50 are in light red. '
        . 'Values < 50 are in light green';
  
      # Write the data.
      $worksheet->write( 'A1', $caption );
      $worksheet->write_col( 'B3', $data );
  
      # Write a conditional format over a range.
      $worksheet->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '>=',
              value    => 50,
              format   => $format1,
          }
      );
  
      # Write another conditional format over the same range.
      $worksheet->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '<',
              value    => 50,
              format   => $format2,
          }
      );
  
  
  =begin html
  
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/conditional_format.jpg" width="640" height="420" alt="Output from conditional_format.pl" /></center></p>
  
  
  =end html
  
  
  
  
  =head2 Example 4
  
  The following is a simple example of using functions.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'stats.xlsx' );
      my $worksheet = $workbook->add_worksheet( 'Test data' );
  
      # Set the column width for columns 1
      $worksheet->set_column( 0, 0, 20 );
  
  
      # Create a format for the headings
      my $format = $workbook->add_format();
      $format->set_bold();
  
  
      # Write the sample data
      $worksheet->write( 0, 0, 'Sample', $format );
      $worksheet->write( 0, 1, 1 );
      $worksheet->write( 0, 2, 2 );
      $worksheet->write( 0, 3, 3 );
      $worksheet->write( 0, 4, 4 );
      $worksheet->write( 0, 5, 5 );
      $worksheet->write( 0, 6, 6 );
      $worksheet->write( 0, 7, 7 );
      $worksheet->write( 0, 8, 8 );
  
      $worksheet->write( 1, 0, 'Length', $format );
      $worksheet->write( 1, 1, 25.4 );
      $worksheet->write( 1, 2, 25.4 );
      $worksheet->write( 1, 3, 24.8 );
      $worksheet->write( 1, 4, 25.0 );
      $worksheet->write( 1, 5, 25.3 );
      $worksheet->write( 1, 6, 24.9 );
      $worksheet->write( 1, 7, 25.2 );
      $worksheet->write( 1, 8, 24.8 );
  
      # Write some statistical functions
      $worksheet->write( 4, 0, 'Count', $format );
      $worksheet->write( 4, 1, '=COUNT(B1:I1)' );
  
      $worksheet->write( 5, 0, 'Sum', $format );
      $worksheet->write( 5, 1, '=SUM(B2:I2)' );
  
      $worksheet->write( 6, 0, 'Average', $format );
      $worksheet->write( 6, 1, '=AVERAGE(B2:I2)' );
  
      $worksheet->write( 7, 0, 'Min', $format );
      $worksheet->write( 7, 1, '=MIN(B2:I2)' );
  
      $worksheet->write( 8, 0, 'Max', $format );
      $worksheet->write( 8, 1, '=MAX(B2:I2)' );
  
      $worksheet->write( 9, 0, 'Standard Deviation', $format );
      $worksheet->write( 9, 1, '=STDEV(B2:I2)' );
  
      $worksheet->write( 10, 0, 'Kurtosis', $format );
      $worksheet->write( 10, 1, '=KURT(B2:I2)' );
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/stats.jpg" width="640" height="420" alt="Output from stats.pl" /></center></p>
  
  =end html
  
  
  
  
  =head2 Example 5
  
  The following example converts a tab separated file called C<tab.txt> into an Excel file called C<tab.xlsx>.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      open( TABFILE, 'tab.txt' ) or die "tab.txt: $!";
  
      my $workbook  = Excel::Writer::XLSX->new( 'tab.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # Row and column are zero indexed
      my $row = 0;
  
      while ( <TABFILE> ) {
          chomp;
  
          # Split on single tab
          my @fields = split( '\t', $_ );
  
          my $col = 0;
          for my $token ( @fields ) {
              $worksheet->write( $row, $col, $token );
              $col++;
          }
          $row++;
      }
  
  
  NOTE: This is a simple conversion program for illustrative purposes only. For converting a CSV or Tab separated or any other type of delimited text file to Excel I recommend the more rigorous csv2xls program that is part of H.Merijn Brand's L<Text::CSV_XS> module distro.
  
  See the examples/csv2xls link here: L<http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST>.
  
  
  
  
  =head2 Additional Examples
  
  The following is a description of the example files that are provided
  in the standard Excel::Writer::XLSX distribution. They demonstrate the
  different features and options of the module. See L<Excel::Writer::XLSX::Examples> for more details.
  
      Getting started
      ===============
      a_simple.pl             A simple demo of some of the features.
      bug_report.pl           A template for submitting bug reports.
      demo.pl                 A demo of some of the available features.
      formats.pl              All the available formatting on several worksheets.
      regions.pl              A simple example of multiple worksheets.
      stats.pl                Basic formulas and functions.
  
  
      Intermediate
      ============
      autofilter.pl           Examples of worksheet autofilters.
      array_formula.pl        Examples of how to write array formulas.
      cgi.pl                  A simple CGI program.
      chart_area.pl           A demo of area style charts.
      chart_bar.pl            A demo of bar (vertical histogram) style charts.
      chart_column.pl         A demo of column (histogram) style charts.
      chart_line.pl           A demo of line style charts.
      chart_pie.pl            A demo of pie style charts.
      chart_doughnut.pl       A demo of doughnut style charts.
      chart_radar.pl          A demo of radar style charts.
      chart_scatter.pl        A demo of scatter style charts.
      chart_secondary_axis.pl A demo of a line chart with a secondary axis.
      chart_combined.pl       A demo of a combined column and line chart.
      chart_pareto.pl         A demo of a combined Pareto chart.
      chart_stock.pl          A demo of stock style charts.
      chart_data_table.pl     A demo of a chart with a data table on the axis.
      chart_data_tools.pl     A demo of charts with data highlighting options.
      chart_clustered.pl      A demo of a chart with a clustered axis.
      chart_styles.pl         A demo of the available chart styles.
      colors.pl               A demo of the colour palette and named colours.
      comments1.pl            Add comments to worksheet cells.
      comments2.pl            Add comments with advanced options.
      conditional_format.pl   Add conditional formats to a range of cells.
      data_validate.pl        An example of data validation and dropdown lists.
      date_time.pl            Write dates and times with write_date_time().
      defined_name.pl         Example of how to create defined names.
      diag_border.pl          A simple example of diagonal cell borders.
      filehandle.pl           Examples of working with filehandles.
      headers.pl              Examples of worksheet headers and footers.
      hide_row_col.pl         Example of hiding rows and columns.
      hide_sheet.pl           Simple example of hiding a worksheet.
      hyperlink1.pl           Shows how to create web hyperlinks.
      hyperlink2.pl           Examples of internal and external hyperlinks.
      indent.pl               An example of cell indentation.
      macros.pl               An example of adding macros from an existing file.
      merge1.pl               A simple example of cell merging.
      merge2.pl               A simple example of cell merging with formatting.
      merge3.pl               Add hyperlinks to merged cells.
      merge4.pl               An advanced example of merging with formatting.
      merge5.pl               An advanced example of merging with formatting.
      merge6.pl               An example of merging with Unicode strings.
      mod_perl1.pl            A simple mod_perl 1 program.
      mod_perl2.pl            A simple mod_perl 2 program.
      panes.pl                An examples of how to create panes.
      outline.pl              An example of outlines and grouping.
      outline_collapsed.pl    An example of collapsed outlines.
      protection.pl           Example of cell locking and formula hiding.
      rich_strings.pl         Example of strings with multiple formats.
      right_to_left.pl        Change default sheet direction to right to left.
      sales.pl                An example of a simple sales spreadsheet.
      shape1.pl               Insert shapes in worksheet.
      shape2.pl               Insert shapes in worksheet. With properties.
      shape3.pl               Insert shapes in worksheet. Scaled.
      shape4.pl               Insert shapes in worksheet. With modification.
      shape5.pl               Insert shapes in worksheet. With connections.
      shape6.pl               Insert shapes in worksheet. With connections.
      shape7.pl               Insert shapes in worksheet. One to many connections.
      shape8.pl               Insert shapes in worksheet. One to many connections.
      shape_all.pl            Demo of all the available shape and connector types.
      sparklines1.pl          Simple sparklines demo.
      sparklines2.pl          Sparklines demo showing formatting options.
      stats_ext.pl            Same as stats.pl with external references.
      stocks.pl               Demonstrates conditional formatting.
      tab_colors.pl           Example of how to set worksheet tab colours.
      tables.pl               Add Excel tables to a worksheet.
      write_handler1.pl       Example of extending the write() method. Step 1.
      write_handler2.pl       Example of extending the write() method. Step 2.
      write_handler3.pl       Example of extending the write() method. Step 3.
      write_handler4.pl       Example of extending the write() method. Step 4.
      write_to_scalar.pl      Example of writing an Excel file to a Perl scalar.
  
      Unicode
      =======
      unicode_2022_jp.pl      Japanese: ISO-2022-JP.
      unicode_8859_11.pl      Thai:     ISO-8859_11.
      unicode_8859_7.pl       Greek:    ISO-8859_7.
      unicode_big5.pl         Chinese:  BIG5.
      unicode_cp1251.pl       Russian:  CP1251.
      unicode_cp1256.pl       Arabic:   CP1256.
      unicode_cyrillic.pl     Russian:  Cyrillic.
      unicode_koi8r.pl        Russian:  KOI8-R.
      unicode_polish_utf8.pl  Polish :  UTF8.
      unicode_shift_jis.pl    Japanese: Shift JIS.
  
  
  
  
  =head1 LIMITATIONS
  
  The following limits are imposed by Excel 2007+:
  
      Description                             Limit
      --------------------------------------  ------
      Maximum number of chars in a string     32,767
      Maximum number of columns               16,384
      Maximum number of rows                  1,048,576
      Maximum chars in a sheet name           31
      Maximum chars in a header/footer        254
  
      Maximum characters in hyperlink url     255
      Maximum characters in hyperlink anchor  255
      Maximum number of unique hyperlinks*    65,530
  
  * Per worksheet. Excel allows a greater number of non-unique hyperlinks if they are contiguous and can be grouped into a single range. This will be supported in a later version of Excel::Writer::XLSX if possible.
  
  
  
  
  =head1 Compatibility with Spreadsheet::WriteExcel
  
  The C<Excel::Writer::XLSX> module is a drop-in replacement for C<Spreadsheet::WriteExcel>.
  
  It supports all of the features of Spreadsheet::WriteExcel with some minor differences noted below.
  
      Workbook Methods            Support
      ================            ======
      new()                       Yes
      add_worksheet()             Yes
      add_format()                Yes
      add_chart()                 Yes
      add_shape()                 Yes. Not in Spreadsheet::WriteExcel.
      add_vba_project()           Yes. Not in Spreadsheet::WriteExcel.
      close()                     Yes
      set_properties()            Yes
      define_name()               Yes
      set_tempdir()               Yes
      set_custom_color()          Yes
      sheets()                    Yes
      set_1904()                  Yes
      set_optimization()          Yes. Not required in Spreadsheet::WriteExcel.
      add_chart_ext()             Not supported. Not required in Excel::Writer::XLSX.
      compatibility_mode()        Deprecated. Not required in Excel::Writer::XLSX.
      set_codepage()              Deprecated. Not required in Excel::Writer::XLSX.
  
  
      Worksheet Methods           Support
      =================           =======
      write()                     Yes
      write_number()              Yes
      write_string()              Yes
      write_rich_string()         Yes. Not in Spreadsheet::WriteExcel.
      write_blank()               Yes
      write_row()                 Yes
      write_col()                 Yes
      write_date_time()           Yes
      write_url()                 Yes
      write_formula()             Yes
      write_array_formula()       Yes. Not in Spreadsheet::WriteExcel.
      keep_leading_zeros()        Yes
      write_comment()             Yes
      show_comments()             Yes
      set_comments_author()       Yes
      add_write_handler()         Yes
      insert_image()              Yes.
      insert_chart()              Yes
      insert_shape()              Yes. Not in Spreadsheet::WriteExcel.
      insert_button()             Yes. Not in Spreadsheet::WriteExcel.
      data_validation()           Yes
      conditional_formatting()    Yes. Not in Spreadsheet::WriteExcel.
      add_sparkline()             Yes. Not in Spreadsheet::WriteExcel.
      add_table()                 Yes. Not in Spreadsheet::WriteExcel.
      get_name()                  Yes
      activate()                  Yes
      select()                    Yes
      hide()                      Yes
      set_first_sheet()           Yes
      protect()                   Yes
      set_selection()             Yes
      set_row()                   Yes.
      set_column()                Yes.
      set_default_row()           Yes. Not in Spreadsheet::WriteExcel.
      outline_settings()          Yes
      freeze_panes()              Yes
      split_panes()               Yes
      merge_range()               Yes
      merge_range_type()          Yes. Not in Spreadsheet::WriteExcel.
      set_zoom()                  Yes
      right_to_left()             Yes
      hide_zero()                 Yes
      set_tab_color()             Yes
      autofilter()                Yes
      filter_column()             Yes
      filter_column_list()        Yes. Not in Spreadsheet::WriteExcel.
      write_utf16be_string()      Deprecated. Use Perl utf8 strings instead.
      write_utf16le_string()      Deprecated. Use Perl utf8 strings instead.
      store_formula()             Deprecated. See docs.
      repeat_formula()            Deprecated. See docs.
      write_url_range()           Not supported. Not required in Excel::Writer::XLSX.
  
      Page Set-up Methods         Support
      ===================         =======
      set_landscape()             Yes
      set_portrait()              Yes
      set_page_view()             Yes
      set_paper()                 Yes
      center_horizontally()       Yes
      center_vertically()         Yes
      set_margins()               Yes
      set_header()                Yes
      set_footer()                Yes
      repeat_rows()               Yes
      repeat_columns()            Yes
      hide_gridlines()            Yes
      print_row_col_headers()     Yes
      print_area()                Yes
      print_across()              Yes
      fit_to_pages()              Yes
      set_start_page()            Yes
      set_print_scale()           Yes
      set_h_pagebreaks()          Yes
      set_v_pagebreaks()          Yes
  
      Format Methods              Support
      ==============              =======
      set_font()                  Yes
      set_size()                  Yes
      set_color()                 Yes
      set_bold()                  Yes
      set_italic()                Yes
      set_underline()             Yes
      set_font_strikeout()        Yes
      set_font_script()           Yes
      set_font_outline()          Yes
      set_font_shadow()           Yes
      set_num_format()            Yes
      set_locked()                Yes
      set_hidden()                Yes
      set_align()                 Yes
      set_rotation()              Yes
      set_text_wrap()             Yes
      set_text_justlast()         Yes
      set_center_across()         Yes
      set_indent()                Yes
      set_shrink()                Yes
      set_pattern()               Yes
      set_bg_color()              Yes
      set_fg_color()              Yes
      set_border()                Yes
      set_bottom()                Yes
      set_top()                   Yes
      set_left()                  Yes
      set_right()                 Yes
      set_border_color()          Yes
      set_bottom_color()          Yes
      set_top_color()             Yes
      set_left_color()            Yes
      set_right_color()           Yes
  
  
  
  
  =head1 REQUIREMENTS
  
  L<http://search.cpan.org/search?dist=Archive-Zip/>.
  
  Perl 5.8.2.
  
  
  
  
  =head1 SPEED AND MEMORY USAGE
  
  C<Spreadsheet::WriteExcel> was written to optimise speed and reduce memory usage. However, these design goals meant that it wasn't easy to implement features that many users requested such as writing formatting and data separately.
  
  As a result C<Excel::Writer::XLSX> takes a different design approach and holds a lot more data in memory so that it is functionally more flexible.
  
  The effect of this is that Excel::Writer::XLSX is about 30% slower than Spreadsheet::WriteExcel and uses 5 times more memory.
  
  In addition the extended row and column ranges in Excel 2007+ mean that it is possible to run out of memory creating large files. This was almost never an issue with Spreadsheet::WriteExcel.
  
  This memory usage can be reduced almost completely by using the Workbook C<set_optimization()> method:
  
      $workbook->set_optimization();
  
  This also gives an increase in performance to within 1-10% of Spreadsheet::WriteExcel, see below.
  
  The trade-off is that you won't be able to take advantage of any new features that manipulate cell data after it is written. One such feature is Tables.
  
  
  =head2 Performance figures
  
  The performance figures below show execution speed and memory usage for 60 columns x N rows for a 50/50 mixture of strings and numbers. Percentage speeds are relative to Spreadsheet::WriteExcel.
  
      Excel::Writer::XLSX
           Rows  Time (s)    Memory (bytes)  Rel. Time
            400      0.66         6,586,254       129%
            800      1.26        13,099,422       125%
           1600      2.55        26,126,361       123%
           3200      5.16        52,211,284       125%
           6400     10.47       104,401,428       128%
          12800     21.48       208,784,519       131%
          25600     43.90       417,700,746       126%
          51200     88.52       835,900,298       126%
  
      Excel::Writer::XLSX + set_optimisation()
           Rows  Time (s)    Memory (bytes)  Rel. Time
            400      0.70            63,059       135%
            800      1.10            63,059       110%
           1600      2.30            63,062       111%
           3200      4.44            63,062       107%
           6400      8.91            63,062       109%
          12800     17.69            63,065       108%
          25600     35.15            63,065       101%
          51200     70.67            63,065       101%
  
      Spreadsheet::WriteExcel
           Rows  Time (s)    Memory (bytes)
            400      0.51         1,265,583
            800      1.01         2,424,855
           1600      2.07         4,743,400
           3200      4.14         9,411,139
           6400      8.20        18,766,915
          12800     16.39        37,478,468
          25600     34.72        75,044,423
          51200     70.21       150,543,431
  
  
  =head1 DOWNLOADING
  
  The latest version of this module is always available at: L<http://search.cpan.org/search?dist=Excel-Writer-XLSX/>.
  
  
  
  
  =head1 INSTALLATION
  
  The module can be installed using the standard Perl procedure:
  
              perl Makefile.PL
              make
              make test
              make install    # You may need to be sudo/root
  
  
  
  
  =head1 DIAGNOSTICS
  
  
  =over 4
  
  =item Filename required by Excel::Writer::XLSX->new()
  
  A filename must be given in the constructor.
  
  =item Can't open filename. It may be in use or protected.
  
  The file cannot be opened for writing. The directory that you are writing to may be protected or the file may be in use by another program.
  
  
  =item Can't call method "XXX" on an undefined value at someprogram.pl.
  
  On Windows this is usually caused by the file that you are trying to create clashing with a version that is already open and locked by Excel.
  
  =item The file you are trying to open 'file.xls' is in a different format than specified by the file extension.
  
  This warning occurs when you create an XLSX file but give it an xls extension.
  
  =back
  
  
  
  
  =head1 WRITING EXCEL FILES
  
  Depending on your requirements, background and general sensibilities you may prefer one of the following methods of getting data into Excel:
  
  =over 4
  
  =item * Spreadsheet::WriteExcel
  
  This module is the precursor to Excel::Writer::XLSX and uses the same interface. It produces files in the Excel Biff xls format that was used in Excel versions 97-2003. These files can still be read by Excel 2007 but have some limitations in relation to the number of rows and columns that the format supports.
  
  L<Spreadsheet::WriteExcel>.
  
  =item * Win32::OLE module and office automation
  
  This requires a Windows platform and an installed copy of Excel. This is the most powerful and complete method for interfacing with Excel.
  
  L<Win32::OLE>
  
  =item * CSV, comma separated variables or text
  
  Excel will open and automatically convert files with a C<csv> extension.
  
  To create CSV files refer to the L<Text::CSV_XS> module.
  
  
  =item * DBI with DBD::ADO or DBD::ODBC
  
  Excel files contain an internal index table that allows them to act like a database file. Using one of the standard Perl database modules you can connect to an Excel file as a database.
  
  
  =back
  
  For other Perl-Excel modules try the following search: L<http://search.cpan.org/search?mode=module&query=excel>.
  
  
  
  
  =head1 READING EXCEL FILES
  
  To read data from Excel files try:
  
  =over 4
  
  =item * Spreadsheet::XLSX
  
  A module for reading formatted or unformatted data form XLSX files.
  
  L<Spreadsheet::XLSX>
  
  =item * SimpleXlsx
  
  A lightweight module for reading data from XLSX files.
  
  L<SimpleXlsx>
  
  =item * Spreadsheet::ParseExcel
  
  This module can read  data from an Excel XLS file but it doesn't support the XLSX format.
  
  L<Spreadsheet::ParseExcel>
  
  =item * Win32::OLE module and office automation (reading)
  
  See above.
  
  =item * DBI with DBD::ADO or DBD::ODBC.
  
  See above.
  
  =back
  
  
  For other Perl-Excel modules try the following search: L<http://search.cpan.org/search?mode=module&query=excel>.
  
  
  =head1 BUGS
  
  =over
  
  =item * Memory usage is very high for large worksheets.
  
  If you run out of memory creating large worksheets use the C<set_optimization()> method. See L</SPEED AND MEMORY USAGE> for more information.
  
  =item * Perl packaging programs can't find chart modules.
  
  When using Excel::Writer::XLSX charts with Perl packagers such as PAR or Cava you should explicitly include the chart that you are trying to create in your C<use> statements. This isn't a bug as such but it might help someone from banging their head off a wall:
  
      ...
      use Excel::Writer::XLSX;
      use Excel::Writer::XLSX::Chart::Column;
      ...
  
  =back
  
  
  If you wish to submit a bug report run the C<bug_report.pl> program in the C<examples> directory of the distro.
  
  
  
  
  The bug tracker is on Github: L<https://github.com/jmcnamara/excel-writer-xlsx/issues>.
  
  
  =head1 TO DO
  
  The roadmap is as follows:
  
  =over 4
  
  =item * New separated data/formatting API to allow cells to be formatted after data is added.
  
  =item * More charting features.
  
  =back
  
  
  
  
  
  =head1 REPOSITORY
  
  The Excel::Writer::XLSX source code in host on github: L<http://github.com/jmcnamara/excel-writer-xlsx>.
  
  
  
  
  =head1 MAILING LIST
  
  There is a Google group for discussing and asking questions about Excel::Writer::XLSX. This is a good place to search to see if your question has been asked before:  L<http://groups.google.com/group/spreadsheet-writeexcel>.
  
  
  
  
  =head1 DONATIONS and SPONSORSHIP
  
  If you'd care to donate to the Excel::Writer::XLSX project or sponsor a new feature, you can do so via PayPal: L<http://tinyurl.com/7ayes>.
  
  
  
  
  =head1 SEE ALSO
  
  Spreadsheet::WriteExcel: L<http://search.cpan.org/dist/Spreadsheet-WriteExcel>.
  
  Spreadsheet::ParseExcel: L<http://search.cpan.org/dist/Spreadsheet-ParseExcel>.
  
  Spreadsheet::XLSX: L<http://search.cpan.org/dist/Spreadsheet-XLSX>.
  
  
  
  =head1 ACKNOWLEDGEMENTS
  
  
  The following people contributed to the debugging, testing or enhancement of Excel::Writer::XLSX:
  
  Rob Messer of IntelliSurvey gave me the initial prompt to port Spreadsheet::WriteExcel to the XLSX format. IntelliSurvey (L<http://www.intellisurvey.com>) also sponsored large files optimisations and the charting feature.
  
  Bariatric Advantage (L<http://www.bariatricadvantage.com>) sponsored work on chart formatting.
  
  Eric Johnson provided the ability to use secondary axes with charts.  Thanks to Foxtons (L<http://foxtons.co.uk>) for sponsoring this work.
  
  BuildFax (L<http://www.buildfax.com>) sponsored the Tables feature and the Chart point formatting feature.
  
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the software "as is" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the software is with you. Should the software prove defective, you assume the cost of all necessary servicing, repair, or correction.
  
  In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for damages, including any general, special, incidental, or consequential damages arising out of the use or inability to use the software (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the software to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
  
  
  
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
      Wilderness for miles, eyes so mild and wise
      Oasis child, born and so wild
      Don't I know you better than the rest
      All deception, all deception from you
  
      Any way you run, you run before us
      Black and white horse arching among us
      Any way you run, you run before us
      Black and white horse arching among us
  
        -- Beach House
  
  
  
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX

$fatpacked{"Excel/Writer/XLSX/Chart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART';
  package Excel::Writer::XLSX::Chart;
  
  ###############################################################################
  #
  # Chart - A class for writing Excel Charts.
  #
  #
  # Used in conjunction with Excel::Writer::XLSX.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Format;
  use Excel::Writer::XLSX::Package::XMLwriter;
  use Excel::Writer::XLSX::Utility qw(xl_cell_to_rowcol
    xl_rowcol_to_cell
    xl_col_to_name xl_range
    xl_range_formula
    quote_sheetname );
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # factory()
  #
  # Factory method for returning chart objects based on their class type.
  #
  sub factory {
  
      my $current_class  = shift;
      my $chart_subclass = shift;
  
      $chart_subclass = ucfirst lc $chart_subclass;
  
      my $module = "Excel::Writer::XLSX::Chart::" . $chart_subclass;
  
      eval "require $module";
  
      # TODO. Need to re-raise this error from Workbook::add_chart().
      die "Chart type '$chart_subclass' not supported in add_chart()\n" if $@;
  
      my $fh = undef;
      return $module->new( $fh, @_ );
  }
  
  
  ###############################################################################
  #
  # new()
  #
  # Default constructor for sub-classes.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_subtype}           = shift;
      $self->{_sheet_type}        = 0x0200;
      $self->{_orientation}       = 0x0;
      $self->{_series}            = [];
      $self->{_embedded}          = 0;
      $self->{_id}                = -1;
      $self->{_series_index}      = 0;
      $self->{_style_id}          = 2;
      $self->{_axis_ids}          = [];
      $self->{_axis2_ids}         = [];
      $self->{_cat_has_num_fmt}   = 0;
      $self->{_requires_category} = 0;
      $self->{_legend_position}   = 'right';
      $self->{_cat_axis_position} = 'b';
      $self->{_val_axis_position} = 'l';
      $self->{_formula_ids}       = {};
      $self->{_formula_data}      = [];
      $self->{_horiz_cat_axis}    = 0;
      $self->{_horiz_val_axis}    = 1;
      $self->{_protection}        = 0;
      $self->{_chartarea}         = {};
      $self->{_plotarea}          = {};
      $self->{_x_axis}            = {};
      $self->{_y_axis}            = {};
      $self->{_y2_axis}           = {};
      $self->{_x2_axis}           = {};
      $self->{_chart_name}        = '';
      $self->{_show_blanks}       = 'gap';
      $self->{_show_hidden_data}  = 0;
      $self->{_show_crosses}      = 1;
      $self->{_width}             = 480;
      $self->{_height}            = 288;
      $self->{_x_scale}           = 1;
      $self->{_y_scale}           = 1;
      $self->{_x_offset}          = 0;
      $self->{_y_offset}          = 0;
      $self->{_table}             = undef;
      $self->{_smooth_allowed}    = 0;
      $self->{_cross_between}     = 'between';
      $self->{_date_category}     = 0;
      $self->{_already_inserted}  = 0;
      $self->{_combined}          = undef;
      $self->{_is_secondary}      = 0;
  
      $self->{_label_positions}          = {};
      $self->{_label_position_default}   = '';
  
      bless $self, $class;
      $self->_set_default_properties();
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration();
  
      # Write the c:chartSpace element.
      $self->_write_chart_space();
  
      # Write the c:lang element.
      $self->_write_lang();
  
      # Write the c:style element.
      $self->_write_style();
  
      # Write the c:protection element.
      $self->_write_protection();
  
      # Write the c:chart element.
      $self->_write_chart();
  
      # Write the c:spPr element for the chartarea formatting.
      $self->_write_sp_pr( $self->{_chartarea} );
  
      # Write the c:printSettings element.
      $self->_write_print_settings() if $self->{_embedded};
  
      # Close the worksheet tag.
      $self->xml_end_tag( 'c:chartSpace' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # Public methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # add_series()
  #
  # Add a series and it's properties to a chart.
  #
  sub add_series {
  
      my $self = shift;
      my %arg  = @_;
  
      # Check that the required input has been specified.
      if ( !exists $arg{values} ) {
          croak "Must specify 'values' in add_series()";
      }
  
      if ( $self->{_requires_category} && !exists $arg{categories} ) {
          croak "Must specify 'categories' in add_series() for this chart type";
      }
  
      # Convert aref params into a formula string.
      my $values     = $self->_aref_to_formula( $arg{values} );
      my $categories = $self->_aref_to_formula( $arg{categories} );
  
      # Switch name and name_formula parameters if required.
      my ( $name, $name_formula ) =
        $self->_process_names( $arg{name}, $arg{name_formula} );
  
      # Get an id for the data equivalent to the range formula.
      my $cat_id  = $self->_get_data_id( $categories,   $arg{categories_data} );
      my $val_id  = $self->_get_data_id( $values,       $arg{values_data} );
      my $name_id = $self->_get_data_id( $name_formula, $arg{name_data} );
  
      # Set the line properties for the series.
      my $line = $self->_get_line_properties( $arg{line} );
  
      # Allow 'border' as a synonym for 'line' in bar/column style charts.
      if ( $arg{border} ) {
          $line = $self->_get_line_properties( $arg{border} );
      }
  
      # Set the fill properties for the series.
      my $fill = $self->_get_fill_properties( $arg{fill} );
  
      # Set the pattern properties for the series.
      my $pattern = $self->_get_pattern_properties( $arg{pattern} );
  
      # Set the gradient fill properties for the series.
      my $gradient = $self->_get_gradient_properties( $arg{gradient} );
  
      # Pattern fill overrides solid fill.
      if ( $pattern ) {
          $fill = undef;
      }
  
      # Gradient fill overrides solid and pattern fills.
      if ( $gradient ) {
          $pattern = undef;
          $fill    = undef;
      }
  
      # Set the marker properties for the series.
      my $marker = $self->_get_marker_properties( $arg{marker} );
  
      # Set the trendline properties for the series.
      my $trendline = $self->_get_trendline_properties( $arg{trendline} );
  
      # Set the line smooth property for the series.
      my $smooth = $arg{smooth};
  
      # Set the error bars properties for the series.
      my $y_error_bars = $self->_get_error_bars_properties( $arg{y_error_bars} );
      my $x_error_bars = $self->_get_error_bars_properties( $arg{x_error_bars} );
  
      # Set the point properties for the series.
      my $points = $self->_get_points_properties($arg{points});
  
      # Set the labels properties for the series.
      my $labels = $self->_get_labels_properties( $arg{data_labels} );
  
      # Set the "invert if negative" fill property.
      my $invert_if_neg = $arg{invert_if_negative};
  
      # Set the secondary axis properties.
      my $x2_axis = $arg{x2_axis};
      my $y2_axis = $arg{y2_axis};
  
      # Store secondary status for combined charts.
      if ($x2_axis || $y2_axis) {
          $self->{_is_secondary} = 1;
      }
  
      # Set the gap for Bar/Column charts.
      if ( defined $arg{gap} ) {
          if ($y2_axis) {
              $self->{_series_gap_2} = $arg{gap};
          }
          else {
              $self->{_series_gap_1} = $arg{gap};
          }
      }
  
      # Set the overlap for Bar/Column charts.
      if ( defined $arg{overlap} ) {
          if ($y2_axis) {
              $self->{_series_overlap_2} = $arg{overlap};
          }
          else {
              $self->{_series_overlap_1} = $arg{overlap};
          }
      }
  
      # Add the user supplied data to the internal structures.
      %arg = (
          _values        => $values,
          _categories    => $categories,
          _name          => $name,
          _name_formula  => $name_formula,
          _name_id       => $name_id,
          _val_data_id   => $val_id,
          _cat_data_id   => $cat_id,
          _line          => $line,
          _fill          => $fill,
          _pattern       => $pattern,
          _gradient      => $gradient,
          _marker        => $marker,
          _trendline     => $trendline,
          _smooth        => $smooth,
          _labels        => $labels,
          _invert_if_neg => $invert_if_neg,
          _x2_axis       => $x2_axis,
          _y2_axis       => $y2_axis,
          _points        => $points,
          _error_bars =>
            { _x_error_bars => $x_error_bars, _y_error_bars => $y_error_bars },
      );
  
  
      push @{ $self->{_series} }, \%arg;
  }
  
  
  ###############################################################################
  #
  # set_x_axis()
  #
  # Set the properties of the X-axis.
  #
  sub set_x_axis {
  
      my $self = shift;
  
      my $axis = $self->_convert_axis_args( $self->{_x_axis}, @_ );
  
      $self->{_x_axis} = $axis;
  }
  
  
  ###############################################################################
  #
  # set_y_axis()
  #
  # Set the properties of the Y-axis.
  #
  sub set_y_axis {
  
      my $self = shift;
  
      my $axis = $self->_convert_axis_args( $self->{_y_axis}, @_ );
  
      $self->{_y_axis} = $axis;
  }
  
  
  ###############################################################################
  #
  # set_x2_axis()
  #
  # Set the properties of the secondary X-axis.
  #
  sub set_x2_axis {
  
      my $self = shift;
  
      my $axis = $self->_convert_axis_args( $self->{_x2_axis}, @_ );
  
      $self->{_x2_axis} = $axis;
  }
  
  
  ###############################################################################
  #
  # set_y2_axis()
  #
  # Set the properties of the secondary Y-axis.
  #
  sub set_y2_axis {
  
      my $self = shift;
  
      my $axis = $self->_convert_axis_args( $self->{_y2_axis}, @_ );
  
      $self->{_y2_axis} = $axis;
  }
  
  
  ###############################################################################
  #
  # set_title()
  #
  # Set the properties of the chart title.
  #
  sub set_title {
  
      my $self = shift;
      my %arg  = @_;
  
      my ( $name, $name_formula ) =
        $self->_process_names( $arg{name}, $arg{name_formula} );
  
      my $data_id = $self->_get_data_id( $name_formula, $arg{data} );
  
      $self->{_title_name}    = $name;
      $self->{_title_formula} = $name_formula;
      $self->{_title_data_id} = $data_id;
  
      # Set the font properties if present.
      $self->{_title_font} = $self->_convert_font_args( $arg{name_font} );
  
      # Set the title layout.
      $self->{_title_layout} = $self->_get_layout_properties( $arg{layout}, 1 );
  
      # Set the title overlay option.
      $self->{_title_overlay} = $arg{overlay};
  
      # Set the no automatic title option.
      $self->{_title_none} = $arg{none};
  }
  
  
  ###############################################################################
  #
  # set_legend()
  #
  # Set the properties of the chart legend.
  #
  sub set_legend {
  
      my $self = shift;
      my %arg  = @_;
  
      $self->{_legend_position}      = $arg{position} || 'right';
      $self->{_legend_delete_series} = $arg{delete_series};
      $self->{_legend_font}          = $self->_convert_font_args( $arg{font} );
  
      # Set the legend layout.
      $self->{_legend_layout} = $self->_get_layout_properties( $arg{layout} );
  
      # Turn off the legend.
      if ( $arg{none} ) {
          $self->{_legend_position} = 'none';
      }
  }
  
  
  ###############################################################################
  #
  # set_plotarea()
  #
  # Set the properties of the chart plotarea.
  #
  sub set_plotarea {
  
      my $self = shift;
  
      # Convert the user defined properties to internal properties.
      $self->{_plotarea} = $self->_get_area_properties( @_ );
  }
  
  
  ###############################################################################
  #
  # set_chartarea()
  #
  # Set the properties of the chart chartarea.
  #
  sub set_chartarea {
  
      my $self = shift;
  
      # Convert the user defined properties to internal properties.
      $self->{_chartarea} = $self->_get_area_properties( @_ );
  }
  
  
  ###############################################################################
  #
  # set_style()
  #
  # Set on of the 48 built-in Excel chart styles. The default style is 2.
  #
  sub set_style {
  
      my $self = shift;
      my $style_id = defined $_[0] ? $_[0] : 2;
  
      if ( $style_id < 0 || $style_id > 48 ) {
          $style_id = 2;
      }
  
      $self->{_style_id} = $style_id;
  }
  
  
  ###############################################################################
  #
  # show_blanks_as()
  #
  # Set the option for displaying blank data in a chart. The default is 'gap'.
  #
  sub show_blanks_as {
  
      my $self   = shift;
      my $option = shift;
  
      return unless $option;
  
      my %valid = (
          gap  => 1,
          zero => 1,
          span => 1,
  
      );
  
      if ( !exists $valid{$option} ) {
          warn "Unknown show_blanks_as() option '$option'\n";
          return;
      }
  
      $self->{_show_blanks} = $option;
  }
  
  
  ###############################################################################
  #
  # show_hidden_data()
  #
  # Display data in hidden rows or columns.
  #
  sub show_hidden_data {
  
      my $self = shift;
  
      $self->{_show_hidden_data} = 1;
  }
  
  
  ###############################################################################
  #
  # set_size()
  #
  # Set dimensions or scale for the chart.
  #
  sub set_size {
  
      my $self = shift;
      my %args = @_;
  
      $self->{_width}    = $args{width}    if $args{width};
      $self->{_height}   = $args{height}   if $args{height};
      $self->{_x_scale}  = $args{x_scale}  if $args{x_scale};
      $self->{_y_scale}  = $args{y_scale}  if $args{y_scale};
      $self->{_x_offset} = $args{x_offset} if $args{x_offset};
      $self->{_y_offset} = $args{y_offset} if $args{y_offset};
  
  }
  
  # Backward compatibility with poorly chosen method name.
  *size = *set_size;
  
  
  ###############################################################################
  #
  # set_table()
  #
  # Set properties for an axis data table.
  #
  sub set_table {
  
      my $self = shift;
      my %args = @_;
  
      my %table = (
          _horizontal => 1,
          _vertical   => 1,
          _outline    => 1,
          _show_keys  => 0,
      );
  
      $table{_horizontal} = $args{horizontal} if defined $args{horizontal};
      $table{_vertical}   = $args{vertical}   if defined $args{vertical};
      $table{_outline}    = $args{outline}    if defined $args{outline};
      $table{_show_keys}  = $args{show_keys}  if defined $args{show_keys};
  
      $self->{_table} = \%table;
  }
  
  
  ###############################################################################
  #
  # set_up_down_bars()
  #
  # Set properties for the chart up-down bars.
  #
  sub set_up_down_bars {
  
      my $self = shift;
      my %args = @_;
  
      # Map border to line.
      if ( defined $args{up}->{border} ) {
          $args{up}->{line} = $args{up}->{border};
      }
      if ( defined $args{down}->{border} ) {
          $args{down}->{line} = $args{down}->{border};
      }
  
      # Set the up and down bar properties.
      my $up_line   = $self->_get_line_properties( $args{up}->{line} );
      my $down_line = $self->_get_line_properties( $args{down}->{line} );
      my $up_fill   = $self->_get_fill_properties( $args{up}->{fill} );
      my $down_fill = $self->_get_fill_properties( $args{down}->{fill} );
  
      $self->{_up_down_bars} = {
          _up => {
              _line => $up_line,
              _fill => $up_fill,
          },
          _down => {
              _line => $down_line,
              _fill => $down_fill,
          },
      };
  }
  
  
  ###############################################################################
  #
  # set_drop_lines()
  #
  # Set properties for the chart drop lines.
  #
  sub set_drop_lines {
  
      my $self = shift;
      my %args = @_;
  
      # Set the drop line properties.
      my $line = $self->_get_line_properties( $args{line} );
  
      $self->{_drop_lines} = { _line => $line };
  }
  
  
  ###############################################################################
  #
  # set_high_low_lines()
  #
  # Set properties for the chart high-low lines.
  #
  sub set_high_low_lines {
  
      my $self = shift;
      my %args = @_;
  
      # Set the drop line properties.
      my $line = $self->_get_line_properties( $args{line} );
  
      $self->{_hi_low_lines} = { _line => $line };
  }
  
  
  ###############################################################################
  #
  # combine()
  #
  # Add another chart to create a combined chart.
  #
  sub combine {
  
      my $self  = shift;
      my $chart = shift;
  
      $self->{_combined} = $chart;
  }
  
  
  ###############################################################################
  #
  # Internal methods. The following section of methods are used for the internal
  # structuring of the Chart object and file format.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _convert_axis_args()
  #
  # Convert user defined axis values into private hash values.
  #
  sub _convert_axis_args {
  
      my $self = shift;
      my $axis = shift;
      my %arg  = ( %{ $axis->{_defaults} }, @_ );
  
      my ( $name, $name_formula ) =
        $self->_process_names( $arg{name}, $arg{name_formula} );
  
      my $data_id = $self->_get_data_id( $name_formula, $arg{data} );
  
      $axis = {
          _defaults          => $axis->{_defaults},
          _name              => $name,
          _formula           => $name_formula,
          _data_id           => $data_id,
          _reverse           => $arg{reverse},
          _min               => $arg{min},
          _max               => $arg{max},
          _minor_unit        => $arg{minor_unit},
          _major_unit        => $arg{major_unit},
          _minor_unit_type   => $arg{minor_unit_type},
          _major_unit_type   => $arg{major_unit_type},
          _log_base          => $arg{log_base},
          _crossing          => $arg{crossing},
          _position_axis     => $arg{position_axis},
          _position          => $arg{position},
          _label_position    => $arg{label_position},
          _num_format        => $arg{num_format},
          _num_format_linked => $arg{num_format_linked},
          _interval_unit     => $arg{interval_unit},
          _interval_tick     => $arg{interval_tick},
          _visible           => defined $arg{visible} ? $arg{visible} : 1,
          _text_axis         => 0,
      };
  
      # Map major_gridlines properties.
      if ( $arg{major_gridlines} && $arg{major_gridlines}->{visible} ) {
          $axis->{_major_gridlines} =
            $self->_get_gridline_properties( $arg{major_gridlines} );
      }
  
      # Map minor_gridlines properties.
      if ( $arg{minor_gridlines} && $arg{minor_gridlines}->{visible} ) {
          $axis->{_minor_gridlines} =
            $self->_get_gridline_properties( $arg{minor_gridlines} );
      }
  
      # Convert the display units.
      $axis->{_display_units} = $self->_get_display_units( $arg{display_units} );
      if ( defined $arg{display_units_visible} ) {
          $axis->{_display_units_visible} = $arg{display_units_visible};
      }
      else {
          $axis->{_display_units_visible} = 1;
      }
  
      # Only use the first letter of bottom, top, left or right.
      if ( defined $axis->{_position} ) {
          $axis->{_position} = substr lc $axis->{_position}, 0, 1;
      }
  
      # Set the position for a category axis on or between the tick marks.
      if ( defined $axis->{_position_axis} ) {
          if ( $axis->{_position_axis} eq 'on_tick' ) {
              $axis->{_position_axis} = 'midCat';
          }
          elsif ( $axis->{_position_axis} eq 'between' ) {
  
              # Doesn't need to be modified.
          }
          else {
              # Otherwise use the default value.
              $axis->{_position_axis} = undef;
          }
      }
  
      # Set the category axis as a date axis.
      if ( $arg{date_axis} ) {
          $self->{_date_category} = 1;
      }
  
      # Set the category axis as a text axis.
      if ( $arg{text_axis} ) {
          $self->{_date_category} = 0;
          $axis->{_text_axis} = 1;
      }
  
  
      # Set the font properties if present.
      $axis->{_num_font}  = $self->_convert_font_args( $arg{num_font} );
      $axis->{_name_font} = $self->_convert_font_args( $arg{name_font} );
  
      # Set the axis name layout.
      $axis->{_layout} = $self->_get_layout_properties( $arg{name_layout}, 1 );
  
      # Set the line properties for the axis.
      $axis->{_line} = $self->_get_line_properties( $arg{line} );
  
      # Set the fill properties for the axis.
      $axis->{_fill} = $self->_get_fill_properties( $arg{fill} );
  
      # Set the tick marker types.
      $axis->{_minor_tick_mark} = $self->_get_tick_type($arg{minor_tick_mark});
      $axis->{_major_tick_mark} = $self->_get_tick_type($arg{major_tick_mark});
  
  
      return $axis;
  }
  
  
  ###############################################################################
  #
  # _convert_fonts_args()
  #
  # Convert user defined font values into private hash values.
  #
  sub _convert_font_args {
  
      my $self = shift;
      my $args = shift;
  
      return unless $args;
  
      my $font = {
          _name         => $args->{name},
          _color        => $args->{color},
          _size         => $args->{size},
          _bold         => $args->{bold},
          _italic       => $args->{italic},
          _underline    => $args->{underline},
          _pitch_family => $args->{pitch_family},
          _charset      => $args->{charset},
          _baseline     => $args->{baseline} || 0,
          _rotation     => $args->{rotation},
      };
  
      # Convert font size units.
      $font->{_size} *= 100 if $font->{_size};
  
      # Convert rotation into 60,000ths of a degree.
      if ( $font->{_rotation} ) {
          $font->{_rotation} = 60_000 * int( $font->{_rotation} );
      }
  
      return $font;
  }
  
  
  ###############################################################################
  #
  # _aref_to_formula()
  #
  # Convert and aref of row col values to a range formula.
  #
  sub _aref_to_formula {
  
      my $self = shift;
      my $data = shift;
  
      # If it isn't an array ref it is probably a formula already.
      return $data if !ref $data;
  
      my $formula = xl_range_formula( @$data );
  
      return $formula;
  }
  
  
  ###############################################################################
  #
  # _process_names()
  #
  # Switch name and name_formula parameters if required.
  #
  sub _process_names {
  
      my $self         = shift;
      my $name         = shift;
      my $name_formula = shift;
  
      if ( defined $name ) {
  
          if ( ref $name eq 'ARRAY' ) {
              my $cell = xl_rowcol_to_cell( $name->[1], $name->[2], 1, 1 );
              $name_formula = quote_sheetname( $name->[0] ) . '!' . $cell;
              $name         = '';
          }
          elsif ( $name =~ m/^=[^!]+!\$/ ) {
  
              # Name looks like a formula, use it to set name_formula.
              $name_formula = $name;
              $name         = '';
          }
      }
  
      return ( $name, $name_formula );
  }
  
  
  ###############################################################################
  #
  # _get_data_type()
  #
  # Find the overall type of the data associated with a series.
  #
  # TODO. Need to handle date type.
  #
  sub _get_data_type {
  
      my $self = shift;
      my $data = shift;
  
      # Check for no data in the series.
      return 'none' if !defined $data;
      return 'none' if @$data == 0;
  
      if (ref $data->[0] eq 'ARRAY') {
          return 'multi_str'
      }
  
      # If the token isn't a number assume it is a string.
      for my $token ( @$data ) {
          next if !defined $token;
          return 'str'
            if $token !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
      }
  
      # The series data was all numeric.
      return 'num';
  }
  
  
  ###############################################################################
  #
  # _get_data_id()
  #
  # Assign an id to a each unique series formula or title/axis formula. Repeated
  # formulas such as for categories get the same id. If the series or title
  # has user specified data associated with it then that is also stored. This
  # data is used to populate cached Excel data when creating a chart.
  # If there is no user defined data then it will be populated by the parent
  # workbook in Workbook::_add_chart_data()
  #
  sub _get_data_id {
  
      my $self    = shift;
      my $formula = shift;
      my $data    = shift;
      my $id;
  
      # Ignore series without a range formula.
      return unless $formula;
  
      # Strip the leading '=' from the formula.
      $formula =~ s/^=//;
  
      # Store the data id in a hash keyed by the formula and store the data
      # in a separate array with the same id.
      if ( !exists $self->{_formula_ids}->{$formula} ) {
  
          # Haven't seen this formula before.
          $id = @{ $self->{_formula_data} };
  
          push @{ $self->{_formula_data} }, $data;
          $self->{_formula_ids}->{$formula} = $id;
      }
      else {
  
          # Formula already seen. Return existing id.
          $id = $self->{_formula_ids}->{$formula};
  
          # Store user defined data if it isn't already there.
          if ( !defined $self->{_formula_data}->[$id] ) {
              $self->{_formula_data}->[$id] = $data;
          }
      }
  
      return $id;
  }
  
  
  ###############################################################################
  #
  # _get_color()
  #
  # Convert the user specified colour index or string to a rgb colour.
  #
  sub _get_color {
  
      my $self  = shift;
      my $color = shift;
  
      # Convert a HTML style #RRGGBB color.
      if ( defined $color and $color =~ /^#[0-9a-fA-F]{6}$/ ) {
          $color =~ s/^#//;
          return uc $color;
      }
  
      my $index = &Excel::Writer::XLSX::Format::_get_color( $color );
  
      # Set undefined colors to black.
      if ( !$index ) {
          $index = 0x08;
          warn "Unknown color '$color' used in chart formatting. "
            . "Converting to black.\n";
      }
  
      return $self->_get_palette_color( $index );
  }
  
  
  ###############################################################################
  #
  # _get_palette_color()
  #
  # Convert from an Excel internal colour index to a XML style #RRGGBB index
  # based on the default or user defined values in the Workbook palette.
  # Note: This version doesn't add an alpha channel.
  #
  sub _get_palette_color {
  
      my $self    = shift;
      my $index   = shift;
      my $palette = $self->{_palette};
  
      # Adjust the colour index.
      $index -= 8;
  
      # Palette is passed in from the Workbook class.
      my @rgb = @{ $palette->[$index] };
  
      return sprintf "%02X%02X%02X", @rgb[0, 1, 2];
  }
  
  
  ###############################################################################
  #
  # _get_swe_line_pattern()
  #
  # Get the Spreadsheet::WriteExcel line pattern for backward compatibility.
  #
  sub _get_swe_line_pattern {
  
      my $self    = shift;
      my $value   = lc shift;
      my $default = 'solid';
      my $pattern;
  
      my %patterns = (
          0              => 'solid',
          1              => 'dash',
          2              => 'dot',
          3              => 'dash_dot',
          4              => 'long_dash_dot_dot',
          5              => 'none',
          6              => 'solid',
          7              => 'solid',
          8              => 'solid',
          'solid'        => 'solid',
          'dash'         => 'dash',
          'dot'          => 'dot',
          'dash-dot'     => 'dash_dot',
          'dash-dot-dot' => 'long_dash_dot_dot',
          'none'         => 'none',
          'dark-gray'    => 'solid',
          'medium-gray'  => 'solid',
          'light-gray'   => 'solid',
      );
  
      if ( exists $patterns{$value} ) {
          $pattern = $patterns{$value};
      }
      else {
          $pattern = $default;
      }
  
      return $pattern;
  }
  
  
  ###############################################################################
  #
  # _get_swe_line_weight()
  #
  # Get the Spreadsheet::WriteExcel line weight for backward compatibility.
  #
  sub _get_swe_line_weight {
  
      my $self    = shift;
      my $value   = lc shift;
      my $default = 1;
      my $weight;
  
      my %weights = (
          1          => 0.25,
          2          => 1,
          3          => 2,
          4          => 3,
          'hairline' => 0.25,
          'narrow'   => 1,
          'medium'   => 2,
          'wide'     => 3,
      );
  
      if ( exists $weights{$value} ) {
          $weight = $weights{$value};
      }
      else {
          $weight = $default;
      }
  
      return $weight;
  }
  
  
  ###############################################################################
  #
  # _get_line_properties()
  #
  # Convert user defined line properties to the structure required internally.
  #
  sub _get_line_properties {
  
      my $self = shift;
      my $line = shift;
  
      return { _defined => 0 } unless $line;
  
      # Copy the user supplied properties.
      $line = { %$line };
  
      my %dash_types = (
          solid               => 'solid',
          round_dot           => 'sysDot',
          square_dot          => 'sysDash',
          dash                => 'dash',
          dash_dot            => 'dashDot',
          long_dash           => 'lgDash',
          long_dash_dot       => 'lgDashDot',
          long_dash_dot_dot   => 'lgDashDotDot',
          dot                 => 'dot',
          system_dash_dot     => 'sysDashDot',
          system_dash_dot_dot => 'sysDashDotDot',
      );
  
      # Check the dash type.
      my $dash_type = $line->{dash_type};
  
      if ( defined $dash_type ) {
          if ( exists $dash_types{$dash_type} ) {
              $line->{dash_type} = $dash_types{$dash_type};
          }
          else {
              warn "Unknown dash type '$dash_type'\n";
              return;
          }
      }
  
      $line->{_defined} = 1;
  
      return $line;
  }
  
  
  ###############################################################################
  #
  # _get_fill_properties()
  #
  # Convert user defined fill properties to the structure required internally.
  #
  sub _get_fill_properties {
  
      my $self = shift;
      my $fill = shift;
  
      return { _defined => 0 } unless $fill;
  
      $fill->{_defined} = 1;
  
      return $fill;
  }
  
  
  ###############################################################################
  #
  # _get_pattern_properties()
  #
  # Convert user defined pattern properties to the structure required internally.
  #
  sub _get_pattern_properties {
  
      my $self    = shift;
      my $args    = shift;
      my $pattern = {};
  
      return unless $args;
  
      # Check the pattern type is present.
      if ( !$args->{pattern} ) {
          carp "Pattern must include 'pattern'";
          return;
      }
  
      # Check the foreground color is present.
      if ( !$args->{fg_color} ) {
          carp "Pattern must include 'fg_color'";
          return;
      }
  
      my %types = (
          'percent_5'                 => 'pct5',
          'percent_10'                => 'pct10',
          'percent_20'                => 'pct20',
          'percent_25'                => 'pct25',
          'percent_30'                => 'pct30',
          'percent_40'                => 'pct40',
  
          'percent_50'                => 'pct50',
          'percent_60'                => 'pct60',
          'percent_70'                => 'pct70',
          'percent_75'                => 'pct75',
          'percent_80'                => 'pct80',
          'percent_90'                => 'pct90',
  
          'light_downward_diagonal'   => 'ltDnDiag',
          'light_upward_diagonal'     => 'ltUpDiag',
          'dark_downward_diagonal'    => 'dkDnDiag',
          'dark_upward_diagonal'      => 'dkUpDiag',
          'wide_downward_diagonal'    => 'wdDnDiag',
          'wide_upward_diagonal'      => 'wdUpDiag',
  
          'light_vertical'            => 'ltVert',
          'light_horizontal'          => 'ltHorz',
          'narrow_vertical'           => 'narVert',
          'narrow_horizontal'         => 'narHorz',
          'dark_vertical'             => 'dkVert',
          'dark_horizontal'           => 'dkHorz',
  
          'dashed_downward_diagonal'  => 'dashDnDiag',
          'dashed_upward_diagonal'    => 'dashUpDiag',
          'dashed_horizontal'         => 'dashHorz',
          'dashed_vertical'           => 'dashVert',
          'small_confetti'            => 'smConfetti',
          'large_confetti'            => 'lgConfetti',
  
          'zigzag'                    => 'zigZag',
          'wave'                      => 'wave',
          'diagonal_brick'            => 'diagBrick',
          'horizontal_brick'          => 'horzBrick',
          'weave'                     => 'weave',
          'plaid'                     => 'plaid',
  
          'divot'                     => 'divot',
          'dotted_grid'               => 'dotGrid',
          'dotted_diamond'            => 'dotDmnd',
          'shingle'                   => 'shingle',
          'trellis'                   => 'trellis',
          'sphere'                    => 'sphere',
  
          'small_grid'                => 'smGrid',
          'large_grid'                => 'lgGrid',
          'small_check'               => 'smCheck',
          'large_check'               => 'lgCheck',
          'outlined_diamond'          => 'openDmnd',
          'solid_diamond'             => 'solidDmnd',
      );
  
      # Check for valid types.
      my $pattern_type = $args->{pattern};
  
      if ( exists $types{$pattern_type} ) {
          $pattern->{pattern} = $types{$pattern_type};
      }
      else {
          carp "Unknown pattern type '$pattern_type'";
          return;
      }
  
      # Specify a default background color.
      if ( !$args->{bg_color} ) {
          $pattern->{bg_color} = '#FFFFFF';
      }
      else {
          $pattern->{bg_color} = $args->{bg_color};
      }
  
      $pattern->{fg_color} = $args->{fg_color};
  
      return $pattern;
  }
  
  
  ###############################################################################
  #
  # _get_gradient_properties()
  #
  # Convert user defined gradient to the structure required internally.
  #
  sub _get_gradient_properties {
  
      my $self     = shift;
      my $args     = shift;
      my $gradient = {};
  
      my %types    = (
          linear      => 'linear',
          radial      => 'circle',
          rectangular => 'rect',
          path        => 'shape'
      );
  
      return unless $args;
  
      # Check the colors array exists and is valid.
      if ( !$args->{colors} || ref $args->{colors} ne 'ARRAY' ) {
          carp "Gradient must include colors array";
          return;
      }
  
      # Check the colors array has the required number of entries.
      if ( @{ $args->{colors} } < 2 ) {
          carp "Gradient colors array must at least 2 values";
          return;
      }
  
      $gradient->{_colors} = $args->{colors};
  
      if ( $args->{positions} ) {
  
          # Check the positions array has the right number of entries.
          if ( @{ $args->{positions} } != @{ $args->{colors} } ) {
              carp "Gradient positions not equal to number of colors";
              return;
          }
  
          # Check the positions are in the correct range.
          for my $pos ( @{ $args->{positions} } ) {
              if ( $pos < 0 || $pos > 100 ) {
                  carp "Gradient position '", $pos,
                    "' must be in range 0 <= pos <= 100";
                  return;
              }
          }
  
          $gradient->{_positions} = $args->{positions};
      }
      else {
          # Use the default gradient positions.
          if ( @{ $args->{colors} } == 2 ) {
              $gradient->{_positions} = [ 0, 100 ];
          }
          elsif ( @{ $args->{colors} } == 3 ) {
              $gradient->{_positions} = [ 0, 50, 100 ];
          }
          elsif ( @{ $args->{colors} } == 4 ) {
              $gradient->{_positions} = [ 0, 33, 66, 100 ];
          }
          else {
              carp "Must specify gradient positions";
              return;
          }
      }
  
      # Set the gradient angle.
      if ( defined $args->{angle} ) {
          my $angle = $args->{angle};
  
          if ( $angle < 0 || $angle > 359.9 ) {
              carp "Gradient angle '", $angle,
                "' must be in range 0 <= pos < 360";
              return;
          }
          $gradient->{_angle} = $angle;
      }
      else {
          $gradient->{_angle} = 90;
      }
  
      # Set the gradient type.
      if ( defined $args->{type} ) {
          my $type = $args->{type};
  
          if ( !exists $types{$type} ) {
              carp "Unknown gradient type '", $type, "'";
              return;
          }
          $gradient->{_type} = $types{$type};
      }
      else {
          $gradient->{_type} = 'linear';
      }
  
      return $gradient;
  }
  
  
  ###############################################################################
  #
  # _get_marker_properties()
  #
  # Convert user defined marker properties to the structure required internally.
  #
  sub _get_marker_properties {
  
      my $self   = shift;
      my $marker = shift;
  
      return if !$marker && ref $marker ne 'HASH';
  
      # Copy the user supplied properties.
      $marker = { %$marker };
  
      my %types = (
          automatic  => 'automatic',
          none       => 'none',
          square     => 'square',
          diamond    => 'diamond',
          triangle   => 'triangle',
          x          => 'x',
          star       => 'star',
          dot        => 'dot',
          short_dash => 'dot',
          dash       => 'dash',
          long_dash  => 'dash',
          circle     => 'circle',
          plus       => 'plus',
          picture    => 'picture',
      );
  
      # Check for valid types.
      my $marker_type = $marker->{type};
  
      if ( defined $marker_type ) {
          if ( $marker_type eq 'automatic' ) {
              $marker->{automatic} = 1;
          }
  
          if ( exists $types{$marker_type} ) {
              $marker->{type} = $types{$marker_type};
          }
          else {
              warn "Unknown marker type '$marker_type'\n";
              return;
          }
      }
  
      # Set the line properties for the marker..
      my $line = $self->_get_line_properties( $marker->{line} );
  
      # Allow 'border' as a synonym for 'line'.
      if ( $marker->{border} ) {
          $line = $self->_get_line_properties( $marker->{border} );
      }
  
      # Set the fill properties for the marker.
      my $fill = $self->_get_fill_properties( $marker->{fill} );
  
      # Set the pattern properties for the series.
      my $pattern = $self->_get_pattern_properties( $marker->{pattern} );
  
      # Set the gradient fill properties for the series.
      my $gradient = $self->_get_gradient_properties( $marker->{gradient} );
  
      # Pattern fill overrides solid fill.
      if ( $pattern ) {
          $fill = undef;
      }
  
      # Gradient fill overrides solid and pattern fills.
      if ( $gradient ) {
          $pattern = undef;
          $fill    = undef;
      }
  
      $marker->{_line}     = $line;
      $marker->{_fill}     = $fill;
      $marker->{_pattern}  = $pattern;
      $marker->{_gradient} = $gradient;
  
      return $marker;
  }
  
  
  ###############################################################################
  #
  # _get_trendline_properties()
  #
  # Convert user defined trendline properties to the structure required
  # internally.
  #
  sub _get_trendline_properties {
  
      my $self      = shift;
      my $trendline = shift;
  
      return if !$trendline && ref $trendline ne 'HASH';
  
      # Copy the user supplied properties.
      $trendline = { %$trendline };
  
      my %types = (
          exponential    => 'exp',
          linear         => 'linear',
          log            => 'log',
          moving_average => 'movingAvg',
          polynomial     => 'poly',
          power          => 'power',
      );
  
      # Check the trendline type.
      my $trend_type = $trendline->{type};
  
      if ( exists $types{$trend_type} ) {
          $trendline->{type} = $types{$trend_type};
      }
      else {
          warn "Unknown trendline type '$trend_type'\n";
          return;
      }
  
      # Set the line properties for the trendline..
      my $line = $self->_get_line_properties( $trendline->{line} );
  
      # Allow 'border' as a synonym for 'line'.
      if ( $trendline->{border} ) {
          $line = $self->_get_line_properties( $trendline->{border} );
      }
  
      # Set the fill properties for the trendline.
      my $fill = $self->_get_fill_properties( $trendline->{fill} );
  
      # Set the pattern properties for the series.
      my $pattern = $self->_get_pattern_properties( $trendline->{pattern} );
  
      # Set the gradient fill properties for the series.
      my $gradient = $self->_get_gradient_properties( $trendline->{gradient} );
  
      # Pattern fill overrides solid fill.
      if ( $pattern ) {
          $fill = undef;
      }
  
      # Gradient fill overrides solid and pattern fills.
      if ( $gradient ) {
          $pattern = undef;
          $fill    = undef;
      }
  
      $trendline->{_line}     = $line;
      $trendline->{_fill}     = $fill;
      $trendline->{_pattern}  = $pattern;
      $trendline->{_gradient} = $gradient;
  
      return $trendline;
  }
  
  
  ###############################################################################
  #
  # _get_error_bars_properties()
  #
  # Convert user defined error bars properties to structure required internally.
  #
  sub _get_error_bars_properties {
  
      my $self = shift;
      my $args = shift;
  
      return if !$args && ref $args ne 'HASH';
  
      # Copy the user supplied properties.
      $args = { %$args };
  
  
      # Default values.
      my $error_bars = {
          _type         => 'fixedVal',
          _value        => 1,
          _endcap       => 1,
          _direction    => 'both',
          _plus_values  => [1],
          _minus_values => [1],
          _plus_data    => [],
          _minus_data   => [],
      };
  
      my %types = (
          fixed              => 'fixedVal',
          percentage         => 'percentage',
          standard_deviation => 'stdDev',
          standard_error     => 'stdErr',
          custom             => 'cust',
      );
  
      # Check the error bars type.
      my $error_type = $args->{type};
  
      if ( exists $types{$error_type} ) {
          $error_bars->{_type} = $types{$error_type};
      }
      else {
          warn "Unknown error bars type '$error_type'\n";
          return;
      }
  
      # Set the value for error types that require it.
      if ( defined $args->{value} ) {
          $error_bars->{_value} = $args->{value};
      }
  
      # Set the end-cap style.
      if ( defined $args->{end_style} ) {
          $error_bars->{_endcap} = $args->{end_style};
      }
  
      # Set the error bar direction.
      if ( defined $args->{direction} ) {
          if ( $args->{direction} eq 'minus' ) {
              $error_bars->{_direction} = 'minus';
          }
          elsif ( $args->{direction} eq 'plus' ) {
              $error_bars->{_direction} = 'plus';
          }
          else {
              # Default to 'both'.
          }
      }
  
      # Set any custom values.
      if ( defined $args->{plus_values} ) {
          $error_bars->{_plus_values} = $args->{plus_values};
      }
      if ( defined $args->{minus_values} ) {
          $error_bars->{_minus_values} = $args->{minus_values};
      }
      if ( defined $args->{plus_data} ) {
          $error_bars->{_plus_data} = $args->{plus_data};
      }
      if ( defined $args->{minus_data} ) {
          $error_bars->{_minus_data} = $args->{minus_data};
      }
  
      # Set the line properties for the error bars.
      $error_bars->{_line} = $self->_get_line_properties( $args->{line} );
  
      return $error_bars;
  }
  
  
  ###############################################################################
  #
  # _get_gridline_properties()
  #
  # Convert user defined gridline properties to the structure required internally.
  #
  sub _get_gridline_properties {
  
      my $self = shift;
      my $args = shift;
      my $gridline;
  
      # Set the visible property for the gridline.
      $gridline->{_visible} = $args->{visible};
  
      # Set the line properties for the gridline..
      $gridline->{_line} = $self->_get_line_properties( $args->{line} );
  
      return $gridline;
  }
  
  
  ###############################################################################
  #
  # _get_labels_properties()
  #
  # Convert user defined labels properties to the structure required internally.
  #
  sub _get_labels_properties {
  
      my $self   = shift;
      my $labels = shift;
  
      return if !$labels && ref $labels ne 'HASH';
  
      # Copy the user supplied properties.
      $labels = { %$labels };
  
      # Map user defined label positions to Excel positions.
      if ( my $position = $labels->{position} ) {
  
          if ( exists $self->{_label_positions}->{$position} ) {
              if ($position eq $self->{_label_position_default}) {
                  $labels->{position} = undef;
              }
              else {
                  $labels->{position} = $self->{_label_positions}->{$position};
              }
          }
          else {
              carp "Unsupported label position '$position' for this chart type";
              return undef
          }
      }
  
      # Map the user defined label separator to the Excel separator.
      if ( my $separator = $labels->{separator} ) {
  
          my %separators = (
              ','  => ', ',
              ';'  => '; ',
              '.'  => '. ',
              "\n" => "\n",
              ' '  => ' '
          );
  
          if ( exists $separators{$separator} ) {
              $labels->{separator} = $separators{$separator};
          }
          else {
              carp "Unsupported label separator";
              return undef
          }
      }
  
      if ($labels->{font}) {
          $labels->{font} = $self->_convert_font_args( $labels->{font} );
      }
  
      return $labels;
  }
  
  
  ###############################################################################
  #
  # _get_area_properties()
  #
  # Convert user defined area properties to the structure required internally.
  #
  sub _get_area_properties {
  
      my $self = shift;
      my %arg  = @_;
      my $area = {};
  
  
      # Map deprecated Spreadsheet::WriteExcel fill colour.
      if ( $arg{color} ) {
          $arg{fill}->{color} = $arg{color};
      }
  
      # Map deprecated Spreadsheet::WriteExcel line_weight.
      if ( $arg{line_weight} ) {
          my $width = $self->_get_swe_line_weight( $arg{line_weight} );
          $arg{border}->{width} = $width;
      }
  
      # Map deprecated Spreadsheet::WriteExcel line_pattern.
      if ( $arg{line_pattern} ) {
          my $pattern = $self->_get_swe_line_pattern( $arg{line_pattern} );
  
          if ( $pattern eq 'none' ) {
              $arg{border}->{none} = 1;
          }
          else {
              $arg{border}->{dash_type} = $pattern;
          }
      }
  
      # Map deprecated Spreadsheet::WriteExcel line colour.
      if ( $arg{line_color} ) {
          $arg{border}->{color} = $arg{line_color};
      }
  
  
      # Handle Excel::Writer::XLSX style properties.
  
      # Set the line properties for the chartarea.
      my $line = $self->_get_line_properties( $arg{line} );
  
      # Allow 'border' as a synonym for 'line'.
      if ( $arg{border} ) {
          $line = $self->_get_line_properties( $arg{border} );
      }
  
      # Set the fill properties for the chartarea.
      my $fill = $self->_get_fill_properties( $arg{fill} );
  
      # Set the pattern properties for the series.
      my $pattern = $self->_get_pattern_properties( $arg{pattern} );
  
      # Set the gradient fill properties for the series.
      my $gradient = $self->_get_gradient_properties( $arg{gradient} );
  
      # Pattern fill overrides solid fill.
      if ( $pattern ) {
          $fill = undef;
      }
  
      # Gradient fill overrides solid and pattern fills.
      if ( $gradient ) {
          $pattern = undef;
          $fill    = undef;
      }
  
      # Set the plotarea layout.
      my $layout = $self->_get_layout_properties( $arg{layout} );
  
      $area->{_line}     = $line;
      $area->{_fill}     = $fill;
      $area->{_pattern}  = $pattern;
      $area->{_gradient} = $gradient;
      $area->{_layout}   = $layout;
  
      return $area;
  }
  
  
  ###############################################################################
  #
  # _get_layout_properties()
  #
  # Convert user defined layout properties to the format required internally.
  #
  sub _get_layout_properties {
  
      my $self    = shift;
      my $args    = shift;
      my $is_text = shift;
      my $layout  = {};
      my @properties;
      my %allowable;
  
      return if !$args;
  
      if ( $is_text ) {
          @properties = ( 'x', 'y' );
      }
      else {
          @properties = ( 'x', 'y', 'width', 'height' );
      }
  
      # Check for valid properties.
      @allowable{@properties} = undef;
  
      for my $key ( keys %$args ) {
  
          if ( !exists $allowable{$key} ) {
              warn "Property '$key' not allowed in layout options\n";
              return;
          }
      }
  
      # Set the layout properties.
      for my $property ( @properties ) {
  
          if ( !exists $args->{$property} ) {
              warn "Property '$property' must be specified in layout options\n";
              return;
          }
  
          my $value = $args->{$property};
  
          if ( $value !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/ ) {
              warn "Property '$property' value '$value' must be numeric"
                . " in layout options\n";
              return;
          }
  
          if ( $value < 0 || $value > 1 ) {
              warn "Property '$property' value '$value' must be in range "
                . "0 < x <= 1 in layout options\n";
              return;
          }
  
          # Convert to the format used by Excel for easier testing
          $layout->{$property} = sprintf "%.17g", $value;
      }
  
      return $layout;
  }
  
  
  ###############################################################################
  #
  # _get_points_properties()
  #
  # Convert user defined points properties to structure required internally.
  #
  sub _get_points_properties {
  
      my $self        = shift;
      my $user_points = shift;
      my @points;
  
      return unless $user_points;
  
      for my $user_point ( @$user_points ) {
  
          my $point;
  
          if ( defined $user_point ) {
  
              # Set the line properties for the point.
              my $line = $self->_get_line_properties( $user_point->{line} );
  
              # Allow 'border' as a synonym for 'line'.
              if ( $user_point->{border} ) {
                  $line = $self->_get_line_properties( $user_point->{border} );
              }
  
              # Set the fill properties for the chartarea.
              my $fill = $self->_get_fill_properties( $user_point->{fill} );
  
  
              # Set the pattern properties for the series.
              my $pattern =
                $self->_get_pattern_properties( $user_point->{pattern} );
  
              # Set the gradient fill properties for the series.
              my $gradient =
                $self->_get_gradient_properties( $user_point->{gradient} );
  
              # Pattern fill overrides solid fill.
              if ( $pattern ) {
                  $fill = undef;
              }
  
              # Gradient fill overrides solid and pattern fills.
              if ( $gradient ) {
                  $pattern = undef;
                  $fill    = undef;
              }
                          # Gradient fill overrides solid fill.
              if ( $gradient ) {
                  $fill = undef;
              }
  
              $point->{_line}     = $line;
              $point->{_fill}     = $fill;
              $point->{_pattern}  = $pattern;
              $point->{_gradient} = $gradient;
          }
  
          push @points, $point;
      }
  
      return \@points;
  }
  
  
  ###############################################################################
  #
  # _get_display_units()
  #
  # Convert user defined display units to internal units.
  #
  sub _get_display_units {
  
      my $self          = shift;
      my $display_units = shift;
  
      return if !$display_units;
  
      my %types = (
          'hundreds'          => 'hundreds',
          'thousands'         => 'thousands',
          'ten_thousands'     => 'tenThousands',
          'hundred_thousands' => 'hundredThousands',
          'millions'          => 'millions',
          'ten_millions'      => 'tenMillions',
          'hundred_millions'  => 'hundredMillions',
          'billions'          => 'billions',
          'trillions'         => 'trillions',
      );
  
      if ( exists $types{$display_units} ) {
          $display_units = $types{$display_units};
      }
      else {
          warn "Unknown display_units type '$display_units'\n";
          return;
      }
  
      return $display_units;
  }
  
  
  
  ###############################################################################
  #
  # _get_tick_type()
  #
  # Convert user tick types to internal units.
  #
  sub _get_tick_type {
  
      my $self      = shift;
      my $tick_type = shift;
  
      return if !$tick_type;
  
      my %types = (
          'outside' => 'out',
          'inside'  => 'in',
          'none'    => 'none',
          'cross'   => 'cross',
      );
  
      if ( exists $types{$tick_type} ) {
          $tick_type = $types{$tick_type};
      }
      else {
          warn "Unknown tick_type type '$tick_type'\n";
          return;
      }
  
      return $tick_type;
  }
  
  
  ###############################################################################
  #
  # _get_primary_axes_series()
  #
  # Returns series which use the primary axes.
  #
  sub _get_primary_axes_series {
  
      my $self = shift;
      my @primary_axes_series;
  
      for my $series ( @{ $self->{_series} } ) {
          push @primary_axes_series, $series unless $series->{_y2_axis};
      }
  
      return @primary_axes_series;
  }
  
  
  ###############################################################################
  #
  # _get_secondary_axes_series()
  #
  # Returns series which use the secondary axes.
  #
  sub _get_secondary_axes_series {
  
      my $self = shift;
      my @secondary_axes_series;
  
      for my $series ( @{ $self->{_series} } ) {
          push @secondary_axes_series, $series if $series->{_y2_axis};
      }
  
      return @secondary_axes_series;
  }
  
  
  ###############################################################################
  #
  # _add_axis_ids()
  #
  # Add unique ids for primary or secondary axes
  #
  sub _add_axis_ids {
  
      my $self       = shift;
      my %args       = @_;
      my $chart_id   = 5001 + $self->{_id};
      my $axis_count = 1 + @{ $self->{_axis2_ids} } + @{ $self->{_axis_ids} };
  
      my $id1 = sprintf '%04d%04d', $chart_id, $axis_count;
      my $id2 = sprintf '%04d%04d', $chart_id, $axis_count + 1;
  
      push @{ $self->{_axis_ids} },  $id1, $id2 if $args{primary_axes};
      push @{ $self->{_axis2_ids} }, $id1, $id2 if !$args{primary_axes};
  }
  
  
  ##############################################################################
  #
  # _get_font_style_attributes.
  #
  # Get the font style attributes from a font hashref.
  #
  sub _get_font_style_attributes {
  
      my $self = shift;
      my $font = shift;
  
      return () unless $font;
  
      my @attributes;
      push @attributes, ( 'sz' => $font->{_size} )   if $font->{_size};
      push @attributes, ( 'b'  => $font->{_bold} )   if defined $font->{_bold};
      push @attributes, ( 'i'  => $font->{_italic} ) if defined $font->{_italic};
      push @attributes, ( 'u' => 'sng' ) if defined $font->{_underline};
  
      # Turn off baseline when testing fonts that don't have it.
      if ($font->{_baseline} != -1) {
          push @attributes, ( 'baseline' => $font->{_baseline} );
      }
  
      return @attributes;
  }
  
  
  ##############################################################################
  #
  # _get_font_latin_attributes.
  #
  # Get the font latin attributes from a font hashref.
  #
  sub _get_font_latin_attributes {
  
      my $self = shift;
      my $font = shift;
  
      return () unless $font;
  
      my @attributes;
      push @attributes, ( 'typeface' => $font->{_name} ) if $font->{_name};
  
      push @attributes, ( 'pitchFamily' => $font->{_pitch_family} )
        if defined $font->{_pitch_family};
  
      push @attributes, ( 'charset' => $font->{_charset} )
        if defined $font->{_charset};
  
      return @attributes;
  }
  
  
  ###############################################################################
  #
  # Config data.
  #
  ###############################################################################
  
  ###############################################################################
  #
  # _set_default_properties()
  #
  # Setup the default properties for a chart.
  #
  sub _set_default_properties {
  
      my $self = shift;
  
      # Set the default axis properties.
      $self->{_x_axis}->{_defaults} = {
          num_format      => 'General',
          major_gridlines => { visible => 0 }
      };
  
      $self->{_y_axis}->{_defaults} = {
          num_format      => 'General',
          major_gridlines => { visible => 1 }
      };
  
      $self->{_x2_axis}->{_defaults} = {
          num_format     => 'General',
          label_position => 'none',
          crossing       => 'max',
          visible        => 0
      };
  
      $self->{_y2_axis}->{_defaults} = {
          num_format      => 'General',
          major_gridlines => { visible => 0 },
          position        => 'right',
          visible         => 1
      };
  
      $self->set_x_axis();
      $self->set_y_axis();
  
      $self->set_x2_axis();
      $self->set_y2_axis();
  }
  
  
  ###############################################################################
  #
  # _set_embedded_config_data()
  #
  # Setup the default configuration data for an embedded chart.
  #
  sub _set_embedded_config_data {
  
      my $self = shift;
  
      $self->{_embedded} = 1;
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_chart_space()
  #
  # Write the <c:chartSpace> element.
  #
  sub _write_chart_space {
  
      my $self    = shift;
      my $schema  = 'http://schemas.openxmlformats.org/';
      my $xmlns_c = $schema . 'drawingml/2006/chart';
      my $xmlns_a = $schema . 'drawingml/2006/main';
      my $xmlns_r = $schema . 'officeDocument/2006/relationships';
  
      my @attributes = (
          'xmlns:c' => $xmlns_c,
          'xmlns:a' => $xmlns_a,
          'xmlns:r' => $xmlns_r,
      );
  
      $self->xml_start_tag( 'c:chartSpace', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_lang()
  #
  # Write the <c:lang> element.
  #
  sub _write_lang {
  
      my $self = shift;
      my $val  = 'en-US';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:lang', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_style()
  #
  # Write the <c:style> element.
  #
  sub _write_style {
  
      my $self     = shift;
      my $style_id = $self->{_style_id};
  
      # Don't write an element for the default style, 2.
      return if $style_id == 2;
  
      my @attributes = ( 'val' => $style_id );
  
      $self->xml_empty_tag( 'c:style', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_chart()
  #
  # Write the <c:chart> element.
  #
  sub _write_chart {
  
      my $self = shift;
  
      $self->xml_start_tag( 'c:chart' );
  
      # Write the chart title elements.
  
      if ( $self->{_title_none} ) {
  
          # Turn off the title.
          $self->_write_auto_title_deleted();
      }
      else {
          my $title;
          if ( $title = $self->{_title_formula} ) {
              $self->_write_title_formula(
  
                  $title,
                  $self->{_title_data_id},
                  undef,
                  $self->{_title_font},
                  $self->{_title_layout},
                  $self->{_title_overlay}
              );
          }
          elsif ( $title = $self->{_title_name} ) {
              $self->_write_title_rich(
  
                  $title,
                  undef,
                  $self->{_title_font},
                  $self->{_title_layout},
                  $self->{_title_overlay}
              );
          }
      }
  
      # Write the c:plotArea element.
      $self->_write_plot_area();
  
      # Write the c:legend element.
      $self->_write_legend();
  
      # Write the c:plotVisOnly element.
      $self->_write_plot_vis_only();
  
      # Write the c:dispBlanksAs element.
      $self->_write_disp_blanks_as();
  
      $self->xml_end_tag( 'c:chart' );
  }
  
  
  ##############################################################################
  #
  # _write_disp_blanks_as()
  #
  # Write the <c:dispBlanksAs> element.
  #
  sub _write_disp_blanks_as {
  
      my $self = shift;
      my $val  = $self->{_show_blanks};
  
      # Ignore the default value.
      return if $val eq 'gap';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:dispBlanksAs', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_plot_area()
  #
  # Write the <c:plotArea> element.
  #
  sub _write_plot_area {
  
      my $self = shift;
      my $second_chart = $self->{_combined};
  
      $self->xml_start_tag( 'c:plotArea' );
  
      # Write the c:layout element.
      $self->_write_layout( $self->{_plotarea}->{_layout}, 'plot' );
  
      # Write the subclass chart type elements for primary and secondary axes.
      $self->_write_chart_type( primary_axes => 1 );
      $self->_write_chart_type( primary_axes => 0 );
  
  
      # Configure a combined chart if present.
      if ( $second_chart ) {
  
          # Secondary axis has unique id otherwise use same as primary.
          if ( $second_chart->{_is_secondary} ) {
              $second_chart->{_id} = 1000 + $self->{_id};
          }
          else {
              $second_chart->{_id} = $self->{_id};
          }
  
          # Shart the same filehandle for writing.
          $second_chart->{_fh} = $self->{_fh};
  
          # Share series index with primary chart.
          $second_chart->{_series_index} = $self->{_series_index};
  
          # Write the subclass chart type elements for combined chart.
          $second_chart->_write_chart_type( primary_axes => 1 );
          $second_chart->_write_chart_type( primary_axes => 0 );
      }
  
      # Write the category and value elements for the primary axes.
      my @args = (
          x_axis   => $self->{_x_axis},
          y_axis   => $self->{_y_axis},
          axis_ids => $self->{_axis_ids}
      );
  
      if ( $self->{_date_category} ) {
          $self->_write_date_axis( @args );
      }
      else {
          $self->_write_cat_axis( @args );
      }
  
      $self->_write_val_axis( @args );
  
      # Write the category and value elements for the secondary axes.
      @args = (
          x_axis   => $self->{_x2_axis},
          y_axis   => $self->{_y2_axis},
          axis_ids => $self->{_axis2_ids}
      );
  
      $self->_write_val_axis( @args );
  
      # Write the secondary axis for the secondary chart.
      if ( $second_chart && $second_chart->{_is_secondary} ) {
  
          @args = (
               x_axis   => $second_chart->{_x2_axis},
               y_axis   => $second_chart->{_y2_axis},
               axis_ids => $second_chart->{_axis2_ids}
              );
  
          $second_chart->_write_val_axis( @args );
      }
  
  
      if ( $self->{_date_category} ) {
          $self->_write_date_axis( @args );
      }
      else {
          $self->_write_cat_axis( @args );
      }
  
      # Write the c:dTable element.
      $self->_write_d_table();
  
      # Write the c:spPr element for the plotarea formatting.
      $self->_write_sp_pr( $self->{_plotarea} );
  
      $self->xml_end_tag( 'c:plotArea' );
  }
  
  
  ##############################################################################
  #
  # _write_layout()
  #
  # Write the <c:layout> element.
  #
  sub _write_layout {
  
      my $self   = shift;
      my $layout = shift;
      my $type   = shift;
  
      if ( !$layout ) {
          # Automatic layout.
          $self->xml_empty_tag( 'c:layout' );
      }
      else {
          # User defined manual layout.
          $self->xml_start_tag( 'c:layout' );
          $self->_write_manual_layout( $layout, $type );
          $self->xml_end_tag( 'c:layout' );
      }
  }
  
  ##############################################################################
  #
  # _write_manual_layout()
  #
  # Write the <c:manualLayout> element.
  #
  sub _write_manual_layout {
  
      my $self   = shift;
      my $layout = shift;
      my $type   = shift;
  
      $self->xml_start_tag( 'c:manualLayout' );
  
      # Plotarea has a layoutTarget element.
      if ( $type eq 'plot' ) {
          $self->xml_empty_tag( 'c:layoutTarget', ( 'val' => 'inner' ) );
      }
  
      # Set the x, y positions.
      $self->xml_empty_tag( 'c:xMode', ( 'val' => 'edge' ) );
      $self->xml_empty_tag( 'c:yMode', ( 'val' => 'edge' ) );
      $self->xml_empty_tag( 'c:x', ( 'val' => $layout->{x} ) );
      $self->xml_empty_tag( 'c:y', ( 'val' => $layout->{y} ) );
  
      # For plotarea and legend set the width and height.
      if ( $type ne 'text' ) {
          $self->xml_empty_tag( 'c:w', ( 'val' => $layout->{width} ) );
          $self->xml_empty_tag( 'c:h', ( 'val' => $layout->{height} ) );
      }
  
      $self->xml_end_tag( 'c:manualLayout' );
  }
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Write the chart type element. This method should be overridden by the
  # subclasses.
  #
  sub _write_chart_type {
  
      my $self = shift;
  }
  
  
  ##############################################################################
  #
  # _write_grouping()
  #
  # Write the <c:grouping> element.
  #
  sub _write_grouping {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:grouping', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_series()
  #
  # Write the series elements.
  #
  sub _write_series {
  
      my $self   = shift;
      my $series = shift;
  
      $self->_write_ser( $series );
  }
  
  
  ##############################################################################
  #
  # _write_ser()
  #
  # Write the <c:ser> element.
  #
  sub _write_ser {
  
      my $self   = shift;
      my $series = shift;
      my $index  = $self->{_series_index}++;
  
      $self->xml_start_tag( 'c:ser' );
  
      # Write the c:idx element.
      $self->_write_idx( $index );
  
      # Write the c:order element.
      $self->_write_order( $index );
  
      # Write the series name.
      $self->_write_series_name( $series );
  
      # Write the c:spPr element.
      $self->_write_sp_pr( $series );
  
      # Write the c:marker element.
      $self->_write_marker( $series->{_marker} );
  
      # Write the c:invertIfNegative element.
      $self->_write_c_invert_if_negative( $series->{_invert_if_neg} );
  
      # Write the c:dPt element.
      $self->_write_d_pt( $series->{_points} );
  
      # Write the c:dLbls element.
      $self->_write_d_lbls( $series->{_labels} );
  
      # Write the c:trendline element.
      $self->_write_trendline( $series->{_trendline} );
  
      # Write the c:errBars element.
      $self->_write_error_bars( $series->{_error_bars} );
  
      # Write the c:cat element.
      $self->_write_cat( $series );
  
      # Write the c:val element.
      $self->_write_val( $series );
  
      # Write the c:smooth element.
      if ( $self->{_smooth_allowed} ) {
          $self->_write_c_smooth( $series->{_smooth} );
      }
  
      $self->xml_end_tag( 'c:ser' );
  }
  
  
  ##############################################################################
  #
  # _write_idx()
  #
  # Write the <c:idx> element.
  #
  sub _write_idx {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:idx', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_order()
  #
  # Write the <c:order> element.
  #
  sub _write_order {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:order', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_series_name()
  #
  # Write the series name.
  #
  sub _write_series_name {
  
      my $self   = shift;
      my $series = shift;
  
      my $name;
      if ( $name = $series->{_name_formula} ) {
          $self->_write_tx_formula( $name, $series->{_name_id} );
      }
      elsif ( $name = $series->{_name} ) {
          $self->_write_tx_value( $name );
      }
  
  }
  
  
  ##############################################################################
  #
  # _write_cat()
  #
  # Write the <c:cat> element.
  #
  sub _write_cat {
  
      my $self    = shift;
      my $series  = shift;
      my $formula = $series->{_categories};
      my $data_id = $series->{_cat_data_id};
      my $data;
  
      if ( defined $data_id ) {
          $data = $self->{_formula_data}->[$data_id];
      }
  
      # Ignore <c:cat> elements for charts without category values.
      return unless $formula;
  
      $self->xml_start_tag( 'c:cat' );
  
      # Check the type of cached data.
      my $type = $self->_get_data_type( $data );
  
      if ( $type eq 'str' ) {
  
          $self->{_cat_has_num_fmt} = 0;
  
          # Write the c:numRef element.
          $self->_write_str_ref( $formula, $data, $type );
      }
      elsif ( $type eq 'multi_str') {
  
          $self->{_cat_has_num_fmt} = 0;
  
          # Write the c:multiLvLStrRef element.
          $self->_write_multi_lvl_str_ref( $formula, $data );
      }
      else {
  
          $self->{_cat_has_num_fmt} = 1;
  
          # Write the c:numRef element.
          $self->_write_num_ref( $formula, $data, $type );
      }
  
  
      $self->xml_end_tag( 'c:cat' );
  }
  
  
  ##############################################################################
  #
  # _write_val()
  #
  # Write the <c:val> element.
  #
  sub _write_val {
  
      my $self    = shift;
      my $series  = shift;
      my $formula = $series->{_values};
      my $data_id = $series->{_val_data_id};
      my $data    = $self->{_formula_data}->[$data_id];
  
      $self->xml_start_tag( 'c:val' );
  
      # Unlike Cat axes data should only be numeric.
  
      # Write the c:numRef element.
      $self->_write_num_ref( $formula, $data, 'num' );
  
      $self->xml_end_tag( 'c:val' );
  }
  
  
  ##############################################################################
  #
  # _write_num_ref()
  #
  # Write the <c:numRef> element.
  #
  sub _write_num_ref {
  
      my $self    = shift;
      my $formula = shift;
      my $data    = shift;
      my $type    = shift;
  
      $self->xml_start_tag( 'c:numRef' );
  
      # Write the c:f element.
      $self->_write_series_formula( $formula );
  
      if ( $type eq 'num' ) {
  
          # Write the c:numCache element.
          $self->_write_num_cache( $data );
      }
      elsif ( $type eq 'str' ) {
  
          # Write the c:strCache element.
          $self->_write_str_cache( $data );
      }
  
      $self->xml_end_tag( 'c:numRef' );
  }
  
  
  ##############################################################################
  #
  # _write_str_ref()
  #
  # Write the <c:strRef> element.
  #
  sub _write_str_ref {
  
      my $self    = shift;
      my $formula = shift;
      my $data    = shift;
      my $type    = shift;
  
      $self->xml_start_tag( 'c:strRef' );
  
      # Write the c:f element.
      $self->_write_series_formula( $formula );
  
      if ( $type eq 'num' ) {
  
          # Write the c:numCache element.
          $self->_write_num_cache( $data );
      }
      elsif ( $type eq 'str' ) {
  
          # Write the c:strCache element.
          $self->_write_str_cache( $data );
      }
  
      $self->xml_end_tag( 'c:strRef' );
  }
  
  
  ##############################################################################
  #
  # _write_multi_lvl_str_ref()
  #
  # Write the <c:multiLvLStrRef> element.
  #
  sub _write_multi_lvl_str_ref {
  
      my $self    = shift;
      my $formula = shift;
      my $data    = shift;
      my $count   = @$data;
  
      return if !$count;
  
      $self->xml_start_tag( 'c:multiLvlStrRef' );
  
      # Write the c:f element.
      $self->_write_series_formula( $formula );
  
      $self->xml_start_tag( 'c:multiLvlStrCache' );
  
      # Write the c:ptCount element.
      $count = @{ $data->[-1] };
      $self->_write_pt_count( $count );
  
      # Write the data arrays in reverse order.
      for my $aref ( reverse @$data ) {
          $self->xml_start_tag( 'c:lvl' );
  
          for my $i ( 0 .. @$aref - 1 ) {
              # Write the c:pt element.
              $self->_write_pt( $i, $aref->[$i] );
          }
  
          $self->xml_end_tag( 'c:lvl' );
      }
  
      $self->xml_end_tag( 'c:multiLvlStrCache' );
  
      $self->xml_end_tag( 'c:multiLvlStrRef' );
  }
  
  
  ##############################################################################
  #
  # _write_series_formula()
  #
  # Write the <c:f> element.
  #
  sub _write_series_formula {
  
      my $self    = shift;
      my $formula = shift;
  
      # Strip the leading '=' from the formula.
      $formula =~ s/^=//;
  
      $self->xml_data_element( 'c:f', $formula );
  }
  
  
  ##############################################################################
  #
  # _write_axis_ids()
  #
  # Write the <c:axId> elements for the primary or secondary axes.
  #
  sub _write_axis_ids {
  
      my $self = shift;
      my %args = @_;
  
      # Generate the axis ids.
      $self->_add_axis_ids( %args );
  
      if ( $args{primary_axes} ) {
  
          # Write the axis ids for the primary axes.
          $self->_write_axis_id( $self->{_axis_ids}->[0] );
          $self->_write_axis_id( $self->{_axis_ids}->[1] );
      }
      else {
          # Write the axis ids for the secondary axes.
          $self->_write_axis_id( $self->{_axis2_ids}->[0] );
          $self->_write_axis_id( $self->{_axis2_ids}->[1] );
      }
  }
  
  
  ##############################################################################
  #
  # _write_axis_id()
  #
  # Write the <c:axId> element.
  #
  sub _write_axis_id {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:axId', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_cat_axis()
  #
  # Write the <c:catAx> element. Usually the X axis.
  #
  sub _write_cat_axis {
  
      my $self     = shift;
      my %args     = @_;
      my $x_axis   = $args{x_axis};
      my $y_axis   = $args{y_axis};
      my $axis_ids = $args{axis_ids};
  
      # if there are no axis_ids then we don't need to write this element
      return unless $axis_ids;
      return unless scalar @$axis_ids;
  
      my $position = $self->{_cat_axis_position};
      my $horiz    = $self->{_horiz_cat_axis};
  
      # Overwrite the default axis position with a user supplied value.
      $position = $x_axis->{_position} || $position;
  
      $self->xml_start_tag( 'c:catAx' );
  
      $self->_write_axis_id( $axis_ids->[0] );
  
      # Write the c:scaling element.
      $self->_write_scaling( $x_axis->{_reverse} );
  
      $self->_write_delete( 1 ) unless $x_axis->{_visible};
  
      # Write the c:axPos element.
      $self->_write_axis_pos( $position, $y_axis->{_reverse} );
  
      # Write the c:majorGridlines element.
      $self->_write_major_gridlines( $x_axis->{_major_gridlines} );
  
      # Write the c:minorGridlines element.
      $self->_write_minor_gridlines( $x_axis->{_minor_gridlines} );
  
      # Write the axis title elements.
      my $title;
      if ( $title = $x_axis->{_formula} ) {
  
          $self->_write_title_formula( $title, $x_axis->{_data_id}, $horiz,
              $x_axis->{_name_font}, $x_axis->{_layout} );
      }
      elsif ( $title = $x_axis->{_name} ) {
          $self->_write_title_rich( $title, $horiz, $x_axis->{_name_font},
              $x_axis->{_layout} );
      }
  
      # Write the c:numFmt element.
      $self->_write_cat_number_format( $x_axis );
  
      # Write the c:majorTickMark element.
      $self->_write_major_tick_mark( $x_axis->{_major_tick_mark} );
  
      # Write the c:minorTickMark element.
      $self->_write_minor_tick_mark( $x_axis->{_minor_tick_mark} );
  
      # Write the c:tickLblPos element.
      $self->_write_tick_label_pos( $x_axis->{_label_position} );
  
      # Write the c:spPr element for the axis line.
      $self->_write_sp_pr( $x_axis );
  
      # Write the axis font elements.
      $self->_write_axis_font( $x_axis->{_num_font} );
  
      # Write the c:crossAx element.
      $self->_write_cross_axis( $axis_ids->[1] );
  
      if ( $self->{_show_crosses} || $x_axis->{_visible} ) {
  
          # Note, the category crossing comes from the value axis.
          if ( !defined $y_axis->{_crossing} || $y_axis->{_crossing} eq 'max' ) {
  
              # Write the c:crosses element.
              $self->_write_crosses( $y_axis->{_crossing} );
          }
          else {
  
              # Write the c:crossesAt element.
              $self->_write_c_crosses_at( $y_axis->{_crossing} );
          }
      }
  
      # Write the c:auto element.
      if (!$x_axis->{_text_axis}) {
          $self->_write_auto( 1 );
      }
  
      # Write the c:labelAlign element.
      $self->_write_label_align( 'ctr' );
  
      # Write the c:labelOffset element.
      $self->_write_label_offset( 100 );
  
      # Write the c:tickLblSkip element.
      $self->_write_tick_lbl_skip( $x_axis->{_interval_unit} );
  
      # Write the c:tickMarkSkip element.
      $self->_write_tick_mark_skip( $x_axis->{_interval_tick} );
  
      $self->xml_end_tag( 'c:catAx' );
  }
  
  
  ##############################################################################
  #
  # _write_val_axis()
  #
  # Write the <c:valAx> element. Usually the Y axis.
  #
  # TODO. Maybe should have a _write_cat_val_axis() method as well for scatter.
  #
  sub _write_val_axis {
  
      my $self     = shift;
      my %args     = @_;
      my $x_axis   = $args{x_axis};
      my $y_axis   = $args{y_axis};
      my $axis_ids = $args{axis_ids};
      my $position = $args{position} || $self->{_val_axis_position};
      my $horiz    = $self->{_horiz_val_axis};
  
      return unless $axis_ids && scalar @$axis_ids;
  
      # Overwrite the default axis position with a user supplied value.
      $position = $y_axis->{_position} || $position;
  
      $self->xml_start_tag( 'c:valAx' );
  
      $self->_write_axis_id( $axis_ids->[1] );
  
      # Write the c:scaling element.
      $self->_write_scaling(
          $y_axis->{_reverse}, $y_axis->{_min},
          $y_axis->{_max},     $y_axis->{_log_base}
      );
  
      $self->_write_delete( 1 ) unless $y_axis->{_visible};
  
      # Write the c:axPos element.
      $self->_write_axis_pos( $position, $x_axis->{_reverse} );
  
      # Write the c:majorGridlines element.
      $self->_write_major_gridlines( $y_axis->{_major_gridlines} );
  
      # Write the c:minorGridlines element.
      $self->_write_minor_gridlines( $y_axis->{_minor_gridlines} );
  
      # Write the axis title elements.
      my $title;
      if ( $title = $y_axis->{_formula} ) {
          $self->_write_title_formula( $title, $y_axis->{_data_id}, $horiz,
              $y_axis->{_name_font}, $y_axis->{_layout} );
      }
      elsif ( $title = $y_axis->{_name} ) {
          $self->_write_title_rich( $title, $horiz, $y_axis->{_name_font},
              $y_axis->{_layout} );
      }
  
      # Write the c:numberFormat element.
      $self->_write_number_format( $y_axis );
  
      # Write the c:majorTickMark element.
      $self->_write_major_tick_mark( $y_axis->{_major_tick_mark} );
  
      # Write the c:minorTickMark element.
      $self->_write_minor_tick_mark( $y_axis->{_minor_tick_mark} );
  
      # Write the c:tickLblPos element.
      $self->_write_tick_label_pos( $y_axis->{_label_position} );
  
      # Write the c:spPr element for the axis line.
      $self->_write_sp_pr( $y_axis );
  
      # Write the axis font elements.
      $self->_write_axis_font( $y_axis->{_num_font} );
  
      # Write the c:crossAx element.
      $self->_write_cross_axis( $axis_ids->[0] );
  
      # Note, the category crossing comes from the value axis.
      if ( !defined $x_axis->{_crossing} || $x_axis->{_crossing} eq 'max' ) {
  
          # Write the c:crosses element.
          $self->_write_crosses( $x_axis->{_crossing} );
      }
      else {
  
          # Write the c:crossesAt element.
          $self->_write_c_crosses_at( $x_axis->{_crossing} );
      }
  
      # Write the c:crossBetween element.
      $self->_write_cross_between( $x_axis->{_position_axis} );
  
      # Write the c:majorUnit element.
      $self->_write_c_major_unit( $y_axis->{_major_unit} );
  
      # Write the c:minorUnit element.
      $self->_write_c_minor_unit( $y_axis->{_minor_unit} );
  
      # Write the c:dispUnits element.
      $self->_write_disp_units( $y_axis->{_display_units},
          $y_axis->{_display_units_visible} );
  
      $self->xml_end_tag( 'c:valAx' );
  }
  
  
  ##############################################################################
  #
  # _write_cat_val_axis()
  #
  # Write the <c:valAx> element. This is for the second valAx in scatter plots.
  # Usually the X axis.
  #
  sub _write_cat_val_axis {
  
      my $self     = shift;
      my %args     = @_;
      my $x_axis   = $args{x_axis};
      my $y_axis   = $args{y_axis};
      my $axis_ids = $args{axis_ids};
      my $position = $args{position} || $self->{_val_axis_position};
      my $horiz    = $self->{_horiz_val_axis};
  
      return unless $axis_ids && scalar @$axis_ids;
  
      # Overwrite the default axis position with a user supplied value.
      $position = $x_axis->{_position} || $position;
  
      $self->xml_start_tag( 'c:valAx' );
  
      $self->_write_axis_id( $axis_ids->[0] );
  
      # Write the c:scaling element.
      $self->_write_scaling(
          $x_axis->{_reverse}, $x_axis->{_min},
          $x_axis->{_max},     $x_axis->{_log_base}
      );
  
      $self->_write_delete( 1 ) unless $x_axis->{_visible};
  
      # Write the c:axPos element.
      $self->_write_axis_pos( $position, $y_axis->{_reverse} );
  
      # Write the c:majorGridlines element.
      $self->_write_major_gridlines( $x_axis->{_major_gridlines} );
  
      # Write the c:minorGridlines element.
      $self->_write_minor_gridlines( $x_axis->{_minor_gridlines} );
  
      # Write the axis title elements.
      my $title;
      if ( $title = $x_axis->{_formula} ) {
          $self->_write_title_formula( $title, $x_axis->{_data_id}, $horiz,
              $x_axis->{_name_font}, $x_axis->{_layout} );
      }
      elsif ( $title = $x_axis->{_name} ) {
          $self->_write_title_rich( $title, $horiz, $x_axis->{_name_font},
              $x_axis->{_layout} );
      }
  
      # Write the c:numberFormat element.
      $self->_write_number_format( $x_axis );
  
      # Write the c:majorTickMark element.
      $self->_write_major_tick_mark( $x_axis->{_major_tick_mark} );
  
      # Write the c:minorTickMark element.
      $self->_write_minor_tick_mark( $x_axis->{_minor_tick_mark} );
  
      # Write the c:tickLblPos element.
      $self->_write_tick_label_pos( $x_axis->{_label_position} );
  
      # Write the c:spPr element for the axis line.
      $self->_write_sp_pr( $x_axis );
  
      # Write the axis font elements.
      $self->_write_axis_font( $x_axis->{_num_font} );
  
      # Write the c:crossAx element.
      $self->_write_cross_axis( $axis_ids->[1] );
  
      # Note, the category crossing comes from the value axis.
      if ( !defined $y_axis->{_crossing} || $y_axis->{_crossing} eq 'max' ) {
  
          # Write the c:crosses element.
          $self->_write_crosses( $y_axis->{_crossing} );
      }
      else {
  
          # Write the c:crossesAt element.
          $self->_write_c_crosses_at( $y_axis->{_crossing} );
      }
  
      # Write the c:crossBetween element.
      $self->_write_cross_between( $y_axis->{_position_axis} );
  
      # Write the c:majorUnit element.
      $self->_write_c_major_unit( $x_axis->{_major_unit} );
  
      # Write the c:minorUnit element.
      $self->_write_c_minor_unit( $x_axis->{_minor_unit} );
  
      # Write the c:dispUnits element.
      $self->_write_disp_units( $x_axis->{_display_units},
          $x_axis->{_display_units_visible} );
  
      $self->xml_end_tag( 'c:valAx' );
  }
  
  
  ##############################################################################
  #
  # _write_date_axis()
  #
  # Write the <c:dateAx> element. Usually the X axis.
  #
  sub _write_date_axis {
  
      my $self     = shift;
      my %args     = @_;
      my $x_axis   = $args{x_axis};
      my $y_axis   = $args{y_axis};
      my $axis_ids = $args{axis_ids};
  
      return unless $axis_ids && scalar @$axis_ids;
  
      my $position = $self->{_cat_axis_position};
  
      # Overwrite the default axis position with a user supplied value.
      $position = $x_axis->{_position} || $position;
  
      $self->xml_start_tag( 'c:dateAx' );
  
      $self->_write_axis_id( $axis_ids->[0] );
  
      # Write the c:scaling element.
      $self->_write_scaling(
          $x_axis->{_reverse}, $x_axis->{_min},
          $x_axis->{_max},     $x_axis->{_log_base}
      );
  
      $self->_write_delete( 1 ) unless $x_axis->{_visible};
  
      # Write the c:axPos element.
      $self->_write_axis_pos( $position, $y_axis->{_reverse} );
  
      # Write the c:majorGridlines element.
      $self->_write_major_gridlines( $x_axis->{_major_gridlines} );
  
      # Write the c:minorGridlines element.
      $self->_write_minor_gridlines( $x_axis->{_minor_gridlines} );
  
      # Write the axis title elements.
      my $title;
      if ( $title = $x_axis->{_formula} ) {
          $self->_write_title_formula( $title, $x_axis->{_data_id}, undef,
              $x_axis->{_name_font}, $x_axis->{_layout} );
      }
      elsif ( $title = $x_axis->{_name} ) {
          $self->_write_title_rich( $title, undef, $x_axis->{_name_font},
              $x_axis->{_layout} );
      }
  
      # Write the c:numFmt element.
      $self->_write_number_format( $x_axis );
  
      # Write the c:majorTickMark element.
      $self->_write_major_tick_mark( $x_axis->{_major_tick_mark} );
  
      # Write the c:minorTickMark element.
      $self->_write_minor_tick_mark( $x_axis->{_minor_tick_mark} );
  
      # Write the c:tickLblPos element.
      $self->_write_tick_label_pos( $x_axis->{_label_position} );
  
      # Write the c:spPr element for the axis line.
      $self->_write_sp_pr( $x_axis );
  
      # Write the axis font elements.
      $self->_write_axis_font( $x_axis->{_num_font} );
  
      # Write the c:crossAx element.
      $self->_write_cross_axis( $axis_ids->[1] );
  
      if ( $self->{_show_crosses} || $x_axis->{_visible} ) {
  
          # Note, the category crossing comes from the value axis.
          if ( !defined $y_axis->{_crossing} || $y_axis->{_crossing} eq 'max' ) {
  
              # Write the c:crosses element.
              $self->_write_crosses( $y_axis->{_crossing} );
          }
          else {
  
              # Write the c:crossesAt element.
              $self->_write_c_crosses_at( $y_axis->{_crossing} );
          }
      }
  
      # Write the c:auto element.
      $self->_write_auto( 1 );
  
      # Write the c:labelOffset element.
      $self->_write_label_offset( 100 );
  
      # Write the c:tickLblSkip element.
      $self->_write_tick_lbl_skip( $x_axis->{_interval_unit} );
  
      # Write the c:tickMarkSkip element.
      $self->_write_tick_mark_skip( $x_axis->{_interval_tick} );
  
      # Write the c:majorUnit element.
      $self->_write_c_major_unit( $x_axis->{_major_unit} );
  
      # Write the c:majorTimeUnit element.
      if ( defined $x_axis->{_major_unit} ) {
          $self->_write_c_major_time_unit( $x_axis->{_major_unit_type} );
      }
  
      # Write the c:minorUnit element.
      $self->_write_c_minor_unit( $x_axis->{_minor_unit} );
  
      # Write the c:minorTimeUnit element.
      if ( defined $x_axis->{_minor_unit} ) {
          $self->_write_c_minor_time_unit( $x_axis->{_minor_unit_type} );
      }
  
      $self->xml_end_tag( 'c:dateAx' );
  }
  
  
  ##############################################################################
  #
  # _write_scaling()
  #
  # Write the <c:scaling> element.
  #
  sub _write_scaling {
  
      my $self     = shift;
      my $reverse  = shift;
      my $min      = shift;
      my $max      = shift;
      my $log_base = shift;
  
      $self->xml_start_tag( 'c:scaling' );
  
      # Write the c:logBase element.
      $self->_write_c_log_base( $log_base );
  
      # Write the c:orientation element.
      $self->_write_orientation( $reverse );
  
      # Write the c:max element.
      $self->_write_c_max( $max );
  
      # Write the c:min element.
      $self->_write_c_min( $min );
  
      $self->xml_end_tag( 'c:scaling' );
  }
  
  
  ##############################################################################
  #
  # _write_c_log_base()
  #
  # Write the <c:logBase> element.
  #
  sub _write_c_log_base {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:logBase', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_orientation()
  #
  # Write the <c:orientation> element.
  #
  sub _write_orientation {
  
      my $self    = shift;
      my $reverse = shift;
      my $val     = 'minMax';
  
      $val = 'maxMin' if $reverse;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:orientation', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_max()
  #
  # Write the <c:max> element.
  #
  sub _write_c_max {
  
      my $self = shift;
      my $max  = shift;
  
      return unless defined $max;
  
      my @attributes = ( 'val' => $max );
  
      $self->xml_empty_tag( 'c:max', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_min()
  #
  # Write the <c:min> element.
  #
  sub _write_c_min {
  
      my $self = shift;
      my $min  = shift;
  
      return unless defined $min;
  
      my @attributes = ( 'val' => $min );
  
      $self->xml_empty_tag( 'c:min', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_axis_pos()
  #
  # Write the <c:axPos> element.
  #
  sub _write_axis_pos {
  
      my $self    = shift;
      my $val     = shift;
      my $reverse = shift;
  
      if ( $reverse ) {
          $val = 'r' if $val eq 'l';
          $val = 't' if $val eq 'b';
      }
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:axPos', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_number_format()
  #
  # Write the <c:numberFormat> element. Note: It is assumed that if a user
  # defined number format is supplied (i.e., non-default) then the sourceLinked
  # attribute is 0. The user can override this if required.
  #
  sub _write_number_format {
  
      my $self          = shift;
      my $axis          = shift;
      my $format_code   = $axis->{_num_format};
      my $source_linked = 1;
  
      # Check if a user defined number format has been set.
      if ( $format_code ne $axis->{_defaults}->{num_format} ) {
          $source_linked = 0;
      }
  
      # User override of sourceLinked.
      if ( $axis->{_num_format_linked} ) {
          $source_linked = 1;
      }
  
      my @attributes = (
          'formatCode'   => $format_code,
          'sourceLinked' => $source_linked,
      );
  
      $self->xml_empty_tag( 'c:numFmt', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_cat_number_format()
  #
  # Write the <c:numFmt> element. Special case handler for category axes which
  # don't always have a number format.
  #
  sub _write_cat_number_format {
  
      my $self           = shift;
      my $axis           = shift;
      my $format_code    = $axis->{_num_format};
      my $source_linked  = 1;
      my $default_format = 1;
  
      # Check if a user defined number format has been set.
      if ( $format_code ne $axis->{_defaults}->{num_format} ) {
          $source_linked  = 0;
          $default_format = 0;
      }
  
      # User override of linkedSource.
      if ( $axis->{_num_format_linked} ) {
          $source_linked = 1;
      }
  
      # Skip if cat doesn't have a num format (unless it is non-default).
      if ( !$self->{_cat_has_num_fmt} && $default_format ) {
          return;
      }
  
      my @attributes = (
          'formatCode'   => $format_code,
          'sourceLinked' => $source_linked,
      );
  
      $self->xml_empty_tag( 'c:numFmt', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_number_format()
  #
  # Write the <c:numberFormat> element for data labels.
  #
  sub _write_data_label_number_format {
  
      my $self          = shift;
      my $format_code   = shift;
      my $source_linked = 0;
  
      my @attributes = (
          'formatCode'   => $format_code,
          'sourceLinked' => $source_linked,
      );
  
      $self->xml_empty_tag( 'c:numFmt', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_major_tick_mark()
  #
  # Write the <c:majorTickMark> element.
  #
  sub _write_major_tick_mark {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:majorTickMark', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_minor_tick_mark()
  #
  # Write the <c:minorTickMark> element.
  #
  sub _write_minor_tick_mark {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:minorTickMark', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_tick_label_pos()
  #
  # Write the <c:tickLblPos> element.
  #
  sub _write_tick_label_pos {
  
      my $self = shift;
      my $val = shift || 'nextTo';
  
      if ( $val eq 'next_to' ) {
          $val = 'nextTo';
      }
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:tickLblPos', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_cross_axis()
  #
  # Write the <c:crossAx> element.
  #
  sub _write_cross_axis {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:crossAx', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_crosses()
  #
  # Write the <c:crosses> element.
  #
  sub _write_crosses {
  
      my $self = shift;
      my $val = shift || 'autoZero';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:crosses', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_crosses_at()
  #
  # Write the <c:crossesAt> element.
  #
  sub _write_c_crosses_at {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:crossesAt', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_auto()
  #
  # Write the <c:auto> element.
  #
  sub _write_auto {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:auto', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_label_align()
  #
  # Write the <c:labelAlign> element.
  #
  sub _write_label_align {
  
      my $self = shift;
      my $val  = 'ctr';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:lblAlgn', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_label_offset()
  #
  # Write the <c:labelOffset> element.
  #
  sub _write_label_offset {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:lblOffset', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_tick_lbl_skip()
  #
  # Write the <c:tickLblSkip> element.
  #
  sub _write_tick_lbl_skip {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:tickLblSkip', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_tick_mark_skip()
  #
  # Write the <c:tickMarkSkip> element.
  #
  sub _write_tick_mark_skip {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:tickMarkSkip', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_major_gridlines()
  #
  # Write the <c:majorGridlines> element.
  #
  sub _write_major_gridlines {
  
      my $self      = shift;
      my $gridlines = shift;
  
      return unless $gridlines;
      return unless $gridlines->{_visible};
  
      if ( $gridlines->{_line}->{_defined} ) {
          $self->xml_start_tag( 'c:majorGridlines' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $gridlines );
  
          $self->xml_end_tag( 'c:majorGridlines' );
      }
      else {
          $self->xml_empty_tag( 'c:majorGridlines' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_minor_gridlines()
  #
  # Write the <c:minorGridlines> element.
  #
  sub _write_minor_gridlines {
  
      my $self      = shift;
      my $gridlines = shift;
  
      return unless $gridlines;
      return unless $gridlines->{_visible};
  
      if ( $gridlines->{_line}->{_defined} ) {
          $self->xml_start_tag( 'c:minorGridlines' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $gridlines );
  
          $self->xml_end_tag( 'c:minorGridlines' );
      }
      else {
          $self->xml_empty_tag( 'c:minorGridlines' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_cross_between()
  #
  # Write the <c:crossBetween> element.
  #
  sub _write_cross_between {
  
      my $self = shift;
  
      my $val = shift || $self->{_cross_between};
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:crossBetween', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_major_unit()
  #
  # Write the <c:majorUnit> element.
  #
  sub _write_c_major_unit {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:majorUnit', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_minor_unit()
  #
  # Write the <c:minorUnit> element.
  #
  sub _write_c_minor_unit {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:minorUnit', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_major_time_unit()
  #
  # Write the <c:majorTimeUnit> element.
  #
  sub _write_c_major_time_unit {
  
      my $self = shift;
      my $val = shift || 'days';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:majorTimeUnit', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_minor_time_unit()
  #
  # Write the <c:minorTimeUnit> element.
  #
  sub _write_c_minor_time_unit {
  
      my $self = shift;
      my $val = shift || 'days';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:minorTimeUnit', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_legend()
  #
  # Write the <c:legend> element.
  #
  sub _write_legend {
  
      my $self          = shift;
      my $position      = $self->{_legend_position};
      my $font          = $self->{_legend_font};
      my @delete_series = ();
      my $overlay       = 0;
  
      if ( defined $self->{_legend_delete_series}
          && ref $self->{_legend_delete_series} eq 'ARRAY' )
      {
          @delete_series = @{ $self->{_legend_delete_series} };
      }
  
      if ( $position =~ s/^overlay_// ) {
          $overlay = 1;
      }
  
      my %allowed = (
          right  => 'r',
          left   => 'l',
          top    => 't',
          bottom => 'b',
      );
  
      return if $position eq 'none';
      return unless exists $allowed{$position};
  
      $position = $allowed{$position};
  
      $self->xml_start_tag( 'c:legend' );
  
      # Write the c:legendPos element.
      $self->_write_legend_pos( $position );
  
      # Remove series labels from the legend.
      for my $index ( @delete_series ) {
  
          # Write the c:legendEntry element.
          $self->_write_legend_entry( $index );
      }
  
      # Write the c:layout element.
      $self->_write_layout( $self->{_legend_layout}, 'legend' );
  
      # Write the c:txPr element.
      if ( $font ) {
          $self->_write_tx_pr( undef, $font );
      }
  
      # Write the c:overlay element.
      $self->_write_overlay() if $overlay;
  
      $self->xml_end_tag( 'c:legend' );
  }
  
  
  ##############################################################################
  #
  # _write_legend_pos()
  #
  # Write the <c:legendPos> element.
  #
  sub _write_legend_pos {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:legendPos', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_legend_entry()
  #
  # Write the <c:legendEntry> element.
  #
  sub _write_legend_entry {
  
      my $self  = shift;
      my $index = shift;
  
      $self->xml_start_tag( 'c:legendEntry' );
  
      # Write the c:idx element.
      $self->_write_idx( $index );
  
      # Write the c:delete element.
      $self->_write_delete( 1 );
  
      $self->xml_end_tag( 'c:legendEntry' );
  }
  
  
  ##############################################################################
  #
  # _write_overlay()
  #
  # Write the <c:overlay> element.
  #
  sub _write_overlay {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:overlay', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_plot_vis_only()
  #
  # Write the <c:plotVisOnly> element.
  #
  sub _write_plot_vis_only {
  
      my $self = shift;
      my $val  = 1;
  
      # Ignore this element if we are plotting hidden data.
      return if $self->{_show_hidden_data};
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:plotVisOnly', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_print_settings()
  #
  # Write the <c:printSettings> element.
  #
  sub _write_print_settings {
  
      my $self = shift;
  
      $self->xml_start_tag( 'c:printSettings' );
  
      # Write the c:headerFooter element.
      $self->_write_header_footer();
  
      # Write the c:pageMargins element.
      $self->_write_page_margins();
  
      # Write the c:pageSetup element.
      $self->_write_page_setup();
  
      $self->xml_end_tag( 'c:printSettings' );
  }
  
  
  ##############################################################################
  #
  # _write_header_footer()
  #
  # Write the <c:headerFooter> element.
  #
  sub _write_header_footer {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'c:headerFooter' );
  }
  
  
  ##############################################################################
  #
  # _write_page_margins()
  #
  # Write the <c:pageMargins> element.
  #
  sub _write_page_margins {
  
      my $self   = shift;
      my $b      = 0.75;
      my $l      = 0.7;
      my $r      = 0.7;
      my $t      = 0.75;
      my $header = 0.3;
      my $footer = 0.3;
  
      my @attributes = (
          'b'      => $b,
          'l'      => $l,
          'r'      => $r,
          't'      => $t,
          'header' => $header,
          'footer' => $footer,
      );
  
      $self->xml_empty_tag( 'c:pageMargins', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_page_setup()
  #
  # Write the <c:pageSetup> element.
  #
  sub _write_page_setup {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'c:pageSetup' );
  }
  
  
  ##############################################################################
  #
  # _write_auto_title_deleted()
  #
  # Write the <c:autoTitleDeleted> element.
  #
  sub _write_auto_title_deleted {
  
      my $self = shift;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:autoTitleDeleted', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_title_rich()
  #
  # Write the <c:title> element for a rich string.
  #
  sub _write_title_rich {
  
      my $self    = shift;
      my $title   = shift;
      my $horiz   = shift;
      my $font    = shift;
      my $layout  = shift;
      my $overlay = shift;
  
      $self->xml_start_tag( 'c:title' );
  
      # Write the c:tx element.
      $self->_write_tx_rich( $title, $horiz, $font );
  
      # Write the c:layout element.
      $self->_write_layout( $layout, 'text' );
  
      # Write the c:overlay element.
      $self->_write_overlay() if $overlay;
  
      $self->xml_end_tag( 'c:title' );
  }
  
  
  ##############################################################################
  #
  # _write_title_formula()
  #
  # Write the <c:title> element for a rich string.
  #
  sub _write_title_formula {
  
      my $self    = shift;
      my $title   = shift;
      my $data_id = shift;
      my $horiz   = shift;
      my $font    = shift;
      my $layout  = shift;
      my $overlay = shift;
  
      $self->xml_start_tag( 'c:title' );
  
      # Write the c:tx element.
      $self->_write_tx_formula( $title, $data_id );
  
      # Write the c:layout element.
      $self->_write_layout( $layout, 'text' );
  
      # Write the c:overlay element.
      $self->_write_overlay() if $overlay;
  
      # Write the c:txPr element.
      $self->_write_tx_pr( $horiz, $font );
  
      $self->xml_end_tag( 'c:title' );
  }
  
  
  ##############################################################################
  #
  # _write_tx_rich()
  #
  # Write the <c:tx> element.
  #
  sub _write_tx_rich {
  
      my $self  = shift;
      my $title = shift;
      my $horiz = shift;
      my $font  = shift;
  
      $self->xml_start_tag( 'c:tx' );
  
      # Write the c:rich element.
      $self->_write_rich( $title, $horiz, $font );
  
      $self->xml_end_tag( 'c:tx' );
  }
  
  
  ##############################################################################
  #
  # _write_tx_value()
  #
  # Write the <c:tx> element with a simple value such as for series names.
  #
  sub _write_tx_value {
  
      my $self  = shift;
      my $title = shift;
  
      $self->xml_start_tag( 'c:tx' );
  
      # Write the c:v element.
      $self->_write_v( $title );
  
      $self->xml_end_tag( 'c:tx' );
  }
  
  
  ##############################################################################
  #
  # _write_tx_formula()
  #
  # Write the <c:tx> element.
  #
  sub _write_tx_formula {
  
      my $self    = shift;
      my $title   = shift;
      my $data_id = shift;
      my $data;
  
      if ( defined $data_id ) {
          $data = $self->{_formula_data}->[$data_id];
      }
  
      $self->xml_start_tag( 'c:tx' );
  
      # Write the c:strRef element.
      $self->_write_str_ref( $title, $data, 'str' );
  
      $self->xml_end_tag( 'c:tx' );
  }
  
  
  ##############################################################################
  #
  # _write_rich()
  #
  # Write the <c:rich> element.
  #
  sub _write_rich {
  
      my $self     = shift;
      my $title    = shift;
      my $horiz    = shift;
      my $rotation = undef;
      my $font     = shift;
  
      if ( $font && exists $font->{_rotation} ) {
          $rotation = $font->{_rotation};
      }
  
      $self->xml_start_tag( 'c:rich' );
  
      # Write the a:bodyPr element.
      $self->_write_a_body_pr( $rotation, $horiz );
  
      # Write the a:lstStyle element.
      $self->_write_a_lst_style();
  
      # Write the a:p element.
      $self->_write_a_p_rich( $title, $font );
  
      $self->xml_end_tag( 'c:rich' );
  }
  
  
  ##############################################################################
  #
  # _write_a_body_pr()
  #
  # Write the <a:bodyPr> element.
  sub _write_a_body_pr {
  
      my $self  = shift;
      my $rot   = shift;
      my $horiz = shift;
  
      my @attributes = ();
  
      if ( !defined $rot && $horiz ) {
          $rot = -5400000;
      }
  
      push @attributes, ( 'rot' => $rot ) if defined $rot;
      push @attributes, ( 'vert' => 'horz' ) if $horiz;
  
      $self->xml_empty_tag( 'a:bodyPr', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_lst_style()
  #
  # Write the <a:lstStyle> element.
  #
  sub _write_a_lst_style {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'a:lstStyle' );
  }
  
  
  ##############################################################################
  #
  # _write_a_p_rich()
  #
  # Write the <a:p> element for rich string titles.
  #
  sub _write_a_p_rich {
  
      my $self  = shift;
      my $title = shift;
      my $font  = shift;
  
      $self->xml_start_tag( 'a:p' );
  
      # Write the a:pPr element.
      $self->_write_a_p_pr_rich( $font );
  
      # Write the a:r element.
      $self->_write_a_r( $title, $font );
  
      $self->xml_end_tag( 'a:p' );
  }
  
  
  ##############################################################################
  #
  # _write_a_p_formula()
  #
  # Write the <a:p> element for formula titles.
  #
  sub _write_a_p_formula {
  
      my $self = shift;
      my $font = shift;
  
      $self->xml_start_tag( 'a:p' );
  
      # Write the a:pPr element.
      $self->_write_a_p_pr_formula( $font );
  
      # Write the a:endParaRPr element.
      $self->_write_a_end_para_rpr();
  
      $self->xml_end_tag( 'a:p' );
  }
  
  
  ##############################################################################
  #
  # _write_a_p_pr_rich()
  #
  # Write the <a:pPr> element for rich string titles.
  #
  sub _write_a_p_pr_rich {
  
      my $self = shift;
      my $font = shift;
  
      $self->xml_start_tag( 'a:pPr' );
  
      # Write the a:defRPr element.
      $self->_write_a_def_rpr( $font );
  
      $self->xml_end_tag( 'a:pPr' );
  }
  
  
  ##############################################################################
  #
  # _write_a_p_pr_formula()
  #
  # Write the <a:pPr> element for formula titles.
  #
  sub _write_a_p_pr_formula {
  
      my $self = shift;
      my $font = shift;
  
      $self->xml_start_tag( 'a:pPr' );
  
      # Write the a:defRPr element.
      $self->_write_a_def_rpr( $font );
  
      $self->xml_end_tag( 'a:pPr' );
  }
  
  
  ##############################################################################
  #
  # _write_a_def_rpr()
  #
  # Write the <a:defRPr> element.
  #
  sub _write_a_def_rpr {
  
      my $self      = shift;
      my $font      = shift;
      my $has_color = 0;
  
      my @style_attributes = $self->_get_font_style_attributes( $font );
      my @latin_attributes = $self->_get_font_latin_attributes( $font );
  
      $has_color = 1 if $font && $font->{_color};
  
      if ( @latin_attributes || $has_color ) {
          $self->xml_start_tag( 'a:defRPr', @style_attributes );
  
  
          if ( $has_color ) {
              $self->_write_a_solid_fill( { color => $font->{_color} } );
          }
  
          if ( @latin_attributes ) {
              $self->_write_a_latin( @latin_attributes );
          }
  
          $self->xml_end_tag( 'a:defRPr' );
      }
      else {
          $self->xml_empty_tag( 'a:defRPr', @style_attributes );
      }
  }
  
  
  ##############################################################################
  #
  # _write_a_end_para_rpr()
  #
  # Write the <a:endParaRPr> element.
  #
  sub _write_a_end_para_rpr {
  
      my $self = shift;
      my $lang = 'en-US';
  
      my @attributes = ( 'lang' => $lang );
  
      $self->xml_empty_tag( 'a:endParaRPr', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_r()
  #
  # Write the <a:r> element.
  #
  sub _write_a_r {
  
      my $self  = shift;
      my $title = shift;
      my $font  = shift;
  
      $self->xml_start_tag( 'a:r' );
  
      # Write the a:rPr element.
      $self->_write_a_r_pr( $font );
  
      # Write the a:t element.
      $self->_write_a_t( $title );
  
      $self->xml_end_tag( 'a:r' );
  }
  
  
  ##############################################################################
  #
  # _write_a_r_pr()
  #
  # Write the <a:rPr> element.
  #
  sub _write_a_r_pr {
  
      my $self      = shift;
      my $font      = shift;
      my $has_color = 0;
      my $lang      = 'en-US';
  
      my @style_attributes = $self->_get_font_style_attributes( $font );
      my @latin_attributes = $self->_get_font_latin_attributes( $font );
  
      $has_color = 1 if $font && $font->{_color};
  
      # Add the lang type to the attributes.
      @style_attributes = ( 'lang' => $lang, @style_attributes );
  
  
      if ( @latin_attributes || $has_color ) {
          $self->xml_start_tag( 'a:rPr', @style_attributes );
  
  
          if ( $has_color ) {
              $self->_write_a_solid_fill( { color => $font->{_color} } );
          }
  
          if ( @latin_attributes ) {
              $self->_write_a_latin( @latin_attributes );
          }
  
          $self->xml_end_tag( 'a:rPr' );
      }
      else {
          $self->xml_empty_tag( 'a:rPr', @style_attributes );
      }
  
  
  }
  
  
  ##############################################################################
  #
  # _write_a_t()
  #
  # Write the <a:t> element.
  #
  sub _write_a_t {
  
      my $self  = shift;
      my $title = shift;
  
      $self->xml_data_element( 'a:t', $title );
  }
  
  
  ##############################################################################
  #
  # _write_tx_pr()
  #
  # Write the <c:txPr> element.
  #
  sub _write_tx_pr {
  
      my $self     = shift;
      my $horiz    = shift;
      my $font     = shift;
      my $rotation = undef;
  
      if ( $font && exists $font->{_rotation} ) {
          $rotation = $font->{_rotation};
      }
  
      $self->xml_start_tag( 'c:txPr' );
  
      # Write the a:bodyPr element.
      $self->_write_a_body_pr( $rotation, $horiz );
  
      # Write the a:lstStyle element.
      $self->_write_a_lst_style();
  
      # Write the a:p element.
      $self->_write_a_p_formula( $font );
  
      $self->xml_end_tag( 'c:txPr' );
  }
  
  
  ##############################################################################
  #
  # _write_marker()
  #
  # Write the <c:marker> element.
  #
  sub _write_marker {
  
      my $self = shift;
      my $marker = shift || $self->{_default_marker};
  
      return unless $marker;
      return if $marker->{automatic};
  
      $self->xml_start_tag( 'c:marker' );
  
      # Write the c:symbol element.
      $self->_write_symbol( $marker->{type} );
  
      # Write the c:size element.
      my $size = $marker->{size};
      $self->_write_marker_size( $size ) if $size;
  
      # Write the c:spPr element.
      $self->_write_sp_pr( $marker );
  
      $self->xml_end_tag( 'c:marker' );
  }
  
  
  ##############################################################################
  #
  # _write_marker_value()
  #
  # Write the <c:marker> element without a sub-element.
  #
  sub _write_marker_value {
  
      my $self  = shift;
      my $style = $self->{_default_marker};
  
      return unless $style;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:marker', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_marker_size()
  #
  # Write the <c:size> element.
  #
  sub _write_marker_size {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:size', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_symbol()
  #
  # Write the <c:symbol> element.
  #
  sub _write_symbol {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:symbol', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_sp_pr()
  #
  # Write the <c:spPr> element.
  #
  sub _write_sp_pr {
  
      my $self   = shift;
      my $series = shift;
  
      if (    !$series->{_line}->{_defined}
          and !$series->{_fill}->{_defined}
          and !$series->{_pattern}
          and !$series->{_gradient} )
      {
          return;
      }
  
  
      $self->xml_start_tag( 'c:spPr' );
  
      # Write the fill elements for solid charts such as pie/doughnut and bar.
      if ( $series->{_fill}->{_defined} ) {
  
          if ( $series->{_fill}->{none} ) {
  
              # Write the a:noFill element.
              $self->_write_a_no_fill();
          }
          else {
              # Write the a:solidFill element.
              $self->_write_a_solid_fill( $series->{_fill} );
          }
      }
  
      if ( $series->{_pattern} ) {
  
          # Write the a:pattFill element.
          $self->_write_a_patt_fill( $series->{_pattern} );
      }
  
      if ( $series->{_gradient} ) {
  
          # Write the a:gradFill element.
          $self->_write_a_grad_fill( $series->{_gradient} );
      }
  
  
      # Write the a:ln element.
      if ( $series->{_line}->{_defined} ) {
          $self->_write_a_ln( $series->{_line} );
      }
  
      $self->xml_end_tag( 'c:spPr' );
  }
  
  
  ##############################################################################
  #
  # _write_a_ln()
  #
  # Write the <a:ln> element.
  #
  sub _write_a_ln {
  
      my $self       = shift;
      my $line       = shift;
      my @attributes = ();
  
      # Add the line width as an attribute.
      if ( my $width = $line->{width} ) {
  
          # Round width to nearest 0.25, like Excel.
          $width = int( ( $width + 0.125 ) * 4 ) / 4;
  
          # Convert to internal units.
          $width = int( 0.5 + ( 12700 * $width ) );
  
          @attributes = ( 'w' => $width );
      }
  
      $self->xml_start_tag( 'a:ln', @attributes );
  
      # Write the line fill.
      if ( $line->{none} ) {
  
          # Write the a:noFill element.
          $self->_write_a_no_fill();
      }
      elsif ( $line->{color} ) {
  
          # Write the a:solidFill element.
          $self->_write_a_solid_fill( $line );
      }
  
      # Write the line/dash type.
      if ( my $type = $line->{dash_type} ) {
  
          # Write the a:prstDash element.
          $self->_write_a_prst_dash( $type );
      }
  
      $self->xml_end_tag( 'a:ln' );
  }
  
  
  ##############################################################################
  #
  # _write_a_no_fill()
  #
  # Write the <a:noFill> element.
  #
  sub _write_a_no_fill {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'a:noFill' );
  }
  
  
  ##############################################################################
  #
  # _write_a_solid_fill()
  #
  # Write the <a:solidFill> element.
  #
  sub _write_a_solid_fill {
  
      my $self = shift;
      my $fill = shift;
  
      $self->xml_start_tag( 'a:solidFill' );
  
      if ( $fill->{color} ) {
  
          my $color = $self->_get_color( $fill->{color} );
  
          # Write the a:srgbClr element.
          $self->_write_a_srgb_clr( $color, $fill->{transparency} );
      }
  
      $self->xml_end_tag( 'a:solidFill' );
  }
  
  
  ##############################################################################
  #
  # _write_a_srgb_clr()
  #
  # Write the <a:srgbClr> element.
  #
  sub _write_a_srgb_clr {
  
      my $self         = shift;
      my $color        = shift;
      my $transparency = shift;
  
      my @attributes = ( 'val' => $color );
  
      if ( $transparency ) {
          $self->xml_start_tag( 'a:srgbClr', @attributes );
  
          # Write the a:alpha element.
          $self->_write_a_alpha( $transparency );
  
          $self->xml_end_tag( 'a:srgbClr' );
      }
      else {
          $self->xml_empty_tag( 'a:srgbClr', @attributes );
      }
  }
  
  
  ##############################################################################
  #
  # _write_a_alpha()
  #
  # Write the <a:alpha> element.
  #
  sub _write_a_alpha {
  
      my $self = shift;
      my $val  = shift;
  
      $val = ( 100 - int( $val ) ) * 1000;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'a:alpha', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_prst_dash()
  #
  # Write the <a:prstDash> element.
  #
  sub _write_a_prst_dash {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'a:prstDash', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_trendline()
  #
  # Write the <c:trendline> element.
  #
  sub _write_trendline {
  
      my $self      = shift;
      my $trendline = shift;
  
      return unless $trendline;
  
      $self->xml_start_tag( 'c:trendline' );
  
      # Write the c:name element.
      $self->_write_name( $trendline->{name} );
  
      # Write the c:spPr element.
      $self->_write_sp_pr( $trendline );
  
      # Write the c:trendlineType element.
      $self->_write_trendline_type( $trendline->{type} );
  
      # Write the c:order element for polynomial trendlines.
      if ( $trendline->{type} eq 'poly' ) {
          $self->_write_trendline_order( $trendline->{order} );
      }
  
      # Write the c:period element for moving average trendlines.
      if ( $trendline->{type} eq 'movingAvg' ) {
          $self->_write_period( $trendline->{period} );
      }
  
      # Write the c:forward element.
      $self->_write_forward( $trendline->{forward} );
  
      # Write the c:backward element.
      $self->_write_backward( $trendline->{backward} );
  
      $self->xml_end_tag( 'c:trendline' );
  }
  
  
  ##############################################################################
  #
  # _write_trendline_type()
  #
  # Write the <c:trendlineType> element.
  #
  sub _write_trendline_type {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:trendlineType', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_name()
  #
  # Write the <c:name> element.
  #
  sub _write_name {
  
      my $self = shift;
      my $data = shift;
  
      return unless defined $data;
  
      $self->xml_data_element( 'c:name', $data );
  }
  
  
  ##############################################################################
  #
  # _write_trendline_order()
  #
  # Write the <c:order> element.
  #
  sub _write_trendline_order {
  
      my $self = shift;
      my $val = defined $_[0] ? $_[0] : 2;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:order', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_period()
  #
  # Write the <c:period> element.
  #
  sub _write_period {
  
      my $self = shift;
      my $val = defined $_[0] ? $_[0] : 2;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:period', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_forward()
  #
  # Write the <c:forward> element.
  #
  sub _write_forward {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:forward', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_backward()
  #
  # Write the <c:backward> element.
  #
  sub _write_backward {
  
      my $self = shift;
      my $val  = shift;
  
      return unless $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:backward', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_hi_low_lines()
  #
  # Write the <c:hiLowLines> element.
  #
  sub _write_hi_low_lines {
  
      my $self = shift;
  
      my $hi_low_lines = $self->{_hi_low_lines};
  
      return unless $hi_low_lines;
  
      if ( $hi_low_lines->{_line}->{_defined} ) {
  
          $self->xml_start_tag( 'c:hiLowLines' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $hi_low_lines );
  
          $self->xml_end_tag( 'c:hiLowLines' );
      }
      else {
          $self->xml_empty_tag( 'c:hiLowLines' );
      }
  }
  
  
  #############################################################################
  #
  # _write_drop_lines()
  #
  # Write the <c:dropLines> element.
  #
  sub _write_drop_lines {
  
      my $self = shift;
  
      my $drop_lines = $self->{_drop_lines};
  
      return unless $drop_lines;
  
      if ( $drop_lines->{_line}->{_defined} ) {
  
          $self->xml_start_tag( 'c:dropLines' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $drop_lines );
  
          $self->xml_end_tag( 'c:dropLines' );
      }
      else {
          $self->xml_empty_tag( 'c:dropLines' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_overlap()
  #
  # Write the <c:overlap> element.
  #
  sub _write_overlap {
  
      my $self = shift;
      my $val  = shift;
  
      return if !defined $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:overlap', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_num_cache()
  #
  # Write the <c:numCache> element.
  #
  sub _write_num_cache {
  
      my $self  = shift;
      my $data  = shift;
      my $count = @$data;
  
      $self->xml_start_tag( 'c:numCache' );
  
      # Write the c:formatCode element.
      $self->_write_format_code( 'General' );
  
      # Write the c:ptCount element.
      $self->_write_pt_count( $count );
  
      for my $i ( 0 .. $count - 1 ) {
          my $token = $data->[$i];
  
          # Write non-numeric data as 0.
          if ( defined $token
              && $token !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/ )
          {
              $token = 0;
          }
  
          # Write the c:pt element.
          $self->_write_pt( $i, $token );
      }
  
      $self->xml_end_tag( 'c:numCache' );
  }
  
  
  ##############################################################################
  #
  # _write_str_cache()
  #
  # Write the <c:strCache> element.
  #
  sub _write_str_cache {
  
      my $self  = shift;
      my $data  = shift;
      my $count = @$data;
  
      $self->xml_start_tag( 'c:strCache' );
  
      # Write the c:ptCount element.
      $self->_write_pt_count( $count );
  
      for my $i ( 0 .. $count - 1 ) {
  
          # Write the c:pt element.
          $self->_write_pt( $i, $data->[$i] );
      }
  
      $self->xml_end_tag( 'c:strCache' );
  }
  
  
  ##############################################################################
  #
  # _write_format_code()
  #
  # Write the <c:formatCode> element.
  #
  sub _write_format_code {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'c:formatCode', $data );
  }
  
  
  ##############################################################################
  #
  # _write_pt_count()
  #
  # Write the <c:ptCount> element.
  #
  sub _write_pt_count {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:ptCount', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_pt()
  #
  # Write the <c:pt> element.
  #
  sub _write_pt {
  
      my $self  = shift;
      my $idx   = shift;
      my $value = shift;
  
      return if !defined $value;
  
      my @attributes = ( 'idx' => $idx );
  
      $self->xml_start_tag( 'c:pt', @attributes );
  
      # Write the c:v element.
      $self->_write_v( $value );
  
      $self->xml_end_tag( 'c:pt' );
  }
  
  
  ##############################################################################
  #
  # _write_v()
  #
  # Write the <c:v> element.
  #
  sub _write_v {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'c:v', $data );
  }
  
  
  ##############################################################################
  #
  # _write_protection()
  #
  # Write the <c:protection> element.
  #
  sub _write_protection {
  
      my $self = shift;
  
      return unless $self->{_protection};
  
      $self->xml_empty_tag( 'c:protection' );
  }
  
  
  ##############################################################################
  #
  # _write_d_pt()
  #
  # Write the <c:dPt> elements.
  #
  sub _write_d_pt {
  
      my $self   = shift;
      my $points = shift;
      my $index  = -1;
  
      return unless $points;
  
      for my $point ( @$points ) {
  
          $index++;
          next unless $point;
  
          $self->_write_d_pt_point( $index, $point );
      }
  }
  
  
  ##############################################################################
  #
  # _write_d_pt_point()
  #
  # Write an individual <c:dPt> element.
  #
  sub _write_d_pt_point {
  
      my $self   = shift;
      my $index = shift;
      my $point = shift;
  
          $self->xml_start_tag( 'c:dPt' );
  
          # Write the c:idx element.
          $self->_write_idx( $index );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $point );
  
          $self->xml_end_tag( 'c:dPt' );
  
  }
  
  
  ##############################################################################
  #
  # _write_d_lbls()
  #
  # Write the <c:dLbls> element.
  #
  sub _write_d_lbls {
  
      my $self   = shift;
      my $labels = shift;
  
      return unless $labels;
  
      $self->xml_start_tag( 'c:dLbls' );
  
      # Write the c:numFmt element.
      if ( $labels->{num_format} ) {
          $self->_write_data_label_number_format( $labels->{num_format} );
      }
  
      # Write the data label font elements.
      if ($labels->{font} ) {
          $self->_write_axis_font( $labels->{font} );
      }
  
      # Write the c:dLblPos element.
      $self->_write_d_lbl_pos( $labels->{position} ) if $labels->{position};
  
      # Write the c:showLegendKey element.
      $self->_write_show_legend_key() if $labels->{legend_key};
  
      # Write the c:showVal element.
      $self->_write_show_val() if $labels->{value};
  
      # Write the c:showCatName element.
      $self->_write_show_cat_name() if $labels->{category};
  
      # Write the c:showSerName element.
      $self->_write_show_ser_name() if $labels->{series_name};
  
      # Write the c:showPercent element.
      $self->_write_show_percent() if $labels->{percentage};
  
      # Write the c:separator element.
      $self->_write_separator($labels->{separator}) if $labels->{separator};
  
      # Write the c:showLeaderLines element.
      $self->_write_show_leader_lines() if $labels->{leader_lines};
  
      $self->xml_end_tag( 'c:dLbls' );
  }
  
  ##############################################################################
  #
  # _write_show_legend_key()
  #
  # Write the <c:showLegendKey> element.
  #
  sub _write_show_legend_key {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:showLegendKey', @attributes );
  }
  
  ##############################################################################
  #
  # _write_show_val()
  #
  # Write the <c:showVal> element.
  #
  sub _write_show_val {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:showVal', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_show_cat_name()
  #
  # Write the <c:showCatName> element.
  #
  sub _write_show_cat_name {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:showCatName', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_show_ser_name()
  #
  # Write the <c:showSerName> element.
  #
  sub _write_show_ser_name {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:showSerName', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_show_percent()
  #
  # Write the <c:showPercent> element.
  #
  sub _write_show_percent {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:showPercent', @attributes );
  }
  
  ##############################################################################
  #
  # _write_separator()
  #
  # Write the <c:separator> element.
  #
  sub _write_separator {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'c:separator', $data );
  }
  
  ##############################################################################
  #
  # _write_show_leader_lines()
  #
  # Write the <c:showLeaderLines> element.
  #
  sub _write_show_leader_lines {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:showLeaderLines', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_d_lbl_pos()
  #
  # Write the <c:dLblPos> element.
  #
  sub _write_d_lbl_pos {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:dLblPos', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_delete()
  #
  # Write the <c:delete> element.
  #
  sub _write_delete {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:delete', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_invert_if_negative()
  #
  # Write the <c:invertIfNegative> element.
  #
  sub _write_c_invert_if_negative {
  
      my $self   = shift;
      my $invert = shift;
      my $val    = 1;
  
      return unless $invert;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:invertIfNegative', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_axis_font()
  #
  # Write the axis font elements.
  #
  sub _write_axis_font {
  
      my $self = shift;
      my $font = shift;
  
      return unless $font;
  
      $self->xml_start_tag( 'c:txPr' );
      $self->_write_a_body_pr($font->{_rotation});
      $self->_write_a_lst_style();
      $self->xml_start_tag( 'a:p' );
  
      $self->_write_a_p_pr_rich( $font );
  
      $self->_write_a_end_para_rpr();
      $self->xml_end_tag( 'a:p' );
      $self->xml_end_tag( 'c:txPr' );
  }
  
  
  ##############################################################################
  #
  # _write_a_latin()
  #
  # Write the <a:latin> element.
  #
  sub _write_a_latin {
  
      my $self       = shift;
      my @attributes = @_;
  
      $self->xml_empty_tag( 'a:latin', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_d_table()
  #
  # Write the <c:dTable> element.
  #
  sub _write_d_table {
  
      my $self  = shift;
      my $table = $self->{_table};
  
      return if !$table;
  
      $self->xml_start_tag( 'c:dTable' );
  
      if ( $table->{_horizontal} ) {
  
          # Write the c:showHorzBorder element.
          $self->_write_show_horz_border();
      }
  
      if ( $table->{_vertical} ) {
  
          # Write the c:showVertBorder element.
          $self->_write_show_vert_border();
      }
  
      if ( $table->{_outline} ) {
  
          # Write the c:showOutline element.
          $self->_write_show_outline();
      }
  
      if ( $table->{_show_keys} ) {
  
          # Write the c:showKeys element.
          $self->_write_show_keys();
      }
  
      $self->xml_end_tag( 'c:dTable' );
  }
  
  
  ##############################################################################
  #
  # _write_show_horz_border()
  #
  # Write the <c:showHorzBorder> element.
  #
  sub _write_show_horz_border {
  
      my $self = shift;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:showHorzBorder', @attributes );
  }
  
  ##############################################################################
  #
  # _write_show_vert_border()
  #
  # Write the <c:showVertBorder> element.
  #
  sub _write_show_vert_border {
  
      my $self = shift;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:showVertBorder', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_show_outline()
  #
  # Write the <c:showOutline> element.
  #
  sub _write_show_outline {
  
      my $self = shift;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:showOutline', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_show_keys()
  #
  # Write the <c:showKeys> element.
  #
  sub _write_show_keys {
  
      my $self = shift;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:showKeys', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_error_bars()
  #
  # Write the X and Y error bars.
  #
  sub _write_error_bars {
  
      my $self       = shift;
      my $error_bars = shift;
  
      return unless $error_bars;
  
      if ( $error_bars->{_x_error_bars} ) {
          $self->_write_err_bars( 'x', $error_bars->{_x_error_bars} );
      }
  
      if ( $error_bars->{_y_error_bars} ) {
          $self->_write_err_bars( 'y', $error_bars->{_y_error_bars} );
      }
  
  }
  
  
  ##############################################################################
  #
  # _write_err_bars()
  #
  # Write the <c:errBars> element.
  #
  sub _write_err_bars {
  
      my $self       = shift;
      my $direction  = shift;
      my $error_bars = shift;
  
      return unless $error_bars;
  
      $self->xml_start_tag( 'c:errBars' );
  
      # Write the c:errDir element.
      $self->_write_err_dir( $direction );
  
      # Write the c:errBarType element.
      $self->_write_err_bar_type( $error_bars->{_direction} );
  
      # Write the c:errValType element.
      $self->_write_err_val_type( $error_bars->{_type} );
  
      if ( !$error_bars->{_endcap} ) {
  
          # Write the c:noEndCap element.
          $self->_write_no_end_cap();
      }
  
      if ( $error_bars->{_type} eq 'stdErr' ) {
  
          # Don't need to write a c:errValType tag.
      }
      elsif ( $error_bars->{_type} eq 'cust' ) {
  
          # Write the custom error tags.
          $self->_write_custom_error( $error_bars );
      }
      else {
          # Write the c:val element.
          $self->_write_error_val( $error_bars->{_value} );
      }
  
      # Write the c:spPr element.
      $self->_write_sp_pr( $error_bars );
  
      $self->xml_end_tag( 'c:errBars' );
  }
  
  
  ##############################################################################
  #
  # _write_err_dir()
  #
  # Write the <c:errDir> element.
  #
  sub _write_err_dir {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:errDir', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_err_bar_type()
  #
  # Write the <c:errBarType> element.
  #
  sub _write_err_bar_type {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:errBarType', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_err_val_type()
  #
  # Write the <c:errValType> element.
  #
  sub _write_err_val_type {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:errValType', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_no_end_cap()
  #
  # Write the <c:noEndCap> element.
  #
  sub _write_no_end_cap {
  
      my $self = shift;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:noEndCap', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_error_val()
  #
  # Write the <c:val> element for error bars.
  #
  sub _write_error_val {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:val', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_custom_error()
  #
  # Write the custom error bars tags.
  #
  sub _write_custom_error {
  
      my $self       = shift;
      my $error_bars = shift;
  
      if ( $error_bars->{_plus_values} ) {
  
          # Write the c:plus element.
          $self->xml_start_tag( 'c:plus' );
  
          if ( ref $error_bars->{_plus_values} eq 'ARRAY' ) {
              $self->_write_num_lit( $error_bars->{_plus_values} );
          }
          else {
              $self->_write_num_ref( $error_bars->{_plus_values},
                  $error_bars->{_plus_data}, 'num' );
          }
  
          $self->xml_end_tag( 'c:plus' );
      }
  
      if ( $error_bars->{_minus_values} ) {
  
          # Write the c:minus element.
          $self->xml_start_tag( 'c:minus' );
  
          if ( ref $error_bars->{_minus_values} eq 'ARRAY' ) {
              $self->_write_num_lit( $error_bars->{_minus_values} );
          }
          else {
              $self->_write_num_ref( $error_bars->{_minus_values},
                  $error_bars->{_minus_data}, 'num' );
          }
  
          $self->xml_end_tag( 'c:minus' );
      }
  }
  
  
  
  ##############################################################################
  #
  # _write_num_lit()
  #
  # Write the <c:numLit> element for literal number list elements.
  #
  sub _write_num_lit {
  
      my $self = shift;
      my $data  = shift;
      my $count = @$data;
  
  
      # Write the c:numLit element.
      $self->xml_start_tag( 'c:numLit' );
  
      # Write the c:formatCode element.
      $self->_write_format_code( 'General' );
  
      # Write the c:ptCount element.
      $self->_write_pt_count( $count );
  
      for my $i ( 0 .. $count - 1 ) {
          my $token = $data->[$i];
  
          # Write non-numeric data as 0.
          if ( defined $token
              && $token !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/ )
          {
              $token = 0;
          }
  
          # Write the c:pt element.
          $self->_write_pt( $i, $token );
      }
  
      $self->xml_end_tag( 'c:numLit' );
  
  
  }
  
  
  ##############################################################################
  #
  # _write_up_down_bars()
  #
  # Write the <c:upDownBars> element.
  #
  sub _write_up_down_bars {
  
      my $self         = shift;
      my $up_down_bars = $self->{_up_down_bars};
  
      return unless $up_down_bars;
  
      $self->xml_start_tag( 'c:upDownBars' );
  
      # Write the c:gapWidth element.
      $self->_write_gap_width( 150 );
  
      # Write the c:upBars element.
      $self->_write_up_bars( $up_down_bars->{_up} );
  
      # Write the c:downBars element.
      $self->_write_down_bars( $up_down_bars->{_down} );
  
      $self->xml_end_tag( 'c:upDownBars' );
  }
  
  
  ##############################################################################
  #
  # _write_gap_width()
  #
  # Write the <c:gapWidth> element.
  #
  sub _write_gap_width {
  
      my $self = shift;
      my $val  = shift;
  
      return if !defined $val;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:gapWidth', @attributes );
  }
  
  ##############################################################################
  #
  # _write_up_bars()
  #
  # Write the <c:upBars> element.
  #
  sub _write_up_bars {
  
      my $self   = shift;
      my $format = shift;
  
      if ( $format->{_line}->{_defined} || $format->{_fill}->{_defined} ) {
  
          $self->xml_start_tag( 'c:upBars' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $format );
  
          $self->xml_end_tag( 'c:upBars' );
      }
      else {
          $self->xml_empty_tag( 'c:upBars' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_down_bars()
  #
  # Write the <c:downBars> element.
  #
  sub _write_down_bars {
  
      my $self   = shift;
      my $format = shift;
  
      if ( $format->{_line}->{_defined} || $format->{_fill}->{_defined} ) {
  
          $self->xml_start_tag( 'c:downBars' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $format );
  
          $self->xml_end_tag( 'c:downBars' );
      }
      else {
          $self->xml_empty_tag( 'c:downBars' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_c_smooth()
  #
  # Write the <c:smooth> element.
  #
  sub _write_c_smooth {
  
      my $self    = shift;
      my $smooth  = shift;
  
      return unless $smooth;
  
      my @attributes = ( 'val' => 1 );
  
      $self->xml_empty_tag( 'c:smooth', @attributes );
  }
  
  ##############################################################################
  #
  # _write_disp_units()
  #
  # Write the <c:dispUnits> element.
  #
  sub _write_disp_units {
  
      my $self    = shift;
      my $units   = shift;
      my $display = shift;
  
      return if not $units;
  
      my @attributes = ( 'val' => $units );
  
      $self->xml_start_tag( 'c:dispUnits' );
  
      $self->xml_empty_tag( 'c:builtInUnit', @attributes );
  
      if ( $display ) {
          $self->xml_start_tag( 'c:dispUnitsLbl' );
          $self->xml_empty_tag( 'c:layout' );
          $self->xml_end_tag( 'c:dispUnitsLbl' );
      }
  
      $self->xml_end_tag( 'c:dispUnits' );
  }
  
  
  ##############################################################################
  #
  # _write_a_grad_fill()
  #
  # Write the <a:gradFill> element.
  #
  sub _write_a_grad_fill {
  
      my $self     = shift;
      my $gradient = shift;
  
  
      my @attributes = (
          'flip'         => 'none',
          'rotWithShape' => 1,
      );
  
  
      if ( $gradient->{_type} eq 'linear' ) {
          @attributes = ();
      }
  
      $self->xml_start_tag( 'a:gradFill', @attributes );
  
      # Write the a:gsLst element.
      $self->_write_a_gs_lst( $gradient );
  
      if ( $gradient->{_type} eq 'linear' ) {
          # Write the a:lin element.
          $self->_write_a_lin( $gradient->{_angle} );
      }
      else {
          # Write the a:path element.
          $self->_write_a_path( $gradient->{_type} );
  
          # Write the a:tileRect element.
          $self->_write_a_tile_rect( $gradient->{_type} );
      }
  
      $self->xml_end_tag( 'a:gradFill' );
  }
  
  
  ##############################################################################
  #
  # _write_a_gs_lst()
  #
  # Write the <a:gsLst> element.
  #
  sub _write_a_gs_lst {
  
      my $self      = shift;
      my $gradient  = shift;
      my $positions = $gradient->{_positions};
      my $colors    = $gradient->{_colors};
  
      $self->xml_start_tag( 'a:gsLst' );
  
      for my $i ( 0 .. @$colors -1 ) {
  
          my $pos = int($positions->[$i] * 1000);
  
          my @attributes = ( 'pos' => $pos );
          $self->xml_start_tag( 'a:gs', @attributes );
  
          my $color = $self->_get_color( $colors->[$i] );
  
          # Write the a:srgbClr element.
          # TODO: Wait for a feature request to support transparency.
          $self->_write_a_srgb_clr( $color );
  
          $self->xml_end_tag( 'a:gs' );
      }
  
      $self->xml_end_tag( 'a:gsLst' );
  }
  
  
  ##############################################################################
  #
  # _write_a_lin()
  #
  # Write the <a:lin> element.
  #
  sub _write_a_lin {
  
      my $self   = shift;
      my $angle  = shift;
      my $scaled = 0;
  
      $angle = int( 60000 * $angle );
  
      my @attributes = (
          'ang'    => $angle,
          'scaled' => $scaled,
      );
  
      $self->xml_empty_tag( 'a:lin', @attributes );
  }
  
  ##############################################################################
  #
  # _write_a_path()
  #
  # Write the <a:path> element.
  #
  sub _write_a_path {
  
      my $self = shift;
      my $type = shift;
  
  
      my @attributes = ( 'path' => $type );
  
      $self->xml_start_tag( 'a:path', @attributes );
  
      # Write the a:fillToRect element.
      $self->_write_a_fill_to_rect( $type );
  
      $self->xml_end_tag( 'a:path' );
  }
  
  
  ##############################################################################
  #
  # _write_a_fill_to_rect()
  #
  # Write the <a:fillToRect> element.
  #
  sub _write_a_fill_to_rect {
  
      my $self       = shift;
      my $type       = shift;
      my @attributes = ();
  
      if ( $type eq 'shape' ) {
          @attributes = (
              'l' => 50000,
              't' => 50000,
              'r' => 50000,
              'b' => 50000,
          );
  
      }
      else {
          @attributes = (
              'l' => 100000,
              't' => 100000,
          );
      }
  
  
      $self->xml_empty_tag( 'a:fillToRect', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_tile_rect()
  #
  # Write the <a:tileRect> element.
  #
  sub _write_a_tile_rect {
  
      my $self       = shift;
      my $type       = shift;
      my @attributes = ();
  
      if ( $type eq 'shape' ) {
          @attributes = ();
      }
      else {
          @attributes = (
              'r' => -100000,
              'b' => -100000,
          );
      }
  
      $self->xml_empty_tag( 'a:tileRect', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_patt_fill()
  #
  # Write the <a:pattFill> element.
  #
  sub _write_a_patt_fill {
  
      my $self     = shift;
      my $pattern  = shift;
  
      my @attributes = ( 'prst' => $pattern->{pattern} );
  
      $self->xml_start_tag( 'a:pattFill', @attributes );
  
      # Write the a:fgClr element.
      $self->_write_a_fg_clr( $pattern->{fg_color} );
  
      # Write the a:bgClr element.
      $self->_write_a_bg_clr( $pattern->{bg_color} );
  
      $self->xml_end_tag( 'a:pattFill' );
  }
  
  
  ##############################################################################
  #
  # _write_a_fg_clr()
  #
  # Write the <a:fgClr> element.
  #
  sub _write_a_fg_clr {
  
      my $self  = shift;
      my $color = shift;
  
      $color = $self->_get_color( $color );
  
      $self->xml_start_tag( 'a:fgClr' );
  
      # Write the a:srgbClr element.
      $self->_write_a_srgb_clr( $color );
  
      $self->xml_end_tag( 'a:fgClr' );
  }
  
  
  
  ##############################################################################
  #
  # _write_a_bg_clr()
  #
  # Write the <a:bgClr> element.
  #
  sub _write_a_bg_clr {
  
      my $self  = shift;
      my $color = shift;
  
      $color = $self->_get_color( $color );
  
      $self->xml_start_tag( 'a:bgClr' );
  
      # Write the a:srgbClr element.
      $self->_write_a_srgb_clr( $color );
  
      $self->xml_end_tag( 'a:bgClr' );
  }
  
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Chart - A class for writing Excel Charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
  
      ];
  
      $worksheet->write( 'A1', $data );
  
      # Add a worksheet chart.
      my $chart = $workbook->add_chart( type => 'column' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      __END__
  
  
  =head1 DESCRIPTION
  
  The C<Chart> module is an abstract base class for modules that implement charts in L<Excel::Writer::XLSX>. The information below is applicable to all of the available subclasses.
  
  The C<Chart> module isn't used directly. A chart object is created via the Workbook C<add_chart()> method where the chart type is specified:
  
      my $chart = $workbook->add_chart( type => 'column' );
  
  Currently the supported chart types are:
  
  =over
  
  =item * C<area>
  
  Creates an Area (filled line) style chart. See L<Excel::Writer::XLSX::Chart::Area>.
  
  =item * C<bar>
  
  Creates a Bar style (transposed histogram) chart. See L<Excel::Writer::XLSX::Chart::Bar>.
  
  =item * C<column>
  
  Creates a column style (histogram) chart. See L<Excel::Writer::XLSX::Chart::Column>.
  
  =item * C<line>
  
  Creates a Line style chart. See L<Excel::Writer::XLSX::Chart::Line>.
  
  =item * C<pie>
  
  Creates a Pie style chart. See L<Excel::Writer::XLSX::Chart::Pie>.
  
  =item * C<doughnut>
  
  Creates a Doughnut style chart. See L<Excel::Writer::XLSX::Chart::Doughnut>.
  
  =item * C<scatter>
  
  Creates a Scatter style chart. See L<Excel::Writer::XLSX::Chart::Scatter>.
  
  =item * C<stock>
  
  Creates a Stock style chart. See L<Excel::Writer::XLSX::Chart::Stock>.
  
  =item * C<radar>
  
  Creates a Radar style chart. See L<Excel::Writer::XLSX::Chart::Radar>.
  
  =back
  
  Chart subtypes are also supported in some cases:
  
      $workbook->add_chart( type => 'bar', subtype => 'stacked' );
  
  The currently available subtypes are:
  
      area
          stacked
          percent_stacked
  
      bar
          stacked
          percent_stacked
  
      column
          stacked
          percent_stacked
  
      scatter
          straight_with_markers
          straight
          smooth_with_markers
          smooth
  
      radar
          with_markers
          filled
  
  More charts and sub-types will be supported in time. See the L</TODO> section.
  
  
  =head1 CHART METHODS
  
  Methods that are common to all chart types are documented below. See the documentation for each of the above chart modules for chart specific information.
  
  =head2 add_series()
  
  In an Excel chart a "series" is a collection of information such as values, X axis labels and the formatting that define which data is plotted.
  
  With an Excel::Writer::XLSX chart object the C<add_series()> method is used to set the properties for a series:
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$10', # Optional.
          values     => '=Sheet1!$B$2:$B$10', # Required.
          line       => { color => 'blue' },
      );
  
  The properties that can be set are:
  
  =over
  
  =item * C<values>
  
  This is the most important property of a series and must be set for every chart object. It links the chart with the worksheet data that it displays. A formula or array ref can be used for the data range, see below.
  
  =item * C<categories>
  
  This sets the chart category labels. The category is more or less the same as the X axis. In most chart types the C<categories> property is optional and the chart will just assume a sequential series from C<1 .. n>.
  
  =item * C<name>
  
  Set the name for the series. The name is displayed in the chart legend and in the formula bar. The name property is optional and if it isn't supplied it will default to C<Series 1 .. n>.
  
  =item * C<line>
  
  Set the properties of the series line type such as colour and width. See the L</CHART FORMATTING> section below.
  
  =item * C<border>
  
  Set the border properties of the series such as colour and style. See the L</CHART FORMATTING> section below.
  
  =item * C<fill>
  
  Set the fill properties of the series such as colour. See the L</CHART FORMATTING> section below.
  
  =item * C<pattern>
  
  Set the pattern properties of the series. See the L</CHART FORMATTING> section below.
  
  =item * C<gradien>
  
  Set the gradient properties of the series. See the L</CHART FORMATTING> section below.
  
  =item * C<marker>
  
  Set the properties of the series marker such as style and colour. See the L</SERIES OPTIONS> section below.
  
  =item * C<trendline>
  
  Set the properties of the series trendline such as linear, polynomial and moving average types. See the L</SERIES OPTIONS> section below.
  
  =item * C<smooth>
  
  The C<smooth> option is used to set the smooth property of a line series. See the L</SERIES OPTIONS> section below.
  
  =item * C<y_error_bars>
  
  Set vertical error bounds for a chart series. See the L</SERIES OPTIONS> section below.
  
  =item * C<x_error_bars>
  
  Set horizontal error bounds for a chart series. See the L</SERIES OPTIONS> section below.
  
  =item * C<data_labels>
  
  Set data labels for the series. See the L</SERIES OPTIONS> section below.
  
  =item * C<points>
  
  Set properties for individual points in a series. See the L</SERIES OPTIONS> section below.
  
  =item * C<invert_if_negative>
  
  Invert the fill colour for negative values. Usually only applicable to column and bar charts.
  
  =item * C<overlap>
  
  Set the overlap between series in a Bar/Column chart. The range is +/- 100. Default is 0.
  
      overlap => 20,
  
  Note, it is only necessary to apply this property to one series of the chart.
  
  =item * C<gap>
  
  Set the gap between series in a Bar/Column chart. The range is 0 to 500. Default is 150.
  
      gap => 200,
  
  Note, it is only necessary to apply this property to one series of the chart.
  
  =back
  
  The C<categories> and C<values> can take either a range formula such as C<=Sheet1!$A$2:$A$7> or, more usefully when generating the range programmatically, an array ref with zero indexed row/column values:
  
       [ $sheetname, $row_start, $row_end, $col_start, $col_end ]
  
  The following are equivalent:
  
      $chart->add_series( categories => '=Sheet1!$A$2:$A$7'      ); # Same as ...
      $chart->add_series( categories => [ 'Sheet1', 1, 6, 0, 0 ] ); # Zero-indexed.
  
  You can add more than one series to a chart. In fact, some chart types such as C<stock> require it. The series numbering and order in the Excel chart will be the same as the order in which they are added in Excel::Writer::XLSX.
  
      # Add the first series.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          name       => 'Test data series 1',
      );
  
      # Add another series. Same categories. Different range values.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          name       => 'Test data series 2',
      );
  
  It is also possible to specify non-contiguous ranges:
  
      $chart->add_series(
          categories      => '=(Sheet1!$A$1:$A$9,Sheet1!$A$14:$A$25)',
          values          => '=(Sheet1!$B$1:$B$9,Sheet1!$B$14:$B$25)',
      );
  
  
  =head2 set_x_axis()
  
  The C<set_x_axis()> method is used to set properties of the X axis.
  
      $chart->set_x_axis( name => 'Quarterly results' );
  
  The properties that can be set are:
  
      name
      name_font
      name_layout
      num_font
      num_format
      line
      fill
      pattern
      gradient
      min
      max
      minor_unit
      major_unit
      interval_unit
      interval_tick
      crossing
      reverse
      position_axis
      log_base
      label_position
      major_gridlines
      minor_gridlines
      visible
      date_axis
      text_axis
      minor_unit_type
      major_unit_type
      minor_tick_mark
      major_tick_mark
      display_units
      display_units_visible
  
  These are explained below. Some properties are only applicable to value or category axes, as indicated. See L<Value and Category Axes> for an explanation of Excel's distinction between the axis types.
  
  =over
  
  =item * C<name>
  
  
  Set the name (title or caption) for the axis. The name is displayed below the X axis. The C<name> property is optional. The default is to have no axis name. (Applicable to category and value axes).
  
      $chart->set_x_axis( name => 'Quarterly results' );
  
  The name can also be a formula such as C<=Sheet1!$A$1>.
  
  =item * C<name_font>
  
  Set the font properties for the axis title. (Applicable to category and value axes).
  
      $chart->set_x_axis( name_font => { name => 'Arial', size => 10 } );
  
  =item * C<name_layout>
  
  Set the C<(x, y)> position of the axis caption in chart relative units. (Applicable to category and value axes).
  
      $chart->set_x_axis(
          name        => 'X axis',
          name_layout => {
              x => 0.34,
              y => 0.85,
          }
      );
  
  See the L</CHART LAYOUT> section below.
  
  =item * C<num_font>
  
  Set the font properties for the axis numbers. (Applicable to category and value axes).
  
      $chart->set_x_axis( num_font => { bold => 1, italic => 1 } );
  
  See the L</CHART FONTS> section below.
  
  =item * C<num_format>
  
  Set the number format for the axis. (Applicable to category and value axes).
  
      $chart->set_x_axis( num_format => '#,##0.00' );
      $chart->set_y_axis( num_format => '0.00%'    );
  
  The number format is similar to the Worksheet Cell Format C<num_format> apart from the fact that a format index cannot be used. The explicit format string must be used as shown above. See L<Excel::Writer::XLSX/set_num_format()> for more information.
  
  =item * C<line>
  
  Set the properties of the axis line type such as colour and width. See the L</CHART FORMATTING> section below.
  
      $chart->set_x_axis( line => { none => 1 });
  
  
  =item * C<fill>
  
  Set the fill properties of the axis such as colour. See the L</CHART FORMATTING> section below. Note, in Excel the axis fill is applied to the area of the numbers of the axis and not to the area of the axis bounding box. That background is set from the chartarea fill.
  
  =item * C<pattern>
  
  Set the pattern properties of the axis such as colour. See the L</CHART FORMATTING> section below.
  
  =item * C<gradient>
  
  Set the gradient properties of the axis such as colour. See the L</CHART FORMATTING> section below.
  
  =item * C<min>
  
  Set the minimum value for the axis range. (Applicable to value axes only.)
  
      $chart->set_x_axis( min => 20 );
  
  =item * C<max>
  
  Set the maximum value for the axis range. (Applicable to value axes only.)
  
      $chart->set_x_axis( max => 80 );
  
  =item * C<minor_unit>
  
  Set the increment of the minor units in the axis range. (Applicable to value axes only.)
  
      $chart->set_x_axis( minor_unit => 0.4 );
  
  =item * C<major_unit>
  
  Set the increment of the major units in the axis range. (Applicable to value axes only.)
  
      $chart->set_x_axis( major_unit => 2 );
  
  =item * C<interval_unit>
  
  Set the interval unit for a category axis. (Applicable to category axes only.)
  
      $chart->set_x_axis( interval_unit => 2 );
  
  =item * C<interval_tick>
  
  Set the tick interval for a category axis. (Applicable to category axes only.)
  
      $chart->set_x_axis( interval_tick => 4 );
  
  =item * C<crossing>
  
  Set the position where the y axis will cross the x axis. (Applicable to category and value axes.)
  
  The C<crossing> value can either be the string C<'max'> to set the crossing at the maximum axis value or a numeric value.
  
      $chart->set_x_axis( crossing => 3 );
      # or
      $chart->set_x_axis( crossing => 'max' );
  
  B<For category axes the numeric value must be an integer> to represent the category number that the axis crosses at. For value axes it can have any value associated with the axis.
  
  If crossing is omitted (the default) the crossing will be set automatically by Excel based on the chart data.
  
  =item * C<position_axis>
  
  Position the axis on or between the axis tick marks. (Applicable to category axes only.)
  
  There are two allowable values C<on_tick> and C<between>:
  
      $chart->set_x_axis( position_axis => 'on_tick' );
      $chart->set_x_axis( position_axis => 'between' );
  
  =item * C<reverse>
  
  Reverse the order of the axis categories or values. (Applicable to category and value axes.)
  
      $chart->set_x_axis( reverse => 1 );
  
  =item * C<log_base>
  
  Set the log base of the axis range. (Applicable to value axes only.)
  
      $chart->set_x_axis( log_base => 10 );
  
  =item * C<label_position>
  
  Set the "Axis labels" position for the axis. The following positions are available:
  
      next_to (the default)
      high
      low
      none
  
  =item * C<major_gridlines>
  
  Configure the major gridlines for the axis. The available properties are:
  
      visible
      line
  
  For example:
  
      $chart->set_x_axis(
          major_gridlines => {
              visible => 1,
              line    => { color => 'red', width => 1.25, dash_type => 'dash' }
          }
      );
  
  The C<visible> property is usually on for the X-axis but it depends on the type of chart.
  
  The C<line> property sets the gridline properties such as colour and width. See the L</CHART FORMATTING> section below.
  
  =item * C<minor_gridlines>
  
  This takes the same options as C<major_gridlines> above.
  
  The minor gridline C<visible> property is off by default for all chart types.
  
  =item * C<visible>
  
  Configure the visibility of the axis.
  
      $chart->set_x_axis( visible => 0 );
  
  
  =item * C<date_axis>
  
  This option is used to treat a category axis with date or time data as a Date Axis. (Applicable to category axes only.)
  
      $chart->set_x_axis( date_axis => 1 );
  
  This option also allows you to set C<max> and C<min> values for a category axis which isn't allowed by Excel for non-date category axes.
  
  See L<Date Category Axes> for more details.
  
  =item * C<text_axis>
  
  This option is used to treat a category axis explicitly as a Text Axis. (Applicable to category axes only.)
  
      $chart->set_x_axis( text_axis => 1 );
  
  
  =item * C<minor_unit_type>
  
  For C<date_axis> axes, see above, this option is used to set the type of the minor units. (Applicable to date category axes only.)
  
      $chart->set_x_axis(
          date_axis         => 1,
          minor_unit        => 4,
          minor_unit_type   => 'months',
      );
  
  The allowable values for this option are C<days>, C<months> and C<years>.
  
  =item * C<major_unit_type>
  
  Same as C<minor_unit_type>, see above, but for major axes unit types.
  
  More than one property can be set in a call to C<set_x_axis()>:
  
      $chart->set_x_axis(
          name => 'Quarterly results',
          min  => 10,
          max  => 80,
      );
  
  =item * C<major_tick_mark>
  
  Set the axis major tick mark type to one of the following values:
  
      none
      inside
      outside
      cross   (inside and outside)
  
  For example:
  
      $chart->set_x_axis( major_tick_mark => 'none',
                          minor_tick_mark => 'inside' );
  
  =item * C<minor_tick_mark>
  
  Set the axis minor tick mark type. Same as C<major_tick_mark>, see above.
  
  =item * C<display_units>
  
  Set the display units for the axis. This can be useful if the axis numbers are very large but you don't want to represent them in scientific notation. (Applicable to value axes only.) The available display units are:
  
      hundreds
      thousands
      ten_thousands
      hundred_thousands
      millions
      ten_millions
      hundred_millions
      billions
      trillions
  
  Example:
  
      $chart->set_x_axis( display_units => 'thousands' )
      $chart->set_y_axis( display_units => 'millions' )
  
  
  * C<display_units_visible>
  
  Control the visibility of the display units turned on by the previous option. This option is on by default. (Applicable to value axes only.)::
  
      $chart->set_x_axis( display_units         => 'thousands',
                          display_units_visible => 0 )
  
  =back
  
  =head2 set_y_axis()
  
  The C<set_y_axis()> method is used to set properties of the Y axis. The properties that can be set are the same as for C<set_x_axis>, see above.
  
  
  =head2 set_x2_axis()
  
  The C<set_x2_axis()> method is used to set properties of the secondary X axis.
  The properties that can be set are the same as for C<set_x_axis>, see above.
  The default properties for this axis are:
  
      label_position => 'none',
      crossing       => 'max',
      visible        => 0,
  
  
  =head2 set_y2_axis()
  
  The C<set_y2_axis()> method is used to set properties of the secondary Y axis.
  The properties that can be set are the same as for C<set_x_axis>, see above.
  The default properties for this axis are:
  
      major_gridlines => { visible => 0 }
  
  
  =head2 combine()
  
  The chart C<combine()> method is used to combine two charts of different
  types, for example a column and line chart:
  
      my $column_chart = $workbook->add_chart( type => 'column', embedded => 1 );
  
      # Configure the data series for the primary chart.
      $column_chart->add_series(...);
  
      # Create a new column chart. This will use this as the secondary chart.
      my $line_chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the data series for the secondary chart.
      $line_chart->add_series(...);
  
      # Combine the charts.
      $column_chart->combine( $line_chart );
  
  See L<Combined Charts> for more details.
  
  
  =head2 set_size()
  
  The C<set_size()> method is used to set the dimensions of the chart. The size properties that can be set are:
  
       width
       height
       x_scale
       y_scale
       x_offset
       y_offset
  
  The C<width> and C<height> are in pixels. The default chart width is 480 pixels and the default height is 288 pixels. The size of the chart can be modified by setting the C<width> and C<height> or by setting the C<x_scale> and C<y_scale>:
  
      $chart->set_size( width => 720, height => 576 );
  
      # Same as:
  
      $chart->set_size( x_scale => 1.5, y_scale => 2 );
  
  The C<x_offset> and C<y_offset> position the top left corner of the chart in the cell that it is inserted into.
  
  
  Note: the C<x_scale>, C<y_scale>, C<x_offset> and C<y_offset> parameters can also be set via the C<insert_chart()> method:
  
      $worksheet->insert_chart( 'E2', $chart, 2, 4, 1.5, 2 );
  
  
  =head2 set_title()
  
  The C<set_title()> method is used to set properties of the chart title.
  
      $chart->set_title( name => 'Year End Results' );
  
  The properties that can be set are:
  
  =over
  
  =item * C<name>
  
  Set the name (title) for the chart. The name is displayed above the chart. The name can also be a formula such as C<=Sheet1!$A$1>. The name property is optional. The default is to have no chart title.
  
  =item * C<name_font>
  
  Set the font properties for the chart title. See the L</CHART FONTS> section below.
  
  =item * C<overlay>
  
  Allow the title to be overlaid on the chart. Generally used with the layout property below.
  
  =item * C<layout>
  
  Set the C<(x, y)> position of the title in chart relative units:
  
      $chart->set_title(
          name    => 'Title',
          overlay => 1,
          layout  => {
              x => 0.42,
              y => 0.14,
          }
      );
  
  See the L</CHART LAYOUT> section below.
  
  =item * C<none>
  
  By default Excel adds an automatic chart title to charts with a single series and a user defined series name. The C<none> option turns this default title off. It also turns off all other C<set_title()> options.
  
      $chart->set_title( none => 1 );
  
  =back
  
  
  =head2 set_legend()
  
  The C<set_legend()> method is used to set properties of the chart legend.
  
  
  The properties that can be set are:
  
  =over
  
  =item * C<none>
  
  The C<none> option turns off the chart legend. In Excel chart legends are on by default:
  
      $chart->set_legend( none => 1 );
  
  Note, for backward compatibility, it is also possible to turn off the legend via the C<position> property:
  
      $chart->set_legend( position => 'none' );
  
  =item * C<position>
  
  Set the position of the chart legend.
  
      $chart->set_legend( position => 'bottom' );
  
  The default legend position is C<right>. The available positions are:
  
      top
      bottom
      left
      right
      overlay_left
      overlay_right
      none
  
  =item * C<layout>
  
  Set the C<(x, y)> position of the legend in chart relative units:
  
      $chart->set_legend(
          layout => {
              x      => 0.80,
              y      => 0.37,
              width  => 0.12,
              height => 0.25,
          }
      );
  
  See the L</CHART LAYOUT> section below.
  
  
  =item * C<delete_series>
  
  This allows you to remove 1 or more series from the legend (the series will still display on the chart). This property takes an array ref as an argument and the series are zero indexed:
  
      # Delete/hide series index 0 and 2 from the legend.
      $chart->set_legend( delete_series => [0, 2] );
  
  =item * C<font>
  
  Set the font properties of the chart legend:
  
      $chart->set_legend( font => { bold => 1, italic => 1 } );
  
  See the L</CHART FONTS> section below.
  
  
  =back
  
  
  =head2 set_chartarea()
  
  The C<set_chartarea()> method is used to set the properties of the chart area.
  
      $chart->set_chartarea(
          border => { none  => 1 },
          fill   => { color => 'red' }
      );
  
  The properties that can be set are:
  
  =over
  
  =item * C<border>
  
  Set the border properties of the chartarea such as colour and style. See the L</CHART FORMATTING> section below.
  
  =item * C<fill>
  
  Set the fill properties of the chartarea such as colour. See the L</CHART FORMATTING> section below.
  
  =item * C<pattern>
  
  Set the pattern fill properties of the chartarea. See the L</CHART FORMATTING> section below.
  
  =item * C<gradient>
  
  Set the gradient fill properties of the chartarea. See the L</CHART FORMATTING> section below.
  
  
  =back
  
  =head2 set_plotarea()
  
  The C<set_plotarea()> method is used to set properties of the plot area of a chart.
  
      $chart->set_plotarea(
          border => { color => 'yellow', width => 1, dash_type => 'dash' },
          fill   => { color => '#92D050' }
      );
  
  The properties that can be set are:
  
  =over
  
  =item * C<border>
  
  Set the border properties of the plotarea such as colour and style. See the L</CHART FORMATTING> section below.
  
  =item * C<fill>
  
  Set the fill properties of the plotarea such as colour. See the L</CHART FORMATTING> section below.
  
  
  =item * C<pattern>
  
  Set the pattern fill properties of the plotarea. See the L</CHART FORMATTING> section below.
  
  =item * C<gradient>
  
  Set the gradient fill properties of the plotarea. See the L</CHART FORMATTING> section below.
  
  =item * C<layout>
  
  Set the C<(x, y)> position of the plotarea in chart relative units:
  
      $chart->set_plotarea(
          layout => {
              x      => 0.35,
              y      => 0.26,
              width  => 0.62,
              height => 0.50,
          }
      );
  
  See the L</CHART LAYOUT> section below.
  
  =back
  
  
  =head2 set_style()
  
  The C<set_style()> method is used to set the style of the chart to one of the 42 built-in styles available on the 'Design' tab in Excel:
  
      $chart->set_style( 4 );
  
  The default style is 2.
  
  
  =head2 set_table()
  
  The C<set_table()> method adds a data table below the horizontal axis with the data used to plot the chart.
  
      $chart->set_table();
  
  The available options, with default values are:
  
      vertical   => 1,    # Display vertical lines in the table.
      horizontal => 1,    # Display horizontal lines in the table.
      outline    => 1,    # Display an outline in the table.
      show_keys  => 0     # Show the legend keys with the table data.
  
  The data table can only be shown with Bar, Column, Line, Area and stock charts.
  
  
  =head2 set_up_down_bars
  
  The C<set_up_down_bars()> method adds Up-Down bars to Line charts to indicate the difference between the first and last data series.
  
      $chart->set_up_down_bars();
  
  It is possible to format the up and down bars to add C<fill>, C<pattern>, C<gradient> and C<border> properties if required. See the L</CHART FORMATTING> section below.
  
      $chart->set_up_down_bars(
          up   => { fill => { color => 'green' } },
          down => { fill => { color => 'red' } },
      );
  
  Up-down bars can only be applied to Line charts and to Stock charts (by default).
  
  
  =head2 set_drop_lines
  
  The C<set_drop_lines()> method adds Drop Lines to charts to show the Category value of points in the data.
  
      $chart->set_drop_lines();
  
  It is possible to format the Drop Line C<line> properties if required. See the L</CHART FORMATTING> section below.
  
      $chart->set_drop_lines( line => { color => 'red', dash_type => 'square_dot' } );
  
  Drop Lines are only available in Line, Area and Stock charts.
  
  
  =head2 set_high_low_lines
  
  The C<set_high_low_lines()> method adds High-Low lines to charts to show the maximum and minimum values of points in a Category.
  
      $chart->set_high_low_lines();
  
  It is possible to format the High-Low Line C<line> properties if required. See the L</CHART FORMATTING> section below.
  
      $chart->set_high_low_lines( line => { color => 'red' } );
  
  High-Low Lines are only available in Line and Stock charts.
  
  
  =head2 show_blanks_as()
  
  The C<show_blanks_as()> method controls how blank data is displayed in a chart.
  
      $chart->show_blanks_as( 'span' );
  
  The available options are:
  
          gap    # Blank data is shown as a gap. The default.
          zero   # Blank data is displayed as zero.
          span   # Blank data is connected with a line.
  
  
  =head2 show_hidden_data()
  
  Display data in hidden rows or columns on the chart.
  
      $chart->show_hidden_data();
  
  
  =head1 SERIES OPTIONS
  
  This section details the following properties of C<add_series()> in more detail:
  
      marker
      trendline
      y_error_bars
      x_error_bars
      data_labels
      points
      smooth
  
  =head2 Marker
  
  The marker format specifies the properties of the markers used to distinguish series on a chart. In general only Line and Scatter chart types and trendlines use markers.
  
  The following properties can be set for C<marker> formats in a chart.
  
      type
      size
      border
      fill
      pattern
      gradient
  
  The C<type> property sets the type of marker that is used with a series.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          marker     => { type => 'diamond' },
      );
  
  The following C<type> properties can be set for C<marker> formats in a chart. These are shown in the same order as in the Excel format dialog.
  
      automatic
      none
      square
      diamond
      triangle
      x
      star
      short_dash
      long_dash
      circle
      plus
  
  The C<automatic> type is a special case which turns on a marker using the default marker style for the particular series number.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          marker     => { type => 'automatic' },
      );
  
  If C<automatic> is on then other marker properties such as size, border or fill cannot be set.
  
  The C<size> property sets the size of the marker and is generally used in conjunction with C<type>.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          marker     => { type => 'diamond', size => 7 },
      );
  
  Nested C<border> and C<fill> properties can also be set for a marker. See the L</CHART FORMATTING> section below.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          marker     => {
              type    => 'square',
              size    => 5,
              border  => { color => 'red' },
              fill    => { color => 'yellow' },
          },
      );
  
  
  =head2 Trendline
  
  A trendline can be added to a chart series to indicate trends in the data such as a moving average or a polynomial fit.
  
  The following properties can be set for trendlines in a chart series.
  
      type
      order       (for polynomial trends)
      period      (for moving average)
      forward     (for all except moving average)
      backward    (for all except moving average)
      name
      line
  
  The C<type> property sets the type of trendline in the series.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          trendline  => { type => 'linear' },
      );
  
  The available C<trendline> types are:
  
      exponential
      linear
      log
      moving_average
      polynomial
      power
  
  A C<polynomial> trendline can also specify the C<order> of the polynomial. The default value is 2.
  
      $chart->add_series(
          values    => '=Sheet1!$B$1:$B$5',
          trendline => {
              type  => 'polynomial',
              order => 3,
          },
      );
  
  A C<moving_average> trendline can also specify the C<period> of the moving average. The default value is 2.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          trendline  => {
              type   => 'moving_average',
              period => 3,
          },
      );
  
  The C<forward> and C<backward> properties set the forecast period of the trendline.
  
      $chart->add_series(
          values    => '=Sheet1!$B$1:$B$5',
          trendline => {
              type     => 'linear',
              forward  => 0.5,
              backward => 0.5,
          },
      );
  
  The C<name> property sets an optional name for the trendline that will appear in the chart legend. If it isn't specified the Excel default name will be displayed. This is usually a combination of the trendline type and the series name.
  
      $chart->add_series(
          values    => '=Sheet1!$B$1:$B$5',
          trendline => {
              type => 'linear',
              name => 'Interpolated trend',
          },
      );
  
  Several of these properties can be set in one go:
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          trendline  => {
              type     => 'linear',
              name     => 'My trend name',
              forward  => 0.5,
              backward => 0.5,
              line     => {
                  color     => 'red',
                  width     => 1,
                  dash_type => 'long_dash',
              },
          },
      );
  
  Trendlines cannot be added to series in a stacked chart or pie chart, radar chart, doughnut or (when implemented) to 3D, or surface charts.
  
  =head2 Error Bars
  
  Error bars can be added to a chart series to indicate error bounds in the data. The error bars can be vertical C<y_error_bars> (the most common type) or horizontal C<x_error_bars> (for Bar and Scatter charts only).
  
  The following properties can be set for error bars in a chart series.
  
      type
      value        (for all types except standard error and custom)
      plus_values  (for custom only)
      minus_values (for custom only)
      direction
      end_style
      line
  
  The C<type> property sets the type of error bars in the series.
  
      $chart->add_series(
          values       => '=Sheet1!$B$1:$B$5',
          y_error_bars => { type => 'standard_error' },
      );
  
  The available error bars types are available:
  
      fixed
      percentage
      standard_deviation
      standard_error
      custom
  
  All error bar types, except for C<standard_error> and C<custom> must also have a value associated with it for the error bounds:
  
      $chart->add_series(
          values       => '=Sheet1!$B$1:$B$5',
          y_error_bars => {
              type  => 'percentage',
              value => 5,
          },
      );
  
  The C<custom> error bar type must specify C<plus_values> and C<minus_values> which should either by a C<Sheet1!$A$1:$A$5> type range formula or an arrayref of
  values:
  
      $chart->add_series(
          categories   => '=Sheet1!$A$1:$A$5',
          values       => '=Sheet1!$B$1:$B$5',
          y_error_bars => {
              type         => 'custom',
              plus_values  => '=Sheet1!$C$1:$C$5',
              minus_values => '=Sheet1!$D$1:$D$5',
          },
      );
  
      # or
  
  
      $chart->add_series(
          categories   => '=Sheet1!$A$1:$A$5',
          values       => '=Sheet1!$B$1:$B$5',
          y_error_bars => {
              type         => 'custom',
              plus_values  => [1, 1, 1, 1, 1],
              minus_values => [2, 2, 2, 2, 2],
          },
      );
  
  Note, as in Excel the items in the C<minus_values> do not need to be negative.
  
  The C<direction> property sets the direction of the error bars. It should be one of the following:
  
      plus    # Positive direction only.
      minus   # Negative direction only.
      both    # Plus and minus directions, The default.
  
  The C<end_style> property sets the style of the error bar end cap. The options are 1 (the default) or 0 (for no end cap):
  
      $chart->add_series(
          values       => '=Sheet1!$B$1:$B$5',
          y_error_bars => {
              type      => 'fixed',
              value     => 2,
              end_style => 0,
              direction => 'minus'
          },
      );
  
  
  
  =head2 Data Labels
  
  Data labels can be added to a chart series to indicate the values of the plotted data points.
  
  The following properties can be set for C<data_labels> formats in a chart.
  
      value
      category
      series_name
      position
      percentage
      leader_lines
      separator
      legend_key
      num_format
      font
  
  The C<value> property turns on the I<Value> data label for a series.
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { value => 1 },
      );
  
  The C<category> property turns on the I<Category Name> data label for a series.
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { category => 1 },
      );
  
  
  The C<series_name> property turns on the I<Series Name> data label for a series.
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { series_name => 1 },
      );
  
  The C<position> property is used to position the data label for a series.
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { value => 1, position => 'center' },
      );
  
  In Excel the data label positions vary for different chart types. The allowable positions are:
  
      |  Position     |  Line     |  Bar      |  Pie      |  Area     |
      |               |  Scatter  |  Column   |  Doughnut |  Radar    |
      |               |  Stock    |           |           |           |
      |---------------|-----------|-----------|-----------|-----------|
      |  center       |  Yes      |  Yes      |  Yes      |  Yes*     |
      |  right        |  Yes*     |           |           |           |
      |  left         |  Yes      |           |           |           |
      |  above        |  Yes      |           |           |           |
      |  below        |  Yes      |           |           |           |
      |  inside_base  |           |  Yes      |           |           |
      |  inside_end   |           |  Yes      |  Yes      |           |
      |  outside_end  |           |  Yes*     |  Yes      |           |
      |  best_fit     |           |           |  Yes*     |           |
  
  Note: The * indicates the default position for each chart type in Excel, if a position isn't specified.
  
  The C<percentage> property is used to turn on the display of data labels as a I<Percentage> for a series. It is mainly used for pie and doughnut charts.
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { percentage => 1 },
      );
  
  The C<leader_lines> property is used to turn on  I<Leader Lines> for the data label for a series. It is mainly used for pie charts.
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { value => 1, leader_lines => 1 },
      );
  
  Note: Even when leader lines are turned on they aren't automatically visible in Excel or Excel::Writer::XLSX. Due to an Excel limitation (or design) leader lines only appear if the data label is moved manually or if the data labels are very close and need to be adjusted automatically.
  
  The C<separator> property is used to change the separator between multiple data label items:
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { percentage => 1 },
          data_labels => { value => 1, category => 1, separator => "\n" },
      );
  
  The separator value must be one of the following strings:
  
              ','
              ';'
              '.'
              "\n"
              ' '
  
  The C<legend_key> property is used to turn on  I<Legend Key> for the data label for a series:
  
      $chart->add_series(
          values      => '=Sheet1!$B$1:$B$5',
          data_labels => { value => 1, legend_key => 1 },
      );
  
  
  The C<num_format> property is used to set the number format for the data labels.
  
      $chart->add_series(
          values      => '=Sheet1!$A$1:$A$5',
          data_labels => { value => 1, num_format => '#,##0.00' },
      );
  
  The number format is similar to the Worksheet Cell Format C<num_format> apart from the fact that a format index cannot be used. The explicit format string must be used as shown above. See L<Excel::Writer::XLSX/set_num_format()> for more information.
  
  The C<font> property is used to set the font properties of the data labels in a series:
  
      $chart->add_series(
          values      => '=Sheet1!$A$1:$A$5',
          data_labels => {
              value => 1,
              font  => { name => 'Consolas' }
          },
      );
  
  See the L</CHART FONTS> section below.
  
  
  =head2 Points
  
  In general formatting is applied to an entire series in a chart. However, it is occasionally required to format individual points in a series. In particular this is required for Pie and Doughnut charts where each segment is represented by a point.
  
  In these cases it is possible to use the C<points> property of C<add_series()>:
  
      $chart->add_series(
          values => '=Sheet1!$A$1:$A$3',
          points => [
              { fill => { color => '#FF0000' } },
              { fill => { color => '#CC0000' } },
              { fill => { color => '#990000' } },
          ],
      );
  
  The C<points> property takes an array ref of format options (see the L</CHART FORMATTING> section below). To assign default properties to points in a series pass C<undef> values in the array ref:
  
      # Format point 3 of 3 only.
      $chart->add_series(
          values => '=Sheet1!$A$1:$A$3',
          points => [
              undef,
              undef,
              { fill => { color => '#990000' } },
          ],
      );
  
      # Format the first point only.
      $chart->add_series(
          values => '=Sheet1!$A$1:$A$3',
          points => [ { fill => { color => '#FF0000' } } ],
      );
  
  =head2 Smooth
  
  The C<smooth> option is used to set the smooth property of a line series. It is only applicable to the C<Line> and C<Scatter> chart types.
  
      $chart->add_series( values => '=Sheet1!$C$1:$C$5',
                          smooth => 1 );
  
  
  =head1 CHART FORMATTING
  
  The following chart formatting properties can be set for any chart object that they apply to (and that are supported by Excel::Writer::XLSX) such as chart lines, column fill areas, plot area borders, markers, gridlines and other chart elements documented above.
  
      line
      border
      fill
      pattern
      gradient
  
  Chart formatting properties are generally set using hash refs.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => { color => 'blue' },
      );
  
  In some cases the format properties can be nested. For example a C<marker> may contain C<border> and C<fill> sub-properties.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => { color => 'blue' },
          marker     => {
              type    => 'square',
              size    => 5,
              border  => { color => 'red' },
              fill    => { color => 'yellow' },
          },
      );
  
  =head2 Line
  
  The line format is used to specify properties of line objects that appear in a chart such as a plotted line on a chart or a border.
  
  The following properties can be set for C<line> formats in a chart.
  
      none
      color
      width
      dash_type
  
  
  The C<none> property is uses to turn the C<line> off (it is always on by default except in Scatter charts). This is useful if you wish to plot a series with markers but without a line.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => { none => 1 },
      );
  
  
  The C<color> property sets the color of the C<line>.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => { color => 'red' },
      );
  
  The available colours are shown in the main L<Excel::Writer::XLSX> documentation. It is also possible to set the colour of a line with a HTML style RGB colour:
  
      $chart->add_series(
          line       => { color => '#FF0000' },
      );
  
  
  The C<width> property sets the width of the C<line>. It should be specified in increments of 0.25 of a point as in Excel.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => { width => 3.25 },
      );
  
  The C<dash_type> property sets the dash style of the line.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => { dash_type => 'dash_dot' },
      );
  
  The following C<dash_type> values are available. They are shown in the order that they appear in the Excel dialog.
  
      solid
      round_dot
      square_dot
      dash
      dash_dot
      long_dash
      long_dash_dot
      long_dash_dot_dot
  
  The default line style is C<solid>.
  
  More than one C<line> property can be specified at a time:
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          line       => {
              color     => 'red',
              width     => 1.25,
              dash_type => 'square_dot',
          },
      );
  
  =head2 Border
  
  The C<border> property is a synonym for C<line>.
  
  It can be used as a descriptive substitute for C<line> in chart types such as Bar and Column that have a border and fill style rather than a line style. In general chart objects with a C<border> property will also have a fill property.
  
  
  =head2 Solid Fill
  
  The fill format is used to specify filled areas of chart objects such as the interior of a column or the background of the chart itself.
  
  The following properties can be set for C<fill> formats in a chart.
  
      none
      color
      transparency
  
  The C<none> property is used to turn the C<fill> property off (it is generally on by default).
  
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          fill       => { none => 1 },
      );
  
  The C<color> property sets the colour of the C<fill> area.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          fill       => { color => 'red' },
      );
  
  The available colours are shown in the main L<Excel::Writer::XLSX> documentation. It is also possible to set the colour of a fill with a HTML style RGB colour:
  
      $chart->add_series(
          fill       => { color => '#FF0000' },
      );
  
  The C<transparency> property sets the transparency of the solid fill color in the integer range 1 - 100:
  
      $chart->set_chartarea( fill => { color => 'yellow', transparency => 75 } );
  
  The C<fill> format is generally used in conjunction with a C<border> format which has the same properties as a C<line> format.
  
      $chart->add_series(
          values     => '=Sheet1!$B$1:$B$5',
          border     => { color => 'red' },
          fill       => { color => 'yellow' },
      );
  
  
  
  =head2 Pattern Fill
  
  The pattern fill format is used to specify pattern filled areas of chart objects such as the interior of a column or the background of the chart itself.
  
  The following properties can be set for C<pattern> fill formats in a chart:
  
      pattern:   the pattern to be applied (required)
      fg_color:  the foreground color of the pattern (required)
      bg_color:  the background color (optional, defaults to white)
  
  
  For example:
  
      $chart->set_plotarea(
          pattern => {
              pattern  => 'percent_5',
              fg_color => 'red',
              bg_color => 'yellow',
          }
      );
  
  The following patterns can be applied:
  
      percent_5
      percent_10
      percent_20
      percent_25
      percent_30
      percent_40
      percent_50
      percent_60
      percent_70
      percent_75
      percent_80
      percent_90
      light_downward_diagonal
      light_upward_diagonal
      dark_downward_diagonal
      dark_upward_diagonal
      wide_downward_diagonal
      wide_upward_diagonal
      light_vertical
      light_horizontal
      narrow_vertical
      narrow_horizontal
      dark_vertical
      dark_horizontal
      dashed_downward_diagonal
      dashed_upward_diagonal
      dashed_horizontal
      dashed_vertical
      small_confetti
      large_confetti
      zigzag
      wave
      diagonal_brick
      horizontal_brick
      weave
      plaid
      divot
      dotted_grid
      dotted_diamond
      shingle
      trellis
      sphere
      small_grid
      large_grid
      small_check
      large_check
      outlined_diamond
      solid_diamond
  
  
  The foreground color, C<fg_color>, is a required parameter and can be a Html style C<#RRGGBB> string or a limited number of named colors. The available colours are shown in the main L<Excel::Writer::XLSX> documentation.
  
  The background color, C<bg_color>, is optional and defaults to black.
  
  If a pattern fill is used on a chart object it overrides the solid fill properties of the object.
  
  
  =head2 Gradient Fill
  
  The gradient fill format is used to specify gradient filled areas of chart objects such as the interior of a column or the background of the chart itself.
  
  
  The following properties can be set for C<gradient> fill formats in a chart:
  
      colors:    a list of colors
      positions: an optional list of positions for the colors
      type:      the optional type of gradient fill
      angle:     the optional angle of the linear fill
  
  The C<colors> property sets a list of colors that define the C<gradient>:
  
      $chart->set_plotarea(
          gradient => { colors => [ '#DDEBCF', '#9CB86E', '#156B13' ] }
      );
  
  Excel allows between 2 and 10 colors in a gradient but it is unlikely that you will require more than 2 or 3.
  
  As with solid or pattern fill it is also possible to set the colors of a gradient with a Html style C<#RRGGBB> string or a limited number of named colors. The available colours are shown in the main L<Excel::Writer::XLSX> documentation:
  
      $chart->add_series(
          values   => '=Sheet1!$A$1:$A$5',
          gradient => { colors => [ 'red', 'green' ] }
      );
  
  The C<positions> defines an optional list of positions, between 0 and 100, of
  where the colors in the gradient are located. Default values are provided for
  C<colors> lists of between 2 and 4 but they can be specified if required:
  
      $chart->add_series(
          values   => '=Sheet1!$A$1:$A$5',
          gradient => {
              colors    => [ '#DDEBCF', '#156B13' ],
              positions => [ 10,        90 ],
          }
      );
  
  The C<type> property can have one of the following values:
  
      linear        (the default)
      radial
      rectangular
      path
  
  For example:
  
      $chart->add_series(
          values   => '=Sheet1!$A$1:$A$5',
          gradient => {
              colors => [ '#DDEBCF', '#9CB86E', '#156B13' ],
              type   => 'radial'
          }
      );
  
  If C<type> isn't specified it defaults to C<linear>.
  
  For a C<linear> fill the angle of the gradient can also be specified:
  
      $chart->add_series(
          values   => '=Sheet1!$A$1:$A$5',
          gradient => { colors => [ '#DDEBCF', '#9CB86E', '#156B13' ],
                        angle => 30 }
      );
  
  The default angle is 90 degrees.
  
  If gradient fill is used on a chart object it overrides the solid fill and pattern fill properties of the object.
  
  
  
  
  =head1 CHART FONTS
  
  The following font properties can be set for any chart object that they apply to (and that are supported by Excel::Writer::XLSX) such as chart titles, axis labels, axis numbering and data labels. They correspond to the equivalent Worksheet cell Format object properties. See L<Excel::Writer::XLSX/FORMAT_METHODS> for more information.
  
      name
      size
      bold
      italic
      underline
      rotation
      color
  
  The following explains the available font properties:
  
  =over
  
  =item * C<name>
  
  Set the font name:
  
      $chart->set_x_axis( num_font => { name => 'Arial' } );
  
  =item * C<size>
  
  Set the font size:
  
      $chart->set_x_axis( num_font => { name => 'Arial', size => 10 } );
  
  =item * C<bold>
  
  Set the font bold property, should be 0 or 1:
  
      $chart->set_x_axis( num_font => { bold => 1 } );
  
  =item * C<italic>
  
  Set the font italic property, should be 0 or 1:
  
      $chart->set_x_axis( num_font => { italic => 1 } );
  
  =item * C<underline>
  
  Set the font underline property, should be 0 or 1:
  
      $chart->set_x_axis( num_font => { underline => 1 } );
  
  =item * C<rotation>
  
  Set the font rotation in the range -90 to 90:
  
      $chart->set_x_axis( num_font => { rotation => 45 } );
  
  This is useful for displaying large axis data such as dates in a more compact format.
  
  =item * C<color>
  
  Set the font color property. Can be a color index, a color name or HTML style RGB colour:
  
      $chart->set_x_axis( num_font => { color => 'red' } );
      $chart->set_y_axis( num_font => { color => '#92D050' } );
  
  =back
  
  Here is an example of Font formatting in a Chart program:
  
      # Format the chart title.
      $chart->set_title(
          name      => 'Sales Results Chart',
          name_font => {
              name  => 'Calibri',
              color => 'yellow',
          },
      );
  
      # Format the X-axis.
      $chart->set_x_axis(
          name      => 'Month',
          name_font => {
              name  => 'Arial',
              color => '#92D050'
          },
          num_font => {
              name  => 'Courier New',
              color => '#00B0F0',
          },
      );
  
      # Format the Y-axis.
      $chart->set_y_axis(
          name      => 'Sales (1000 units)',
          name_font => {
              name      => 'Century',
              underline => 1,
              color     => 'red'
          },
          num_font => {
              bold   => 1,
              italic => 1,
              color  => '#7030A0',
          },
      );
  
  
  
  =head1 CHART LAYOUT
  
  The position of the chart in the worksheet is controlled by the C<set_size()> method shown above.
  
  It is also possible to change the layout of the following chart sub-objects:
  
      plotarea
      legend
      title
      x_axis caption
      y_axis caption
  
  Here are some examples:
  
      $chart->set_plotarea(
          layout => {
              x      => 0.35,
              y      => 0.26,
              width  => 0.62,
              height => 0.50,
          }
      );
  
      $chart->set_legend(
          layout => {
              x      => 0.80,
              y      => 0.37,
              width  => 0.12,
              height => 0.25,
          }
      );
  
      $chart->set_title(
          name   => 'Title',
          layout => {
              x => 0.42,
              y => 0.14,
          }
      );
  
      $chart->set_x_axis(
          name        => 'X axis',
          name_layout => {
              x => 0.34,
              y => 0.85,
          }
      );
  
  Note that it is only possible to change the width and height for the C<plotarea> and C<legend> objects. For the other text based objects the width and height are changed by the font dimensions.
  
  The layout units must be a float in the range C<0 < x <= 1> and are expressed as a percentage of the chart dimensions as shown below:
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/layout.png" width="826" height="423" alt="Chart object layout." /></center></p>
  
  =end html
  
  From this the layout units are calculated as follows:
  
      layout:
          width  = w / W
          height = h / H
          x      = a / W
          y      = b / H
  
  These units are slightly cumbersome but are required by Excel so that the chart object positions remain relative to each other if the chart is resized by the user.
  
  Note that for C<plotarea> the origin is the top left corner in the plotarea itself and does not take into account the axes.
  
  
  =head1 WORKSHEET METHODS
  
  In Excel a chartsheet (i.e, a chart that isn't embedded) shares properties with data worksheets such as tab selection, headers, footers, margins, and print properties.
  
  In Excel::Writer::XLSX you can set chartsheet properties using the same methods that are used for Worksheet objects.
  
  The following Worksheet methods are also available through a non-embedded Chart object:
  
      get_name()
      activate()
      select()
      hide()
      set_first_sheet()
      protect()
      set_zoom()
      set_tab_color()
  
      set_landscape()
      set_portrait()
      set_paper()
      set_margins()
      set_header()
      set_footer()
  
  See L<Excel::Writer::XLSX> for a detailed explanation of these methods.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates some of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'column', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart->set_style( 11 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/area1.jpg" width="527" height="320" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 Value and Category Axes
  
  Excel differentiates between a chart axis that is used for series B<categories> and an axis that is used for series B<values>.
  
  In the example above the X axis is the category axis and each of the values is evenly spaced. The Y axis (in this case) is the value axis and points are displayed according to their value.
  
  Since Excel treats the axes differently it also handles their formatting differently and exposes different properties for each.
  
  As such some of C<Excel::Writer::XLSX> axis properties can be set for a value axis, some can be set for a category axis and some properties can be set for both.
  
  For example the C<min> and C<max> properties can only be set for value axes and C<reverse> can be set for both. The type of axis that a property applies to is shown in the C<set_x_axis()> section of the documentation above.
  
  Some charts such as C<Scatter> and C<Stock> have two value axes.
  
  Date Axes are a special type of category axis which are explained below.
  
  =head1 Date Category Axes
  
  Date Category Axes are category axes that display time or date information. In Excel::Writer::XLSX Date Category Axes are set using the C<date_axis> option:
  
      $chart->set_x_axis( date_axis => 1 );
  
  In general you should also specify a number format for a date axis although Excel will usually default to the same format as the data being plotted:
  
      $chart->set_x_axis(
          date_axis         => 1,
          num_format        => 'dd/mm/yyyy',
      );
  
  Excel doesn't normally allow minimum and maximum values to be set for category axes. However, date axes are an exception. The C<min> and C<max> values should be set as Excel times or dates:
  
      $chart->set_x_axis(
          date_axis         => 1,
          min               => $worksheet->convert_date_time('2013-01-02T'),
          max               => $worksheet->convert_date_time('2013-01-09T'),
          num_format        => 'dd/mm/yyyy',
      );
  
  For date axes it is also possible to set the type of the major and minor units:
  
      $chart->set_x_axis(
          date_axis         => 1,
          minor_unit        => 4,
          minor_unit_type   => 'months',
          major_unit        => 1,
          major_unit_type   => 'years',
          num_format        => 'dd/mm/yyyy',
      );
  
  
  =head1 Secondary Axes
  
  It is possible to add a secondary axis of the same type to a chart by setting the C<y2_axis> or C<x2_axis> property of the series:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_secondary_axis.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # Add the worksheet data that the charts will refer to.
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
  
      ];
  
      $worksheet->write( 'A1', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure a series with a secondary axis
      $chart->add_series(
          values  => '=Sheet1!$A$1:$A$6',
          y2_axis => 1,
      );
  
      $chart->add_series(
          values => '=Sheet1!$B$1:$B$6',
      );
  
  
      # Insert the chart into the worksheet.
      $worksheet->insert_chart( 'D2', $chart );
  
      __END__
  
  It is also possible to have a secondary, combined, chart either with a shared or secondary axis, see below.
  
  =head1 Combined Charts
  
  It is also possible to combine two different chart types, for example a column and line chart to create a Pareto chart using the Chart C<combine()> method:
  
  
  =begin html
  
  <p><center><img src="https://raw.githubusercontent.com/jmcnamara/XlsxWriter/master/dev/docs/source/_images/chart_pareto.png" alt="Chart image." /></center></p>
  
  =end html
  
  
  Here is a simpler example:
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_combined.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      #
      # In the first example we will create a combined column and line chart.
      # They will share the same X and Y axes.
      #
  
      # Create a new column chart. This will use this as the primary chart.
      my $column_chart = $workbook->add_chart( type => 'column', embedded => 1 );
  
      # Configure the data series for the primary chart.
      $column_chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Create a new column chart. This will use this as the secondary chart.
      my $line_chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the data series for the secondary chart.
      $line_chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
  
      # Combine the charts.
      $column_chart->combine( $line_chart );
  
      # Add a chart title and some axis labels. Note, this is done via the
      # primary chart.
      $column_chart->set_title( name => 'Combined chart - same Y axis' );
      $column_chart->set_x_axis( name => 'Test number' );
      $column_chart->set_y_axis( name => 'Sample length (mm)' );
  
  
      # Insert the chart into the worksheet
      $worksheet->insert_chart( 'E2', $column_chart );
  
  =begin html
  
  <p><center><img src="https://raw.githubusercontent.com/jmcnamara/XlsxWriter/master/dev/docs/source/_images/chart_combined1.png" alt="Chart image." /></center></p>
  
  =end html
  
  
  
  The secondary chart can also be placed on a secondary axis using the methods shown in the previous section.
  
  In this case it is just necessary to add a C<y2_axis> parameter to the series and, if required, add a title using C<set_y2_axis()> B<of the secondary chart>. The following are the additions to the previous example to place the secondary chart on the secondary axis:
  
      ...
  
      $line_chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          y2_axis    => 1,
      );
  
      ...
  
      # Note: the y2 properites are on the secondary chart.
      $line_chart2->set_y2_axis( name => 'Target length (mm)' );
  
  
  =begin html
  
  <p><center><img src="https://raw.githubusercontent.com/jmcnamara/XlsxWriter/master/dev/docs/source/_images/chart_combined2.png" alt="Chart image." /></center></p>
  
  =end html
  
  
  The examples above use the concept of a I<primary> and I<secondary> chart. The primary chart is the chart that defines the primary X and Y axis. It is also used for setting all chart properties apart from the secondary data series. For example the chart title and axes properties should be set via the primary chart (except for the the secondary C<y2> axis properties which should be applied to the secondary chart).
  
  See also C<chart_combined.pl> and C<chart_pareto.pl> examples in the distro for more detailed
  examples.
  
  There are some limitations on combined charts:
  
  =over
  
  =item * Pie charts cannot currently be combined.
  
  =item * Scatter charts cannot currently be used as a primary chart but they can be used as a secondary chart.
  
  =item * Bar charts can only combined secondary charts on a secondary axis. This is an Excel limitation.
  
  =back
  
  
  
  =head1 TODO
  
  Chart features that are on the TODO list and will hopefully be added are:
  
  =over
  
  =item * Add more chart sub-types.
  
  =item * Additional formatting options.
  
  =item * More axis controls.
  
  =item * 3D charts.
  
  =item * Additional chart types.
  
  =back
  
  If you are interested in sponsoring a feature to have it implemented or expedited let me know.
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_CHART

$fatpacked{"Excel/Writer/XLSX/Chart/Area.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_AREA';
  package Excel::Writer::XLSX::Chart::Area;
  
  ###############################################################################
  #
  # Area - A class for writing Excel Area charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_subtype}       = $self->{_subtype} || 'standard';
      $self->{_cross_between} = 'midCat';
      $self->{_show_crosses}  = 0;
  
      # Override and reset the default axis values.
      if ( $self->{_subtype} eq 'percent_stacked' ) {
          $self->{_y_axis}->{_defaults}->{num_format} = '0%';
      }
  
      $self->set_y_axis();
  
      # Sset the available data label positions for this chart type.
      $self->{_label_position_default} = 'center';
      $self->{_label_positions} = { center => 'ctr' };
  
      bless $self, $class;
      return $self;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:areaChart element.
      $self->_write_area_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_area_chart()
  #
  # Write the <c:areaChart> element.
  #
  sub _write_area_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      my $subtype = $self->{_subtype};
  
      $subtype = 'percentStacked' if $subtype eq 'percent_stacked';
  
      $self->xml_start_tag( 'c:areaChart' );
  
      # Write the c:grouping element.
      $self->_write_grouping( $subtype );
  
      # Write the series elements.
      $self->_write_series( $_ ) for @series;
  
      # Write the c:dropLines element.
      $self->_write_drop_lines();
  
      # Write the c:marker element.
      $self->_write_marker_value();
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:areaChart' );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Area - A class for writing Excel Area charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with an Area chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'area' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Area charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'area' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Area Chart Subtypes
  
  
  The C<Area> chart module also supports the following sub-types:
  
      stacked
      percent_stacked
  
  These can be specified at creation time via the C<add_chart()> Worksheet method:
  
      my $chart = $workbook->add_chart( type => 'area', subtype => 'stacked' );
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_area.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 40, 40, 50, 30, 25, 50 ],
          [ 30, 25, 30, 10,  5, 10 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'area', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart->set_style( 11 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/area1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_CHART_AREA

$fatpacked{"Excel/Writer/XLSX/Chart/Bar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_BAR';
  package Excel::Writer::XLSX::Chart::Bar;
  
  ###############################################################################
  #
  # Bar - A class for writing Excel Bar charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_subtype}           = $self->{_subtype} || 'clustered';
      $self->{_cat_axis_position} = 'l';
      $self->{_val_axis_position} = 'b';
      $self->{_horiz_val_axis}    = 0;
      $self->{_horiz_cat_axis}    = 1;
      $self->{_show_crosses}      = 0;
  
      # Override and reset the default axis values.
      $self->{_x_axis}->{_defaults}->{major_gridlines} = { visible => 1 };
      $self->{_y_axis}->{_defaults}->{major_gridlines} = { visible => 0 };
  
      if ( $self->{_subtype} eq 'percent_stacked' ) {
          $self->{_x_axis}->{_defaults}->{num_format} = '0%';
      }
  
      $self->set_x_axis();
      $self->set_y_axis();
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'outside_end';
      $self->{_label_positions} = {
          center      => 'ctr',
          inside_base => 'inBase',
          inside_end  => 'inEnd',
          outside_end => 'outEnd',
      };
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # combine()
  #
  # Override parent method to add an extra check that is required for Bar
  # charts to ensure that their combined chart is on a secondary axis.
  #
  sub combine {
  
      my $self  = shift;
      my $chart = shift;
  
      if (!$chart->{_is_secondary}) {
          carp 'Charts combined with Bar charts must be on a secondary axis';
          return;
      }
  
      $self->{_combined} = $chart;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
      my %args = @_;
  
      if ( $args{primary_axes} ) {
  
          # Reverse X and Y axes for Bar charts.
          my $tmp = $self->{_y_axis};
          $self->{_y_axis} = $self->{_x_axis};
          $self->{_x_axis} = $tmp;
  
          if ( $self->{_y2_axis}->{_position} eq 'r' ) {
              $self->{_y2_axis}->{_position} = 't';
          }
      }
  
      # Write the c:barChart element.
      $self->_write_bar_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_bar_chart()
  #
  # Write the <c:barChart> element.
  #
  sub _write_bar_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      my $subtype = $self->{_subtype};
      $subtype = 'percentStacked' if $subtype eq 'percent_stacked';
  
      # Set a default overlap for stacked charts.
      if ($self->{_subtype} =~ /stacked/) {
          if (!defined $self->{_series_overlap_1}) {
              $self->{_series_overlap_1} = 100;
          }
      }
  
      $self->xml_start_tag( 'c:barChart' );
  
      # Write the c:barDir element.
      $self->_write_bar_dir();
  
      # Write the c:grouping element.
      $self->_write_grouping( $subtype );
  
      # Write the c:ser elements.
      $self->_write_ser( $_ ) for @series;
  
      # Write the c:marker element.
      $self->_write_marker_value();
  
      if ( $args{primary_axes} ) {
          # Write the c:gapWidth element.
          $self->_write_gap_width( $self->{_series_gap_1} );
  
          # Write the c:overlap element.
          $self->_write_overlap( $self->{_series_overlap_1} );
      }
      else {
          # Write the c:gapWidth element.
          $self->_write_gap_width( $self->{_series_gap_2} );
  
          # Write the c:overlap element.
          $self->_write_overlap( $self->{_series_overlap_2} );
      }
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:barChart' );
  }
  
  
  ##############################################################################
  #
  # _write_bar_dir()
  #
  # Write the <c:barDir> element.
  #
  sub _write_bar_dir {
  
      my $self = shift;
      my $val  = 'bar';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:barDir', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_err_dir()
  #
  # Write the <c:errDir> element. Overridden from Chart class since it is not
  # used in Bar charts.
  #
  sub _write_err_dir {}
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Bar - A class for writing Excel Bar charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Bar chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'bar' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Bar charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'bar' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Bar Chart Subtypes
  
  The C<Bar> chart module also supports the following sub-types:
  
      stacked
      percent_stacked
  
  These can be specified at creation time via the C<add_chart()> Worksheet method:
  
      my $chart = $workbook->add_chart( type => 'bar', subtype => 'stacked' );
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_bar.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'bar', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart->set_style( 11 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/bar1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_CHART_BAR

$fatpacked{"Excel/Writer/XLSX/Chart/Column.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_COLUMN';
  package Excel::Writer::XLSX::Chart::Column;
  
  ###############################################################################
  #
  # Column - A class for writing Excel Column charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_subtype} = $self->{_subtype} || 'clustered';
      $self->{_horiz_val_axis} = 0;
  
      # Override and reset the default axis values.
      if ( $self->{_subtype} eq 'percent_stacked' ) {
          $self->{_y_axis}->{_defaults}->{num_format} = '0%';
      }
  
      $self->set_y_axis();
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'outside_end';
      $self->{_label_positions} = {
          center      => 'ctr',
          inside_base => 'inBase',
          inside_end  => 'inEnd',
          outside_end => 'outEnd',
      };
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:barChart element.
      $self->_write_bar_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_bar_chart()
  #
  # Write the <c:barChart> element.
  #
  sub _write_bar_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      my $subtype = $self->{_subtype};
      $subtype = 'percentStacked' if $subtype eq 'percent_stacked';
  
      # Set a default overlap for stacked charts.
      if ($self->{_subtype} =~ /stacked/) {
          if (!defined $self->{_series_overlap_1}) {
              $self->{_series_overlap_1} = 100;
          }
      }
  
      $self->xml_start_tag( 'c:barChart' );
  
      # Write the c:barDir element.
      $self->_write_bar_dir();
  
      # Write the c:grouping element.
      $self->_write_grouping( $subtype );
  
      # Write the c:ser elements.
      $self->_write_ser( $_ ) for @series;
  
      # Write the c:marker element.
      $self->_write_marker_value();
  
      if ( $args{primary_axes} ) {
          # Write the c:gapWidth element.
          $self->_write_gap_width( $self->{_series_gap_1} );
  
          # Write the c:overlap element.
          $self->_write_overlap( $self->{_series_overlap_1} );
      }
      else {
          # Write the c:gapWidth element.
          $self->_write_gap_width( $self->{_series_gap_2} );
  
          # Write the c:overlap element.
          $self->_write_overlap( $self->{_series_overlap_2} );
      }
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:barChart' );
  }
  
  
  ##############################################################################
  #
  # _write_bar_dir()
  #
  # Write the <c:barDir> element.
  #
  sub _write_bar_dir {
  
      my $self = shift;
      my $val  = 'col';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:barDir', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_err_dir()
  #
  # Write the <c:errDir> element. Overridden from Chart class since it is not
  # used in Bar charts.
  #
  sub _write_err_dir {}
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Column - A class for writing Excel Column charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Column chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'column' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Column charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'column' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Column Chart Subtypes
  
  The C<Column> chart module also supports the following sub-types:
  
      stacked
      percent_stacked
  
  These can be specified at creation time via the C<add_chart()> Worksheet method:
  
      my $chart = $workbook->add_chart( type => 'column', subtype => 'stacked' );
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_column.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'column', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart->set_style( 11 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/column1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_CHART_COLUMN

$fatpacked{"Excel/Writer/XLSX/Chart/Doughnut.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_DOUGHNUT';
  package Excel::Writer::XLSX::Chart::Doughnut;
  
  ###############################################################################
  #
  # Doughnut - A class for writing Excel Doughnut charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart::Pie;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart::Pie);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart::Pie->new( @_ );
  
      $self->{_vary_data_color} = 1;
      $self->{_hole_size}       = 50;
      $self->{_rotation}        = 0;
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # set_hole_size()
  #
  # Set the Doughnut chart hole size.
  #
  sub set_hole_size {
  
      my $self = shift;
      my $size = shift;
  
      return if !defined $size;
  
      if ( $size >= 10 && $size <= 90 ) {
          $self->{_hole_size} = $size;
      }
      else {
          carp "Hole size $size outside Excel range: 10 <= size <= 90";
      }
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:doughnutChart element.
      $self->_write_doughnut_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_doughnut_chart()
  #
  # Write the <c:doughnutChart> element. Over-ridden method to remove axis_id code
  # since Doughnut charts don't require val and cat axes.
  #
  sub _write_doughnut_chart {
  
      my $self = shift;
  
      $self->xml_start_tag( 'c:doughnutChart' );
  
      # Write the c:varyColors element.
      $self->_write_vary_colors();
  
      # Write the series elements.
      $self->_write_ser( $_ ) for @{ $self->{_series} };
  
      # Write the c:firstSliceAng element.
      $self->_write_first_slice_ang();
  
      # Write the c:holeSize element.
      $self->_write_hole_size();
  
      $self->xml_end_tag( 'c:doughnutChart' );
  }
  
  
  ##############################################################################
  #
  # _write_hole_size()
  #
  # Write the <c:holeSize> element.
  #
  sub _write_hole_size {
  
      my $self = shift;
      my $val  = $self->{_hole_size};
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:holeSize', @attributes );
  }
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Doughnut - A class for writing Excel Doughnut charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Doughnut chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'doughnut' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Doughnut charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'doughnut' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Doughnut Chart Methods
  
  =head2 set_rotation()
  
  The C<set_rotation()> method is used to set the rotation of the first segment of a Pie/Doughnut chart. This has the effect of rotating the entire chart:
  
      $chart->set_rotation( 90 );
  
  The angle of rotation must be C<< 0 <= rotation <= 360 >>.
  
  
  =head2 set_hole_size()
  
  The C<set_hole_size()> method is used to set the hole size of a Doughnut chart:
  
      $chart->set_hole_size( 33 );
  
  The the hole size must be a percentage in the range  C<< 10 <= size <= 90 >>.
  
  
  =head2 User defined colors
  
  It is possible to define chart colors for most types of Excel::Writer::XLSX charts via the add_series() method. However, Pie/Doughnut charts are a special case since each segment is represented as a point so it is necessary to assign formatting to each point in the series:
  
      $chart->add_series(
          values => '=Sheet1!$A$1:$A$3',
          points => [
              { fill => { color => '#FF0000' } },
              { fill => { color => '#CC0000' } },
              { fill => { color => '#990000' } },
          ],
      );
  
  See the main L<Excel::Writer::XLSX::Chart> documentation for more details.
  
  Doughnut charts support leader lines:
  
      $chart->add_series(
          name        => 'Doughnut sales data',
          categories  => [ 'Sheet1', 1, 3, 0, 0 ],
          values      => [ 'Sheet1', 1, 3, 1, 1 ],
          data_labels => {
              series_name  => 1,
              percentage   => 1,
              leader_lines => 1,
              position     => 'outside_end'
          },
      );
  
  Note: Even when leader lines are turned on they aren't automatically visible in Excel or Excel::Writer::XLSX. Due to an Excel limitation (or design) leader lines only appear if the data label is moved manually or if the data labels are very close and need to be adjusted automatically.
  
  =head2 Unsupported Methods
  
  A Doughnut chart doesn't have an X or Y axis so the following common chart methods are ignored.
  
      $chart->set_x_axis();
      $chart->set_y_axis();
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_doughnut.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values' ];
      my $data = [
          [ 'Glazed', 'Chocolate', 'Cream' ],
          [ 50,       35,          15      ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'doughnut', embedded => 1 );
  
      # Configure the series. Note the use of the array ref to define ranges:
      # [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => 'Doughnut sales data',
          categories => [ 'Sheet1', 1, 3, 0, 0 ],
          values     => [ 'Sheet1', 1, 3, 1, 1 ],
      );
  
      # Add a title.
      $chart->set_title( name => 'Popular Doughnut Types' );
  
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart->set_style( 10 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/doughnut1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_CHART_DOUGHNUT

$fatpacked{"Excel/Writer/XLSX/Chart/Line.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_LINE';
  package Excel::Writer::XLSX::Chart::Line;
  
  ###############################################################################
  #
  # Line - A class for writing Excel Line charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_default_marker} = { type => 'none' };
      $self->{_smooth_allowed} = 1;
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'right';
      $self->{_label_positions} = {
          center      => 'ctr',
          right       => 'r',
          left        => 'l',
          above       => 't',
          below       => 'b',
          # For backward compatibility.
          top         => 't',
          bottom      => 'b',
      };
  
      bless $self, $class;
      return $self;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:lineChart element.
      $self->_write_line_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_line_chart()
  #
  # Write the <c:lineChart> element.
  #
  sub _write_line_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      $self->xml_start_tag( 'c:lineChart' );
  
      # Write the c:grouping element.
      $self->_write_grouping( 'standard' );
  
      # Write the series elements.
      $self->_write_series( $_ ) for @series;
  
      # Write the c:dropLines element.
      $self->_write_drop_lines();
  
      # Write the c:hiLowLines element.
      $self->_write_hi_low_lines();
  
      # Write the c:upDownBars element.
      $self->_write_up_down_bars();
  
      # Write the c:marker element.
      $self->_write_marker_value();
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:lineChart' );
  }
  
  
  ##############################################################################
  #
  # _write_d_pt_point()
  #
  # Write an individual <c:dPt> element. Override the parent method to add
  # markers.
  #
  sub _write_d_pt_point {
  
      my $self   = shift;
      my $index = shift;
      my $point = shift;
  
          $self->xml_start_tag( 'c:dPt' );
  
          # Write the c:idx element.
          $self->_write_idx( $index );
  
          $self->xml_start_tag( 'c:marker' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $point );
  
          $self->xml_end_tag( 'c:marker' );
  
          $self->xml_end_tag( 'c:dPt' );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Line - A class for writing Excel Line charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Line chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'line' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Line charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'line' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Line Chart Methods
  
  There aren't currently any line chart specific methods. See the TODO section of L<Excel::Writer::XLSX::Chart>.
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_line.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart->set_style( 10 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/line1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_CHART_LINE

$fatpacked{"Excel/Writer/XLSX/Chart/Pie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_PIE';
  package Excel::Writer::XLSX::Chart::Pie;
  
  ###############################################################################
  #
  # Pie - A class for writing Excel Pie charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_vary_data_color} = 1;
      $self->{_rotation}        = 0;
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'best_fit';
      $self->{_label_positions} = {
          center      => 'ctr',
          inside_end  => 'inEnd',
          outside_end => 'outEnd',
          best_fit    => 'bestFit',
      };
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # set_rotation()
  #
  # Set the Pie/Doughnut chart rotation: the angle of the first slice.
  #
  sub set_rotation {
  
      my $self     = shift;
      my $rotation = shift;
  
      return if !defined $rotation;
  
      if ( $rotation >= 0 && $rotation <= 360 ) {
          $self->{_rotation} = $rotation;
      }
      else {
          carp "Chart rotation $rotation outside range: 0 <= rotation <= 360";
      }
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:pieChart element.
      $self->_write_pie_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_pie_chart()
  #
  # Write the <c:pieChart> element.  Over-ridden method to remove axis_id code
  # since Pie charts don't require val and cat axes.
  #
  sub _write_pie_chart {
  
      my $self = shift;
  
      $self->xml_start_tag( 'c:pieChart' );
  
      # Write the c:varyColors element.
      $self->_write_vary_colors();
  
      # Write the series elements.
      $self->_write_ser( $_ ) for @{ $self->{_series} };
  
      # Write the c:firstSliceAng element.
      $self->_write_first_slice_ang();
  
      $self->xml_end_tag( 'c:pieChart' );
  }
  
  
  ###############################################################################
  #
  # combine()
  #
  # Override parent method to add a warning.
  #
  sub combine {
  
      my $self  = shift;
      my $chart = shift;
  
      carp "Combined chart not currently supported for Pie charts";
      return;
  }
  
  
  ##############################################################################
  #
  # _write_plot_area().
  #
  # Over-ridden method to remove the cat_axis() and val_axis() code since
  # Pie/Doughnut charts don't require those axes.
  #
  # Write the <c:plotArea> element.
  #
  sub _write_plot_area {
  
      my $self = shift;
  
      $self->xml_start_tag( 'c:plotArea' );
  
      # Write the c:layout element.
      $self->_write_layout( $self->{_plotarea}->{_layout}, 'plot' );
  
      # Write the subclass chart type element.
      $self->_write_chart_type();
  
      $self->xml_end_tag( 'c:plotArea' );
  }
  
  
  ##############################################################################
  #
  # _write_legend().
  #
  # Over-ridden method to add <c:txPr> to legend.
  #
  # Write the <c:legend> element.
  #
  sub _write_legend {
  
      my $self          = shift;
      my $position      = $self->{_legend_position};
      my $font          = $self->{_legend_font};
      my @delete_series = ();
      my $overlay       = 0;
  
      if ( defined $self->{_legend_delete_series}
          && ref $self->{_legend_delete_series} eq 'ARRAY' )
      {
          @delete_series = @{ $self->{_legend_delete_series} };
      }
  
      if ( $position =~ s/^overlay_// ) {
          $overlay = 1;
      }
  
      my %allowed = (
          right  => 'r',
          left   => 'l',
          top    => 't',
          bottom => 'b',
      );
  
      return if $position eq 'none';
      return unless exists $allowed{$position};
  
      $position = $allowed{$position};
  
      $self->xml_start_tag( 'c:legend' );
  
      # Write the c:legendPos element.
      $self->_write_legend_pos( $position );
  
      # Remove series labels from the legend.
      for my $index ( @delete_series ) {
  
          # Write the c:legendEntry element.
          $self->_write_legend_entry( $index );
      }
  
      # Write the c:layout element.
      $self->_write_layout( $self->{_legend_layout}, 'legend' );
  
      # Write the c:overlay element.
      $self->_write_overlay() if $overlay;
  
      # Write the c:txPr element. Over-ridden.
      $self->_write_tx_pr_legend( 0, $font );
  
      $self->xml_end_tag( 'c:legend' );
  }
  
  
  ##############################################################################
  #
  # _write_tx_pr_legend()
  #
  # Write the <c:txPr> element for legends.
  #
  sub _write_tx_pr_legend {
  
      my $self     = shift;
      my $horiz    = shift;
      my $font     = shift;
      my $rotation = undef;
  
      if ( $font && exists $font->{_rotation} ) {
          $rotation = $font->{_rotation};
      }
  
      $self->xml_start_tag( 'c:txPr' );
  
      # Write the a:bodyPr element.
      $self->_write_a_body_pr( $rotation, $horiz );
  
      # Write the a:lstStyle element.
      $self->_write_a_lst_style();
  
      # Write the a:p element.
      $self->_write_a_p_legend( $font );
  
      $self->xml_end_tag( 'c:txPr' );
  }
  
  
  ##############################################################################
  #
  # _write_a_p_legend()
  #
  # Write the <a:p> element for legends.
  #
  sub _write_a_p_legend {
  
      my $self = shift;
      my $font = shift;
  
      $self->xml_start_tag( 'a:p' );
  
      # Write the a:pPr element.
      $self->_write_a_p_pr_legend( $font );
  
      # Write the a:endParaRPr element.
      $self->_write_a_end_para_rpr();
  
      $self->xml_end_tag( 'a:p' );
  }
  
  
  ##############################################################################
  #
  # _write_a_p_pr_legend()
  #
  # Write the <a:pPr> element for legends.
  #
  sub _write_a_p_pr_legend {
  
      my $self = shift;
      my $font = shift;
      my $rtl  = 0;
  
      my @attributes = ( 'rtl' => $rtl );
  
      $self->xml_start_tag( 'a:pPr', @attributes );
  
      # Write the a:defRPr element.
      $self->_write_a_def_rpr( $font );
  
      $self->xml_end_tag( 'a:pPr' );
  }
  
  
  ##############################################################################
  #
  # _write_vary_colors()
  #
  # Write the <c:varyColors> element.
  #
  sub _write_vary_colors {
  
      my $self = shift;
      my $val  = 1;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:varyColors', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_first_slice_ang()
  #
  # Write the <c:firstSliceAng> element.
  #
  sub _write_first_slice_ang {
  
      my $self = shift;
      my $val  = $self->{_rotation};
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:firstSliceAng', @attributes );
  }
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Pie - A class for writing Excel Pie charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Pie chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'pie' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Pie charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'pie' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Pie Chart Methods
  
  =head2 set_rotation()
  
  The C<set_rotation()> method is used to set the rotation of the first segment of a Pie/Doughnut chart. This has the effect of rotating the entire chart:
  
      $chart->set_rotation( 90 );
  
  The angle of rotation must be C<< 0 <= rotation <= 360 >>.
  
  
  =head2 User defined colors
  
  It is possible to define chart colors for most types of Excel::Writer::XLSX charts via the add_series() method. However, Pie/Doughnut charts are a special case since each segment is represented as a point so it is necessary to assign formatting to each point in the series:
  
      $chart->add_series(
          values => '=Sheet1!$A$1:$A$3',
          points => [
              { fill => { color => '#FF0000' } },
              { fill => { color => '#CC0000' } },
              { fill => { color => '#990000' } },
          ],
      );
  
  See the main L<Excel::Writer::XLSX::Chart> documentation for more details.
  
  Pie charts support leader lines:
  
      $chart->add_series(
          name        => 'Pie sales data',
          categories  => [ 'Sheet1', 1, 3, 0, 0 ],
          values      => [ 'Sheet1', 1, 3, 1, 1 ],
          data_labels => {
              series_name  => 1,
              percentage   => 1,
              leader_lines => 1,
              position     => 'outside_end'
          },
      );
  
  Note: Even when leader lines are turned on they aren't automatically visible in Excel or Excel::Writer::XLSX. Due to an Excel limitation (or design) leader lines only appear if the data label is moved manually or if the data labels are very close and need to be adjusted automatically.
  
  =head2 Unsupported Methods
  
  A Pie chart doesn't have an X or Y axis so the following common chart methods are ignored.
  
      $chart->set_x_axis();
      $chart->set_y_axis();
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_pie.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values' ];
      my $data = [
          [ 'Apple', 'Cherry', 'Pecan' ],
          [ 60,       30,       10     ],
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'pie', embedded => 1 );
  
      # Configure the series. Note the use of the array ref to define ranges:
      # [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => 'Pie sales data',
          categories => [ 'Sheet1', 1, 3, 0, 0 ],
          values     => [ 'Sheet1', 1, 3, 1, 1 ],
      );
  
      # Add a title.
      $chart->set_title( name => 'Popular Pie Types' );
  
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart->set_style( 10 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/pie1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_CHART_PIE

$fatpacked{"Excel/Writer/XLSX/Chart/Radar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_RADAR';
  package Excel::Writer::XLSX::Chart::Radar;
  
  ###############################################################################
  #
  # Radar - A class for writing Excel Radar charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_subtype} = $self->{_subtype} || 'marker';
  
      if ( $self->{_subtype} eq 'marker' ) {
          $self->{_default_marker} = { type => 'none' };
      }
  
      # Override and reset the default axis values.
      $self->{_x_axis}->{_defaults}->{major_gridlines} = { visible => 1 };
      $self->set_x_axis();
  
      # Hardcode major_tick_mark for now until there is an accessor.
      $self->{_y_axis}->{_major_tick_mark} = 'cross';
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'center';
      $self->{_label_positions} = { center => 'ctr' };
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:radarChart element.
      $self->_write_radar_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_radar_chart()
  #
  # Write the <c:radarChart> element.
  #
  sub _write_radar_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      $self->xml_start_tag( 'c:radarChart' );
  
      # Write the c:radarStyle element.
      $self->_write_radar_style();
  
      # Write the series elements.
      $self->_write_series( $_ ) for @series;
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:radarChart' );
  }
  
  
  ##############################################################################
  #
  # _write_radar_style()
  #
  # Write the <c:radarStyle> element.
  #
  sub _write_radar_style {
  
      my $self = shift;
      my $val  = 'marker';
  
      if ( $self->{_subtype} eq 'filled' ) {
          $val = 'filled';
      }
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:radarStyle', @attributes );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Radar - A class for writing Excel Radar charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Radar chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'radar' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Radar charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'radar' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Radar Chart Methods
  
  The C<Radar> chart module also supports the following sub-types:
  
      with_markers
      filled
  
  These can be specified at creation time via the C<add_chart()> Worksheet method:
  
      my $chart = $workbook->add_chart( type => 'radar', subtype => 'filled' );
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_radar.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 30, 60, 70, 50, 40, 30 ],
          [ 25, 40, 50, 30, 50, 40 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'radar', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart->set_style( 10 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/radar1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_CHART_RADAR

$fatpacked{"Excel/Writer/XLSX/Chart/Scatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_SCATTER';
  package Excel::Writer::XLSX::Chart::Scatter;
  
  ###############################################################################
  #
  # Scatter - A class for writing Excel Scatter charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
  
      $self->{_subtype}           = $self->{_subtype} || 'marker_only';
      $self->{_cross_between}     = 'midCat';
      $self->{_horiz_val_axis}    = 0;
      $self->{_val_axis_postion}  = 'b';
      $self->{_smooth_allowed}    = 1;
      $self->{_requires_category} = 1;
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'right';
      $self->{_label_positions} = {
          center      => 'ctr',
          right       => 'r',
          left        => 'l',
          above       => 't',
          below       => 'b',
          # For backward compatibility.
          top         => 't',
          bottom      => 'b',
      };
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # combine()
  #
  # Override parent method to add a warning.
  #
  sub combine {
  
      my $self  = shift;
      my $chart = shift;
  
      carp 'Combined chart not currently supported with scatter chart ' .
        'as the primary chart';
      return;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:scatterChart element.
      $self->_write_scatter_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_scatter_chart()
  #
  # Write the <c:scatterChart> element.
  #
  sub _write_scatter_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      my $style   = 'lineMarker';
      my $subtype = $self->{_subtype};
  
      # Set the user defined chart subtype.
      $style = 'lineMarker'   if $subtype eq 'marker_only';
      $style = 'lineMarker'   if $subtype eq 'straight_with_markers';
      $style = 'lineMarker'   if $subtype eq 'straight';
      $style = 'smoothMarker' if $subtype eq 'smooth_with_markers';
      $style = 'smoothMarker' if $subtype eq 'smooth';
  
      # Add default formatting to the series data.
      $self->_modify_series_formatting();
  
      $self->xml_start_tag( 'c:scatterChart' );
  
      # Write the c:scatterStyle element.
      $self->_write_scatter_style( $style );
  
      # Write the series elements.
      $self->_write_ser( $_ ) for @series;
  
      # Write the c:marker element.
      $self->_write_marker_value();
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:scatterChart' );
  }
  
  
  ##############################################################################
  #
  # _write_ser()
  #
  # Over-ridden to write c:xVal/c:yVal instead of c:cat/c:val elements.
  #
  # Write the <c:ser> element.
  #
  sub _write_ser {
  
      my $self   = shift;
      my $series = shift;
      my $index  = $self->{_series_index}++;
  
      $self->xml_start_tag( 'c:ser' );
  
      # Write the c:idx element.
      $self->_write_idx( $index );
  
      # Write the c:order element.
      $self->_write_order( $index );
  
      # Write the series name.
      $self->_write_series_name( $series );
  
      # Write the c:spPr element.
      $self->_write_sp_pr( $series );
  
      # Write the c:marker element.
      $self->_write_marker( $series->{_marker} );
  
      # Write the c:dPt element.
      $self->_write_d_pt( $series->{_points} );
  
      # Write the c:dLbls element.
      $self->_write_d_lbls( $series->{_labels} );
  
      # Write the c:trendline element.
      $self->_write_trendline( $series->{_trendline} );
  
      # Write the c:errBars element.
      $self->_write_error_bars( $series->{_error_bars} );
  
      # Write the c:xVal element.
      $self->_write_x_val( $series );
  
      # Write the c:yVal element.
      $self->_write_y_val( $series );
  
      # Write the c:smooth element.
      if ( $self->{_subtype} =~ /smooth/ && !defined $series->{_smooth} ) {
          # Default is on for smooth scatter charts.
          $self->_write_c_smooth( 1 );
      }
      else {
          $self->_write_c_smooth( $series->{_smooth} );
      }
  
      $self->xml_end_tag( 'c:ser' );
  }
  
  
  ##############################################################################
  #
  # _write_plot_area()
  #
  # Over-ridden to have 2 valAx elements for scatter charts instead of
  # catAx/valAx.
  #
  # Write the <c:plotArea> element.
  #
  sub _write_plot_area {
  
      my $self = shift;
  
      $self->xml_start_tag( 'c:plotArea' );
  
      # Write the c:layout element.
      $self->_write_layout( $self->{_plotarea}->{_layout}, 'plot' );
  
      # Write the subclass chart type elements for primary and secondary axes.
      $self->_write_chart_type( primary_axes => 1 );
      $self->_write_chart_type( primary_axes => 0 );
  
      # Write c:catAx and c:valAx elements for series using primary axes.
      $self->_write_cat_val_axis(
          x_axis   => $self->{_x_axis},
          y_axis   => $self->{_y_axis},
          axis_ids => $self->{_axis_ids},
          position => 'b',
      );
  
      my $tmp = $self->{_horiz_val_axis};
      $self->{_horiz_val_axis} = 1;
      $self->_write_val_axis(
          x_axis   => $self->{_x_axis},
          y_axis   => $self->{_y_axis},
          axis_ids => $self->{_axis_ids},
          position => 'l',
      );
      $self->{_horiz_val_axis} = $tmp;
  
      # Write c:valAx and c:catAx elements for series using secondary axes.
      $self->_write_cat_val_axis(
          x_axis   => $self->{_x2_axis},
          y_axis   => $self->{_y2_axis},
          axis_ids => $self->{_axis2_ids},
          position => 'b',
      );
      $self->{_horiz_val_axis} = 1;
      $self->_write_val_axis(
          x_axis   => $self->{_x2_axis},
          y_axis   => $self->{_y2_axis},
          axis_ids => $self->{_axis2_ids},
          position => 'l',
      );
  
      # Write the c:spPr element for the plotarea formatting.
      $self->_write_sp_pr( $self->{_plotarea} );
  
      $self->xml_end_tag( 'c:plotArea' );
  }
  
  
  ##############################################################################
  #
  # _write_x_val()
  #
  # Write the <c:xVal> element.
  #
  sub _write_x_val {
  
      my $self    = shift;
      my $series  = shift;
      my $formula = $series->{_categories};
      my $data_id = $series->{_cat_data_id};
      my $data    = $self->{_formula_data}->[$data_id];
  
      $self->xml_start_tag( 'c:xVal' );
  
      # Check the type of cached data.
      my $type = $self->_get_data_type( $data );
  
      # TODO. Can a scatter plot have non-numeric data.
  
      if ( $type eq 'str' ) {
  
          # Write the c:numRef element.
          $self->_write_str_ref( $formula, $data, $type );
      }
      else {
  
          # Write the c:numRef element.
          $self->_write_num_ref( $formula, $data, $type );
      }
  
      $self->xml_end_tag( 'c:xVal' );
  }
  
  
  ##############################################################################
  #
  # _write_y_val()
  #
  # Write the <c:yVal> element.
  #
  sub _write_y_val {
  
      my $self    = shift;
      my $series  = shift;
      my $formula = $series->{_values};
      my $data_id = $series->{_val_data_id};
      my $data    = $self->{_formula_data}->[$data_id];
  
      $self->xml_start_tag( 'c:yVal' );
  
      # Unlike Cat axes data should only be numeric.
  
      # Write the c:numRef element.
      $self->_write_num_ref( $formula, $data, 'num' );
  
      $self->xml_end_tag( 'c:yVal' );
  }
  
  
  ##############################################################################
  #
  # _write_scatter_style()
  #
  # Write the <c:scatterStyle> element.
  #
  sub _write_scatter_style {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'c:scatterStyle', @attributes );
  }
  
  
  ##############################################################################
  #
  # _modify_series_formatting()
  #
  # Add default formatting to the series data unless it has already been
  # specified by the user.
  #
  sub _modify_series_formatting {
  
      my $self    = shift;
      my $subtype = $self->{_subtype};
  
      # The default scatter style "markers only" requires a line type.
      if ( $subtype eq 'marker_only' ) {
  
          # Go through each series and define default values.
          for my $series ( @{ $self->{_series} } ) {
  
              # Set a line type unless there is already a user defined type.
              if ( !$series->{_line}->{_defined} ) {
                  $series->{_line} = {
                      width    => 2.25,
                      none     => 1,
                      _defined => 1,
                  };
              }
          }
      }
  
      # Turn markers off for subtypes that don't have them.
      if ( $subtype !~ /marker/ ) {
  
          # Go through each series and define default values.
          for my $series ( @{ $self->{_series} } ) {
  
              # Set a marker type unless there is already a user defined type.
              if ( !$series->{_marker} ) {
                  $series->{_marker} = {
                      type     => 'none',
                      _defined => 1,
                  };
              }
          }
      }
  
  }
  
  
  ##############################################################################
  #
  # _write_d_pt_point()
  #
  # Write an individual <c:dPt> element. Override the parent method to add
  # markers.
  #
  sub _write_d_pt_point {
  
      my $self   = shift;
      my $index = shift;
      my $point = shift;
  
          $self->xml_start_tag( 'c:dPt' );
  
          # Write the c:idx element.
          $self->_write_idx( $index );
  
          $self->xml_start_tag( 'c:marker' );
  
          # Write the c:spPr element.
          $self->_write_sp_pr( $point );
  
          $self->xml_end_tag( 'c:marker' );
  
          $self->xml_end_tag( 'c:dPt' );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Scatter - A class for writing Excel Scatter charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Scatter chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart     = $workbook->add_chart( type => 'scatter' );
  
      # Configure the chart.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Add the worksheet data the chart refers to.
      my $data = [
          [ 'Category', 2, 3, 4, 5, 6, 7 ],
          [ 'Value',    1, 4, 5, 2, 1, 5 ],
      ];
  
      $worksheet->write( 'A1', $data );
  
      __END__
  
  =head1 DESCRIPTION
  
  This module implements Scatter charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'scatter' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Scatter Chart Subtypes
  
  The C<Scatter> chart module also supports the following sub-types:
  
      markers_only (the default)
      straight_with_markers
      straight
      smooth_with_markers
      smooth
  
  These can be specified at creation time via the C<add_chart()> Worksheet method:
  
      my $chart = $workbook->add_chart(
          type    => 'scatter',
          subtype => 'straight_with_markers'
      );
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart_scatter.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
  
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'scatter', embedded => 1 );
  
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
  
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
  
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart->set_style( 10 );
  
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
  
      __END__
  
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/scatter1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_CHART_SCATTER

$fatpacked{"Excel/Writer/XLSX/Chart/Stock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHART_STOCK';
  package Excel::Writer::XLSX::Chart::Stock;
  
  ###############################################################################
  #
  # Stock - A class for writing Excel Stock charts.
  #
  # Used in conjunction with Excel::Writer::XLSX::Chart.
  #
  # See formatting note in Excel::Writer::XLSX::Chart.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Chart;
  
  our @ISA     = qw(Excel::Writer::XLSX::Chart);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # new()
  #
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Chart->new( @_ );
      $self->{_show_crosses}  = 0;
      $self->{_hi_low_lines}  = {};
      $self->{_date_category} = 1;
  
      # Override and reset the default axis values.
      $self->{_x_axis}->{_defaults}->{num_format}  = 'dd/mm/yyyy';
      $self->{_x2_axis}->{_defaults}->{num_format} = 'dd/mm/yyyy';
      $self->set_x_axis();
      $self->set_x2_axis();
  
      # Set the available data label positions for this chart type.
      $self->{_label_position_default} = 'right';
      $self->{_label_positions} = {
          center      => 'ctr',
          right       => 'r',
          left        => 'l',
          above       => 't',
          below       => 'b',
          # For backward compatibility.
          top         => 't',
          bottom      => 'b',
      };
  
      bless $self, $class;
      return $self;
  }
  
  
  ##############################################################################
  #
  # _write_chart_type()
  #
  # Override the virtual superclass method with a chart specific method.
  #
  sub _write_chart_type {
  
      my $self = shift;
  
      # Write the c:stockChart element.
      $self->_write_stock_chart( @_ );
  }
  
  
  ##############################################################################
  #
  # _write_stock_chart()
  #
  # Write the <c:stockChart> element.
  # Overridden to add hi_low_lines(). TODO. Refactor up into the SUPER class.
  #
  sub _write_stock_chart {
  
      my $self = shift;
      my %args = @_;
  
      my @series;
      if ( $args{primary_axes} ) {
          @series = $self->_get_primary_axes_series;
      }
      else {
          @series = $self->_get_secondary_axes_series;
      }
  
      return unless scalar @series;
  
      # Add default formatting to the series data.
      $self->_modify_series_formatting();
  
      $self->xml_start_tag( 'c:stockChart' );
  
      # Write the series elements.
      $self->_write_ser( $_ ) for @series;
  
      # Write the c:dropLines element.
      $self->_write_drop_lines();
  
      # Write the c:hiLowLines element.
      $self->_write_hi_low_lines() if $args{primary_axes};
  
      # Write the c:upDownBars element.
      $self->_write_up_down_bars();
  
      # Write the c:marker element.
      $self->_write_marker_value();
  
      # Write the c:axId elements
      $self->_write_axis_ids( %args );
  
      $self->xml_end_tag( 'c:stockChart' );
  }
  
  
  ##############################################################################
  #
  # _modify_series_formatting()
  #
  # Add default formatting to the series data.
  #
  sub _modify_series_formatting {
  
      my $self = shift;
  
      my $index = 0;
      for my $series ( @{ $self->{_series} } ) {
          if ( $index % 4 != 3 ) {
              if ( !$series->{_line}->{_defined} ) {
                  $series->{_line} = {
                      width    => 2.25,
                      none     => 1,
                      _defined => 1,
                  };
              }
  
              if ( !$series->{_marker} ) {
                  if ( $index % 4 == 2 ) {
                      $series->{_marker} = { type => 'dot', size => 3 };
                  }
                  else {
                      $series->{_marker} = { type => 'none' };
  
                  }
              }
          }
          $index++;
      }
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Stock - A class for writing Excel Stock charts.
  
  =head1 SYNOPSIS
  
  To create a simple Excel file with a Stock chart using Excel::Writer::XLSX:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'chart.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      my $chart = $workbook->add_chart( type => 'stock' );
  
      # Add a series for each High-Low-Close.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$B$2:$B$6'
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$C$2:$C$6'
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$D$2:$D$6'
      );
  
      # Add the worksheet data the chart refers to.
      # ... See the full example below.
  
      __END__
  
  
  =head1 DESCRIPTION
  
  This module implements Stock charts for L<Excel::Writer::XLSX>. The chart object is created via the Workbook C<add_chart()> method:
  
      my $chart = $workbook->add_chart( type => 'stock' );
  
  Once the object is created it can be configured via the following methods that are common to all chart classes:
  
      $chart->add_series();
      $chart->set_x_axis();
      $chart->set_y_axis();
      $chart->set_title();
  
  These methods are explained in detail in L<Excel::Writer::XLSX::Chart>. Class specific methods or settings, if any, are explained below.
  
  =head1 Stock Chart Methods
  
  There aren't currently any stock chart specific methods. See the TODO section of L<Excel::Writer::XLSX::Chart>.
  
  The default Stock chart is a High-Low-Close chart. A series must be added for each of these data sources.
  
  
  =head1 EXAMPLE
  
  Here is a complete example that demonstrates most of the available features when creating a Stock chart.
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      use Excel::Writer::XLSX;
  
      my $workbook    = Excel::Writer::XLSX->new( 'chart_stock.xlsx' );
      my $worksheet   = $workbook->add_worksheet();
      my $bold        = $workbook->add_format( bold => 1 );
      my $date_format = $workbook->add_format( num_format => 'dd/mm/yyyy' );
      my $chart       = $workbook->add_chart( type => 'stock', embedded => 1 );
  
  
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Date', 'High', 'Low', 'Close' ];
      my $data = [
  
          [ '2007-01-01T', '2007-01-02T', '2007-01-03T', '2007-01-04T', '2007-01-05T' ],
          [ 27.2,  25.03, 19.05, 20.34, 18.5 ],
          [ 23.49, 19.55, 15.12, 17.84, 16.34 ],
          [ 25.45, 23.05, 17.32, 20.45, 17.34 ],
  
      ];
  
      $worksheet->write( 'A1', $headings, $bold );
  
      for my $row ( 0 .. 4 ) {
          $worksheet->write_date_time( $row+1, 0, $data->[0]->[$row], $date_format );
          $worksheet->write( $row+1, 1, $data->[1]->[$row] );
          $worksheet->write( $row+1, 2, $data->[2]->[$row] );
          $worksheet->write( $row+1, 3, $data->[3]->[$row] );
  
      }
  
      $worksheet->set_column( 'A:D', 11 );
  
      # Add a series for each of the High-Low-Close columns.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$B$2:$B$6',
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$C$2:$C$6',
      );
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$D$2:$D$6',
      );
  
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'High-Low-Close', );
      $chart->set_x_axis( name => 'Date', );
      $chart->set_y_axis( name => 'Share price', );
  
  
      $worksheet->insert_chart( 'E9', $chart );
  
      __END__
  
  =begin html
  
  <p>This will produce a chart that looks like this:</p>
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/stock1.jpg" width="483" height="291" alt="Chart example." /></center></p>
  
  =end html
  
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_CHART_STOCK

$fatpacked{"Excel/Writer/XLSX/Chartsheet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_CHARTSHEET';
  package Excel::Writer::XLSX::Chartsheet;
  
  ###############################################################################
  #
  # Chartsheet - A class for writing the Excel XLSX Chartsheet files.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Exporter;
  use Excel::Writer::XLSX::Worksheet;
  
  our @ISA     = qw(Excel::Writer::XLSX::Worksheet);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Worksheet->new( @_ );
  
      $self->{_drawing}           = 1;
      $self->{_is_chartsheet}     = 1;
      $self->{_chart}             = undef;
      $self->{_charts}            = [1];
      $self->{_zoom_scale_normal} = 0;
      $self->{_orientation}       = 0;
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
  
      # Write the root chartsheet element.
      $self->_write_chartsheet();
  
      # Write the worksheet properties.
      $self->_write_sheet_pr();
  
      # Write the sheet view properties.
      $self->_write_sheet_views();
  
      # Write the sheetProtection element.
      $self->_write_sheet_protection();
  
      # Write the printOptions element.
      $self->_write_print_options();
  
      # Write the worksheet page_margins.
      $self->_write_page_margins();
  
      # Write the worksheet page setup.
      $self->_write_page_setup();
  
      # Write the headerFooter element.
      $self->_write_header_footer();
  
      # Write the drawing element.
      $self->_write_drawings();
  
      # Close the worksheet tag.
      $self->xml_end_tag( 'chartsheet' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # Public methods.
  #
  ###############################################################################
  
  # Over-ride parent protect() method to protect both worksheet and chart.
  sub protect {
  
      my $self     = shift;
      my $password = shift || '';
      my $options  = shift || {};
  
      $self->{_chart}->{_protection} = 1;
  
      $options->{sheet}     = 0;
      $options->{content}   = 1;
      $options->{scenarios} = 1;
  
      $self->SUPER::protect( $password, $options );
  }
  
  
  ###############################################################################
  #
  # Encapsulated Chart methods.
  #
  ###############################################################################
  
  sub add_series         { return shift->{_chart}->add_series( @_ ) }
  sub combine            { return shift->{_chart}->combine( @_ ) }
  sub set_x_axis         { return shift->{_chart}->set_x_axis( @_ ) }
  sub set_y_axis         { return shift->{_chart}->set_y_axis( @_ ) }
  sub set_x2_axis        { return shift->{_chart}->set_x2_axis( @_ ) }
  sub set_y2_axis        { return shift->{_chart}->set_y2_axis( @_ ) }
  sub set_title          { return shift->{_chart}->set_title( @_ ) }
  sub set_legend         { return shift->{_chart}->set_legend( @_ ) }
  sub set_plotarea       { return shift->{_chart}->set_plotarea( @_ ) }
  sub set_chartarea      { return shift->{_chart}->set_chartarea( @_ ) }
  sub set_style          { return shift->{_chart}->set_style( @_ ) }
  sub show_blanks_as     { return shift->{_chart}->show_blanks_as( @_ ) }
  sub show_hidden_data   { return shift->{_chart}->show_hidden_data( @_ ) }
  sub set_size           { return shift->{_chart}->set_size( @_ ) }
  sub set_table          { return shift->{_chart}->set_table( @_ ) }
  sub set_up_down_bars   { return shift->{_chart}->set_up_down_bars( @_ ) }
  sub set_drop_lines     { return shift->{_chart}->set_drop_lines( @_ ) }
  sub set_high_low_lines { return shift->{_chart}->high_low_lines( @_ ) }
  
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _prepare_chart()
  #
  # Set up chart/drawings.
  #
  sub _prepare_chart {
  
      my $self       = shift;
      my $index      = shift;
      my $chart_id   = shift;
      my $drawing_id = shift;
  
      $self->{_chart}->{_id} = $chart_id -1;
  
      my $drawing = Excel::Writer::XLSX::Drawing->new();
      $self->{_drawing} = $drawing;
      $self->{_drawing}->{_orientation} = $self->{_orientation};
  
      push @{ $self->{_external_drawing_links} },
        [ '/drawing', '../drawings/drawing' . $drawing_id . '.xml' ];
  
      push @{ $self->{_drawing_links} },
        [ '/chart', '../charts/chart' . $chart_id . '.xml' ];
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_chartsheet()
  #
  # Write the <chartsheet> element. This is the root element of Chartsheet.
  #
  sub _write_chartsheet {
  
      my $self                   = shift;
      my $schema                 = 'http://schemas.openxmlformats.org/';
      my $xmlns                  = $schema . 'spreadsheetml/2006/main';
      my $xmlns_r                = $schema . 'officeDocument/2006/relationships';
      my $xmlns_mc               = $schema . 'markup-compatibility/2006';
      my $xmlns_mv               = 'urn:schemas-microsoft-com:mac:vml';
      my $mc_ignorable           = 'mv';
      my $mc_preserve_attributes = 'mv:*';
  
      my @attributes = (
          'xmlns'   => $xmlns,
          'xmlns:r' => $xmlns_r,
      );
  
      $self->xml_start_tag( 'chartsheet', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_sheet_pr()
  #
  # Write the <sheetPr> element for Sheet level properties.
  #
  sub _write_sheet_pr {
  
      my $self       = shift;
      my @attributes = ();
  
  
      push @attributes, ( 'filterMode' => 1 ) if $self->{_filter_on};
  
      if ( $self->{_fit_page} || $self->{_tab_color} ) {
          $self->xml_start_tag( 'sheetPr', @attributes );
          $self->_write_tab_color();
          $self->_write_page_set_up_pr();
          $self->xml_end_tag( 'sheetPr' );
      }
      else {
          $self->xml_empty_tag( 'sheetPr', @attributes );
      }
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Chartsheet - A class for writing the Excel XLSX Chartsheet files.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_CHARTSHEET

$fatpacked{"Excel/Writer/XLSX/Drawing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_DRAWING';
  package Excel::Writer::XLSX::Drawing;
  
  ###############################################################################
  #
  # Drawing - A class for writing the Excel XLSX drawing.xml file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  use Excel::Writer::XLSX::Worksheet;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_drawings}    = [];
      $self->{_embedded}    = 0;
      $self->{_orientation} = 0;
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
  
      # Write the xdr:wsDr element.
      $self->_write_drawing_workspace();
  
      if ( $self->{_embedded} ) {
  
          my $index = 0;
          for my $dimensions ( @{ $self->{_drawings} } ) {
  
              # Write the xdr:twoCellAnchor element.
              $self->_write_two_cell_anchor( ++$index, @$dimensions );
          }
  
      }
      else {
          my $index = 0;
  
          # Write the xdr:absoluteAnchor element.
          $self->_write_absolute_anchor( ++$index );
      }
  
      $self->xml_end_tag( 'xdr:wsDr' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _add_drawing_object()
  #
  # Add a chart, image or shape sub object to the drawing.
  #
  sub _add_drawing_object {
  
      my $self = shift;
  
      push @{ $self->{_drawings} }, [@_];
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_drawing_workspace()
  #
  # Write the <xdr:wsDr> element.
  #
  sub _write_drawing_workspace {
  
      my $self      = shift;
      my $schema    = 'http://schemas.openxmlformats.org/drawingml/';
      my $xmlns_xdr = $schema . '2006/spreadsheetDrawing';
      my $xmlns_a   = $schema . '2006/main';
  
      my @attributes = (
          'xmlns:xdr' => $xmlns_xdr,
          'xmlns:a'   => $xmlns_a,
      );
  
      $self->xml_start_tag( 'xdr:wsDr', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_two_cell_anchor()
  #
  # Write the <xdr:twoCellAnchor> element.
  #
  sub _write_two_cell_anchor {
  
      my $self            = shift;
      my $index           = shift;
      my $type            = shift;
      my $col_from        = shift;
      my $row_from        = shift;
      my $col_from_offset = shift;
      my $row_from_offset = shift;
      my $col_to          = shift;
      my $row_to          = shift;
      my $col_to_offset   = shift;
      my $row_to_offset   = shift;
      my $col_absolute    = shift;
      my $row_absolute    = shift;
      my $width           = shift;
      my $height          = shift;
      my $description     = shift;
      my $shape           = shift;
  
      my @attributes = ();
  
  
      # Add attribute for images.
      if ( $type == 2 ) {
          push @attributes, ( editAs => 'oneCell' );
      }
  
      # Add editAs attribute for shapes.
      push @attributes, ( editAs => $shape->{_editAs} ) if $shape->{_editAs};
  
      $self->xml_start_tag( 'xdr:twoCellAnchor', @attributes );
  
      # Write the xdr:from element.
      $self->_write_from(
          $col_from,
          $row_from,
          $col_from_offset,
          $row_from_offset,
  
      );
  
      # Write the xdr:from element.
      $self->_write_to(
          $col_to,
          $row_to,
          $col_to_offset,
          $row_to_offset,
  
      );
  
      if ( $type == 1 ) {
  
          # Graphic frame.
  
          # Write the xdr:graphicFrame element for charts.
          $self->_write_graphic_frame( $index, $description );
      }
      elsif ( $type == 2 ) {
  
          # Write the xdr:pic element.
          $self->_write_pic( $index, $col_absolute, $row_absolute, $width,
              $height, $description );
      }
      else {
  
          # Write the xdr:sp element for shapes.
          $self->_write_sp( $index, $col_absolute, $row_absolute, $width, $height,
              $shape );
      }
  
      # Write the xdr:clientData element.
      $self->_write_client_data();
  
      $self->xml_end_tag( 'xdr:twoCellAnchor' );
  }
  
  
  ##############################################################################
  #
  # _write_absolute_anchor()
  #
  # Write the <xdr:absoluteAnchor> element.
  #
  sub _write_absolute_anchor {
  
      my $self  = shift;
      my $index = shift;
  
      $self->xml_start_tag( 'xdr:absoluteAnchor' );
  
      # Different co-ordinates for horizonatal (= 0) and vertical (= 1).
      if ( $self->{_orientation} == 0 ) {
  
          # Write the xdr:pos element.
          $self->_write_pos( 0, 0 );
  
          # Write the xdr:ext element.
          $self->_write_ext( 9308969, 6078325 );
  
      }
      else {
  
          # Write the xdr:pos element.
          $self->_write_pos( 0, -47625 );
  
          # Write the xdr:ext element.
          $self->_write_ext( 6162675, 6124575 );
  
      }
  
  
      # Write the xdr:graphicFrame element.
      $self->_write_graphic_frame( $index );
  
      # Write the xdr:clientData element.
      $self->_write_client_data();
  
      $self->xml_end_tag( 'xdr:absoluteAnchor' );
  }
  
  
  ##############################################################################
  #
  # _write_from()
  #
  # Write the <xdr:from> element.
  #
  sub _write_from {
  
      my $self       = shift;
      my $col        = shift;
      my $row        = shift;
      my $col_offset = shift;
      my $row_offset = shift;
  
      $self->xml_start_tag( 'xdr:from' );
  
      # Write the xdr:col element.
      $self->_write_col( $col );
  
      # Write the xdr:colOff element.
      $self->_write_col_off( $col_offset );
  
      # Write the xdr:row element.
      $self->_write_row( $row );
  
      # Write the xdr:rowOff element.
      $self->_write_row_off( $row_offset );
  
      $self->xml_end_tag( 'xdr:from' );
  }
  
  
  ##############################################################################
  #
  # _write_to()
  #
  # Write the <xdr:to> element.
  #
  sub _write_to {
  
      my $self       = shift;
      my $col        = shift;
      my $row        = shift;
      my $col_offset = shift;
      my $row_offset = shift;
  
      $self->xml_start_tag( 'xdr:to' );
  
      # Write the xdr:col element.
      $self->_write_col( $col );
  
      # Write the xdr:colOff element.
      $self->_write_col_off( $col_offset );
  
      # Write the xdr:row element.
      $self->_write_row( $row );
  
      # Write the xdr:rowOff element.
      $self->_write_row_off( $row_offset );
  
      $self->xml_end_tag( 'xdr:to' );
  }
  
  
  ##############################################################################
  #
  # _write_col()
  #
  # Write the <xdr:col> element.
  #
  sub _write_col {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'xdr:col', $data );
  }
  
  
  ##############################################################################
  #
  # _write_col_off()
  #
  # Write the <xdr:colOff> element.
  #
  sub _write_col_off {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'xdr:colOff', $data );
  }
  
  
  ##############################################################################
  #
  # _write_row()
  #
  # Write the <xdr:row> element.
  #
  sub _write_row {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'xdr:row', $data );
  }
  
  
  ##############################################################################
  #
  # _write_row_off()
  #
  # Write the <xdr:rowOff> element.
  #
  sub _write_row_off {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'xdr:rowOff', $data );
  }
  
  
  ##############################################################################
  #
  # _write_pos()
  #
  # Write the <xdr:pos> element.
  #
  sub _write_pos {
  
      my $self = shift;
      my $x    = shift;
      my $y    = shift;
  
      my @attributes = (
          'x' => $x,
          'y' => $y,
      );
  
      $self->xml_empty_tag( 'xdr:pos', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_ext()
  #
  # Write the <xdr:ext> element.
  #
  sub _write_ext {
  
      my $self = shift;
      my $cx   = shift;
      my $cy   = shift;
  
      my @attributes = (
          'cx' => $cx,
          'cy' => $cy,
      );
  
      $self->xml_empty_tag( 'xdr:ext', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_graphic_frame()
  #
  # Write the <xdr:graphicFrame> element.
  #
  sub _write_graphic_frame {
  
      my $self  = shift;
      my $index = shift;
      my $name  = shift;
      my $macro = '';
  
      my @attributes = ( 'macro' => $macro );
  
      $self->xml_start_tag( 'xdr:graphicFrame', @attributes );
  
      # Write the xdr:nvGraphicFramePr element.
      $self->_write_nv_graphic_frame_pr( $index, $name );
  
      # Write the xdr:xfrm element.
      $self->_write_xfrm();
  
      # Write the a:graphic element.
      $self->_write_atag_graphic( $index );
  
      $self->xml_end_tag( 'xdr:graphicFrame' );
  }
  
  
  ##############################################################################
  #
  # _write_nv_graphic_frame_pr()
  #
  # Write the <xdr:nvGraphicFramePr> element.
  #
  sub _write_nv_graphic_frame_pr {
  
      my $self  = shift;
      my $index = shift;
      my $name  = shift;
  
      if ( !$name ) {
          $name = 'Chart ' . $index;
      }
  
      $self->xml_start_tag( 'xdr:nvGraphicFramePr' );
  
      # Write the xdr:cNvPr element.
      $self->_write_c_nv_pr( $index + 1, $name );
  
      # Write the xdr:cNvGraphicFramePr element.
      $self->_write_c_nv_graphic_frame_pr();
  
      $self->xml_end_tag( 'xdr:nvGraphicFramePr' );
  }
  
  
  ##############################################################################
  #
  # _write_c_nv_pr()
  #
  # Write the <xdr:cNvPr> element.
  #
  sub _write_c_nv_pr {
  
      my $self  = shift;
      my $id    = shift;
      my $name  = shift;
      my $descr = shift;
  
      my @attributes = (
          'id'   => $id,
          'name' => $name,
      );
  
      # Add description attribute for images.
      if ( defined $descr ) {
          push @attributes, ( descr => $descr );
      }
  
      $self->xml_empty_tag( 'xdr:cNvPr', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_c_nv_graphic_frame_pr()
  #
  # Write the <xdr:cNvGraphicFramePr> element.
  #
  sub _write_c_nv_graphic_frame_pr {
  
      my $self = shift;
  
      if ( $self->{_embedded} ) {
          $self->xml_empty_tag( 'xdr:cNvGraphicFramePr' );
      }
      else {
          $self->xml_start_tag( 'xdr:cNvGraphicFramePr' );
  
          # Write the a:graphicFrameLocks element.
          $self->_write_a_graphic_frame_locks();
  
          $self->xml_end_tag( 'xdr:cNvGraphicFramePr' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_a_graphic_frame_locks()
  #
  # Write the <a:graphicFrameLocks> element.
  #
  sub _write_a_graphic_frame_locks {
  
      my $self   = shift;
      my $no_grp = 1;
  
      my @attributes = ( 'noGrp' => $no_grp );
  
      $self->xml_empty_tag( 'a:graphicFrameLocks', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_xfrm()
  #
  # Write the <xdr:xfrm> element.
  #
  sub _write_xfrm {
  
      my $self = shift;
  
      $self->xml_start_tag( 'xdr:xfrm' );
  
      # Write the xfrmOffset element.
      $self->_write_xfrm_offset();
  
      # Write the xfrmOffset element.
      $self->_write_xfrm_extension();
  
      $self->xml_end_tag( 'xdr:xfrm' );
  }
  
  
  ##############################################################################
  #
  # _write_xfrm_offset()
  #
  # Write the <a:off> xfrm sub-element.
  #
  sub _write_xfrm_offset {
  
      my $self = shift;
      my $x    = 0;
      my $y    = 0;
  
      my @attributes = (
          'x' => $x,
          'y' => $y,
      );
  
      $self->xml_empty_tag( 'a:off', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_xfrm_extension()
  #
  # Write the <a:ext> xfrm sub-element.
  #
  sub _write_xfrm_extension {
  
      my $self = shift;
      my $x    = 0;
      my $y    = 0;
  
      my @attributes = (
          'cx' => $x,
          'cy' => $y,
      );
  
      $self->xml_empty_tag( 'a:ext', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_atag_graphic()
  #
  # Write the <a:graphic> element.
  #
  sub _write_atag_graphic {
  
      my $self  = shift;
      my $index = shift;
  
      $self->xml_start_tag( 'a:graphic' );
  
      # Write the a:graphicData element.
      $self->_write_atag_graphic_data( $index );
  
      $self->xml_end_tag( 'a:graphic' );
  }
  
  
  ##############################################################################
  #
  # _write_atag_graphic_data()
  #
  # Write the <a:graphicData> element.
  #
  sub _write_atag_graphic_data {
  
      my $self  = shift;
      my $index = shift;
      my $uri   = 'http://schemas.openxmlformats.org/drawingml/2006/chart';
  
      my @attributes = ( 'uri' => $uri, );
  
      $self->xml_start_tag( 'a:graphicData', @attributes );
  
      # Write the c:chart element.
      $self->_write_c_chart( 'rId' . $index );
  
      $self->xml_end_tag( 'a:graphicData' );
  }
  
  
  ##############################################################################
  #
  # _write_c_chart()
  #
  # Write the <c:chart> element.
  #
  sub _write_c_chart {
  
      my $self    = shift;
      my $r_id    = shift;
      my $schema  = 'http://schemas.openxmlformats.org/';
      my $xmlns_c = $schema . 'drawingml/2006/chart';
      my $xmlns_r = $schema . 'officeDocument/2006/relationships';
  
  
      my @attributes = (
          'xmlns:c' => $xmlns_c,
          'xmlns:r' => $xmlns_r,
          'r:id'    => $r_id,
      );
  
      $self->xml_empty_tag( 'c:chart', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_client_data()
  #
  # Write the <xdr:clientData> element.
  #
  sub _write_client_data {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'xdr:clientData' );
  }
  
  
  ##############################################################################
  #
  # _write_sp()
  #
  # Write the <xdr:sp> element.
  #
  sub _write_sp {
  
      my $self         = shift;
      my $index        = shift;
      my $col_absolute = shift;
      my $row_absolute = shift;
      my $width        = shift;
      my $height       = shift;
      my $shape        = shift;
  
      if ( $shape->{_connect} ) {
          my @attributes = ( macro => '' );
          $self->xml_start_tag( 'xdr:cxnSp', @attributes );
  
          # Write the xdr:nvCxnSpPr element.
          $self->_write_nv_cxn_sp_pr( $index, $shape );
  
          # Write the xdr:spPr element.
          $self->_write_xdr_sp_pr( $index, $col_absolute, $row_absolute, $width,
              $height, $shape );
  
          $self->xml_end_tag( 'xdr:cxnSp' );
      }
      else {
  
          # Add attribute for shapes.
          my @attributes = ( macro => '', textlink => '' );
          $self->xml_start_tag( 'xdr:sp', @attributes );
  
          # Write the xdr:nvSpPr element.
          $self->_write_nv_sp_pr( $index, $shape );
  
          # Write the xdr:spPr element.
          $self->_write_xdr_sp_pr( $index, $col_absolute, $row_absolute, $width,
              $height, $shape );
  
          # Write the xdr:txBody element.
          if ( $shape->{_text} ) {
              $self->_write_txBody( $col_absolute, $row_absolute, $width, $height,
                  $shape );
          }
  
          $self->xml_end_tag( 'xdr:sp' );
      }
  }
  ##############################################################################
  #
  # _write_nv_cxn_sp_pr()
  #
  # Write the <xdr:nvCxnSpPr> element.
  #
  sub _write_nv_cxn_sp_pr {
  
      my $self  = shift;
      my $index = shift;
      my $shape = shift;
  
      $self->xml_start_tag( 'xdr:nvCxnSpPr' );
  
      $shape->{_name} = join( ' ', $shape->{_type}, $index )
        unless defined $shape->{_name};
      $self->_write_c_nv_pr( $shape->{_id}, $shape->{_name} );
  
      $self->xml_start_tag( 'xdr:cNvCxnSpPr' );
  
      my @attributes = ( noChangeShapeType => '1' );
      $self->xml_empty_tag( 'a:cxnSpLocks', @attributes );
  
      if ( $shape->{_start} ) {
          @attributes =
            ( 'id' => $shape->{_start}, 'idx' => $shape->{_start_index} );
          $self->xml_empty_tag( 'a:stCxn', @attributes );
      }
  
      if ( $shape->{_end} ) {
          @attributes = ( 'id' => $shape->{_end}, 'idx' => $shape->{_end_index} );
          $self->xml_empty_tag( 'a:endCxn', @attributes );
      }
      $self->xml_end_tag( 'xdr:cNvCxnSpPr' );
      $self->xml_end_tag( 'xdr:nvCxnSpPr' );
  }
  
  
  ##############################################################################
  #
  # _write_nv_sp_pr()
  #
  # Write the <xdr:NvSpPr> element.
  #
  sub _write_nv_sp_pr {
  
      my $self  = shift;
      my $index = shift;
      my $shape = shift;
  
      my @attributes = ();
  
      $self->xml_start_tag( 'xdr:nvSpPr' );
  
      my $shape_name = $shape->{_type} . ' ' . $index;
  
      $self->_write_c_nv_pr( $shape->{_id}, $shape_name );
  
      @attributes = ( 'txBox' => 1 ) if $shape->{_txBox};
  
      $self->xml_start_tag( 'xdr:cNvSpPr', @attributes );
  
      @attributes = ( noChangeArrowheads => '1' );
  
      $self->xml_empty_tag( 'a:spLocks', @attributes );
  
      $self->xml_end_tag( 'xdr:cNvSpPr' );
      $self->xml_end_tag( 'xdr:nvSpPr' );
  }
  
  
  ##############################################################################
  #
  # _write_pic()
  #
  # Write the <xdr:pic> element.
  #
  sub _write_pic {
  
      my $self         = shift;
      my $index        = shift;
      my $col_absolute = shift;
      my $row_absolute = shift;
      my $width        = shift;
      my $height       = shift;
      my $description  = shift;
  
      $self->xml_start_tag( 'xdr:pic' );
  
      # Write the xdr:nvPicPr element.
      $self->_write_nv_pic_pr( $index, $description );
  
      # Write the xdr:blipFill element.
      $self->_write_blip_fill( $index );
  
      # Pictures are rectangle shapes by default.
      my $shape = { _type => 'rect' };
  
      # Write the xdr:spPr element.
      $self->_write_sp_pr( $col_absolute, $row_absolute, $width, $height,
          $shape );
  
      $self->xml_end_tag( 'xdr:pic' );
  }
  
  
  ##############################################################################
  #
  # _write_nv_pic_pr()
  #
  # Write the <xdr:nvPicPr> element.
  #
  sub _write_nv_pic_pr {
  
      my $self        = shift;
      my $index       = shift;
      my $description = shift;
  
      $self->xml_start_tag( 'xdr:nvPicPr' );
  
      # Write the xdr:cNvPr element.
      $self->_write_c_nv_pr( $index + 1, 'Picture ' . $index, $description );
  
      # Write the xdr:cNvPicPr element.
      $self->_write_c_nv_pic_pr();
  
      $self->xml_end_tag( 'xdr:nvPicPr' );
  }
  
  
  ##############################################################################
  #
  # _write_c_nv_pic_pr()
  #
  # Write the <xdr:cNvPicPr> element.
  #
  sub _write_c_nv_pic_pr {
  
      my $self = shift;
  
      $self->xml_start_tag( 'xdr:cNvPicPr' );
  
      # Write the a:picLocks element.
      $self->_write_a_pic_locks();
  
      $self->xml_end_tag( 'xdr:cNvPicPr' );
  }
  
  
  ##############################################################################
  #
  # _write_a_pic_locks()
  #
  # Write the <a:picLocks> element.
  #
  sub _write_a_pic_locks {
  
      my $self             = shift;
      my $no_change_aspect = 1;
  
      my @attributes = ( 'noChangeAspect' => $no_change_aspect );
  
      $self->xml_empty_tag( 'a:picLocks', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_blip_fill()
  #
  # Write the <xdr:blipFill> element.
  #
  sub _write_blip_fill {
  
      my $self  = shift;
      my $index = shift;
  
      $self->xml_start_tag( 'xdr:blipFill' );
  
      # Write the a:blip element.
      $self->_write_a_blip( $index );
  
      # Write the a:stretch element.
      $self->_write_a_stretch();
  
      $self->xml_end_tag( 'xdr:blipFill' );
  }
  
  
  ##############################################################################
  #
  # _write_a_blip()
  #
  # Write the <a:blip> element.
  #
  sub _write_a_blip {
  
      my $self    = shift;
      my $index   = shift;
      my $schema  = 'http://schemas.openxmlformats.org/officeDocument/';
      my $xmlns_r = $schema . '2006/relationships';
      my $r_embed = 'rId' . $index;
  
      my @attributes = (
          'xmlns:r' => $xmlns_r,
          'r:embed' => $r_embed,
      );
  
      $self->xml_empty_tag( 'a:blip', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_stretch()
  #
  # Write the <a:stretch> element.
  #
  sub _write_a_stretch {
  
      my $self = shift;
  
      $self->xml_start_tag( 'a:stretch' );
  
      # Write the a:fillRect element.
      $self->_write_a_fill_rect();
  
      $self->xml_end_tag( 'a:stretch' );
  }
  
  
  ##############################################################################
  #
  # _write_a_fill_rect()
  #
  # Write the <a:fillRect> element.
  #
  sub _write_a_fill_rect {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'a:fillRect' );
  }
  
  
  ##############################################################################
  #
  # _write_sp_pr()
  #
  # Write the <xdr:spPr> element, for charts.
  #
  sub _write_sp_pr {
  
      my $self         = shift;
      my $col_absolute = shift;
      my $row_absolute = shift;
      my $width        = shift;
      my $height       = shift;
      my $shape        = shift || {};
  
      $self->xml_start_tag( 'xdr:spPr' );
  
      # Write the a:xfrm element.
      $self->_write_a_xfrm( $col_absolute, $row_absolute, $width, $height );
  
      # Write the a:prstGeom element.
      $self->_write_a_prst_geom( $shape );
  
      $self->xml_end_tag( 'xdr:spPr' );
  }
  
  
  ##############################################################################
  #
  # _write_xdr_sp_pr()
  #
  # Write the <xdr:spPr> element for shapes.
  #
  sub _write_xdr_sp_pr {
  
      my $self         = shift;
      my $index        = shift;
      my $col_absolute = shift;
      my $row_absolute = shift;
      my $width        = shift;
      my $height       = shift;
      my $shape        = shift;
  
      my @attributes = ( 'bwMode' => 'auto' );
  
      $self->xml_start_tag( 'xdr:spPr', @attributes );
  
      # Write the a:xfrm element.
      $self->_write_a_xfrm( $col_absolute, $row_absolute, $width, $height,
          $shape );
  
      # Write the a:prstGeom element.
      $self->_write_a_prst_geom( $shape );
  
      my $fill = $shape->{_fill};
  
      if ( length $fill > 1 ) {
  
          # Write the a:solidFill element.
          $self->_write_a_solid_fill( $fill );
      }
      else {
          $self->xml_empty_tag( 'a:noFill' );
      }
  
      # Write the a:ln element.
      $self->_write_a_ln( $shape );
  
      $self->xml_end_tag( 'xdr:spPr' );
  }
  
  ##############################################################################
  #
  # _write_a_xfrm()
  #
  # Write the <a:xfrm> element.
  #
  sub _write_a_xfrm {
  
      my $self         = shift;
      my $col_absolute = shift;
      my $row_absolute = shift;
      my $width        = shift;
      my $height       = shift;
      my $shape        = shift || {};
      my @attributes   = ();
  
      my $rotation = $shape->{_rotation} || 0;
      $rotation *= 60000;
  
      push( @attributes, ( 'rot'   => $rotation ) ) if $rotation;
      push( @attributes, ( 'flipH' => 1 ) )         if $shape->{_flip_h};
      push( @attributes, ( 'flipV' => 1 ) )         if $shape->{_flip_v};
  
      $self->xml_start_tag( 'a:xfrm', @attributes );
  
      # Write the a:off element.
      $self->_write_a_off( $col_absolute, $row_absolute );
  
      # Write the a:ext element.
      $self->_write_a_ext( $width, $height );
  
      $self->xml_end_tag( 'a:xfrm' );
  }
  
  
  ##############################################################################
  #
  # _write_a_off()
  #
  # Write the <a:off> element.
  #
  sub _write_a_off {
  
      my $self = shift;
      my $x    = shift;
      my $y    = shift;
  
      my @attributes = (
          'x' => $x,
          'y' => $y,
      );
  
      $self->xml_empty_tag( 'a:off', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_ext()
  #
  # Write the <a:ext> element.
  #
  sub _write_a_ext {
  
      my $self = shift;
      my $cx   = shift;
      my $cy   = shift;
  
      my @attributes = (
          'cx' => $cx,
          'cy' => $cy,
      );
  
      $self->xml_empty_tag( 'a:ext', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_a_prst_geom()
  #
  # Write the <a:prstGeom> element.
  #
  sub _write_a_prst_geom {
  
      my $self = shift;
      my $shape = shift || {};
  
      my @attributes = ();
  
      @attributes = ( 'prst' => $shape->{_type} ) if $shape->{_type};
  
      $self->xml_start_tag( 'a:prstGeom', @attributes );
  
      # Write the a:avLst element.
      $self->_write_a_av_lst( $shape );
  
      $self->xml_end_tag( 'a:prstGeom' );
  }
  
  
  ##############################################################################
  #
  # _write_a_av_lst()
  #
  # Write the <a:avLst> element.
  #
  sub _write_a_av_lst {
  
      my $self        = shift;
      my $shape       = shift || {};
      my $adjustments = [];
  
      if ( defined $shape->{_adjustments} ) {
          $adjustments = $shape->{_adjustments};
      }
  
      if ( @$adjustments ) {
          $self->xml_start_tag( 'a:avLst' );
  
          my $i = 0;
          foreach my $adj ( @{$adjustments} ) {
              $i++;
  
              # Only connectors have multiple adjustments.
              my $suffix = $shape->{_connect} ? $i : '';
  
              # Scale Adjustments: 100,000 = 100%.
              my $adj_int = int( $adj * 1000 );
  
              my @attributes =
                ( name => 'adj' . $suffix, fmla => "val $adj_int" );
  
              $self->xml_empty_tag( 'a:gd', @attributes );
          }
          $self->xml_end_tag( 'a:avLst' );
      }
      else {
          $self->xml_empty_tag( 'a:avLst' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_a_solid_fill()
  #
  # Write the <a:solidFill> element.
  #
  sub _write_a_solid_fill {
  
      my $self = shift;
      my $rgb  = shift;
  
      $rgb = '000000' unless defined $rgb;
  
      my @attributes = ( 'val' => $rgb );
  
      $self->xml_start_tag( 'a:solidFill' );
  
      $self->xml_empty_tag( 'a:srgbClr', @attributes );
  
      $self->xml_end_tag( 'a:solidFill' );
  }
  
  
  ##############################################################################
  #
  # _write_a_ln()
  #
  # Write the <a:ln> element.
  #
  sub _write_a_ln {
  
      my $self = shift;
      my $shape = shift || {};
  
      my $weight = $shape->{_line_weight};
  
      my @attributes = ( 'w' => $weight * 9525 );
  
      $self->xml_start_tag( 'a:ln', @attributes );
  
      my $line = $shape->{_line};
  
      if ( length $line > 1 ) {
  
          # Write the a:solidFill element.
          $self->_write_a_solid_fill( $line );
      }
      else {
          $self->xml_empty_tag( 'a:noFill' );
      }
  
      if ( $shape->{_line_type} ) {
  
          @attributes = ( 'val' => $shape->{_line_type} );
          $self->xml_empty_tag( 'a:prstDash', @attributes );
      }
  
      if ( $shape->{_connect} ) {
          $self->xml_empty_tag( 'a:round' );
      }
      else {
          @attributes = ( 'lim' => 800000 );
          $self->xml_empty_tag( 'a:miter', @attributes );
      }
  
      $self->xml_empty_tag( 'a:headEnd' );
      $self->xml_empty_tag( 'a:tailEnd' );
  
      $self->xml_end_tag( 'a:ln' );
  }
  
  
  ##############################################################################
  #
  # _write_txBody
  #
  # Write the <xdr:txBody> element.
  #
  sub _write_txBody {
  
      my $self         = shift;
      my $col_absolute = shift;
      my $row_absolute = shift;
      my $width        = shift;
      my $height       = shift;
      my $shape        = shift;
  
      my @attributes = (
          vertOverflow => "clip",
          wrap         => "square",
          lIns         => "27432",
          tIns         => "22860",
          rIns         => "27432",
          bIns         => "22860",
          anchor       => $shape->{_valign},
          upright      => "1",
      );
  
      $self->xml_start_tag( 'xdr:txBody' );
      $self->xml_empty_tag( 'a:bodyPr', @attributes );
      $self->xml_empty_tag( 'a:lstStyle' );
  
      $self->xml_start_tag( 'a:p' );
  
      my $rotation = $shape->{_format}->{_rotation};
      $rotation = 0 unless defined $rotation;
      $rotation *= 60000;
  
      @attributes = ( algn => $shape->{_align}, rtl => $rotation );
      $self->xml_start_tag( 'a:pPr', @attributes );
  
      @attributes = ( sz => "1000" );
      $self->xml_empty_tag( 'a:defRPr', @attributes );
  
      $self->xml_end_tag( 'a:pPr' );
      $self->xml_start_tag( 'a:r' );
  
      my $size = $shape->{_format}->{_size};
      $size = 8 unless defined $size;
      $size *= 100;
  
      my $bold = $shape->{_format}->{_bold};
      $bold = 0 unless defined $bold;
  
      my $italic = $shape->{_format}->{_italic};
      $italic = 0 unless defined $italic;
  
      my $underline = $shape->{_format}->{_underline};
      $underline = $underline ? 'sng' : 'none';
  
      my $strike = $shape->{_format}->{_font_strikeout};
      $strike = $strike ? 'Strike' : 'noStrike';
  
      @attributes = (
          lang     => "en-US",
          sz       => $size,
          b        => $bold,
          i        => $italic,
          u        => $underline,
          strike   => $strike,
          baseline => 0,
      );
  
      $self->xml_start_tag( 'a:rPr', @attributes );
  
      my $color = $shape->{_format}->{_color};
      if ( defined $color ) {
          $color = $shape->_get_palette_color( $color );
          $color =~ s/^FF//;    # Remove leading FF from rgb for shape color.
      }
      else {
          $color = '000000';
      }
  
      $self->_write_a_solid_fill( $color );
  
      my $font = $shape->{_format}->{_font};
      $font = 'Calibri' unless defined $font;
      @attributes = ( typeface => $font );
      $self->xml_empty_tag( 'a:latin', @attributes );
  
      $self->xml_empty_tag( 'a:cs', @attributes );
  
      $self->xml_end_tag( 'a:rPr' );
  
      $self->xml_data_element( 'a:t', $shape->{_text} );
  
      $self->xml_end_tag( 'a:r' );
      $self->xml_end_tag( 'a:p' );
      $self->xml_end_tag( 'xdr:txBody' );
  
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  Drawing - A class for writing the Excel XLSX drawing.xml file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_DRAWING

$fatpacked{"Excel/Writer/XLSX/Examples.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_EXAMPLES';
  package Excel::Writer::XLSX::Examples;
  
  ###############################################################################
  #
  # Examples - Excel::Writer::XLSX examples.
  #
  # A documentation only module showing the examples that are
  # included in the Excel::Writer::XLSX distribution. This
  # file was generated automatically via the gen_examples_pod.pl
  # program that is also included in the examples directory.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.89';
  
  1;
  
  __END__
  
  =pod
  
  =encoding ISO8859-1
  
  =head1 NAME
  
  Examples - Excel::Writer::XLSX example programs.
  
  =head1 DESCRIPTION
  
  This is a documentation only module showing the examples that are
  included in the L<Excel::Writer::XLSX> distribution.
  
  This file was auto-generated via the gen_examples_pod.pl
  program that is also included in the examples directory.
  
  =head1 Example programs
  
  The following is a list of the 87 example programs that are included in the Excel::Writer::XLSX distribution.
  
  =over
  
  =item * L<Example: a_simple.pl> A simple demo of some of the features.
  
  =item * L<Example: bug_report.pl> A template for submitting bug reports.
  
  =item * L<Example: demo.pl> A demo of some of the available features.
  
  =item * L<Example: formats.pl> All the available formatting on several worksheets.
  
  =item * L<Example: regions.pl> A simple example of multiple worksheets.
  
  =item * L<Example: stats.pl> Basic formulas and functions.
  
  =item * L<Example: autofilter.pl> Examples of worksheet autofilters.
  
  =item * L<Example: array_formula.pl> Examples of how to write array formulas.
  
  =item * L<Example: cgi.pl> A simple CGI program.
  
  =item * L<Example: chart_area.pl> A demo of area style charts.
  
  =item * L<Example: chart_bar.pl> A demo of bar (vertical histogram) style charts.
  
  =item * L<Example: chart_column.pl> A demo of column (histogram) style charts.
  
  =item * L<Example: chart_line.pl> A demo of line style charts.
  
  =item * L<Example: chart_pie.pl> A demo of pie style charts.
  
  =item * L<Example: chart_doughnut.pl> A demo of dougnut style charts.
  
  =item * L<Example: chart_radar.pl> A demo of radar style charts.
  
  =item * L<Example: chart_scatter.pl> A demo of scatter style charts.
  
  =item * L<Example: chart_secondary_axis.pl> A demo of a line chart with a secondary axis.
  
  =item * L<Example: chart_combined.pl> A demo of a combined column and line chart.
  
  =item * L<Example: chart_pareto.pl> A demo of a combined Pareto chart.
  
  =item * L<Example: chart_stock.pl> A demo of stock style charts.
  
  =item * L<Example: chart_data_table.pl> A demo of a chart with a data table on the axis.
  
  =item * L<Example: chart_data_tools.pl> A demo of charts with data highlighting options.
  
  =item * L<Example: chart_clustered.pl> A demo of a chart with a clustered axis.
  
  =item * L<Example: chart_styles.pl> A demo of the available chart styles.
  
  =item * L<Example: colors.pl> A demo of the colour palette and named colours.
  
  =item * L<Example: comments1.pl> Add comments to worksheet cells.
  
  =item * L<Example: comments2.pl> Add comments with advanced options.
  
  =item * L<Example: conditional_format.pl> Add conditional formats to a range of cells.
  
  =item * L<Example: data_validate.pl> An example of data validation and dropdown lists.
  
  =item * L<Example: date_time.pl> Write dates and times with write_date_time().
  
  =item * L<Example: defined_name.pl> Example of how to create defined names.
  
  =item * L<Example: diag_border.pl> A simple example of diagonal cell borders.
  
  =item * L<Example: filehandle.pl> Examples of working with filehandles.
  
  =item * L<Example: headers.pl> Examples of worksheet headers and footers.
  
  =item * L<Example: hide_row_col.pl> Example of hiding rows and columns.
  
  =item * L<Example: hide_sheet.pl> Simple example of hiding a worksheet.
  
  =item * L<Example: hyperlink1.pl> Shows how to create web hyperlinks.
  
  =item * L<Example: hyperlink2.pl> Examples of internal and external hyperlinks.
  
  =item * L<Example: indent.pl> An example of cell indentation.
  
  =item * L<Example: macros.pl> An example of adding macros from an existing file.
  
  =item * L<Example: merge1.pl> A simple example of cell merging.
  
  =item * L<Example: merge2.pl> A simple example of cell merging with formatting.
  
  =item * L<Example: merge3.pl> Add hyperlinks to merged cells.
  
  =item * L<Example: merge4.pl> An advanced example of merging with formatting.
  
  =item * L<Example: merge5.pl> An advanced example of merging with formatting.
  
  =item * L<Example: merge6.pl> An example of merging with Unicode strings.
  
  =item * L<Example: mod_perl1.pl> A simple mod_perl 1 program.
  
  =item * L<Example: mod_perl2.pl> A simple mod_perl 2 program.
  
  =item * L<Example: outline.pl> An example of outlines and grouping.
  
  =item * L<Example: outline_collapsed.pl> An example of collapsed outlines.
  
  =item * L<Example: panes.pl> An example of how to create panes.
  
  =item * L<Example: properties.pl> Add document properties to a workbook.
  
  =item * L<Example: protection.pl> Example of cell locking and formula hiding.
  
  =item * L<Example: rich_strings.pl> Example of strings with multiple formats.
  
  =item * L<Example: right_to_left.pl> Change default sheet direction to right to left.
  
  =item * L<Example: sales.pl> An example of a simple sales spreadsheet.
  
  =item * L<Example: shape1.pl> Insert shapes in worksheet.
  
  =item * L<Example: shape2.pl> Insert shapes in worksheet. With properties.
  
  =item * L<Example: shape3.pl> Insert shapes in worksheet. Scaled.
  
  =item * L<Example: shape4.pl> Insert shapes in worksheet. With modification.
  
  =item * L<Example: shape5.pl> Insert shapes in worksheet. With connections.
  
  =item * L<Example: shape6.pl> Insert shapes in worksheet. With connections.
  
  =item * L<Example: shape7.pl> Insert shapes in worksheet. One to many connections.
  
  =item * L<Example: shape8.pl> Insert shapes in worksheet. One to many connections.
  
  =item * L<Example: shape_all.pl> Demo of all the available shape and connector types.
  
  =item * L<Example: sparklines1.pl> Simple sparklines demo.
  
  =item * L<Example: sparklines2.pl> Sparklines demo showing formatting options.
  
  =item * L<Example: stats_ext.pl> Same as stats.pl with external references.
  
  =item * L<Example: stocks.pl> Demonstrates conditional formatting.
  
  =item * L<Example: tab_colors.pl> Example of how to set worksheet tab colours.
  
  =item * L<Example: tables.pl> Add Excel tables to a worksheet.
  
  =item * L<Example: write_handler1.pl> Example of extending the write() method. Step 1.
  
  =item * L<Example: write_handler2.pl> Example of extending the write() method. Step 2.
  
  =item * L<Example: write_handler3.pl> Example of extending the write() method. Step 3.
  
  =item * L<Example: write_handler4.pl> Example of extending the write() method. Step 4.
  
  =item * L<Example: write_to_scalar.pl> Example of writing an Excel file to a Perl scalar.
  
  =item * L<Example: unicode_2022_jp.pl> Japanese: ISO-2022-JP.
  
  =item * L<Example: unicode_8859_11.pl> Thai:     ISO-8859_11.
  
  =item * L<Example: unicode_8859_7.pl> Greek:    ISO-8859_7.
  
  =item * L<Example: unicode_big5.pl> Chinese:  BIG5.
  
  =item * L<Example: unicode_cp1251.pl> Russian:  CP1251.
  
  =item * L<Example: unicode_cp1256.pl> Arabic:   CP1256.
  
  =item * L<Example: unicode_cyrillic.pl> Russian:  Cyrillic.
  
  =item * L<Example: unicode_koi8r.pl> Russian:  KOI8-R.
  
  =item * L<Example: unicode_polish_utf8.pl> Polish :  UTF8.
  
  =item * L<Example: unicode_shift_jis.pl> Japanese: Shift JIS.
  
  =back
  
  =head2 Example: a_simple.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  write text and numbers to an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/a_simple.jpg" width="640" height="420" alt="Output from a_simple.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # write text and numbers to an Excel xlsx file.
      #
      # reverse ('(c)'), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      # Create a new workbook called simple.xls and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'a_simple.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # The general syntax is write($row, $column, $token). Note that row and
      # column are zero indexed
      #
      
      # Write some text
      $worksheet->write( 0, 0, "Hi Excel!" );
      
      
      # Write some numbers
      $worksheet->write( 2, 0, 3 );          # Writes 3
      $worksheet->write( 3, 0, 3.00000 );    # Writes 3
      $worksheet->write( 4, 0, 3.00001 );    # Writes 3.00001
      $worksheet->write( 5, 0, 3.14159 );    # TeX revision no.?
      
      
      # Write some formulas
      $worksheet->write( 7, 0, '=A3 + A6' );
      $worksheet->write( 8, 0, '=IF(A5>3,"Yes", "No")' );
      
      
      # Write a hyperlink
      my $hyperlink_format = $workbook->add_format(
          color     => 'blue',
          underline => 1,
      );
      
      $worksheet->write( 10, 0, 'http://www.perl.com/', $hyperlink_format );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/a_simple.pl>
  
  =head2 Example: bug_report.pl
  
  
  
  A template for submitting a bug report.
  
  Run this program and read the output from the command line.
  
  
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A template for submitting a bug report.
      #
      # Run this program and read the output from the command line.
      #
      # reverse ('(c)'), March 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      
      print << 'HINTS_1';
      
      REPORTING A BUG OR ASKING A QUESTION
      
          Feel free to report bugs or ask questions. However, to save time
          consider the following steps first:
      
          Read the documentation:
      
              The Excel::Writer::XLSX documentation has been refined in
              response to user questions. Therefore, if you have a question it is
              possible that someone else has asked it before you and that it is
              already addressed in the documentation. Since there is a lot of
              documentation to get through you should at least read the table of
              contents and search for keywords that you are interested in.
      
          Look at the example programs:
      
              There are over 80 example programs shipped with the standard
              Excel::Writer::XLSX distribution. Many of these were created
              in response to user questions. Try to identify an example program
              that corresponds to your query and adapt it to your needs.
      
      HINTS_1
      print "Press enter ..."; <STDIN>;
      
      print << 'HINTS_2';
      
          If you submit a bug report here are some pointers.
      
          1.  Put "Excel::Writer::XLSX:" at the beginning of the subject line.
              This helps to filter genuine messages from spam.
      
          2.  Describe the problems as clearly and as concisely as possible.
      
          3.  Send a sample program. It is often easier to describe a problem in
              code than in written prose.
      
          4.  The sample program should be as small as possible to demonstrate the
              problem. Don't copy and past large sections of your program. The
              program should also be self contained and working.
      
          A sample bug report is generated below. If you use this format then it
          will help to analyse your question and respond to it more quickly.
      
          Please don't send patches without contacting the author first.
      
      
      HINTS_2
      print "Press enter ..."; <STDIN>;
      
      
      print << 'EMAIL';
      
      =======================================================================
      
      To:      John McNamara <jmcnamara@cpan.org>
      Subject: Excel::Writer::XLSX: Problem with something.
      
      Hi John,
      
      I am using Excel::Writer::XLSX and I have encountered a problem. I
      want it to do SOMETHING but the module appears to do SOMETHING_ELSE.
      
      Here is some code that demonstrates the problem.
      
          #!/usr/bin/perl -w
      
          use strict;
          use Excel::Writer::XLSX;
      
          my $workbook  = Excel::Writer::XLSX->new("reload.xls");
          my $worksheet = $workbook->add_worksheet();
      
          $worksheet->write(0, 0, "Hi Excel!");
      
          __END__
      
      My automatically generated system details are as follows:
      EMAIL
      
      
      print "\n    Perl version   : $]";
      print "\n    OS name        : $^O";
      print "\n    Module versions: (not all are required)\n";
      
      
      my @modules = qw(
                        Excel::Writer::XLSX
                        Spreadsheet::WriteExcel
                        Archive::Zip
                        XML::Writer
                        IO::File
                        File::Temp
                      );
      
      
      for my $module (@modules) {
          my $version;
          eval "require $module";
      
          if (not $@) {
              $version = $module->VERSION;
              $version = '(unknown)' if not defined $version;
          }
          else {
              $version = '(not installed)';
          }
      
          printf "%21s%-24s\t%s\n", "", $module, $version;
      }
      
      
      print << "BYE";
      Yours etc.,
      
      A. Person
      --
      
      BYE
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/bug_report.pl>
  
  =head2 Example: demo.pl
  
  
  
  A simple demo of some of the features of Excel::Writer::XLSX.
  
  This program is used to create the project screenshot for Freshmeat:
  L<http://freshmeat.net/projects/writeexcel/>
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/demo.jpg" width="640" height="420" alt="Output from demo.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      #######################################################################
      #
      # A simple demo of some of the features of Excel::Writer::XLSX.
      #
      # This program is used to create the project screenshot for Freshmeat:
      # L<http://freshmeat.net/projects/writeexcel/>
      #
      # reverse ('(c)'), October 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      my $workbook   = Excel::Writer::XLSX->new( 'demo.xlsx' );
      my $worksheet  = $workbook->add_worksheet( 'Demo' );
      my $worksheet2 = $workbook->add_worksheet( 'Another sheet' );
      my $worksheet3 = $workbook->add_worksheet( 'And another' );
      
      my $bold = $workbook->add_format( bold => 1 );
      
      
      #######################################################################
      #
      # Write a general heading
      #
      $worksheet->set_column( 'A:A', 36, $bold );
      $worksheet->set_column( 'B:B', 20 );
      $worksheet->set_row( 0, 40 );
      
      my $heading = $workbook->add_format(
          bold  => 1,
          color => 'blue',
          size  => 16,
          merge => 1,
          align => 'vcenter',
      );
      
      my $hyperlink_format = $workbook->add_format(
          color => 'blue',
          underline => 1,
      );
      
      
      my @headings = ( 'Features of Excel::Writer::XLSX', '' );
      $worksheet->write_row( 'A1', \@headings, $heading );
      
      
      #######################################################################
      #
      # Some text examples
      #
      my $text_format = $workbook->add_format(
          bold   => 1,
          italic => 1,
          color  => 'red',
          size   => 18,
          font   => 'Lucida Calligraphy'
      );
      
      
      $worksheet->write( 'A2', "Text" );
      $worksheet->write( 'B2', "Hello Excel" );
      $worksheet->write( 'A3', "Formatted text" );
      $worksheet->write( 'B3', "Hello Excel", $text_format );
      $worksheet->write( 'A4', "Unicode text" );
      $worksheet->write( 'B4', "\x{0410} \x{0411} \x{0412} \x{0413} \x{0414}" );
      
      #######################################################################
      #
      # Some numeric examples
      #
      my $num1_format = $workbook->add_format( num_format => '$#,##0.00' );
      my $num2_format = $workbook->add_format( num_format => ' d mmmm yyy' );
      
      
      $worksheet->write( 'A5', "Numbers" );
      $worksheet->write( 'B5', 1234.56 );
      $worksheet->write( 'A6', "Formatted numbers" );
      $worksheet->write( 'B6', 1234.56, $num1_format );
      $worksheet->write( 'A7', "Formatted numbers" );
      $worksheet->write( 'B7', 37257, $num2_format );
      
      
      #######################################################################
      #
      # Formulae
      #
      $worksheet->set_selection( 'B8' );
      $worksheet->write( 'A8', 'Formulas and functions, "=SIN(PI()/4)"' );
      $worksheet->write( 'B8', '=SIN(PI()/4)' );
      
      
      #######################################################################
      #
      # Hyperlinks
      #
      $worksheet->write( 'A9', "Hyperlinks" );
      $worksheet->write( 'B9', 'http://www.perl.com/', $hyperlink_format );
      
      
      #######################################################################
      #
      # Images
      #
      $worksheet->write( 'A10', "Images" );
      $worksheet->insert_image( 'B10', 'republic.png', 16, 8 );
      
      
      #######################################################################
      #
      # Misc
      #
      $worksheet->write( 'A18', "Page/printer setup" );
      $worksheet->write( 'A19', "Multiple worksheets" );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/demo.pl>
  
  =head2 Example: formats.pl
  
  
  
  Examples of formatting using the Excel::Writer::XLSX module.
  
  This program demonstrates almost all possible formatting options. It is worth
  running this program and viewing the output Excel file if you are interested
  in the various formatting possibilities.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/formats.jpg" width="640" height="420" alt="Output from formats.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Examples of formatting using the Excel::Writer::XLSX module.
      #
      # This program demonstrates almost all possible formatting options. It is worth
      # running this program and viewing the output Excel file if you are interested
      # in the various formatting possibilities.
      #
      # reverse ('(c)'), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'formats.xlsx' );
      
      # Some common formats
      my $center = $workbook->add_format( align => 'center' );
      my $heading = $workbook->add_format( align => 'center', bold => 1 );
      
      # The named colors
      my %colors = (
          0x08, 'black',
          0x0C, 'blue',
          0x10, 'brown',
          0x0F, 'cyan',
          0x17, 'gray',
          0x11, 'green',
          0x0B, 'lime',
          0x0E, 'magenta',
          0x12, 'navy',
          0x35, 'orange',
          0x21, 'pink',
          0x14, 'purple',
          0x0A, 'red',
          0x16, 'silver',
          0x09, 'white',
          0x0D, 'yellow',
      
      );
      
      # Call these subroutines to demonstrate different formatting options
      intro();
      fonts();
      named_colors();
      standard_colors();
      numeric_formats();
      borders();
      patterns();
      alignment();
      misc();
      
      # Note: this is required
      $workbook->close();
      
      
      ######################################################################
      #
      # Intro.
      #
      sub intro {
      
          my $worksheet = $workbook->add_worksheet( 'Introduction' );
      
          $worksheet->set_column( 0, 0, 60 );
      
          my $format = $workbook->add_format();
          $format->set_bold();
          $format->set_size( 14 );
          $format->set_color( 'blue' );
          $format->set_align( 'center' );
      
          my $format2 = $workbook->add_format();
          $format2->set_bold();
          $format2->set_color( 'blue' );
      
          my $format3 = $workbook->add_format(
              color     => 'blue',
              underline => 1,
          );
      
          $worksheet->write( 2, 0, 'This workbook demonstrates some of', $format );
          $worksheet->write( 3, 0, 'the formatting options provided by', $format );
          $worksheet->write( 4, 0, 'the Excel::Writer::XLSX module.',    $format );
          $worksheet->write( 'A7', 'Sections:', $format2 );
      
          $worksheet->write( 'A8', "internal:Fonts!A1", 'Fonts', $format3 );
      
          $worksheet->write( 'A9', "internal:'Named colors'!A1",
              'Named colors', $format3 );
      
          $worksheet->write(
              'A10',
              "internal:'Standard colors'!A1",
              'Standard colors', $format3
          );
      
          $worksheet->write(
              'A11',
              "internal:'Numeric formats'!A1",
              'Numeric formats', $format3
          );
      
          $worksheet->write( 'A12', "internal:Borders!A1", 'Borders', $format3 );
          $worksheet->write( 'A13', "internal:Patterns!A1", 'Patterns', $format3 );
          $worksheet->write( 'A14', "internal:Alignment!A1", 'Alignment', $format3 );
          $worksheet->write( 'A15', "internal:Miscellaneous!A1", 'Miscellaneous',
              $format3 );
      
      }
      
      
      ######################################################################
      #
      # Demonstrate the named colors.
      #
      sub named_colors {
      
          my $worksheet = $workbook->add_worksheet( 'Named colors' );
      
          $worksheet->set_column( 0, 3, 15 );
      
          $worksheet->write( 0, 0, "Index", $heading );
          $worksheet->write( 0, 1, "Index", $heading );
          $worksheet->write( 0, 2, "Name",  $heading );
          $worksheet->write( 0, 3, "Color", $heading );
      
          my $i = 1;
      
          while ( my ( $index, $color ) = each %colors ) {
              my $format = $workbook->add_format(
                  bg_color => $color,
                  pattern  => 1,
                  border   => 1
              );
      
              $worksheet->write( $i + 1, 0, $index, $center );
              $worksheet->write( $i + 1, 1, sprintf( "0x%02X", $index ), $center );
              $worksheet->write( $i + 1, 2, $color, $center );
              $worksheet->write( $i + 1, 3, '',     $format );
              $i++;
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel colors in the range 8..63.
      #
      sub standard_colors {
      
          my $worksheet = $workbook->add_worksheet( 'Standard colors' );
      
          $worksheet->set_column( 0, 3, 15 );
      
          $worksheet->write( 0, 0, "Index", $heading );
          $worksheet->write( 0, 1, "Index", $heading );
          $worksheet->write( 0, 2, "Color", $heading );
          $worksheet->write( 0, 3, "Name",  $heading );
      
          for my $i ( 8 .. 63 ) {
              my $format = $workbook->add_format(
                  bg_color => $i,
                  pattern  => 1,
                  border   => 1
              );
      
              $worksheet->write( ( $i - 7 ), 0, $i, $center );
              $worksheet->write( ( $i - 7 ), 1, sprintf( "0x%02X", $i ), $center );
              $worksheet->write( ( $i - 7 ), 2, '', $format );
      
              # Add the  color names
              if ( exists $colors{$i} ) {
                  $worksheet->write( ( $i - 7 ), 3, $colors{$i}, $center );
      
              }
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard numeric formats.
      #
      sub numeric_formats {
      
          my $worksheet = $workbook->add_worksheet( 'Numeric formats' );
      
          $worksheet->set_column( 0, 4, 15 );
          $worksheet->set_column( 5, 5, 45 );
      
          $worksheet->write( 0, 0, "Index",       $heading );
          $worksheet->write( 0, 1, "Index",       $heading );
          $worksheet->write( 0, 2, "Unformatted", $heading );
          $worksheet->write( 0, 3, "Formatted",   $heading );
          $worksheet->write( 0, 4, "Negative",    $heading );
          $worksheet->write( 0, 5, "Format",      $heading );
      
          #<<<
          my @formats;
          push @formats, [ 0x00, 1234.567,   0,         'General' ];
          push @formats, [ 0x01, 1234.567,   0,         '0' ];
          push @formats, [ 0x02, 1234.567,   0,         '0.00' ];
          push @formats, [ 0x03, 1234.567,   0,         '#,##0' ];
          push @formats, [ 0x04, 1234.567,   0,         '#,##0.00' ];
          push @formats, [ 0x05, 1234.567,   -1234.567, '($#,##0_);($#,##0)' ];
          push @formats, [ 0x06, 1234.567,   -1234.567, '($#,##0_);[Red]($#,##0)' ];
          push @formats, [ 0x07, 1234.567,   -1234.567, '($#,##0.00_);($#,##0.00)' ];
          push @formats, [ 0x08, 1234.567,   -1234.567, '($#,##0.00_);[Red]($#,##0.00)' ];
          push @formats, [ 0x09, 0.567,      0,         '0%' ];
          push @formats, [ 0x0a, 0.567,      0,         '0.00%' ];
          push @formats, [ 0x0b, 1234.567,   0,         '0.00E+00' ];
          push @formats, [ 0x0c, 0.75,       0,         '# ?/?' ];
          push @formats, [ 0x0d, 0.3125,     0,         '# ??/??' ];
          push @formats, [ 0x0e, 36892.521,  0,         'm/d/yy' ];
          push @formats, [ 0x0f, 36892.521,  0,         'd-mmm-yy' ];
          push @formats, [ 0x10, 36892.521,  0,         'd-mmm' ];
          push @formats, [ 0x11, 36892.521,  0,         'mmm-yy' ];
          push @formats, [ 0x12, 36892.521,  0,         'h:mm AM/PM' ];
          push @formats, [ 0x13, 36892.521,  0,         'h:mm:ss AM/PM' ];
          push @formats, [ 0x14, 36892.521,  0,         'h:mm' ];
          push @formats, [ 0x15, 36892.521,  0,         'h:mm:ss' ];
          push @formats, [ 0x16, 36892.521,  0,         'm/d/yy h:mm' ];
          push @formats, [ 0x25, 1234.567,   -1234.567, '(#,##0_);(#,##0)' ];
          push @formats, [ 0x26, 1234.567,   -1234.567, '(#,##0_);[Red](#,##0)' ];
          push @formats, [ 0x27, 1234.567,   -1234.567, '(#,##0.00_);(#,##0.00)' ];
          push @formats, [ 0x28, 1234.567,   -1234.567, '(#,##0.00_);[Red](#,##0.00)' ];
          push @formats, [ 0x29, 1234.567,   -1234.567, '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)' ];
          push @formats, [ 0x2a, 1234.567,   -1234.567, '_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)' ];
          push @formats, [ 0x2b, 1234.567,   -1234.567, '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)' ];
          push @formats, [ 0x2c, 1234.567,   -1234.567, '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)' ];
          push @formats, [ 0x2d, 36892.521,  0,         'mm:ss' ];
          push @formats, [ 0x2e, 3.0153,     0,         '[h]:mm:ss' ];
          push @formats, [ 0x2f, 36892.521,  0,         'mm:ss.0' ];
          push @formats, [ 0x30, 1234.567,   0,         '##0.0E+0' ];
          push @formats, [ 0x31, 1234.567,   0,         '@' ];
          #>>>
      
          my $i;
          foreach my $format ( @formats ) {
              my $style = $workbook->add_format();
              $style->set_num_format( $format->[0] );
      
              $i++;
              $worksheet->write( $i, 0, $format->[0], $center );
              $worksheet->write( $i, 1, sprintf( "0x%02X", $format->[0] ), $center );
              $worksheet->write( $i, 2, $format->[1], $center );
              $worksheet->write( $i, 3, $format->[1], $style );
      
              if ( $format->[2] ) {
                  $worksheet->write( $i, 4, $format->[2], $style );
              }
      
              $worksheet->write_string( $i, 5, $format->[3] );
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the font options.
      #
      sub fonts {
      
          my $worksheet = $workbook->add_worksheet( 'Fonts' );
      
          $worksheet->set_column( 0, 0, 30 );
          $worksheet->set_column( 1, 1, 10 );
      
          $worksheet->write( 0, 0, "Font name", $heading );
          $worksheet->write( 0, 1, "Font size", $heading );
      
          my @fonts;
          push @fonts, [ 10, 'Arial' ];
          push @fonts, [ 12, 'Arial' ];
          push @fonts, [ 14, 'Arial' ];
          push @fonts, [ 12, 'Arial Black' ];
          push @fonts, [ 12, 'Arial Narrow' ];
          push @fonts, [ 12, 'Century Schoolbook' ];
          push @fonts, [ 12, 'Courier' ];
          push @fonts, [ 12, 'Courier New' ];
          push @fonts, [ 12, 'Garamond' ];
          push @fonts, [ 12, 'Impact' ];
          push @fonts, [ 12, 'Lucida Handwriting' ];
          push @fonts, [ 12, 'Times New Roman' ];
          push @fonts, [ 12, 'Symbol' ];
          push @fonts, [ 12, 'Wingdings' ];
          push @fonts, [ 12, 'A font that doesn\'t exist' ];
      
          my $i;
          foreach my $font ( @fonts ) {
              my $format = $workbook->add_format();
      
              $format->set_size( $font->[0] );
              $format->set_font( $font->[1] );
      
              $i++;
              $worksheet->write( $i, 0, $font->[1], $format );
              $worksheet->write( $i, 1, $font->[0], $format );
          }
      
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel border styles.
      #
      sub borders {
      
          my $worksheet = $workbook->add_worksheet( 'Borders' );
      
          $worksheet->set_column( 0, 4, 10 );
          $worksheet->set_column( 5, 5, 40 );
      
          $worksheet->write( 0, 0, "Index",                                $heading );
          $worksheet->write( 0, 1, "Index",                                $heading );
          $worksheet->write( 0, 3, "Style",                                $heading );
          $worksheet->write( 0, 5, "The style is highlighted in red for ", $heading );
          $worksheet->write( 1, 5, "emphasis, the default color is black.",
              $heading );
      
          for my $i ( 0 .. 13 ) {
              my $format = $workbook->add_format();
              $format->set_border( $i );
              $format->set_border_color( 'red' );
              $format->set_align( 'center' );
      
              $worksheet->write( ( 2 * ( $i + 1 ) ), 0, $i, $center );
              $worksheet->write( ( 2 * ( $i + 1 ) ),
                  1, sprintf( "0x%02X", $i ), $center );
      
              $worksheet->write( ( 2 * ( $i + 1 ) ), 3, "Border", $format );
          }
      
          $worksheet->write( 30, 0, "Diag type",             $heading );
          $worksheet->write( 30, 1, "Index",                 $heading );
          $worksheet->write( 30, 3, "Style",                 $heading );
          $worksheet->write( 30, 5, "Diagonal Boder styles", $heading );
      
          for my $i ( 1 .. 3 ) {
              my $format = $workbook->add_format();
              $format->set_diag_type( $i );
              $format->set_diag_border( 1 );
              $format->set_diag_color( 'red' );
              $format->set_align( 'center' );
      
              $worksheet->write( ( 2 * ( $i + 15 ) ), 0, $i, $center );
              $worksheet->write( ( 2 * ( $i + 15 ) ),
                  1, sprintf( "0x%02X", $i ), $center );
      
              $worksheet->write( ( 2 * ( $i + 15 ) ), 3, "Border", $format );
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel cell patterns.
      #
      sub patterns {
      
          my $worksheet = $workbook->add_worksheet( 'Patterns' );
      
          $worksheet->set_column( 0, 4, 10 );
          $worksheet->set_column( 5, 5, 50 );
      
          $worksheet->write( 0, 0, "Index",   $heading );
          $worksheet->write( 0, 1, "Index",   $heading );
          $worksheet->write( 0, 3, "Pattern", $heading );
      
          $worksheet->write( 0, 5, "The background colour has been set to silver.",
              $heading );
          $worksheet->write( 1, 5, "The foreground colour has been set to green.",
              $heading );
      
          for my $i ( 0 .. 18 ) {
              my $format = $workbook->add_format();
      
              $format->set_pattern( $i );
              $format->set_bg_color( 'silver' );
              $format->set_fg_color( 'green' );
              $format->set_align( 'center' );
      
              $worksheet->write( ( 2 * ( $i + 1 ) ), 0, $i, $center );
              $worksheet->write( ( 2 * ( $i + 1 ) ),
                  1, sprintf( "0x%02X", $i ), $center );
      
              $worksheet->write( ( 2 * ( $i + 1 ) ), 3, "Pattern", $format );
      
              if ( $i == 1 ) {
                  $worksheet->write( ( 2 * ( $i + 1 ) ),
                      5, "This is solid colour, the most useful pattern.", $heading );
              }
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel cell alignments.
      #
      sub alignment {
      
          my $worksheet = $workbook->add_worksheet( 'Alignment' );
      
          $worksheet->set_column( 0, 7, 12 );
          $worksheet->set_row( 0, 40 );
          $worksheet->set_selection( 7, 0 );
      
          my $format01 = $workbook->add_format();
          my $format02 = $workbook->add_format();
          my $format03 = $workbook->add_format();
          my $format04 = $workbook->add_format();
          my $format05 = $workbook->add_format();
          my $format06 = $workbook->add_format();
          my $format07 = $workbook->add_format();
          my $format08 = $workbook->add_format();
          my $format09 = $workbook->add_format();
          my $format10 = $workbook->add_format();
          my $format11 = $workbook->add_format();
          my $format12 = $workbook->add_format();
          my $format13 = $workbook->add_format();
          my $format14 = $workbook->add_format();
          my $format15 = $workbook->add_format();
          my $format16 = $workbook->add_format();
          my $format17 = $workbook->add_format();
      
          $format02->set_align( 'top' );
          $format03->set_align( 'bottom' );
          $format04->set_align( 'vcenter' );
          $format05->set_align( 'vjustify' );
          $format06->set_text_wrap();
      
          $format07->set_align( 'left' );
          $format08->set_align( 'right' );
          $format09->set_align( 'center' );
          $format10->set_align( 'fill' );
          $format11->set_align( 'justify' );
          $format12->set_merge();
      
          $format13->set_rotation( 45 );
          $format14->set_rotation( -45 );
          $format15->set_rotation( 270 );
      
          $format16->set_shrink();
          $format17->set_indent( 1 );
      
          $worksheet->write( 0, 0, 'Vertical',   $heading );
          $worksheet->write( 0, 1, 'top',        $format02 );
          $worksheet->write( 0, 2, 'bottom',     $format03 );
          $worksheet->write( 0, 3, 'vcenter',    $format04 );
          $worksheet->write( 0, 4, 'vjustify',   $format05 );
          $worksheet->write( 0, 5, "text\nwrap", $format06 );
      
          $worksheet->write( 2, 0, 'Horizontal', $heading );
          $worksheet->write( 2, 1, 'left',       $format07 );
          $worksheet->write( 2, 2, 'right',      $format08 );
          $worksheet->write( 2, 3, 'center',     $format09 );
          $worksheet->write( 2, 4, 'fill',       $format10 );
          $worksheet->write( 2, 5, 'justify',    $format11 );
      
          $worksheet->write( 3, 1, 'merge', $format12 );
          $worksheet->write( 3, 2, '',      $format12 );
      
          $worksheet->write( 3, 3, 'Shrink ' x 3, $format16 );
          $worksheet->write( 3, 4, 'Indent',      $format17 );
      
      
          $worksheet->write( 5, 0, 'Rotation',   $heading );
          $worksheet->write( 5, 1, 'Rotate 45',  $format13 );
          $worksheet->write( 6, 1, 'Rotate -45', $format14 );
          $worksheet->write( 7, 1, 'Rotate 270', $format15 );
      }
      
      
      ######################################################################
      #
      # Demonstrate other miscellaneous features.
      #
      sub misc {
      
          my $worksheet = $workbook->add_worksheet( 'Miscellaneous' );
      
          $worksheet->set_column( 2, 2, 25 );
      
          my $format01 = $workbook->add_format();
          my $format02 = $workbook->add_format();
          my $format03 = $workbook->add_format();
          my $format04 = $workbook->add_format();
          my $format05 = $workbook->add_format();
          my $format06 = $workbook->add_format();
          my $format07 = $workbook->add_format();
      
          $format01->set_underline( 0x01 );
          $format02->set_underline( 0x02 );
          $format03->set_underline( 0x21 );
          $format04->set_underline( 0x22 );
          $format05->set_font_strikeout();
          $format06->set_font_outline();
          $format07->set_font_shadow();
      
          $worksheet->write( 1,  2, 'Underline  0x01',          $format01 );
          $worksheet->write( 3,  2, 'Underline  0x02',          $format02 );
          $worksheet->write( 5,  2, 'Underline  0x21',          $format03 );
          $worksheet->write( 7,  2, 'Underline  0x22',          $format04 );
          $worksheet->write( 9,  2, 'Strikeout',                $format05 );
          $worksheet->write( 11, 2, 'Outline (Macintosh only)', $format06 );
          $worksheet->write( 13, 2, 'Shadow (Macintosh only)',  $format07 );
      }
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/formats.pl>
  
  =head2 Example: regions.pl
  
  
  
  An example of how to use the Excel::Writer::XLSX module to write a basic
  Excel workbook with multiple worksheets.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/regions.jpg" width="640" height="420" alt="Output from regions.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # An example of how to use the Excel::Writer::XLSX module to write a basic
      # Excel workbook with multiple worksheets.
      #
      # reverse ('(c)'), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      # Create a new Excel workbook
      my $workbook = Excel::Writer::XLSX->new( 'regions.xlsx' );
      
      # Add some worksheets
      my $north = $workbook->add_worksheet( "North" );
      my $south = $workbook->add_worksheet( "South" );
      my $east  = $workbook->add_worksheet( "East" );
      my $west  = $workbook->add_worksheet( "West" );
      
      # Add a Format
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_color( 'blue' );
      
      # Add a caption to each worksheet
      foreach my $worksheet ( $workbook->sheets() ) {
          $worksheet->write( 0, 0, "Sales", $format );
      }
      
      # Write some data
      $north->write( 0, 1, 200000 );
      $south->write( 0, 1, 100000 );
      $east->write( 0, 1, 150000 );
      $west->write( 0, 1, 100000 );
      
      # Set the active worksheet
      $south->activate();
      
      # Set the width of the first column
      $south->set_column( 0, 0, 20 );
      
      # Set the active cell
      $south->set_selection( 0, 1 );
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/regions.pl>
  
  =head2 Example: stats.pl
  
  
  
  A simple example of how to use functions with the Excel::Writer::XLSX
  module.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/stats.jpg" width="640" height="420" alt="Output from stats.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # A simple example of how to use functions with the Excel::Writer::XLSX
      # module.
      #
      # reverse ('(c)'), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'stats.xlsx' );
      my $worksheet = $workbook->add_worksheet( 'Test data' );
      
      # Set the column width for columns 1
      $worksheet->set_column( 0, 0, 20 );
      
      
      # Create a format for the headings
      my $format = $workbook->add_format();
      $format->set_bold();
      
      
      # Write the sample data
      $worksheet->write( 0, 0, 'Sample', $format );
      $worksheet->write( 0, 1, 1 );
      $worksheet->write( 0, 2, 2 );
      $worksheet->write( 0, 3, 3 );
      $worksheet->write( 0, 4, 4 );
      $worksheet->write( 0, 5, 5 );
      $worksheet->write( 0, 6, 6 );
      $worksheet->write( 0, 7, 7 );
      $worksheet->write( 0, 8, 8 );
      
      $worksheet->write( 1, 0, 'Length', $format );
      $worksheet->write( 1, 1, 25.4 );
      $worksheet->write( 1, 2, 25.4 );
      $worksheet->write( 1, 3, 24.8 );
      $worksheet->write( 1, 4, 25.0 );
      $worksheet->write( 1, 5, 25.3 );
      $worksheet->write( 1, 6, 24.9 );
      $worksheet->write( 1, 7, 25.2 );
      $worksheet->write( 1, 8, 24.8 );
      
      # Write some statistical functions
      $worksheet->write( 4, 0, 'Count', $format );
      $worksheet->write( 4, 1, '=COUNT(B1:I1)' );
      
      $worksheet->write( 5, 0, 'Sum', $format );
      $worksheet->write( 5, 1, '=SUM(B2:I2)' );
      
      $worksheet->write( 6, 0, 'Average', $format );
      $worksheet->write( 6, 1, '=AVERAGE(B2:I2)' );
      
      $worksheet->write( 7, 0, 'Min', $format );
      $worksheet->write( 7, 1, '=MIN(B2:I2)' );
      
      $worksheet->write( 8, 0, 'Max', $format );
      $worksheet->write( 8, 1, '=MAX(B2:I2)' );
      
      $worksheet->write( 9, 0, 'Standard Deviation', $format );
      $worksheet->write( 9, 1, '=STDEV(B2:I2)' );
      
      $worksheet->write( 10, 0, 'Kurtosis', $format );
      $worksheet->write( 10, 1, '=KURT(B2:I2)' );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/stats.pl>
  
  =head2 Example: autofilter.pl
  
  
  
  An example of how to create autofilters with Excel::Writer::XLSX.
  
  An autofilter is a way of adding drop down lists to the headers of a 2D range
  of worksheet data. This allows users to filter the data based on
  simple criteria so that some data is shown and some is hidden.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/autofilter.jpg" width="640" height="420" alt="Output from autofilter.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # An example of how to create autofilters with Excel::Writer::XLSX.
      #
      # An autofilter is a way of adding drop down lists to the headers of a 2D range
      # of worksheet data. This allows users to filter the data based on
      # simple criteria so that some data is shown and some is hidden.
      #
      # reverse ('(c)'), September 2007, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'autofilter.xlsx' );
      
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      my $worksheet5 = $workbook->add_worksheet();
      my $worksheet6 = $workbook->add_worksheet();
      
      my $bold = $workbook->add_format( bold => 1 );
      
      
      # Extract the data embedded at the end of this file.
      my @headings = split ' ', <DATA>;
      my @data;
      push @data, [split] while <DATA>;
      
      
      # Set up several sheets with the same data.
      for my $worksheet ( $workbook->sheets() ) {
          $worksheet->set_column( 'A:D', 12 );
          $worksheet->set_row( 0, 20, $bold );
          $worksheet->write( 'A1', \@headings );
      }
      
      
      ###############################################################################
      #
      # Example 1. Autofilter without conditions.
      #
      
      $worksheet1->autofilter( 'A1:D51' );
      $worksheet1->write( 'A2', [ [@data] ] );
      
      
      ###############################################################################
      #
      #
      # Example 2. Autofilter with a filter condition in the first column.
      #
      
      # The range in this example is the same as above but in row-column notation.
      $worksheet2->autofilter( 0, 0, 50, 3 );
      
      # The placeholder "Region" in the filter is ignored and can be any string
      # that adds clarity to the expression.
      #
      $worksheet2->filter_column( 0, 'Region eq East' );
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      my $row = 1;
      
      for my $row_data ( @data ) {
          my $region = $row_data->[0];
      
          if ( $region eq 'East' ) {
      
              # Row is visible.
          }
          else {
      
              # Hide row.
              $worksheet2->set_row( $row, undef, undef, 1 );
          }
      
          $worksheet2->write( $row++, 0, $row_data );
      }
      
      
      ###############################################################################
      #
      #
      # Example 3. Autofilter with a dual filter condition in one of the columns.
      #
      
      $worksheet3->autofilter( 'A1:D51' );
      
      $worksheet3->filter_column( 'A', 'x eq East or x eq South' );
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data ( @data ) {
          my $region = $row_data->[0];
      
          if ( $region eq 'East' or $region eq 'South' ) {
      
              # Row is visible.
          }
          else {
      
              # Hide row.
              $worksheet3->set_row( $row, undef, undef, 1 );
          }
      
          $worksheet3->write( $row++, 0, $row_data );
      }
      
      
      ###############################################################################
      #
      #
      # Example 4. Autofilter with filter conditions in two columns.
      #
      
      $worksheet4->autofilter( 'A1:D51' );
      
      $worksheet4->filter_column( 'A', 'x eq East' );
      $worksheet4->filter_column( 'C', 'x > 3000 and x < 8000' );
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data ( @data ) {
          my $region = $row_data->[0];
          my $volume = $row_data->[2];
      
          if (    $region eq 'East'
              and $volume > 3000
              and $volume < 8000 )
          {
      
              # Row is visible.
          }
          else {
      
              # Hide row.
              $worksheet4->set_row( $row, undef, undef, 1 );
          }
      
          $worksheet4->write( $row++, 0, $row_data );
      }
      
      
      ###############################################################################
      #
      #
      # Example 5. Autofilter with filter for blanks.
      #
      
      # Create a blank cell in our test data.
      $data[5]->[0] = '';
      
      
      $worksheet5->autofilter( 'A1:D51' );
      $worksheet5->filter_column( 'A', 'x == Blanks' );
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data ( @data ) {
          my $region = $row_data->[0];
      
          if ( $region eq '' ) {
      
              # Row is visible.
          }
          else {
      
              # Hide row.
              $worksheet5->set_row( $row, undef, undef, 1 );
          }
      
          $worksheet5->write( $row++, 0, $row_data );
      }
      
      
      ###############################################################################
      #
      #
      # Example 6. Autofilter with filter for non-blanks.
      #
      
      
      $worksheet6->autofilter( 'A1:D51' );
      $worksheet6->filter_column( 'A', 'x == NonBlanks' );
      
      #
      # Hide the rows that don't match the filter criteria.
      #
      $row = 1;
      
      for my $row_data ( @data ) {
          my $region = $row_data->[0];
      
          if ( $region ne '' ) {
      
              # Row is visible.
          }
          else {
      
              # Hide row.
              $worksheet6->set_row( $row, undef, undef, 1 );
          }
      
          $worksheet6->write( $row++, 0, $row_data );
      }
      
      
      __DATA__
      Region    Item      Volume    Month
      East      Apple     9000      July
      East      Apple     5000      July
      South     Orange    9000      September
      North     Apple     2000      November
      West      Apple     9000      November
      South     Pear      7000      October
      North     Pear      9000      August
      West      Orange    1000      December
      West      Grape     1000      November
      South     Pear      10000     April
      West      Grape     6000      January
      South     Orange    3000      May
      North     Apple     3000      December
      South     Apple     7000      February
      West      Grape     1000      December
      East      Grape     8000      February
      South     Grape     10000     June
      West      Pear      7000      December
      South     Apple     2000      October
      East      Grape     7000      December
      North     Grape     6000      April
      East      Pear      8000      February
      North     Apple     7000      August
      North     Orange    7000      July
      North     Apple     6000      June
      South     Grape     8000      September
      West      Apple     3000      October
      South     Orange    10000     November
      West      Grape     4000      July
      North     Orange    5000      August
      East      Orange    1000      November
      East      Orange    4000      October
      North     Grape     5000      August
      East      Apple     1000      December
      South     Apple     10000     March
      East      Grape     7000      October
      West      Grape     1000      September
      East      Grape     10000     October
      South     Orange    8000      March
      North     Apple     4000      July
      South     Orange    5000      July
      West      Apple     4000      June
      East      Apple     5000      April
      North     Pear      3000      August
      East      Grape     9000      November
      North     Orange    8000      October
      East      Apple     10000     June
      South     Pear      1000      December
      North     Grape     10000     July
      East      Grape     6000      February
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/autofilter.pl>
  
  =head2 Example: array_formula.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX module to write simple
  array formulas.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/array_formula.jpg" width="640" height="420" alt="Output from array_formula.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # Example of how to use the Excel::Writer::XLSX module to write simple
      # array formulas.
      #
      # reverse ('(c)'), August 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'array_formula.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Write some test data.
      $worksheet->write( 'B1', [ [ 500, 10 ], [ 300, 15 ] ] );
      $worksheet->write( 'B5', [ [ 1, 2, 3 ], [ 20234, 21003, 10000 ] ] );
      
      # Write an array formula that returns a single value
      $worksheet->write( 'A1', '{=SUM(B1:C1*B2:C2)}' );
      
      # Same as above but more verbose.
      $worksheet->write_array_formula( 'A2:A2', '{=SUM(B1:C1*B2:C2)}' );
      
      # Write an array formula that returns a range of values
      $worksheet->write_array_formula( 'A5:A7', '{=TREND(C5:C7,B5:B7)}' );
      
      __END__
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/array_formula.pl>
  
  =head2 Example: cgi.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX module to send an Excel
  file to a browser in a CGI program.
  
  On Windows the hash-bang line should be something like:
  
      #!C:\Perl\bin\perl.exe
  
  The "Content-Disposition" line will cause a prompt to be generated to save
  the file. If you want to stream the file to the browser instead, comment out
  that line as shown below.
  
  
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX module to send an Excel
      # file to a browser in a CGI program.
      #
      # On Windows the hash-bang line should be something like:
      #
      #     #!C:\Perl\bin\perl.exe
      #
      # The "Content-Disposition" line will cause a prompt to be generated to save
      # the file. If you want to stream the file to the browser instead, comment out
      # that line as shown below.
      #
      # reverse ('(c)'), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Set the filename and send the content type
      my $filename = "cgitest.xlsx";
      
      print "Content-type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n";
      
      # The Content-Disposition will generate a prompt to save the file. If you want
      # to stream the file to the browser, comment out the following line.
      print "Content-Disposition: attachment; filename=$filename\n";
      print "\n";
      
      # Redirect the output to STDOUT. Binmode the filehandle in case it is needed.
      binmode STDOUT;
      
      my $workbook  = Excel::Writer::XLSX->new( \*STDOUT );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Set the column width for column 1
      $worksheet->set_column( 0, 0, 20 );
      
      
      # Create a format
      my $format = $workbook->add_format();
      $format->set_bold();
      $format->set_size( 15 );
      $format->set_color( 'blue' );
      
      
      # Write to the workbook
      $worksheet->write( 0, 0, "Hi Excel!", $format );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/cgi.pl>
  
  =head2 Example: chart_area.pl
  
  
  
  A demo of an Area chart in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_area.jpg" width="640" height="420" alt="Output from chart_area.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of an Area chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_area.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 40, 40, 50, 30, 25, 50 ],
          [ 30, 25, 30, 10, 5,  10 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'area', embedded => 1 );
      
      # Configure the first series.
      $chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart1->set_title ( name => 'Results of sample analysis' );
      $chart1->set_x_axis( name => 'Test number' );
      $chart1->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart1->set_style( 11 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #
      # Create a stacked chart sub-type
      #
      my $chart2 = $workbook->add_chart(
          type     => 'area',
          embedded => 1,
          subtype  => 'stacked'
      );
      
      # Configure the first series.
      $chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart2->set_title ( name => 'Stacked Chart' );
      $chart2->set_x_axis( name => 'Test number' );
      $chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart2->set_style( 12 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 11 );
      
      
      #
      # Create a percent stacked chart sub-type
      #
      my $chart3 = $workbook->add_chart(
          type     => 'area',
          embedded => 1,
          subtype  => 'percent_stacked'
      );
      
      # Configure the first series.
      $chart3->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart3->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart3->set_title ( name => 'Percent Stacked Chart' );
      $chart3->set_x_axis( name => 'Test number' );
      $chart3->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart3->set_style( 13 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D34', $chart3, 25, 11 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_area.pl>
  
  =head2 Example: chart_bar.pl
  
  
  
  A demo of an Bar chart in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_bar.jpg" width="640" height="420" alt="Output from chart_bar.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of an Bar chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_bar.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'bar', embedded => 1 );
      
      # Configure the first series.
      $chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart1->set_title ( name => 'Results of sample analysis' );
      $chart1->set_x_axis( name => 'Test number' );
      $chart1->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart1->set_style( 11 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #
      # Create a stacked chart sub-type
      #
      my $chart2 = $workbook->add_chart(
          type     => 'bar',
          embedded => 1,
          subtype  => 'stacked'
      );
      
      # Configure the first series.
      $chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart2->set_title ( name => 'Stacked Chart' );
      $chart2->set_x_axis( name => 'Test number' );
      $chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart2->set_style( 12 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 11 );
      
      
      #
      # Create a percent stacked chart sub-type
      #
      my $chart3 = $workbook->add_chart(
          type     => 'bar',
          embedded => 1,
          subtype  => 'percent_stacked'
      );
      
      # Configure the first series.
      $chart3->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart3->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart3->set_title ( name => 'Percent Stacked Chart' );
      $chart3->set_x_axis( name => 'Test number' );
      $chart3->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart3->set_style( 13 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D34', $chart3, 25, 11 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_bar.pl>
  
  =head2 Example: chart_column.pl
  
  
  
  A demo of a Column chart in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_column.jpg" width="640" height="420" alt="Output from chart_column.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Column chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_column.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the first series.
      $chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart1->set_title ( name => 'Results of sample analysis' );
      $chart1->set_x_axis( name => 'Test number' );
      $chart1->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart1->set_style( 11 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #
      # Create a stacked chart sub-type
      #
      my $chart2 = $workbook->add_chart(
          type     => 'column',
          embedded => 1,
          subtype  => 'stacked'
      );
      
      # Configure the first series.
      $chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart2->set_title ( name => 'Stacked Chart' );
      $chart2->set_x_axis( name => 'Test number' );
      $chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart2->set_style( 12 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 11 );
      
      
      #
      # Create a percent stacked chart sub-type
      #
      my $chart3 = $workbook->add_chart(
          type     => 'column',
          embedded => 1,
          subtype  => 'percent_stacked'
      );
      
      # Configure the first series.
      $chart3->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart3->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart3->set_title ( name => 'Percent Stacked Chart' );
      $chart3->set_x_axis( name => 'Test number' );
      $chart3->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart3->set_style( 13 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D34', $chart3, 25, 11 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_column.pl>
  
  =head2 Example: chart_line.pl
  
  
  
  A demo of a Line chart in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_line.jpg" width="640" height="420" alt="Output from chart_line.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Line chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_line.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2, 3, 4, 5, 6, 7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the first series.
      $chart->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'Results of sample analysis' );
      $chart->set_x_axis( name => 'Test number' );
      $chart->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart->set_style( 10 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_line.pl>
  
  =head2 Example: chart_pie.pl
  
  
  
  A demo of a Pie chart in Excel::Writer::XLSX.
  
  The demo also shows how to set segment colours. It is possible to define
  chart colors for most types of Excel::Writer::XLSX charts via the
  add_series() method. However, Pie and Doughtnut charts are a special case
  since each segment is represented as a point so it is necessary to assign
  formatting to each point in the series.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_pie.jpg" width="640" height="420" alt="Output from chart_pie.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Pie chart in Excel::Writer::XLSX.
      #
      # The demo also shows how to set segment colours. It is possible to define
      # chart colors for most types of Excel::Writer::XLSX charts via the
      # add_series() method. However, Pie and Doughtnut charts are a special case
      # since each segment is represented as a point so it is necessary to assign
      # formatting to each point in the series.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_pie.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values' ];
      my $data = [
          [ 'Apple', 'Cherry', 'Pecan' ],
          [ 60,       30,       10     ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'pie', embedded => 1 );
      
      # Configure the series. Note the use of the array ref to define ranges:
      # [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      # See below for an alternative syntax.
      $chart1->add_series(
          name       => 'Pie sales data',
          categories => [ 'Sheet1', 1, 3, 0, 0 ],
          values     => [ 'Sheet1', 1, 3, 1, 1 ],
      );
      
      # Add a title.
      $chart1->set_title( name => 'Popular Pie Types' );
      
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart1->set_style( 10 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C2', $chart1, 25, 10 );
      
      
      #
      # Create a Pie chart with user defined segment colors.
      #
      
      # Create an example Pie chart like above.
      my $chart2 = $workbook->add_chart( type => 'pie', embedded => 1 );
      
      # Configure the series and add user defined segment colours.
      $chart2->add_series(
          name       => 'Pie sales data',
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
          points     => [
              { fill => { color => '#5ABA10' } },
              { fill => { color => '#FE110E' } },
              { fill => { color => '#CA5C05' } },
          ],
      );
      
      # Add a title.
      $chart2->set_title( name => 'Pie Chart with user defined colors' );
      
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C18', $chart2, 25, 10 );
      
      
      #
      # Create a Pie chart with rotation of the segments.
      #
      
      # Create an example Pie chart like above.
      my $chart3 = $workbook->add_chart( type => 'pie', embedded => 1 );
      
      # Configure the series.
      $chart3->add_series(
          name       => 'Pie sales data',
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
      );
      
      # Add a title.
      $chart3->set_title( name => 'Pie Chart with segment rotation' );
      
      # Change the angle/rotation of the first segment.
      $chart3->set_rotation(90);
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C34', $chart3, 25, 10 );
      
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_pie.pl>
  
  =head2 Example: chart_doughnut.pl
  
  
  
  A demo of a Doughnut chart in Excel::Writer::XLSX.
  
  The demo also shows how to set segment colours. It is possible to define
  chart colors for most types of Excel::Writer::XLSX charts via the
  add_series() method. However, Pie and Doughtnut charts are a special case
  since each segment is represented as a point so it is necessary to assign
  formatting to each point in the series.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_doughnut.jpg" width="640" height="420" alt="Output from chart_doughnut.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Doughnut chart in Excel::Writer::XLSX.
      #
      # The demo also shows how to set segment colours. It is possible to define
      # chart colors for most types of Excel::Writer::XLSX charts via the
      # add_series() method. However, Pie and Doughtnut charts are a special case
      # since each segment is represented as a point so it is necessary to assign
      # formatting to each point in the series.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_doughnut.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Category', 'Values' ];
      my $data = [
          [ 'Glazed', 'Chocolate', 'Cream' ],
          [ 50,       35,          15      ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'doughnut', embedded => 1 );
      
      # Configure the series. Note the use of the array ref to define ranges:
      # [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      # See below for an alternative syntax.
      $chart1->add_series(
          name       => 'Doughnut sales data',
          categories => [ 'Sheet1', 1, 3, 0, 0 ],
          values     => [ 'Sheet1', 1, 3, 1, 1 ],
      );
      
      # Add a title.
      $chart1->set_title( name => 'Popular Doughnut Types' );
      
      # Set an Excel chart style. Colors with white outline and shadow.
      $chart1->set_style( 10 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C2', $chart1, 25, 10 );
      
      
      #
      # Create a Doughnut chart with user defined segment colors.
      #
      
      # Create an example Doughnut chart like above.
      my $chart2 = $workbook->add_chart( type => 'doughnut', embedded => 1 );
      
      # Configure the series and add user defined segment colours.
      $chart2->add_series(
          name       => 'Doughnut sales data',
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
          points     => [
              { fill => { color => '#FA58D0' } },
              { fill => { color => '#61210B' } },
              { fill => { color => '#F5F6CE' } },
          ],
      );
      
      # Add a title.
      $chart2->set_title( name => 'Doughnut Chart with user defined colors' );
      
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C18', $chart2, 25, 10 );
      
      
      #
      # Create a Doughnut chart with rotation of the segments.
      #
      
      # Create an example Doughnut chart like above.
      my $chart3 = $workbook->add_chart( type => 'doughnut', embedded => 1 );
      
      # Configure the series.
      $chart3->add_series(
          name       => 'Doughnut sales data',
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
      );
      
      # Add a title.
      $chart3->set_title( name => 'Doughnut Chart with segment rotation' );
      
      # Change the angle/rotation of the first segment.
      $chart3->set_rotation(90);
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C34', $chart3, 25, 10 );
      
      
      #
      # Create a Doughnut chart with user defined hole size.
      #
      
      # Create an example Doughnut chart like above.
      my $chart4 = $workbook->add_chart( type => 'doughnut', embedded => 1 );
      
      # Configure the series.
      $chart4->add_series(
          name       => 'Doughnut sales data',
          categories => '=Sheet1!$A$2:$A$4',
          values     => '=Sheet1!$B$2:$B$4',
      );
      
      # Add a title.
      $chart4->set_title( name => 'Doughnut Chart with user defined hole size' );
      
      # Change the hole size.
      $chart4->set_hole_size(33);
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'C50', $chart4, 25, 10 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_doughnut.pl>
  
  =head2 Example: chart_radar.pl
  
  
  
  A demo of an Radar chart in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_radar.jpg" width="640" height="420" alt="Output from chart_radar.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of an Radar chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), October 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_radar.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 30, 60, 70, 50, 40, 30 ],
          [ 25, 40, 50, 30, 50, 40 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'radar', embedded => 1 );
      
      # Configure the first series.
      $chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart1->set_title ( name => 'Results of sample analysis' );
      $chart1->set_x_axis( name => 'Test number' );
      $chart1->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart1->set_style( 11 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #
      # Create a with_markers chart sub-type
      #
      my $chart2 = $workbook->add_chart(
          type     => 'radar',
          embedded => 1,
          subtype  => 'with_markers'
      );
      
      # Configure the first series.
      $chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart2->set_title ( name => 'Stacked Chart' );
      $chart2->set_x_axis( name => 'Test number' );
      $chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart2->set_style( 12 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 11 );
      
      
      #
      # Create a filled chart sub-type
      #
      my $chart3 = $workbook->add_chart(
          type     => 'radar',
          embedded => 1,
          subtype  => 'filled'
      );
      
      # Configure the first series.
      $chart3->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart3->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart3->set_title ( name => 'Percent Stacked Chart' );
      $chart3->set_x_axis( name => 'Test number' );
      $chart3->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart3->set_style( 13 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D34', $chart3, 25, 11 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_radar.pl>
  
  =head2 Example: chart_scatter.pl
  
  
  
  A demo of a Scatter chart in Excel::Writer::XLSX. Other subtypes are
  also supported such as markers_only (the default), straight_with_markers,
  straight, smooth_with_markers and smooth. See the main documentation for
  more details.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_scatter.jpg" width="640" height="420" alt="Output from chart_scatter.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Scatter chart in Excel::Writer::XLSX. Other subtypes are
      # also supported such as markers_only (the default), straight_with_markers,
      # straight, smooth_with_markers and smooth. See the main documentation for
      # more details.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_scatter.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart1 = $workbook->add_chart( type => 'scatter', embedded => 1 );
      
      # Configure the first series.
      $chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart1->set_title ( name => 'Results of sample analysis' );
      $chart1->set_x_axis( name => 'Test number' );
      $chart1->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart1->set_style( 11 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #
      # Create a scatter chart sub-type with straight lines and markers.
      #
      my $chart2 = $workbook->add_chart(
          type     => 'scatter',
          embedded => 1,
          subtype  => 'straight_with_markers'
      );
      
      # Configure the first series.
      $chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart2->set_title ( name => 'Straight line with markers' );
      $chart2->set_x_axis( name => 'Test number' );
      $chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart2->set_style( 12 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 11 );
      
      
      #
      # Create a scatter chart sub-type with straight lines and no markers.
      #
      my $chart3 = $workbook->add_chart(
          type     => 'scatter',
          embedded => 1,
          subtype  => 'straight'
      );
      
      # Configure the first series.
      $chart3->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart3->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart3->set_title ( name => 'Straight line' );
      $chart3->set_x_axis( name => 'Test number' );
      $chart3->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart3->set_style( 13 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D34', $chart3, 25, 11 );
      
      
      #
      # Create a scatter chart sub-type with smooth lines and markers.
      #
      my $chart4 = $workbook->add_chart(
          type     => 'scatter',
          embedded => 1,
          subtype  => 'smooth_with_markers'
      );
      
      # Configure the first series.
      $chart4->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart4->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart4->set_title ( name => 'Smooth line with markers' );
      $chart4->set_x_axis( name => 'Test number' );
      $chart4->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart4->set_style( 14 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D51', $chart4, 25, 11 );
      
      
      #
      # Create a scatter chart sub-type with smooth lines and no markers.
      #
      my $chart5 = $workbook->add_chart(
          type     => 'scatter',
          embedded => 1,
          subtype  => 'smooth'
      );
      
      # Configure the first series.
      $chart5->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart5->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart5->set_title ( name => 'Smooth line' );
      $chart5->set_x_axis( name => 'Test number' );
      $chart5->set_y_axis( name => 'Sample length (mm)' );
      
      # Set an Excel chart style. Blue colors with white outline and shadow.
      $chart5->set_style( 15 );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D66', $chart5, 25, 11 );
      
      
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_scatter.pl>
  
  =head2 Example: chart_secondary_axis.pl
  
  
  
  A demo of a Line chart with a secondary axis in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_secondary_axis.jpg" width="640" height="420" alt="Output from chart_secondary_axis.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Line chart with a secondary axis in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_secondary_axis.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Aliens', 'Humans', ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
      
      ];
      
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure a series with a secondary axis
      $chart->add_series(
          name    => '=Sheet1!$A$1',
          values  => '=Sheet1!$A$2:$A$7',
          y2_axis => 1,
      );
      
      $chart->add_series(
          name   => '=Sheet1!$B$1',
          values => '=Sheet1!$B$2:$B$7',
      );
      
      $chart->set_legend( position => 'right' );
      
      # Add a chart title and some axis labels.
      $chart->set_title( name => 'Survey results' );
      $chart->set_x_axis( name => 'Days', );
      $chart->set_y_axis( name => 'Population', major_gridlines => { visible => 0 } );
      $chart->set_y2_axis( name => 'Laser wounds' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart, 25, 10 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_secondary_axis.pl>
  
  =head2 Example: chart_combined.pl
  
  
  
  An example of a Combined chart in Excel::Writer::XLSX.
  
  
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # An example of a Combined chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2015, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_combined.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      #
      # In the first example we will create a combined column and line chart.
      # They will share the same X and Y axes.
      #
      
      # Create a new column chart. This will use this as the primary chart.
      my $column_chart1 = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the data series for the primary chart.
      $column_chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Create a new column chart. This will use this as the secondary chart.
      my $line_chart1 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the data series for the secondary chart.
      $line_chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
      
      # Combine the charts.
      $column_chart1->combine( $line_chart1 );
      
      # Add a chart title and some axis labels. Note, this is done via the
      # primary chart.
      $column_chart1->set_title( name => 'Combined chart - same Y axis' );
      $column_chart1->set_x_axis( name => 'Test number' );
      $column_chart1->set_y_axis( name => 'Sample length (mm)' );
      
      
      # Insert the chart into the worksheet
      $worksheet->insert_chart( 'E2', $column_chart1 );
      
      #
      # In the second example we will create a similar combined column and line
      # chart except that the secondary chart will have a secondary Y axis.
      #
      
      # Create a new column chart. This will use this as the primary chart.
      my $column_chart2 = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the data series for the primary chart.
      $column_chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Create a new column chart. This will use this as the secondary chart.
      my $line_chart2 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the data series for the secondary chart. We also set a
      # secondary Y axis via (y2_axis). This is the only difference between
      # this and the first example, apart from the axis label below.
      $line_chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          y2_axis    => 1,
      );
      
      # Combine the charts.
      $column_chart2->combine( $line_chart2 );
      
      # Add a chart title and some axis labels.
      $column_chart2->set_title(  name => 'Combine chart - secondary Y axis' );
      $column_chart2->set_x_axis( name => 'Test number' );
      $column_chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Note: the y2 properites are on the secondary chart.
      $line_chart2->set_y2_axis( name => 'Target length (mm)' );
      
      
      # Insert the chart into the worksheet
      $worksheet->insert_chart( 'E18', $column_chart2 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_combined.pl>
  
  =head2 Example: chart_pareto.pl
  
  
  
  A demo of a Pareto chart in Excel::Writer::XLSX.
  
  
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Pareto chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2015, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_pareto.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Formats used in the workbook.
      my $bold           = $workbook->add_format( bold       => 1 );
      my $percent_format = $workbook->add_format( num_format => '0.0%' );
      
      
      # Widen the columns for visibility.
      $worksheet->set_column( 'A:A', 15 );
      $worksheet->set_column( 'B:C', 10 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Reason', 'Number', 'Percentage' ];
      
      my $reasons = [
          'Traffic',   'Child care', 'Public Transport', 'Weather',
          'Overslept', 'Emergency',
      ];
      
      my $numbers  = [ 60,   40,    20,  15,  10,    5 ];
      my $percents = [ 0.44, 0.667, 0.8, 0.9, 0.967, 1 ];
      
      $worksheet->write_row( 'A1', $headings, $bold );
      $worksheet->write_col( 'A2', $reasons );
      $worksheet->write_col( 'B2', $numbers );
      $worksheet->write_col( 'C2', $percents, $percent_format );
      
      
      # Create a new column chart. This will be the primary chart.
      my $column_chart = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Add a series.
      $column_chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Add a chart title.
      $column_chart->set_title( name => 'Reasons for lateness' );
      
      # Turn off the chart legend.
      $column_chart->set_legend( position => 'none' );
      
      # Set the title and scale of the Y axes. Note, the secondary axis is set from
      # the primary chart.
      $column_chart->set_y_axis(
          name => 'Respondents (number)',
          min  => 0,
          max  => 120
      );
      $column_chart->set_y2_axis( max => 1 );
      
      # Create a new line chart. This will be the secondary chart.
      my $line_chart = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Add a series, on the secondary axis.
      $line_chart->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          marker     => { type => 'automatic' },
          y2_axis    => 1,
      );
      
      
      # Combine the charts.
      $column_chart->combine( $line_chart );
      
      # Insert the chart into the worksheet.
      $worksheet->insert_chart( 'F2', $column_chart );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_pareto.pl>
  
  =head2 Example: chart_stock.pl
  
  
  
  A demo of a Stock chart in Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_stock.jpg" width="640" height="420" alt="Output from chart_stock.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a Stock chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      use Excel::Writer::XLSX;
      
      my $workbook    = Excel::Writer::XLSX->new( 'chart_stock.xlsx' );
      my $worksheet   = $workbook->add_worksheet();
      my $bold        = $workbook->add_format( bold => 1 );
      my $date_format = $workbook->add_format( num_format => 'dd/mm/yyyy' );
      my $chart       = $workbook->add_chart( type => 'stock', embedded => 1 );
      
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Date', 'High', 'Low', 'Close' ];
      my $data = [
      
          [ '2007-01-01T', '2007-01-02T', '2007-01-03T', '2007-01-04T', '2007-01-05T' ],
          [ 27.2,  25.03, 19.05, 20.34, 18.5 ],
          [ 23.49, 19.55, 15.12, 17.84, 16.34 ],
          [ 25.45, 23.05, 17.32, 20.45, 17.34 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      
      for my $row ( 0 .. 4 ) {
          $worksheet->write_date_time( $row+1, 0, $data->[0]->[$row], $date_format );
          $worksheet->write( $row+1, 1, $data->[1]->[$row] );
          $worksheet->write( $row+1, 2, $data->[2]->[$row] );
          $worksheet->write( $row+1, 3, $data->[3]->[$row] );
      
      }
      
      $worksheet->set_column( 'A:D', 11 );
      
      # Add a series for each of the High-Low-Close columns.
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$B$2:$B$6',
      );
      
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$C$2:$C$6',
      );
      
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$6',
          values     => '=Sheet1!$D$2:$D$6',
      );
      
      # Add a chart title and some axis labels.
      $chart->set_title ( name => 'High-Low-Close', );
      $chart->set_x_axis( name => 'Date', );
      $chart->set_y_axis( name => 'Share price', );
      
      
      $worksheet->insert_chart( 'E9', $chart );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_stock.pl>
  
  =head2 Example: chart_data_table.pl
  
  
  
  A demo of an Column chart with a data table on the X-axis using
  Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_data_table.jpg" width="640" height="420" alt="Output from chart_data_table.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of an Column chart with a data table on the X-axis using
      # Excel::Writer::XLSX.
      #
      # reverse ('(c)'), December 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_data_table.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Batch 1', 'Batch 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      # Create a column chart with a data table.
      my $chart1 = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the first series.
      $chart1->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series. Note alternative use of array ref to define
      # ranges: [ $sheetname, $row_start, $row_end, $col_start, $col_end ].
      $chart1->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart1->set_title( name => 'Chart with Data Table' );
      $chart1->set_x_axis( name => 'Test number' );
      $chart1->set_y_axis( name => 'Sample length (mm)' );
      
      # Set a default data table on the X-Axis.
      $chart1->set_table();
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #
      # Create a second chart.
      #
      my $chart2 = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the first series.
      $chart2->add_series(
          name       => '=Sheet1!$B$1',
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure second series.
      $chart2->add_series(
          name       => '=Sheet1!$C$1',
          categories => [ 'Sheet1', 1, 6, 0, 0 ],
          values     => [ 'Sheet1', 1, 6, 2, 2 ],
      );
      
      # Add a chart title and some axis labels.
      $chart2->set_title( name => 'Data Table with legend keys' );
      $chart2->set_x_axis( name => 'Test number' );
      $chart2->set_y_axis( name => 'Sample length (mm)' );
      
      # Set a data table on the X-Axis with the legend keys showm.
      $chart2->set_table( show_keys => 1 );
      
      # Hide the chart legend since the keys are show on the data table.
      $chart2->set_legend( position => 'none' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 11 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_data_table.pl>
  
  =head2 Example: chart_data_tools.pl
  
  
  
  A demo of an various Excel chart data tools that are available via
  an Excel::Writer::XLSX chart.
  
  These include, Trendlines, Data Labels, Error Bars, Drop Lines,
  High-Low Lines and Up-Down Bars.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/chart_data_tools.jpg" width="640" height="420" alt="Output from chart_data_tools.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of an various Excel chart data tools that are available via
      # an Excel::Writer::XLSX chart.
      #
      # These include, Trendlines, Data Labels, Error Bars, Drop Lines,
      # High-Low Lines and Up-Down Bars.
      #
      # reverse ('(c)'), December 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_data_tools.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Number', 'Data 1', 'Data 2' ];
      my $data = [
          [ 2,  3,  4,  5,  6,  7 ],
          [ 10, 40, 50, 20, 10, 50 ],
          [ 30, 60, 70, 50, 40, 30 ],
      
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write( 'A2', $data );
      
      
      #######################################################################
      #
      # Trendline example.
      #
      
      # Create a Line chart.
      my $chart1 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the first series with a polynomial trendline.
      $chart1->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
          trendline  => {
              type  => 'polynomial',
              order => 3,
          },
      );
      
      # Configure the second series with a moving average trendline.
      $chart1->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
          trendline  => { type => 'linear' },
      );
      
      # Add a chart title. and some axis labels.
      $chart1->set_title( name => 'Chart with Trendlines' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D2', $chart1, 25, 10 );
      
      
      #######################################################################
      #
      # Data Labels and Markers example.
      #
      
      # Create a Line chart.
      my $chart2 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the first series.
      $chart2->add_series(
          categories  => '=Sheet1!$A$2:$A$7',
          values      => '=Sheet1!$B$2:$B$7',
          data_labels => { value => 1 },
          marker      => { type => 'automatic' },
      );
      
      # Configure the second series.
      $chart2->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
      
      # Add a chart title. and some axis labels.
      $chart2->set_title( name => 'Chart with Data Labels and Markers' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D18', $chart2, 25, 10 );
      
      
      #######################################################################
      #
      # Error Bars example.
      #
      
      # Create a Line chart.
      my $chart3 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Configure the first series.
      $chart3->add_series(
          categories   => '=Sheet1!$A$2:$A$7',
          values       => '=Sheet1!$B$2:$B$7',
          y_error_bars => { type => 'standard_error' },
      );
      
      # Configure the second series.
      $chart3->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
      
      # Add a chart title. and some axis labels.
      $chart3->set_title( name => 'Chart with Error Bars' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D34', $chart3, 25, 10 );
      
      
      #######################################################################
      #
      # Up-Down Bars example.
      #
      
      # Create a Line chart.
      my $chart4 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Add the Up-Down Bars.
      $chart4->set_up_down_bars();
      
      # Configure the first series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure the second series.
      $chart4->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
      
      # Add a chart title. and some axis labels.
      $chart4->set_title( name => 'Chart with Up-Down Bars' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D50', $chart4, 25, 10 );
      
      
      #######################################################################
      #
      # High-Low Lines example.
      #
      
      # Create a Line chart.
      my $chart5 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Add the High-Low lines.
      $chart5->set_high_low_lines();
      
      # Configure the first series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure the second series.
      $chart5->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
      
      # Add a chart title. and some axis labels.
      $chart5->set_title( name => 'Chart with High-Low Lines' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D66', $chart5, 25, 10 );
      
      
      #######################################################################
      #
      # Drop Lines example.
      #
      
      # Create a Line chart.
      my $chart6 = $workbook->add_chart( type => 'line', embedded => 1 );
      
      # Add Drop Lines.
      $chart6->set_drop_lines();
      
      # Configure the first series.
      $chart6->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$B$2:$B$7',
      );
      
      # Configure the second series.
      $chart6->add_series(
          categories => '=Sheet1!$A$2:$A$7',
          values     => '=Sheet1!$C$2:$C$7',
      );
      
      # Add a chart title. and some axis labels.
      $chart6->set_title( name => 'Chart with Drop Lines' );
      
      # Insert the chart into the worksheet (with an offset).
      $worksheet->insert_chart( 'D82', $chart6, 25, 10 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_data_tools.pl>
  
  =head2 Example: chart_clustered.pl
  
  
  
  A demo of a clustered category chart in Excel::Writer::XLSX.
  
  
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A demo of a clustered category chart in Excel::Writer::XLSX.
      #
      # reverse ('(c)'), March 2015, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'chart_clustered.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      # Add the worksheet data that the charts will refer to.
      my $headings = [ 'Types',  'Sub Type',   'Value 1', 'Value 2', 'Value 3' ];
      my $data = [
          [ 'Type 1', 'Sub Type A', 5000,      8000,      6000 ],
          [ '',       'Sub Type B', 2000,      3000,      4000 ],
          [ '',       'Sub Type C', 250,       1000,      2000 ],
          [ 'Type 2', 'Sub Type D', 6000,      6000,      6500 ],
          [ '',       'Sub Type E', 500,       300,       200 ],
      ];
      
      $worksheet->write( 'A1', $headings, $bold );
      $worksheet->write_col( 'A2', $data );
      
      # Create a new chart object. In this case an embedded chart.
      my $chart = $workbook->add_chart( type => 'column', embedded => 1 );
      
      # Configure the series. Note, that the categories are 2D ranges (from column A
      # to column B). This creates the clusters. The series are shown as formula
      # strings for clarity but you can also use the array syntax. See the docs.
      $chart->add_series(
          name       => '=Sheet1!$C$1',
          categories => '=Sheet1!$A$2:$B$6',
          values     => '=Sheet1!$C$2:$C$6',
      );
      
      $chart->add_series(
          name       => '=Sheet1!$D$1',
          categories => '=Sheet1!$A$2:$B$6',
          values     => '=Sheet1!$D$2:$D$6',
      );
      
      $chart->add_series(
          name       => '=Sheet1!$E$1',
          categories => '=Sheet1!$A$2:$B$6',
          values     => '=Sheet1!$E$2:$E$6',
      );
      
      # Set the Excel chart style.
      $chart->set_style( 37 );
      
      # Turn off the legend.
      $chart->set_legend( position => 'none' );
      
      # Insert the chart into the worksheet.
      $worksheet->insert_chart( 'G3', $chart );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_clustered.pl>
  
  =head2 Example: chart_styles.pl
  
  
  
  An example showing all 48 default chart styles available in Excel 2007
  using Excel::Writer::XLSX.. Note, these styles are not the same as the
  styles available in Excel 2013.
  
  
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # An example showing all 48 default chart styles available in Excel 2007
      # using Excel::Writer::XLSX.. Note, these styles are not the same as the
      # styles available in Excel 2013.
      #
      # reverse ('(c)'), March 2015, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'chart_styles.xlsx' );
      
      # Show the styles for all of these chart types.
      my @chart_types = ( 'column', 'area', 'line', 'pie' );
      
      
      for my $chart_type ( @chart_types ) {
      
          # Add a worksheet for each chart type.
          my $worksheet = $workbook->add_worksheet( ucfirst( $chart_type ) );
          $worksheet->set_zoom( 30 );
          my $style_number = 1;
      
          # Create 48 charts, each with a different style.
          for ( my $row_num = 0 ; $row_num < 90 ; $row_num += 15 ) {
              for ( my $col_num = 0 ; $col_num < 64 ; $col_num += 8 ) {
      
                  my $chart = $workbook->add_chart(
                      type     => $chart_type,
                      embedded => 1
                  );
      
                  $chart->add_series( values => '=Data!$A$1:$A$6' );
                  $chart->set_title( name => 'Style ' . $style_number );
                  $chart->set_legend( none => 1 );
                  $chart->set_style( $style_number );
      
                  $worksheet->insert_chart( $row_num, $col_num, $chart );
                  $style_number++;
              }
          }
      }
      
      # Create a worksheet with data for the charts.
      my $data = [ 10, 40, 50, 20, 10, 50 ];
      my $data_worksheet = $workbook->add_worksheet( 'Data' );
      $data_worksheet->write_col( 'A1', $data );
      $data_worksheet->hide();
      
      $workbook->close();
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/chart_styles.pl>
  
  =head2 Example: colors.pl
  
  
  
  Demonstrates Excel::Writer::XLSX's named colours and the Excel colour
  palette.
  
  The set_custom_color() Worksheet method can be used to override one of the
  built-in palette values with a more suitable colour. See the main docs.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/colors.jpg" width="640" height="420" alt="Output from colors.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ################################################################################
      #
      # Demonstrates Excel::Writer::XLSX's named colours and the Excel colour
      # palette.
      #
      # The set_custom_color() Worksheet method can be used to override one of the
      # built-in palette values with a more suitable colour. See the main docs.
      #
      # reverse ('(c)'), March 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'colors.xlsx' );
      
      # Some common formats
      my $center = $workbook->add_format( align => 'center' );
      my $heading = $workbook->add_format( align => 'center', bold => 1 );
      
      
      ######################################################################
      #
      # Demonstrate the named colors.
      #
      
      my %colors = (
          0x08, 'black',
          0x0C, 'blue',
          0x10, 'brown',
          0x0F, 'cyan',
          0x17, 'gray',
          0x11, 'green',
          0x0B, 'lime',
          0x0E, 'magenta',
          0x12, 'navy',
          0x35, 'orange',
          0x21, 'pink',
          0x14, 'purple',
          0x0A, 'red',
          0x16, 'silver',
          0x09, 'white',
          0x0D, 'yellow',
      
      );
      
      my $worksheet1 = $workbook->add_worksheet( 'Named colors' );
      
      $worksheet1->set_column( 0, 3, 15 );
      
      $worksheet1->write( 0, 0, "Index", $heading );
      $worksheet1->write( 0, 1, "Index", $heading );
      $worksheet1->write( 0, 2, "Name",  $heading );
      $worksheet1->write( 0, 3, "Color", $heading );
      
      my $i = 1;
      
      while ( my ( $index, $color ) = each %colors ) {
          my $format = $workbook->add_format(
              fg_color => $color,
              pattern  => 1,
              border   => 1
          );
      
          $worksheet1->write( $i + 1, 0, $index, $center );
          $worksheet1->write( $i + 1, 1, sprintf( "0x%02X", $index ), $center );
          $worksheet1->write( $i + 1, 2, $color, $center );
          $worksheet1->write( $i + 1, 3, '',     $format );
          $i++;
      }
      
      
      ######################################################################
      #
      # Demonstrate the standard Excel colors in the range 8..63.
      #
      
      my $worksheet2 = $workbook->add_worksheet( 'Standard colors' );
      
      $worksheet2->set_column( 0, 3, 15 );
      
      $worksheet2->write( 0, 0, "Index", $heading );
      $worksheet2->write( 0, 1, "Index", $heading );
      $worksheet2->write( 0, 2, "Color", $heading );
      $worksheet2->write( 0, 3, "Name",  $heading );
      
      for my $i ( 8 .. 63 ) {
          my $format = $workbook->add_format(
              fg_color => $i,
              pattern  => 1,
              border   => 1
          );
      
          $worksheet2->write( ( $i - 7 ), 0, $i, $center );
          $worksheet2->write( ( $i - 7 ), 1, sprintf( "0x%02X", $i ), $center );
          $worksheet2->write( ( $i - 7 ), 2, '', $format );
      
          # Add the  color names
          if ( exists $colors{$i} ) {
              $worksheet2->write( ( $i - 7 ), 3, $colors{$i}, $center );
      
          }
      }
      
      
      ######################################################################
      #
      # Demonstrate the Html colors.
      #
      
      
      
      %colors = (
      	'#000000',  'black',
      	'#0000FF',  'blue',
      	'#800000',  'brown',
      	'#00FFFF',  'cyan',
      	'#808080',  'gray',
      	'#008000',  'green',
      	'#00FF00',  'lime',
      	'#FF00FF',  'magenta',
      	'#000080',  'navy',
      	'#FF6600',  'orange',
      	'#FF00FF',  'pink',
      	'#800080',  'purple',
      	'#FF0000',  'red',
      	'#C0C0C0',  'silver',
      	'#FFFFFF',  'white',
      	'#FFFF00',  'yellow',
      );
      
      my $worksheet3 = $workbook->add_worksheet( 'Html colors' );
      
      $worksheet3->set_column( 0, 3, 15 );
      
      $worksheet3->write( 0, 0, "Html", $heading );
      $worksheet3->write( 0, 1, "Name",  $heading );
      $worksheet3->write( 0, 2, "Color", $heading );
      
      $i = 1;
      
      while ( my ( $html_color, $color ) = each %colors ) {
          my $format = $workbook->add_format(
              fg_color => $html_color,
              pattern  => 1,
              border   => 1
          );
      
          $worksheet3->write( $i + 1, 1, $html_color, $center );
          $worksheet3->write( $i + 1, 2, $color,      $center );
          $worksheet3->write( $i + 1, 3, '',          $format );
          $i++;
      }
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/colors.pl>
  
  =head2 Example: comments1.pl
  
  
  
  This example demonstrates writing cell comments.
  
  A cell comment is indicated in Excel by a small red triangle in the upper
  right-hand corner of the cell.
  
  For more advanced comment options see comments2.pl.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/comments1.jpg" width="640" height="420" alt="Output from comments1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # This example demonstrates writing cell comments.
      #
      # A cell comment is indicated in Excel by a small red triangle in the upper
      # right-hand corner of the cell.
      #
      # For more advanced comment options see comments2.pl.
      #
      # reverse ('(c)'), November 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'comments1.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      $worksheet->write( 'A1', 'Hello' );
      $worksheet->write_comment( 'A1', 'This is a comment' );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/comments1.pl>
  
  =head2 Example: comments2.pl
  
  
  
  This example demonstrates writing cell comments.
  
  A cell comment is indicated in Excel by a small red triangle in the upper
  right-hand corner of the cell.
  
  Each of the worksheets demonstrates different features of cell comments.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/comments2.jpg" width="640" height="420" alt="Output from comments2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # This example demonstrates writing cell comments.
      #
      # A cell comment is indicated in Excel by a small red triangle in the upper
      # right-hand corner of the cell.
      #
      # Each of the worksheets demonstrates different features of cell comments.
      #
      # reverse ('(c)'), November 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook   = Excel::Writer::XLSX->new( 'comments2.xlsx' );
      my $text_wrap  = $workbook->add_format( text_wrap => 1, valign => 'top' );
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      my $worksheet5 = $workbook->add_worksheet();
      my $worksheet6 = $workbook->add_worksheet();
      my $worksheet7 = $workbook->add_worksheet();
      my $worksheet8 = $workbook->add_worksheet();
      
      
      # Variables that we will use in each example.
      my $cell_text = '';
      my $comment   = '';
      
      
      ###############################################################################
      #
      # Example 1. Demonstrates a simple cell comments without formatting.
      #            comments.
      #
      
      # Set up some formatting.
      $worksheet1->set_column( 'C:C', 25 );
      $worksheet1->set_row( 2, 50 );
      $worksheet1->set_row( 5, 50 );
      
      
      # Simple ascii string.
      $cell_text = 'Hold the mouse over this cell to see the comment.';
      
      $comment = 'This is a comment.';
      
      $worksheet1->write( 'C3', $cell_text, $text_wrap );
      $worksheet1->write_comment( 'C3', $comment );
      
      $cell_text = 'This is a UTF-8 string.';
      $comment   = chr 0x263a;
      
      $worksheet1->write( 'C6', $cell_text, $text_wrap );
      $worksheet1->write_comment( 'C6', $comment );
      
      
      
      ###############################################################################
      #
      # Example 2. Demonstrates visible and hidden comments.
      #
      
      # Set up some formatting.
      $worksheet2->set_column( 'C:C', 25 );
      $worksheet2->set_row( 2, 50 );
      $worksheet2->set_row( 5, 50 );
      
      
      $cell_text = 'This cell comment is visible.';
      
      $comment = 'Hello.';
      
      $worksheet2->write( 'C3', $cell_text, $text_wrap );
      $worksheet2->write_comment( 'C3', $comment, visible => 1 );
      
      
      $cell_text = "This cell comment isn't visible (the default).";
      
      $comment = 'Hello.';
      
      $worksheet2->write( 'C6', $cell_text, $text_wrap );
      $worksheet2->write_comment( 'C6', $comment );
      
      
      ###############################################################################
      #
      # Example 3. Demonstrates visible and hidden comments set at the worksheet
      #            level.
      #
      
      # Set up some formatting.
      $worksheet3->set_column( 'C:C', 25 );
      $worksheet3->set_row( 2, 50 );
      $worksheet3->set_row( 5, 50 );
      $worksheet3->set_row( 8, 50 );
      
      # Make all comments on the worksheet visible.
      $worksheet3->show_comments();
      
      $cell_text = 'This cell comment is visible, explicitly.';
      
      $comment = 'Hello.';
      
      $worksheet3->write( 'C3', $cell_text, $text_wrap );
      $worksheet3->write_comment( 'C3', $comment, visible => 1 );
      
      
      $cell_text =
        'This cell comment is also visible because ' . 'we used show_comments().';
      
      $comment = 'Hello.';
      
      $worksheet3->write( 'C6', $cell_text, $text_wrap );
      $worksheet3->write_comment( 'C6', $comment );
      
      
      $cell_text = 'However, we can still override it locally.';
      
      $comment = 'Hello.';
      
      $worksheet3->write( 'C9', $cell_text, $text_wrap );
      $worksheet3->write_comment( 'C9', $comment, visible => 0 );
      
      
      ###############################################################################
      #
      # Example 4. Demonstrates changes to the comment box dimensions.
      #
      
      # Set up some formatting.
      $worksheet4->set_column( 'C:C', 25 );
      $worksheet4->set_row( 2,  50 );
      $worksheet4->set_row( 5,  50 );
      $worksheet4->set_row( 8,  50 );
      $worksheet4->set_row( 15, 50 );
      
      $worksheet4->show_comments();
      
      $cell_text = 'This cell comment is default size.';
      
      $comment = 'Hello.';
      
      $worksheet4->write( 'C3', $cell_text, $text_wrap );
      $worksheet4->write_comment( 'C3', $comment );
      
      
      $cell_text = 'This cell comment is twice as wide.';
      
      $comment = 'Hello.';
      
      $worksheet4->write( 'C6', $cell_text, $text_wrap );
      $worksheet4->write_comment( 'C6', $comment, x_scale => 2 );
      
      
      $cell_text = 'This cell comment is twice as high.';
      
      $comment = 'Hello.';
      
      $worksheet4->write( 'C9', $cell_text, $text_wrap );
      $worksheet4->write_comment( 'C9', $comment, y_scale => 2 );
      
      
      $cell_text = 'This cell comment is scaled in both directions.';
      
      $comment = 'Hello.';
      
      $worksheet4->write( 'C16', $cell_text, $text_wrap );
      $worksheet4->write_comment( 'C16', $comment, x_scale => 1.2, y_scale => 0.8 );
      
      
      $cell_text = 'This cell comment has width and height specified in pixels.';
      
      $comment = 'Hello.';
      
      $worksheet4->write( 'C19', $cell_text, $text_wrap );
      $worksheet4->write_comment( 'C19', $comment, width => 200, height => 20 );
      
      
      ###############################################################################
      #
      # Example 5. Demonstrates changes to the cell comment position.
      #
      
      $worksheet5->set_column( 'C:C', 25 );
      $worksheet5->set_row( 2,  50 );
      $worksheet5->set_row( 5,  50 );
      $worksheet5->set_row( 8,  50 );
      $worksheet5->set_row( 11, 50 );
      
      $worksheet5->show_comments();
      
      $cell_text = 'This cell comment is in the default position.';
      
      $comment = 'Hello.';
      
      $worksheet5->write( 'C3', $cell_text, $text_wrap );
      $worksheet5->write_comment( 'C3', $comment );
      
      
      $cell_text = 'This cell comment has been moved to another cell.';
      
      $comment = 'Hello.';
      
      $worksheet5->write( 'C6', $cell_text, $text_wrap );
      $worksheet5->write_comment( 'C6', $comment, start_cell => 'E4' );
      
      
      $cell_text = 'This cell comment has been moved to another cell.';
      
      $comment = 'Hello.';
      
      $worksheet5->write( 'C9', $cell_text, $text_wrap );
      $worksheet5->write_comment( 'C9', $comment, start_row => 8, start_col => 4 );
      
      
      $cell_text = 'This cell comment has been shifted within its default cell.';
      
      $comment = 'Hello.';
      
      $worksheet5->write( 'C12', $cell_text, $text_wrap );
      $worksheet5->write_comment( 'C12', $comment, x_offset => 30, y_offset => 12 );
      
      
      ###############################################################################
      #
      # Example 6. Demonstrates changes to the comment background colour.
      #
      
      $worksheet6->set_column( 'C:C', 25 );
      $worksheet6->set_row( 2, 50 );
      $worksheet6->set_row( 5, 50 );
      $worksheet6->set_row( 8, 50 );
      
      $worksheet6->show_comments();
      
      $cell_text = 'This cell comment has a different colour.';
      
      $comment = 'Hello.';
      
      $worksheet6->write( 'C3', $cell_text, $text_wrap );
      $worksheet6->write_comment( 'C3', $comment, color => 'green' );
      
      
      $cell_text = 'This cell comment has the default colour.';
      
      $comment = 'Hello.';
      
      $worksheet6->write( 'C6', $cell_text, $text_wrap );
      $worksheet6->write_comment( 'C6', $comment );
      
      
      $cell_text = 'This cell comment has a different colour.';
      
      $comment = 'Hello.';
      
      $worksheet6->write( 'C9', $cell_text, $text_wrap );
      $worksheet6->write_comment( 'C9', $comment, color => '#FF6600' );
      
      
      ###############################################################################
      #
      # Example 7. Demonstrates how to set the cell comment author.
      #
      
      $worksheet7->set_column( 'C:C', 30 );
      $worksheet7->set_row( 2,  50 );
      $worksheet7->set_row( 5,  50 );
      $worksheet7->set_row( 8,  50 );
      
      my $author = '';
      my $cell   = 'C3';
      
      $cell_text = "Move the mouse over this cell and you will see 'Cell commented "
        . "by $author' (blank) in the status bar at the bottom";
      
      $comment = 'Hello.';
      
      $worksheet7->write( $cell, $cell_text, $text_wrap );
      $worksheet7->write_comment( $cell, $comment );
      
      
      $author    = 'Perl';
      $cell      = 'C6';
      $cell_text = "Move the mouse over this cell and you will see 'Cell commented "
        . "by $author' in the status bar at the bottom";
      
      $comment = 'Hello.';
      
      $worksheet7->write( $cell, $cell_text, $text_wrap );
      $worksheet7->write_comment( $cell, $comment, author => $author );
      
      
      $author    = chr 0x20AC;
      $cell      = 'C9';
      $cell_text = "Move the mouse over this cell and you will see 'Cell commented "
        . "by $author' in the status bar at the bottom";
      $comment = 'Hello.';
      
      $worksheet7->write( $cell, $cell_text, $text_wrap );
      $worksheet7->write_comment( $cell, $comment, author => $author );
      
      
      
      
      ###############################################################################
      #
      # Example 8. Demonstrates the need to explicitly set the row height.
      #
      
      # Set up some formatting.
      $worksheet8->set_column( 'C:C', 25 );
      $worksheet8->set_row( 2, 80 );
      
      $worksheet8->show_comments();
      
      
      $cell_text =
          'The height of this row has been adjusted explicitly using '
        . 'set_row(). The size of the comment box is adjusted '
        . 'accordingly by Excel::Writer::XLSX.';
      
      $comment = 'Hello.';
      
      $worksheet8->write( 'C3', $cell_text, $text_wrap );
      $worksheet8->write_comment( 'C3', $comment );
      
      
      $cell_text =
          'The height of this row has been adjusted by Excel due to the '
        . 'text wrap property being set. Unfortunately this means that '
        . 'the height of the row is unknown to Excel::Writer::XLSX at '
        . "run time and thus the comment box is stretched as well.\n\n"
        . 'Use set_row() to specify the row height explicitly to avoid '
        . 'this problem.';
      
      $comment = 'Hello.';
      
      $worksheet8->write( 'C6', $cell_text, $text_wrap );
      $worksheet8->write_comment( 'C6', $comment );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/comments2.pl>
  
  =head2 Example: conditional_format.pl
  
  
  
  Example of how to add conditional formatting to an Excel::Writer::XLSX file.
  
  Conditional formatting allows you to apply a format to a cell or a range of
  cells based on certain criteria.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/conditional_format.jpg" width="640" height="420" alt="Output from conditional_format.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to add conditional formatting to an Excel::Writer::XLSX file.
      #
      # Conditional formatting allows you to apply a format to a cell or a range of
      # cells based on certain criteria.
      #
      # reverse ('(c)'), October 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook   = Excel::Writer::XLSX->new( 'conditional_format.xlsx' );
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      my $worksheet5 = $workbook->add_worksheet();
      my $worksheet6 = $workbook->add_worksheet();
      my $worksheet7 = $workbook->add_worksheet();
      my $worksheet8 = $workbook->add_worksheet();
      my $worksheet9 = $workbook->add_worksheet();
      
      
      # Light red fill with dark red text.
      my $format1 = $workbook->add_format(
          bg_color => '#FFC7CE',
          color    => '#9C0006',
      
      );
      
      # Green fill with dark green text.
      my $format2 = $workbook->add_format(
          bg_color => '#C6EFCE',
          color    => '#006100',
      
      );
      
      # Blue fill with dark blue text.
      my $format3 = $workbook->add_format(
          bg_color => '#C6CEFF',
          color    => '#0000FF',
      
      );
      
      # Some sample data to run the conditional formatting against.
      my $data = [
          [ 34, 72,  38, 30, 75, 48, 75, 66, 84, 86 ],
          [ 6,  24,  1,  84, 54, 62, 60, 3,  26, 59 ],
          [ 28, 79,  97, 13, 85, 93, 93, 22, 5,  14 ],
          [ 27, 71,  40, 17, 18, 79, 90, 93, 29, 47 ],
          [ 88, 25,  33, 23, 67, 1,  59, 79, 47, 36 ],
          [ 24, 100, 20, 88, 29, 33, 38, 54, 54, 88 ],
          [ 6,  57,  88, 28, 10, 26, 37, 7,  41, 48 ],
          [ 52, 78,  1,  96, 26, 45, 47, 33, 96, 36 ],
          [ 60, 54,  81, 66, 81, 90, 80, 93, 12, 55 ],
          [ 70, 5,   46, 14, 71, 19, 66, 36, 41, 21 ],
      ];
      
      
      ###############################################################################
      #
      # Example 1.
      #
      my $caption = 'Cells with values >= 50 are in light red. '
        . 'Values < 50 are in light green.';
      
      # Write the data.
      $worksheet1->write( 'A1', $caption );
      $worksheet1->write_col( 'B3', $data );
      
      # Write a conditional format over a range.
      $worksheet1->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '>=',
              value    => 50,
              format   => $format1,
          }
      );
      
      # Write another conditional format over the same range.
      $worksheet1->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '<',
              value    => 50,
              format   => $format2,
          }
      );
      
      
      ###############################################################################
      #
      # Example 2.
      #
      $caption = 'Values between 30 and 70 are in light red. '
        . 'Values outside that range are in light green.';
      
      $worksheet2->write( 'A1', $caption );
      $worksheet2->write_col( 'B3', $data );
      
      $worksheet2->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => 'between',
              minimum  => 30,
              maximum  => 70,
              format   => $format1,
          }
      );
      
      $worksheet2->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => 'not between',
              minimum  => 30,
              maximum  => 70,
              format   => $format2,
          }
      );
      
      
      ###############################################################################
      #
      # Example 3.
      #
      $caption = 'Duplicate values are in light red. '
        . 'Unique values are in light green.';
      
      $worksheet3->write( 'A1', $caption );
      $worksheet3->write_col( 'B3', $data );
      
      $worksheet3->conditional_formatting( 'B3:K12',
          {
              type     => 'duplicate',
              format   => $format1,
          }
      );
      
      $worksheet3->conditional_formatting( 'B3:K12',
          {
              type     => 'unique',
              format   => $format2,
          }
      );
      
      
      ###############################################################################
      #
      # Example 4.
      #
      $caption = 'Above average values are in light red. '
        . 'Below average values are in light green.';
      
      $worksheet4->write( 'A1', $caption );
      $worksheet4->write_col( 'B3', $data );
      
      $worksheet4->conditional_formatting( 'B3:K12',
          {
              type     => 'average',
              criteria => 'above',
              format   => $format1,
          }
      );
      
      $worksheet4->conditional_formatting( 'B3:K12',
          {
              type     => 'average',
              criteria => 'below',
              format   => $format2,
          }
      );
      
      
      ###############################################################################
      #
      # Example 5.
      #
      $caption = 'Top 10 values are in light red. '
        . 'Bottom 10 values are in light green.';
      
      $worksheet5->write( 'A1', $caption );
      $worksheet5->write_col( 'B3', $data );
      
      $worksheet5->conditional_formatting( 'B3:K12',
          {
              type     => 'top',
              value    => '10',
              format   => $format1,
          }
      );
      
      $worksheet5->conditional_formatting( 'B3:K12',
          {
              type     => 'bottom',
              value    => '10',
              format   => $format2,
          }
      );
      
      
      ###############################################################################
      #
      # Example 6.
      #
      $caption = 'Cells with values >= 50 are in light red. '
        . 'Values < 50 are in light green. Non-contiguous ranges.';
      
      # Write the data.
      $worksheet6->write( 'A1', $caption );
      $worksheet6->write_col( 'B3', $data );
      
      # Write a conditional format over a range.
      $worksheet6->conditional_formatting( 'B3:K6,B9:K12',
          {
              type     => 'cell',
              criteria => '>=',
              value    => 50,
              format   => $format1,
          }
      );
      
      # Write another conditional format over the same range.
      $worksheet6->conditional_formatting( 'B3:K6,B9:K12',
          {
              type     => 'cell',
              criteria => '<',
              value    => 50,
              format   => $format2,
          }
      );
      
      
      ###############################################################################
      #
      # Example 7.
      #
      $caption = 'Examples of color scales and data bars. Default colors.';
      
      # Use different sample data for examples 7 and 8
      my $data7 = [ 1 .. 12 ];
      
      $worksheet7->write( 'A1', $caption );
      
      $worksheet7->write    ( 'B2', "2 Color Scale" );
      $worksheet7->write_col( 'B3', $data7 );
      
      $worksheet7->write    ( 'D2', "3 Color Scale" );
      $worksheet7->write_col( 'D3', $data7 );
      
      $worksheet7->write    ( 'F2', "Data Bars" );
      $worksheet7->write_col( 'F3', $data7 );
      
      
      $worksheet7->conditional_formatting( 'B3:B14',
          {
              type => '2_color_scale',
          }
      );
      
      $worksheet7->conditional_formatting( 'D3:D14',
          {
              type => '3_color_scale',
          }
      );
      
      $worksheet7->conditional_formatting( 'F3:F14',
          {
              type => 'data_bar',
          }
      );
      
      
      ###############################################################################
      #
      # Example 8.
      #
      $caption = 'Examples of color scales and data bars. Modified colors.';
      
      $worksheet8->write( 'A1', $caption );
      
      $worksheet8->write    ( 'B2', "2 Color Scale" );
      $worksheet8->write_col( 'B3', $data7 );
      
      $worksheet8->write    ( 'D2', "3 Color Scale" );
      $worksheet8->write_col( 'D3', $data7 );
      
      $worksheet8->write    ( 'F2', "Data Bars" );
      $worksheet8->write_col( 'F3', $data7 );
      
      
      $worksheet8->conditional_formatting( 'B3:B14',
          {
              type      => '2_color_scale',
              min_color => "#FF0000",
              max_color => "#00FF00",
      
          }
      );
      
      $worksheet8->conditional_formatting( 'D3:D14',
          {
              type      => '3_color_scale',
              min_color => "#C5D9F1",
              mid_color => "#8DB4E3",
              max_color => "#538ED5",
          }
      );
      
      $worksheet8->conditional_formatting( 'F3:F14',
          {
              type      => 'data_bar',
              bar_color => '#63C384'
          }
      );
      
      
      ###############################################################################
      #
      # Example 9
      #
      $caption = 'Cells with values >= 100 are always in blue. '
        . 'Otherwise, cells with values >= 50 are in light red '
        . 'and values < 50 are in light green.';
      
      # Write the data.
      $worksheet9->write( 'A1', $caption );
      $worksheet9->write_col( 'B3', $data );
      
      # Write a conditional format over a range.
      # Use stopIfTrue to prevent previous formats from being used
      # if the conditions of this format are met.
      $worksheet9->conditional_formatting( 'B3:K12',
          {
              type         => 'cell',
              criteria     => '>=',
              value        => 100,
              format       => $format3,
              stop_if_true => 1,
          }
      );
      
      # Write another conditional format over the same range.
      $worksheet9->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '>=',
              value    => 50,
              format   => $format1,
          }
      );
      
      # Write another conditional format over the same range.
      $worksheet9->conditional_formatting( 'B3:K12',
          {
              type     => 'cell',
              criteria => '<',
              value    => 50,
              format   => $format2,
          }
      );
      
      
      __END__
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/conditional_format.pl>
  
  =head2 Example: data_validate.pl
  
  
  
  Example of how to add data validation and dropdown lists to an
  Excel::Writer::XLSX file.
  
  Data validation is a feature of Excel which allows you to restrict the data
  that a user enters in a cell and to display help and warning messages. It
  also allows you to restrict input to values in a drop down list.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/data_validate.jpg" width="640" height="420" alt="Output from data_validate.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to add data validation and dropdown lists to an
      # Excel::Writer::XLSX file.
      #
      # Data validation is a feature of Excel which allows you to restrict the data
      # that a user enters in a cell and to display help and warning messages. It
      # also allows you to restrict input to values in a drop down list.
      #
      # reverse ('(c)'), August 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'data_validate.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Add a format for the header cells.
      my $header_format = $workbook->add_format(
          border    => 1,
          bg_color  => '#C6EFCE',
          bold      => 1,
          text_wrap => 1,
          valign    => 'vcenter',
          indent    => 1,
      );
      
      # Set up layout of the worksheet.
      $worksheet->set_column( 'A:A', 68 );
      $worksheet->set_column( 'B:B', 15 );
      $worksheet->set_column( 'D:D', 15 );
      $worksheet->set_row( 0, 36 );
      $worksheet->set_selection( 'B3' );
      
      
      # Write the header cells and some data that will be used in the examples.
      my $row = 0;
      my $txt;
      my $heading1 = 'Some examples of data validation in Excel::Writer::XLSX';
      my $heading2 = 'Enter values in this column';
      my $heading3 = 'Sample Data';
      
      $worksheet->write( 'A1', $heading1, $header_format );
      $worksheet->write( 'B1', $heading2, $header_format );
      $worksheet->write( 'D1', $heading3, $header_format );
      
      $worksheet->write( 'D3', [ 'Integers', 1, 10 ] );
      $worksheet->write( 'D4', [ 'List data', 'open', 'high', 'close' ] );
      $worksheet->write( 'D5', [ 'Formula', '=AND(F5=50,G5=60)', 50, 60 ] );
      
      
      #
      # Example 1. Limiting input to an integer in a fixed range.
      #
      $txt = 'Enter an integer between 1 and 10';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'integer',
              criteria => 'between',
              minimum  => 1,
              maximum  => 10,
          }
      );
      
      
      #
      # Example 2. Limiting input to an integer outside a fixed range.
      #
      $txt = 'Enter an integer that is not between 1 and 10 (using cell references)';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'integer',
              criteria => 'not between',
              minimum  => '=E3',
              maximum  => '=F3',
          }
      );
      
      
      #
      # Example 3. Limiting input to an integer greater than a fixed value.
      #
      $txt = 'Enter an integer greater than 0';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'integer',
              criteria => '>',
              value    => 0,
          }
      );
      
      
      #
      # Example 4. Limiting input to an integer less than a fixed value.
      #
      $txt = 'Enter an integer less than 10';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'integer',
              criteria => '<',
              value    => 10,
          }
      );
      
      
      #
      # Example 5. Limiting input to a decimal in a fixed range.
      #
      $txt = 'Enter a decimal between 0.1 and 0.5';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'decimal',
              criteria => 'between',
              minimum  => 0.1,
              maximum  => 0.5,
          }
      );
      
      
      #
      # Example 6. Limiting input to a value in a dropdown list.
      #
      $txt = 'Select a value from a drop down list';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'list',
              source   => [ 'open', 'high', 'close' ],
          }
      );
      
      
      #
      # Example 6. Limiting input to a value in a dropdown list.
      #
      $txt = 'Select a value from a drop down list (using a cell range)';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'list',
              source   => '=$E$4:$G$4',
          }
      );
      
      
      #
      # Example 7. Limiting input to a date in a fixed range.
      #
      $txt = 'Enter a date between 1/1/2008 and 12/12/2008';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'date',
              criteria => 'between',
              minimum  => '2008-01-01T',
              maximum  => '2008-12-12T',
          }
      );
      
      
      #
      # Example 8. Limiting input to a time in a fixed range.
      #
      $txt = 'Enter a time between 6:00 and 12:00';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'time',
              criteria => 'between',
              minimum  => 'T06:00',
              maximum  => 'T12:00',
          }
      );
      
      
      #
      # Example 9. Limiting input to a string greater than a fixed length.
      #
      $txt = 'Enter a string longer than 3 characters';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'length',
              criteria => '>',
              value    => 3,
          }
      );
      
      
      #
      # Example 10. Limiting input based on a formula.
      #
      $txt = 'Enter a value if the following is true "=AND(F5=50,G5=60)"';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate => 'custom',
              value    => '=AND(F5=50,G5=60)',
          }
      );
      
      
      #
      # Example 11. Displaying and modify data validation messages.
      #
      $txt = 'Displays a message when you select the cell';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
          }
      );
      
      
      #
      # Example 12. Displaying and modify data validation messages.
      #
      $txt = 'Display a custom error message when integer isn\'t between 1 and 100';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
              error_title   => 'Input value is not valid!',
              error_message => 'It should be an integer between 1 and 100',
          }
      );
      
      
      #
      # Example 13. Displaying and modify data validation messages.
      #
      $txt =
        'Display a custom information message when integer isn\'t between 1 and 100';
      $row += 2;
      
      $worksheet->write( $row, 0, $txt );
      $worksheet->data_validation(
          $row, 1,
          {
              validate      => 'integer',
              criteria      => 'between',
              minimum       => 1,
              maximum       => 100,
              input_title   => 'Enter an integer:',
              input_message => 'between 1 and 100',
              error_title   => 'Input value is not valid!',
              error_message => 'It should be an integer between 1 and 100',
              error_type    => 'information',
          }
      );
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/data_validate.pl>
  
  =head2 Example: date_time.pl
  
  
  
  Excel::Writer::XLSX example of writing dates and times using the
  write_date_time() Worksheet method.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/date_time.jpg" width="640" height="420" alt="Output from date_time.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Excel::Writer::XLSX example of writing dates and times using the
      # write_date_time() Worksheet method.
      #
      # reverse ('(c)'), August 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'date_time.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      my $bold      = $workbook->add_format( bold => 1 );
      
      
      # Expand the first columns so that the date is visible.
      $worksheet->set_column( "A:B", 30 );
      
      
      # Write the column headers
      $worksheet->write( 'A1', 'Formatted date', $bold );
      $worksheet->write( 'B1', 'Format',         $bold );
      
      
      # Examples date and time formats. In the output file compare how changing
      # the format codes change the appearance of the date.
      #
      my @date_formats = (
          'dd/mm/yy',
          'mm/dd/yy',
          '',
          'd mm yy',
          'dd mm yy',
          '',
          'dd m yy',
          'dd mm yy',
          'dd mmm yy',
          'dd mmmm yy',
          '',
          'dd mm y',
          'dd mm yyy',
          'dd mm yyyy',
          '',
          'd mmmm yyyy',
          '',
          'dd/mm/yy',
          'dd/mm/yy hh:mm',
          'dd/mm/yy hh:mm:ss',
          'dd/mm/yy hh:mm:ss.000',
          '',
          'hh:mm',
          'hh:mm:ss',
          'hh:mm:ss.000',
      );
      
      
      # Write the same date and time using each of the above formats. The empty
      # string formats create a blank line to make the example clearer.
      #
      my $row = 0;
      for my $date_format ( @date_formats ) {
          $row++;
          next if $date_format eq '';
      
          # Create a format for the date or time.
          my $format = $workbook->add_format(
              num_format => $date_format,
              align      => 'left'
          );
      
          # Write the same date using different formats.
          $worksheet->write_date_time( $row, 0, '2004-08-01T12:30:45.123', $format );
          $worksheet->write( $row, 1, $date_format );
      }
      
      
      # The following is an example of an invalid date. It is written as a string
      # instead of a number. This is also Excel's default behaviour.
      #
      $row += 2;
      $worksheet->write_date_time( $row, 0, '2004-13-01T12:30:45.123' );
      $worksheet->write( $row, 1, 'Invalid date. Written as string.', $bold );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/date_time.pl>
  
  =head2 Example: defined_name.pl
  
  
  
  Example of how to create defined names in an Excel::Writer::XLSX file.
  
  This method is used to define a user friendly name to represent a value,
  a single cell or a range of cells in a workbook.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/defined_name.jpg" width="640" height="420" alt="Output from defined_name.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # Example of how to create defined names in an Excel::Writer::XLSX file.
      #
      # This method is used to define a user friendly name to represent a value,
      # a single cell or a range of cells in a workbook.
      #
      # reverse ('(c)'), September 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook   = Excel::Writer::XLSX->new( 'defined_name.xlsx' );
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      
      # Define some global/workbook names.
      $workbook->define_name( 'Exchange_rate', '=0.96' );
      $workbook->define_name( 'Sales',         '=Sheet1!$G$1:$H$10' );
      
      # Define a local/worksheet name.
      $workbook->define_name( 'Sheet2!Sales', '=Sheet2!$G$1:$G$10' );
      
      # Write some text in the file and one of the defined names in a formula.
      for my $worksheet ( $workbook->sheets() ) {
          $worksheet->set_column( 'A:A', 45 );
          $worksheet->write( 'A1', 'This worksheet contains some defined names.' );
          $worksheet->write( 'A2', 'See Formulas -> Name Manager above.' );
          $worksheet->write( 'A3', 'Example formula in cell B3 ->' );
      
          $worksheet->write( 'B3', '=Exchange_rate' );
      }
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/defined_name.pl>
  
  =head2 Example: diag_border.pl
  
  
  
  A simple formatting example that demonstrates how to add a diagonal cell
  border with Excel::Writer::XLSX
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/diag_border.jpg" width="640" height="420" alt="Output from diag_border.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple formatting example that demonstrates how to add a diagonal cell
      # border with Excel::Writer::XLSX
      #
      # reverse ('(c)'), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      
      my $workbook  = Excel::Writer::XLSX->new( 'diag_border.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      my $format1 = $workbook->add_format( diag_type => 1 );
      
      my $format2 = $workbook->add_format( diag_type => 2 );
      
      my $format3 = $workbook->add_format( diag_type => 3 );
      
      my $format4 = $workbook->add_format(
          diag_type   => 3,
          diag_border => 7,
          diag_color  => 'red',
      );
      
      
      $worksheet->write( 'B3',  'Text', $format1 );
      $worksheet->write( 'B6',  'Text', $format2 );
      $worksheet->write( 'B9',  'Text', $format3 );
      $worksheet->write( 'B12', 'Text', $format4 );
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/diag_border.pl>
  
  =head2 Example: filehandle.pl
  
  
  
  Example of using Excel::Writer::XLSX to write Excel files to different
  filehandles.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/filehandle.jpg" width="640" height="420" alt="Output from filehandle.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of using Excel::Writer::XLSX to write Excel files to different
      # filehandles.
      #
      # reverse ('(c)'), April 2003, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      use IO::Scalar;
      
      
      ###############################################################################
      #
      # Example 1. This demonstrates the standard way of creating an Excel file by
      # specifying a file name.
      #
      
      my $workbook1  = Excel::Writer::XLSX->new( 'fh_01.xlsx' );
      my $worksheet1 = $workbook1->add_worksheet();
      
      $worksheet1->write( 0, 0, 'Hi Excel 1' );
      
      
      ###############################################################################
      #
      # Example 2. Write an Excel file to an existing filehandle.
      #
      
      open TEST, '>', 'fh_02.xlsx' or die "Couldn't open file: $!";
      binmode TEST;   # Always do this regardless of whether the platform requires it.
      
      my $workbook2  = Excel::Writer::XLSX->new( \*TEST );
      my $worksheet2 = $workbook2->add_worksheet();
      
      $worksheet2->write( 0, 0, 'Hi Excel 2' );
      
      
      ###############################################################################
      #
      # Example 3. Write an Excel file to an existing OO style filehandle.
      #
      
      my $fh = FileHandle->new( '> fh_03.xlsx' ) or die "Couldn't open file: $!";
      
      binmode( $fh );
      
      my $workbook3  = Excel::Writer::XLSX->new( $fh );
      my $worksheet3 = $workbook3->add_worksheet();
      
      $worksheet3->write( 0, 0, 'Hi Excel 3' );
      
      
      ###############################################################################
      #
      # Example 4. Write an Excel file to a string via IO::Scalar. Please refer to
      # the IO::Scalar documentation for further details.
      #
      
      my $xlsx_str;
      
      tie *XLSX, 'IO::Scalar', \$xlsx_str;
      
      my $workbook4  = Excel::Writer::XLSX->new( \*XLSX );
      my $worksheet4 = $workbook4->add_worksheet();
      
      $worksheet4->write( 0, 0, 'Hi Excel 4' );
      $workbook4->close();    # This is required before we use the scalar
      
      
      # The Excel file is now in $xlsx_str. As a demonstration, print it to a file.
      open TMP, '>', 'fh_04.xlsx' or die "Couldn't open file: $!";
      binmode TMP;
      print TMP $xlsx_str;
      close TMP;
      
      
      ###############################################################################
      #
      # Example 5. Write an Excel file to a string via IO::Scalar's newer interface.
      # Please refer to the IO::Scalar documentation for further details.
      #
      my $xlsx_str2;
      
      my $fh5 = IO::Scalar->new( \$xlsx_str2 );
      
      my $workbook5  = Excel::Writer::XLSX->new( $fh5 );
      my $worksheet5 = $workbook5->add_worksheet();
      
      $worksheet5->write( 0, 0, 'Hi Excel 5' );
      $workbook5->close();    # This is required before we use the scalar
      
      # The Excel file is now in $xlsx_str. As a demonstration, print it to a file.
      open TMP, '>', 'fh_05.xlsx' or die "Couldn't open file: $!";
      binmode TMP;
      print TMP $xlsx_str2;
      close TMP;
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/filehandle.pl>
  
  =head2 Example: headers.pl
  
  
  
  This program shows several examples of how to set up headers and
  footers with Excel::Writer::XLSX.
  
  The control characters used in the header/footer strings are:
  
      Control             Category            Description
      =======             ========            ===========
      &L                  Justification       Left
      &C                                      Center
      &R                                      Right
  
      &P                  Information         Page number
      &N                                      Total number of pages
      &D                                      Date
      &T                                      Time
      &F                                      File name
      &A                                      Worksheet name
  
      &fontsize           Font                Font size
      &"font,style"                           Font name and style
      &U                                      Single underline
      &E                                      Double underline
      &S                                      Strikethrough
      &X                                      Superscript
      &Y                                      Subscript
  
      &[Picture]          Images              Image placeholder
      &G                                      Same as &[Picture]
  
      &&                  Miscellaneous       Literal ampersand &
  
  See the main Excel::Writer::XLSX documentation for more information.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/headers.jpg" width="640" height="420" alt="Output from headers.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ######################################################################
      #
      # This program shows several examples of how to set up headers and
      # footers with Excel::Writer::XLSX.
      #
      # The control characters used in the header/footer strings are:
      #
      #     Control             Category            Description
      #     =======             ========            ===========
      #     &L                  Justification       Left
      #     &C                                      Center
      #     &R                                      Right
      #
      #     &P                  Information         Page number
      #     &N                                      Total number of pages
      #     &D                                      Date
      #     &T                                      Time
      #     &F                                      File name
      #     &A                                      Worksheet name
      #
      #     &fontsize           Font                Font size
      #     &"font,style"                           Font name and style
      #     &U                                      Single underline
      #     &E                                      Double underline
      #     &S                                      Strikethrough
      #     &X                                      Superscript
      #     &Y                                      Subscript
      #
      #     &[Picture]          Images              Image placeholder
      #     &G                                      Same as &[Picture]
      #
      #     &&                  Miscellaneous       Literal ampersand &
      #
      # See the main Excel::Writer::XLSX documentation for more information.
      #
      # reverse ('(c)'), March 2002, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'headers.xlsx' );
      my $preview  = 'Select Print Preview to see the header and footer';
      
      
      ######################################################################
      #
      # A simple example to start
      #
      my $worksheet1 = $workbook->add_worksheet( 'Simple' );
      my $header1    = '&CHere is some centred text.';
      my $footer1    = '&LHere is some left aligned text.';
      
      $worksheet1->set_header( $header1 );
      $worksheet1->set_footer( $footer1 );
      
      $worksheet1->set_column( 'A:A', 50 );
      $worksheet1->write( 'A1', $preview );
      
      
      ######################################################################
      #
      # A simple example to start
      #
      my $worksheet2 = $workbook->add_worksheet( 'Image' );
      my $header2    = '&L&[Picture]';
      
      # Adjust the page top margin to allow space for the header image.
      $worksheet2->set_margin_top(1.75);
      
      $worksheet2->set_header( $header2, 0.3, {image_left => 'republic.png'});
      
      $worksheet2->set_column( 'A:A', 50 );
      $worksheet2->write( 'A1', $preview );
      
      
      ######################################################################
      #
      # This is an example of some of the header/footer variables.
      #
      my $worksheet3 = $workbook->add_worksheet( 'Variables' );
      my $header3    = '&LPage &P of &N' . '&CFilename: &F' . '&RSheetname: &A';
      my $footer3    = '&LCurrent date: &D' . '&RCurrent time: &T';
      
      $worksheet3->set_header( $header3 );
      $worksheet3->set_footer( $footer3 );
      
      $worksheet3->set_column( 'A:A', 50 );
      $worksheet3->write( 'A1',  $preview );
      $worksheet3->write( 'A21', 'Next sheet' );
      $worksheet3->set_h_pagebreaks( 20 );
      
      
      ######################################################################
      #
      # This example shows how to use more than one font
      #
      my $worksheet4 = $workbook->add_worksheet( 'Mixed fonts' );
      my $header4    = q(&C&"Courier New,Bold"Hello &"Arial,Italic"World);
      my $footer4    = q(&C&"Symbol"e&"Arial" = mc&X2);
      
      $worksheet4->set_header( $header4 );
      $worksheet4->set_footer( $footer4 );
      
      $worksheet4->set_column( 'A:A', 50 );
      $worksheet4->write( 'A1', $preview );
      
      
      ######################################################################
      #
      # Example of line wrapping
      #
      my $worksheet5 = $workbook->add_worksheet( 'Word wrap' );
      my $header5    = "&CHeading 1\nHeading 2";
      
      $worksheet5->set_header( $header5 );
      
      $worksheet5->set_column( 'A:A', 50 );
      $worksheet5->write( 'A1', $preview );
      
      
      ######################################################################
      #
      # Example of inserting a literal ampersand &
      #
      my $worksheet6 = $workbook->add_worksheet( 'Ampersand' );
      my $header6    = '&CCuriouser && Curiouser - Attorneys at Law';
      
      $worksheet6->set_header( $header6 );
      
      $worksheet6->set_column( 'A:A', 50 );
      $worksheet6->write( 'A1', $preview );
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/headers.pl>
  
  =head2 Example: hide_row_col.pl
  
  
  
  Example of how to hide rows and columns in Excel::Writer::XLSX. In order to
  hide rows without setting each one, (of approximately 1 million rows),
  Excel uses an optimisation to hide all rows that don't have data.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/hide_row_col.jpg" width="640" height="420" alt="Output from hide_row_col.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to hide rows and columns in Excel::Writer::XLSX. In order to
      # hide rows without setting each one, (of approximately 1 million rows),
      # Excel uses an optimisation to hide all rows that don't have data.
      #
      # reverse ('(c)'), December 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'hide_row_col.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Write some data.
      $worksheet->write( 'D1', 'Some hidden columns.' );
      $worksheet->write( 'A8', 'Some hidden rows.' );
      
      # Hide all rows without data.
      $worksheet->set_default_row( undef, 1 );
      
      # Set emptys row that we do want to display. All other will be hidden.
      for my $row (1 .. 6) {
          $worksheet->set_row( $row, 15 );
      }
      
      # Hide a range of columns.
      $worksheet->set_column( 'G:XFD', undef, undef, 1);
      
      __END__
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/hide_row_col.pl>
  
  =head2 Example: hide_sheet.pl
  
  
  
  Example of how to hide a worksheet with Excel::Writer::XLSX.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/hide_sheet.jpg" width="640" height="420" alt="Output from hide_sheet.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # Example of how to hide a worksheet with Excel::Writer::XLSX.
      #
      # reverse ('(c)'), April 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook   = Excel::Writer::XLSX->new( 'hide_sheet.xlsx' );
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      
      $worksheet1->set_column( 'A:A', 30 );
      $worksheet2->set_column( 'A:A', 30 );
      $worksheet3->set_column( 'A:A', 30 );
      
      # Sheet2 won't be visible until it is unhidden in Excel.
      $worksheet2->hide();
      
      $worksheet1->write( 0, 0, 'Sheet2 is hidden' );
      $worksheet2->write( 0, 0, "Now it's my turn to find you." );
      $worksheet3->write( 0, 0, 'Sheet2 is hidden' );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/hide_sheet.pl>
  
  =head2 Example: hyperlink1.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX module to write hyperlinks
  
  See also hyperlink2.pl for worksheet URL examples.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/hyperlink1.jpg" width="640" height="420" alt="Output from hyperlink1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX module to write hyperlinks
      #
      # See also hyperlink2.pl for worksheet URL examples.
      #
      # reverse ('(c)'), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook = Excel::Writer::XLSX->new( 'hyperlink.xlsx' );
      
      
      my $worksheet = $workbook->add_worksheet( 'Hyperlinks' );
      
      # Format the first column
      $worksheet->set_column( 'A:A', 30 );
      $worksheet->set_selection( 'B1' );
      
      
      # Add the standard url link format.
      my $url_format = $workbook->add_format(
          color     => 'blue',
          underline => 1,
      );
      
      # Add a sample format.
      my $red_format = $workbook->add_format(
          color     => 'red',
          bold      => 1,
          underline => 1,
          size      => 12,
      );
      
      # Add an alternate description string to the URL.
      my $str = 'Perl home.';
      
      # Add a "tool tip" to the URL.
      my $tip = 'Get the latest Perl news here.';
      
      
      # Write some hyperlinks
      $worksheet->write( 'A1', 'http://www.perl.com/', $url_format );
      $worksheet->write( 'A3', 'http://www.perl.com/', $url_format, $str );
      $worksheet->write( 'A5', 'http://www.perl.com/', $url_format, $str, $tip );
      $worksheet->write( 'A7', 'http://www.perl.com/', $red_format );
      $worksheet->write( 'A9', 'mailto:jmcnamara@cpan.org', $url_format, 'Mail me' );
      
      # Write a URL that isn't a hyperlink
      $worksheet->write_string( 'A11', 'http://www.perl.com/' );
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/hyperlink1.pl>
  
  =head2 Example: hyperlink2.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX module to write internal and
  external hyperlinks.
  
  If you wish to run this program and follow the hyperlinks you should create
  the following directory structure:
  
  C:\ -- Temp --+-- Europe
                |
                \-- Asia
  
  
  See also hyperlink1.pl for web URL examples.
  
  
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX module to write internal and
      # external hyperlinks.
      #
      # If you wish to run this program and follow the hyperlinks you should create
      # the following directory structure:
      #
      # C:\ -- Temp --+-- Europe
      #               |
      #               \-- Asia
      #
      #
      # See also hyperlink1.pl for web URL examples.
      #
      # reverse ('(c)'), February 2002, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create three workbooks:
      #   C:\Temp\Europe\Ireland.xlsx
      #   C:\Temp\Europe\Italy.xlsx
      #   C:\Temp\Asia\China.xlsx
      #
      
      my $ireland = Excel::Writer::XLSX->new( 'C:\Temp\Europe\Ireland.xlsx' );
      
      my $ire_links      = $ireland->add_worksheet( 'Links' );
      my $ire_sales      = $ireland->add_worksheet( 'Sales' );
      my $ire_data       = $ireland->add_worksheet( 'Product Data' );
      my $ire_url_format = $ireland->add_format(
          color     => 'blue',
          underline => 1,
      );
      
      
      my $italy = Excel::Writer::XLSX->new( 'C:\Temp\Europe\Italy.xlsx' );
      
      my $ita_links      = $italy->add_worksheet( 'Links' );
      my $ita_sales      = $italy->add_worksheet( 'Sales' );
      my $ita_data       = $italy->add_worksheet( 'Product Data' );
      my $ita_url_format = $italy->add_format(
          color     => 'blue',
          underline => 1,
      );
      
      
      my $china = Excel::Writer::XLSX->new( 'C:\Temp\Asia\China.xlsx' );
      
      my $cha_links      = $china->add_worksheet( 'Links' );
      my $cha_sales      = $china->add_worksheet( 'Sales' );
      my $cha_data       = $china->add_worksheet( 'Product Data' );
      my $cha_url_format = $china->add_format(
          color     => 'blue',
          underline => 1,
      );
      
      
      # Add an alternative format
      my $format = $ireland->add_format( color => 'green', bold => 1 );
      $ire_links->set_column( 'A:B', 25 );
      
      
      ###############################################################################
      #
      # Examples of internal links
      #
      $ire_links->write( 'A1', 'Internal links', $format );
      
      # Internal link
      $ire_links->write_url( 'A2', 'internal:Sales!A2', $ire_url_format );
      
      # Internal link to a range
      $ire_links->write_url( 'A3', 'internal:Sales!A3:D3', $ire_url_format );
      
      # Internal link with an alternative string
      $ire_links->write_url( 'A4', 'internal:Sales!A4', $ire_url_format, 'Link' );
      
      # Internal link with an alternative format
      $ire_links->write_url( 'A5', 'internal:Sales!A5', $format );
      
      # Internal link with an alternative string and format
      $ire_links->write_url( 'A6', 'internal:Sales!A6', $ire_url_format, 'Link' );
      
      # Internal link (spaces in worksheet name)
      $ire_links->write_url( 'A7', q{internal:'Product Data'!A7}, $ire_url_format );
      
      
      ###############################################################################
      #
      # Examples of external links
      #
      $ire_links->write( 'B1', 'External links', $format );
      
      # External link to a local file
      $ire_links->write_url( 'B2', 'external:Italy.xlsx', $ire_url_format );
      
      # External link to a local file with worksheet
      $ire_links->write_url( 'B3', 'external:Italy.xlsx#Sales!B3', $ire_url_format );
      
      # External link to a local file with worksheet and alternative string
      $ire_links->write_url( 'B4', 'external:Italy.xlsx#Sales!B4', $ire_url_format, 'Link' );
      
      # External link to a local file with worksheet and format
      $ire_links->write_url( 'B5', 'external:Italy.xlsx#Sales!B5', $format );
      
      # External link to a remote file, absolute path
      $ire_links->write_url( 'B6', 'external:C:/Temp/Asia/China.xlsx', $ire_url_format );
      
      # External link to a remote file, relative path
      $ire_links->write_url( 'B7', 'external:../Asia/China.xlsx', $ire_url_format );
      
      # External link to a remote file with worksheet
      $ire_links->write_url( 'B8', 'external:C:/Temp/Asia/China.xlsx#Sales!B8', $ire_url_format );
      
      # External link to a remote file with worksheet (with spaces in the name)
      $ire_links->write_url( 'B9', q{external:C:/Temp/Asia/China.xlsx#'Product Data'!B9}, $ire_url_format );
      
      
      ###############################################################################
      #
      # Some utility links to return to the main sheet
      #
      $ire_sales->write_url( 'A2', 'internal:Links!A2', $ire_url_format, 'Back' );
      $ire_sales->write_url( 'A3', 'internal:Links!A3', $ire_url_format, 'Back' );
      $ire_sales->write_url( 'A4', 'internal:Links!A4', $ire_url_format, 'Back' );
      $ire_sales->write_url( 'A5', 'internal:Links!A5', $ire_url_format, 'Back' );
      $ire_sales->write_url( 'A6', 'internal:Links!A6', $ire_url_format, 'Back' );
      $ire_data->write_url ( 'A7', 'internal:Links!A7', $ire_url_format, 'Back' );
      
      $ita_links->write_url( 'A1', 'external:Ireland.xlsx#Links!B2', $ita_url_format, 'Back' );
      $ita_sales->write_url( 'B3', 'external:Ireland.xlsx#Links!B3', $ita_url_format, 'Back' );
      $ita_sales->write_url( 'B4', 'external:Ireland.xlsx#Links!B4', $ita_url_format, 'Back' );
      $ita_sales->write_url( 'B5', 'external:Ireland.xlsx#Links!B5', $ita_url_format, 'Back' );
      $cha_links->write_url( 'A1', 'external:C:/Temp/Europe/Ireland.xlsx#Links!B6', $cha_url_format, 'Back' );
      $cha_sales->write_url( 'B8', 'external:C:/Temp/Europe/Ireland.xlsx#Links!B8', $cha_url_format, 'Back' );
      $cha_data->write_url ( 'B9', 'external:C:/Temp/Europe/Ireland.xlsx#Links!B9', $cha_url_format, 'Back' );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/hyperlink2.pl>
  
  =head2 Example: indent.pl
  
  
  
  A simple formatting example using Excel::Writer::XLSX.
  
  This program demonstrates the indentation cell format.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/indent.jpg" width="640" height="420" alt="Output from indent.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ##############################################################################
      #
      # A simple formatting example using Excel::Writer::XLSX.
      #
      # This program demonstrates the indentation cell format.
      #
      # reverse ('(c)'), May 2004, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'indent.xlsx' );
      
      my $worksheet = $workbook->add_worksheet();
      my $indent1   = $workbook->add_format( indent => 1 );
      my $indent2   = $workbook->add_format( indent => 2 );
      
      $worksheet->set_column( 'A:A', 40 );
      
      
      $worksheet->write( 'A1', "This text is indented 1 level",  $indent1 );
      $worksheet->write( 'A2', "This text is indented 2 levels", $indent2 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/indent.pl>
  
  =head2 Example: macros.pl
  
  
  
  An example of adding macros to an Excel::Writer::XLSX file using
  a VBA project file extracted from an existing Excel xlsm file.
  
  The C<extract_vba> utility supplied with Excel::Writer::XLSX can be
  used to extract the vbaProject.bin file.
  
  An embedded macro is connected to a form button on the worksheet.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/macros.jpg" width="640" height="420" alt="Output from macros.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # An example of adding macros to an Excel::Writer::XLSX file using
      # a VBA project file extracted from an existing Excel xlsm file.
      #
      # The C<extract_vba> utility supplied with Excel::Writer::XLSX can be
      # used to extract the vbaProject.bin file.
      #
      # An embedded macro is connected to a form button on the worksheet.
      #
      # reverse('(c)'), November 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Note the file extension should be .xlsm.
      my $workbook  = Excel::Writer::XLSX->new( 'macros.xlsm' );
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->set_column( 'A:A', 30 );
      
      # Add the VBA project binary.
      $workbook->add_vba_project( './vbaProject.bin' );
      
      # Show text for the end user.
      $worksheet->write( 'A3', 'Press the button to say hello.' );
      
      # Add a button tied to a macro in the VBA project.
      $worksheet->insert_button(
          'B3',
          {
              macro   => 'say_hello',
              caption => 'Press Me',
              width   => 80,
              height  => 30
          }
      );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/macros.pl>
  
  =head2 Example: merge1.pl
  
  
  
  Simple example of merging cells using the Excel::Writer::XLSX module.
  
  This example merges three cells using the "Centre Across Selection"
  alignment which was the Excel 5 method of achieving a merge. For a more
  modern approach use the merge_range() worksheet method instead.
  See the merge3.pl - merge6.pl programs.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/merge1.jpg" width="640" height="420" alt="Output from merge1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Simple example of merging cells using the Excel::Writer::XLSX module.
      #
      # This example merges three cells using the "Centre Across Selection"
      # alignment which was the Excel 5 method of achieving a merge. For a more
      # modern approach use the merge_range() worksheet method instead.
      # See the merge3.pl - merge6.pl programs.
      #
      # reverse ('(c)'), August 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'merge1.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_column( 'B:D', 20 );
      $worksheet->set_row( 2, 30 );
      
      
      # Create a merge format
      my $format = $workbook->add_format( center_across => 1 );
      
      
      # Only one cell should contain text, the others should be blank.
      $worksheet->write( 2, 1, "Center across selection", $format );
      $worksheet->write_blank( 2, 2, $format );
      $worksheet->write_blank( 2, 3, $format );
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/merge1.pl>
  
  =head2 Example: merge2.pl
  
  
  
  Simple example of merging cells using the Excel::Writer::XLSX module
  
  This example merges three cells using the "Centre Across Selection"
  alignment which was the Excel 5 method of achieving a merge. For a more
  modern approach use the merge_range() worksheet method instead.
  See the merge3.pl - merge6.pl programs.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/merge2.jpg" width="640" height="420" alt="Output from merge2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Simple example of merging cells using the Excel::Writer::XLSX module
      #
      # This example merges three cells using the "Centre Across Selection"
      # alignment which was the Excel 5 method of achieving a merge. For a more
      # modern approach use the merge_range() worksheet method instead.
      # See the merge3.pl - merge6.pl programs.
      #
      # reverse ('(c)'), August 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'merge2.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_column( 1, 2, 30 );
      $worksheet->set_row( 2, 40 );
      
      
      # Create a merged format
      my $format = $workbook->add_format(
          center_across => 1,
          bold          => 1,
          size          => 15,
          pattern       => 1,
          border        => 6,
          color         => 'white',
          fg_color      => 'green',
          border_color  => 'yellow',
          align         => 'vcenter',
      );
      
      
      # Only one cell should contain text, the others should be blank.
      $worksheet->write( 2, 1, "Center across selection", $format );
      $worksheet->write_blank( 2, 2, $format );
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/merge2.pl>
  
  =head2 Example: merge3.pl
  
  
  
  Example of how to use Excel::Writer::XLSX to write a hyperlink in a
  merged cell.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/merge3.jpg" width="640" height="420" alt="Output from merge3.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use Excel::Writer::XLSX to write a hyperlink in a
      # merged cell.
      #
      # reverse ('(c)'), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'merge3.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row( $_, 30 ) for ( 3, 6, 7 );
      $worksheet->set_column( 'B:D', 20 );
      
      
      ###############################################################################
      #
      # Example: Merge cells containing a hyperlink using merge_range().
      #
      my $format = $workbook->add_format(
          border    => 1,
          underline => 1,
          color     => 'blue',
          align     => 'center',
          valign    => 'vcenter',
      );
      
      # Merge 3 cells
      $worksheet->merge_range( 'B4:D4', 'http://www.perl.com', $format );
      
      
      # Merge 3 cells over two rows
      $worksheet->merge_range( 'B7:D8', 'http://www.perl.com', $format );
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/merge3.pl>
  
  =head2 Example: merge4.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX merge_range() workbook
  method with complex formatting.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/merge4.jpg" width="640" height="420" alt="Output from merge4.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX merge_range() workbook
      # method with complex formatting.
      #
      # reverse ('(c)'), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'merge4.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row( $_, 30 ) for ( 1 .. 11 );
      $worksheet->set_column( 'B:D', 20 );
      
      
      ###############################################################################
      #
      # Example 1: Text centered vertically and horizontally
      #
      my $format1 = $workbook->add_format(
          border => 6,
          bold   => 1,
          color  => 'red',
          valign => 'vcenter',
          align  => 'center',
      );
      
      
      $worksheet->merge_range( 'B2:D3', 'Vertical and horizontal', $format1 );
      
      
      ###############################################################################
      #
      # Example 2: Text aligned to the top and left
      #
      my $format2 = $workbook->add_format(
          border => 6,
          bold   => 1,
          color  => 'red',
          valign => 'top',
          align  => 'left',
      );
      
      
      $worksheet->merge_range( 'B5:D6', 'Aligned to the top and left', $format2 );
      
      
      ###############################################################################
      #
      # Example 3:  Text aligned to the bottom and right
      #
      my $format3 = $workbook->add_format(
          border => 6,
          bold   => 1,
          color  => 'red',
          valign => 'bottom',
          align  => 'right',
      );
      
      
      $worksheet->merge_range( 'B8:D9', 'Aligned to the bottom and right', $format3 );
      
      
      ###############################################################################
      #
      # Example 4:  Text justified (i.e. wrapped) in the cell
      #
      my $format4 = $workbook->add_format(
          border => 6,
          bold   => 1,
          color  => 'red',
          valign => 'top',
          align  => 'justify',
      );
      
      
      $worksheet->merge_range( 'B11:D12', 'Justified: ' . 'so on and ' x 18,
          $format4 );
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/merge4.pl>
  
  =head2 Example: merge5.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX merge_cells() workbook
  method with complex formatting and rotation.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/merge5.jpg" width="640" height="420" alt="Output from merge5.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX merge_cells() workbook
      # method with complex formatting and rotation.
      #
      #
      # reverse ('(c)'), September 2002, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'merge5.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row( $_, 36 ) for ( 3 .. 8 );
      $worksheet->set_column( $_, $_, 15 ) for ( 1, 3, 5 );
      
      
      ###############################################################################
      #
      # Rotation 1, letters run from top to bottom
      #
      my $format1 = $workbook->add_format(
          border   => 6,
          bold     => 1,
          color    => 'red',
          valign   => 'vcentre',
          align    => 'centre',
          rotation => 270,
      );
      
      
      $worksheet->merge_range( 'B4:B9', 'Rotation 270', $format1 );
      
      
      ###############################################################################
      #
      # Rotation 2, 90 anticlockwise
      #
      my $format2 = $workbook->add_format(
          border   => 6,
          bold     => 1,
          color    => 'red',
          valign   => 'vcentre',
          align    => 'centre',
          rotation => 90,
      );
      
      
      $worksheet->merge_range( 'D4:D9', 'Rotation 90', $format2 );
      
      
      ###############################################################################
      #
      # Rotation 3, 90 clockwise
      #
      my $format3 = $workbook->add_format(
          border   => 6,
          bold     => 1,
          color    => 'red',
          valign   => 'vcentre',
          align    => 'centre',
          rotation => -90,
      );
      
      
      $worksheet->merge_range( 'F4:F9', 'Rotation -90', $format3 );
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/merge5.pl>
  
  =head2 Example: merge6.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX merge_cells() workbook
  method with Unicode strings.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/merge6.jpg" width="640" height="420" alt="Output from merge6.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX merge_cells() workbook
      # method with Unicode strings.
      #
      #
      # reverse ('(c)'), December 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'merge6.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      # Increase the cell size of the merged cells to highlight the formatting.
      $worksheet->set_row( $_, 36 ) for 2 .. 9;
      $worksheet->set_column( 'B:D', 25 );
      
      
      # Format for the merged cells.
      my $format = $workbook->add_format(
          border => 6,
          bold   => 1,
          color  => 'red',
          size   => 20,
          valign => 'vcentre',
          align  => 'left',
          indent => 1,
      );
      
      
      ###############################################################################
      #
      # Write an Ascii string.
      #
      $worksheet->merge_range( 'B3:D4', 'ASCII: A simple string', $format );
      
      
      ###############################################################################
      #
      # Write a UTF-8 Unicode string.
      #
      my $smiley = chr 0x263a;
      $worksheet->merge_range( 'B6:D7', "UTF-8: A Unicode smiley $smiley", $format );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/merge6.pl>
  
  =head2 Example: mod_perl1.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX module to send an Excel
  file to a browser using mod_perl 1 and Apache
  
  This module ties *XLSX directly to Apache, and with the correct
  content-disposition/types it will prompt the user to save
  the file, or open it at this location.
  
  This script is a modification of the Excel::Writer::XLSX cgi.pl example.
  
  Change the name of this file to Cgi.pm.
  Change the package location to wherever you locate this package.
  In the example below it is located in the Excel::Writer::XLSX directory.
  
  Your httpd.conf entry for this module, should you choose to use it
  as a stand alone app, should look similar to the following:
  
      <Location /spreadsheet-test>
        SetHandler perl-script
        PerlHandler Excel::Writer::XLSX::Cgi
        PerlSendHeader On
      </Location>
  
  The PerlHandler name above and the package name below *have* to match.
  
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX module to send an Excel
      # file to a browser using mod_perl 1 and Apache
      #
      # This module ties *XLSX directly to Apache, and with the correct
      # content-disposition/types it will prompt the user to save
      # the file, or open it at this location.
      #
      # This script is a modification of the Excel::Writer::XLSX cgi.pl example.
      #
      # Change the name of this file to Cgi.pm.
      # Change the package location to wherever you locate this package.
      # In the example below it is located in the Excel::Writer::XLSX directory.
      #
      # Your httpd.conf entry for this module, should you choose to use it
      # as a stand alone app, should look similar to the following:
      #
      #     <Location /spreadsheet-test>
      #       SetHandler perl-script
      #       PerlHandler Excel::Writer::XLSX::Cgi
      #       PerlSendHeader On
      #     </Location>
      #
      # The PerlHandler name above and the package name below *have* to match.
      
      # Apr 2001, Thomas Sullivan, webmaster@860.org
      # Feb 2001, John McNamara, jmcnamara@cpan.org
      
      package Excel::Writer::XLSX::Cgi;
      
      ##########################################
      # Pragma Definitions
      ##########################################
      use strict;
      
      ##########################################
      # Required Modules
      ##########################################
      use Apache::Constants qw(:common);
      use Apache::Request;
      use Apache::URI;    # This may not be needed
      use Excel::Writer::XLSX;
      
      ##########################################
      # Main App Body
      ##########################################
      sub handler {
      
          # New apache object
          # Should you decide to use it.
          my $r = Apache::Request->new( shift );
      
          # Set the filename and send the content type
          # This will appear when they save the spreadsheet
          my $filename = "cgitest.xlsx";
      
          ####################################################
          ## Send the content type headers
          ####################################################
          print "Content-disposition: attachment;filename=$filename\n";
          print "Content-type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n\n";
      
          ####################################################
          # Tie a filehandle to Apache's STDOUT.
          # Create a new workbook and add a worksheet.
          ####################################################
          tie *XLSX => 'Apache';
          binmode( *XLSX );
      
          my $workbook  = Excel::Writer::XLSX->new( \*XLSX );
          my $worksheet = $workbook->add_worksheet();
      
      
          # Set the column width for column 1
          $worksheet->set_column( 0, 0, 20 );
      
      
          # Create a format
          my $format = $workbook->add_format();
          $format->set_bold();
          $format->set_size( 15 );
          $format->set_color( 'blue' );
      
      
          # Write to the workbook
          $worksheet->write( 0, 0, "Hi Excel!", $format );
      
          # You must close the workbook for Content-disposition
          $workbook->close();
      }
      
      1;
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/mod_perl1.pl>
  
  =head2 Example: mod_perl2.pl
  
  
  
  Example of how to use the Excel::Writer::XLSX module to send an Excel
  file to a browser using mod_perl 2 and Apache.
  
  This module ties *XLSX directly to Apache, and with the correct
  content-disposition/types it will prompt the user to save
  the file, or open it at this location.
  
  This script is a modification of the Excel::Writer::XLSX cgi.pl example.
  
  Change the name of this file to MP2Test.pm.
  Change the package location to wherever you locate this package.
  In the example below it is located in the Excel::Writer::XLSX directory.
  
  Your httpd.conf entry for this module, should you choose to use it
  as a stand alone app, should look similar to the following:
  
      PerlModule Apache2::RequestRec
      PerlModule APR::Table
      PerlModule Apache2::RequestIO
  
      <Location /spreadsheet-test>
         SetHandler perl-script
         PerlResponseHandler Excel::Writer::XLSX::MP2Test
      </Location>
  
  The PerlResponseHandler must match the package name below.
  
      ###############################################################################
      #
      # Example of how to use the Excel::Writer::XLSX module to send an Excel
      # file to a browser using mod_perl 2 and Apache.
      #
      # This module ties *XLSX directly to Apache, and with the correct
      # content-disposition/types it will prompt the user to save
      # the file, or open it at this location.
      #
      # This script is a modification of the Excel::Writer::XLSX cgi.pl example.
      #
      # Change the name of this file to MP2Test.pm.
      # Change the package location to wherever you locate this package.
      # In the example below it is located in the Excel::Writer::XLSX directory.
      #
      # Your httpd.conf entry for this module, should you choose to use it
      # as a stand alone app, should look similar to the following:
      #
      #     PerlModule Apache2::RequestRec
      #     PerlModule APR::Table
      #     PerlModule Apache2::RequestIO
      #
      #     <Location /spreadsheet-test>
      #        SetHandler perl-script
      #        PerlResponseHandler Excel::Writer::XLSX::MP2Test
      #     </Location>
      #
      # The PerlResponseHandler must match the package name below.
      
      # Jun 2004, Matisse Enzer, matisse@matisse.net  (mod_perl 2 version)
      # Apr 2001, Thomas Sullivan, webmaster@860.org
      # Feb 2001, John McNamara, jmcnamara@cpan.org
      
      package Excel::Writer::XLSX::MP2Test;
      
      ##########################################
      # Pragma Definitions
      ##########################################
      use strict;
      
      ##########################################
      # Required Modules
      ##########################################
      use Apache2::Const -compile => qw( :common );
      use Excel::Writer::XLSX;
      
      ##########################################
      # Main App Body
      ##########################################
      sub handler {
          my ( $r ) = @_;   # Apache request object is passed to handler in mod_perl 2
      
          # Set the filename and send the content type
          # This will appear when they save the spreadsheet
          my $filename = "mod_perl2_test.xlsx";
      
          ####################################################
          ## Send the content type headers the mod_perl 2 way
          ####################################################
          $r->headers_out->{'Content-Disposition'} = "attachment;filename=$filename";
          $r->content_type( 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' );
      
          ####################################################
          # Tie a filehandle to Apache's STDOUT.
          # Create a new workbook and add a worksheet.
          ####################################################
          tie *XLSX => $r;  # The mod_perl 2 way. Tie to the Apache::RequestRec object
          binmode( *XLSX );
      
          my $workbook  = Excel::Writer::XLSX->new( \*XLSX );
          my $worksheet = $workbook->add_worksheet();
      
      
          # Set the column width for column 1
          $worksheet->set_column( 0, 0, 20 );
      
      
          # Create a format
          my $format = $workbook->add_format();
          $format->set_bold();
          $format->set_size( 15 );
          $format->set_color( 'blue' );
      
      
          # Write to the workbook
          $worksheet->write( 0, 0, 'Hi Excel! from ' . $r->hostname, $format );
      
          # You must close the workbook for Content-disposition
          $workbook->close();
          return Apache2::Const::OK;
      }
      
      1;
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/mod_perl2.pl>
  
  =head2 Example: outline.pl
  
  
  
  Example of how use Excel::Writer::XLSX to generate Excel outlines and
  grouping.
  
  
  Excel allows you to group rows or columns so that they can be hidden or
  displayed with a single mouse click. This feature is referred to as outlines.
  
  Outlines can reduce complex data down to a few salient sub-totals or
  summaries.
  
  This feature is best viewed in Excel but the following is an ASCII
  representation of what a worksheet with three outlines might look like.
  Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at
  level 1. The lines at the left hand side are called outline level bars.
  
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |  _  | 2 |   B   |       |       |       |  ...
       | |   | 3 |  (C)  |       |       |       |  ...
       | |   | 4 |  (D)  |       |       |       |  ...
       | -   | 5 |   E   |       |       |       |  ...
       |  _  | 6 |   F   |       |       |       |  ...
       | |   | 7 |  (G)  |       |       |       |  ...
       | |   | 8 |  (H)  |       |       |       |  ...
       | -   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking the minus sign on each of the level 2 outlines will collapse and
  hide the data as shown in the next figure. The minus sign changes to a plus
  sign to indicate that the data in the outline is hidden.
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
        _    | 1 |   A   |       |       |       |  ...
       |     | 2 |   B   |       |       |       |  ...
       | +   | 5 |   E   |       |       |       |  ...
       |     | 6 |   F   |       |       |       |  ...
       | +   | 9 |   I   |       |       |       |  ...
       -     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  
  Clicking on the minus sign on the level 1 outline will collapse the remaining
  rows as follows:
  
              ------------------------------------------
       1 2 3 |   |   A   |   B   |   C   |   D   |  ...
              ------------------------------------------
             | 1 |   A   |       |       |       |  ...
       +     | . |  ...  |  ...  |  ...  |  ...  |  ...
  
  See the main Excel::Writer::XLSX documentation for more information.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/outline.jpg" width="640" height="420" alt="Output from outline.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how use Excel::Writer::XLSX to generate Excel outlines and
      # grouping.
      #
      #
      # Excel allows you to group rows or columns so that they can be hidden or
      # displayed with a single mouse click. This feature is referred to as outlines.
      #
      # Outlines can reduce complex data down to a few salient sub-totals or
      # summaries.
      #
      # This feature is best viewed in Excel but the following is an ASCII
      # representation of what a worksheet with three outlines might look like.
      # Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at
      # level 1. The lines at the left hand side are called outline level bars.
      #
      #
      #             ------------------------------------------
      #      1 2 3 |   |   A   |   B   |   C   |   D   |  ...
      #             ------------------------------------------
      #       _    | 1 |   A   |       |       |       |  ...
      #      |  _  | 2 |   B   |       |       |       |  ...
      #      | |   | 3 |  (C)  |       |       |       |  ...
      #      | |   | 4 |  (D)  |       |       |       |  ...
      #      | -   | 5 |   E   |       |       |       |  ...
      #      |  _  | 6 |   F   |       |       |       |  ...
      #      | |   | 7 |  (G)  |       |       |       |  ...
      #      | |   | 8 |  (H)  |       |       |       |  ...
      #      | -   | 9 |   I   |       |       |       |  ...
      #      -     | . |  ...  |  ...  |  ...  |  ...  |  ...
      #
      #
      # Clicking the minus sign on each of the level 2 outlines will collapse and
      # hide the data as shown in the next figure. The minus sign changes to a plus
      # sign to indicate that the data in the outline is hidden.
      #
      #             ------------------------------------------
      #      1 2 3 |   |   A   |   B   |   C   |   D   |  ...
      #             ------------------------------------------
      #       _    | 1 |   A   |       |       |       |  ...
      #      |     | 2 |   B   |       |       |       |  ...
      #      | +   | 5 |   E   |       |       |       |  ...
      #      |     | 6 |   F   |       |       |       |  ...
      #      | +   | 9 |   I   |       |       |       |  ...
      #      -     | . |  ...  |  ...  |  ...  |  ...  |  ...
      #
      #
      # Clicking on the minus sign on the level 1 outline will collapse the remaining
      # rows as follows:
      #
      #             ------------------------------------------
      #      1 2 3 |   |   A   |   B   |   C   |   D   |  ...
      #             ------------------------------------------
      #            | 1 |   A   |       |       |       |  ...
      #      +     | . |  ...  |  ...  |  ...  |  ...  |  ...
      #
      # See the main Excel::Writer::XLSX documentation for more information.
      #
      # reverse ('(c)'), April 2003, John McNamara, jmcnamara@cpan.org
      #
      
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add some worksheets
      my $workbook   = Excel::Writer::XLSX->new( 'outline.xlsx' );
      my $worksheet1 = $workbook->add_worksheet( 'Outlined Rows' );
      my $worksheet2 = $workbook->add_worksheet( 'Collapsed Rows' );
      my $worksheet3 = $workbook->add_worksheet( 'Outline Columns' );
      my $worksheet4 = $workbook->add_worksheet( 'Outline levels' );
      
      # Add a general format
      my $bold = $workbook->add_format( bold => 1 );
      
      
      ###############################################################################
      #
      # Example 1: Create a worksheet with outlined rows. It also includes SUBTOTAL()
      # functions so that it looks like the type of automatic outlines that are
      # generated when you use the Excel Data->SubTotals menu item.
      #
      
      
      # For outlines the important parameters are $hidden and $level. Rows with the
      # same $level are grouped together. The group will be collapsed if $hidden is
      # non-zero. $height and $XF are assigned default values if they are undef.
      #
      # The syntax is: set_row($row, $height, $XF, $hidden, $level, $collapsed)
      #
      $worksheet1->set_row( 1, undef, undef, 0, 2 );
      $worksheet1->set_row( 2, undef, undef, 0, 2 );
      $worksheet1->set_row( 3, undef, undef, 0, 2 );
      $worksheet1->set_row( 4, undef, undef, 0, 2 );
      $worksheet1->set_row( 5, undef, undef, 0, 1 );
      
      $worksheet1->set_row( 6,  undef, undef, 0, 2 );
      $worksheet1->set_row( 7,  undef, undef, 0, 2 );
      $worksheet1->set_row( 8,  undef, undef, 0, 2 );
      $worksheet1->set_row( 9,  undef, undef, 0, 2 );
      $worksheet1->set_row( 10, undef, undef, 0, 1 );
      
      
      # Add a column format for clarity
      $worksheet1->set_column( 'A:A', 20 );
      
      # Add the data, labels and formulas
      $worksheet1->write( 'A1', 'Region', $bold );
      $worksheet1->write( 'A2', 'North' );
      $worksheet1->write( 'A3', 'North' );
      $worksheet1->write( 'A4', 'North' );
      $worksheet1->write( 'A5', 'North' );
      $worksheet1->write( 'A6', 'North Total', $bold );
      
      $worksheet1->write( 'B1', 'Sales', $bold );
      $worksheet1->write( 'B2', 1000 );
      $worksheet1->write( 'B3', 1200 );
      $worksheet1->write( 'B4', 900 );
      $worksheet1->write( 'B5', 1200 );
      $worksheet1->write( 'B6', '=SUBTOTAL(9,B2:B5)', $bold );
      
      $worksheet1->write( 'A7',  'South' );
      $worksheet1->write( 'A8',  'South' );
      $worksheet1->write( 'A9',  'South' );
      $worksheet1->write( 'A10', 'South' );
      $worksheet1->write( 'A11', 'South Total', $bold );
      
      $worksheet1->write( 'B7',  400 );
      $worksheet1->write( 'B8',  600 );
      $worksheet1->write( 'B9',  500 );
      $worksheet1->write( 'B10', 600 );
      $worksheet1->write( 'B11', '=SUBTOTAL(9,B7:B10)', $bold );
      
      $worksheet1->write( 'A12', 'Grand Total',         $bold );
      $worksheet1->write( 'B12', '=SUBTOTAL(9,B2:B10)', $bold );
      
      
      ###############################################################################
      #
      # Example 2: Create a worksheet with outlined rows. This is the same as the
      # previous example except that the rows are collapsed.
      # Note: We need to indicate the row that contains the collapsed symbol '+'
      # with the optional parameter, $collapsed.
      
      # The group will be collapsed if $hidden is non-zero.
      # The syntax is: set_row($row, $height, $XF, $hidden, $level, $collapsed)
      #
      $worksheet2->set_row( 1, undef, undef, 1, 2 );
      $worksheet2->set_row( 2, undef, undef, 1, 2 );
      $worksheet2->set_row( 3, undef, undef, 1, 2 );
      $worksheet2->set_row( 4, undef, undef, 1, 2 );
      $worksheet2->set_row( 5, undef, undef, 1, 1 );
      
      $worksheet2->set_row( 6,  undef, undef, 1, 2 );
      $worksheet2->set_row( 7,  undef, undef, 1, 2 );
      $worksheet2->set_row( 8,  undef, undef, 1, 2 );
      $worksheet2->set_row( 9,  undef, undef, 1, 2 );
      $worksheet2->set_row( 10, undef, undef, 1, 1 );
      $worksheet2->set_row( 11, undef, undef, 0, 0, 1 );
      
      
      # Add a column format for clarity
      $worksheet2->set_column( 'A:A', 20 );
      
      # Add the data, labels and formulas
      $worksheet2->write( 'A1', 'Region', $bold );
      $worksheet2->write( 'A2', 'North' );
      $worksheet2->write( 'A3', 'North' );
      $worksheet2->write( 'A4', 'North' );
      $worksheet2->write( 'A5', 'North' );
      $worksheet2->write( 'A6', 'North Total', $bold );
      
      $worksheet2->write( 'B1', 'Sales', $bold );
      $worksheet2->write( 'B2', 1000 );
      $worksheet2->write( 'B3', 1200 );
      $worksheet2->write( 'B4', 900 );
      $worksheet2->write( 'B5', 1200 );
      $worksheet2->write( 'B6', '=SUBTOTAL(9,B2:B5)', $bold );
      
      $worksheet2->write( 'A7',  'South' );
      $worksheet2->write( 'A8',  'South' );
      $worksheet2->write( 'A9',  'South' );
      $worksheet2->write( 'A10', 'South' );
      $worksheet2->write( 'A11', 'South Total', $bold );
      
      $worksheet2->write( 'B7',  400 );
      $worksheet2->write( 'B8',  600 );
      $worksheet2->write( 'B9',  500 );
      $worksheet2->write( 'B10', 600 );
      $worksheet2->write( 'B11', '=SUBTOTAL(9,B7:B10)', $bold );
      
      $worksheet2->write( 'A12', 'Grand Total',         $bold );
      $worksheet2->write( 'B12', '=SUBTOTAL(9,B2:B10)', $bold );
      
      
      ###############################################################################
      #
      # Example 3: Create a worksheet with outlined columns.
      #
      my $data = [
          [ 'Month', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', ' Total' ],
          [ 'North', 50,    20,    15,    25,    65,    80,    '=SUM(B2:G2)' ],
          [ 'South', 10,    20,    30,    50,    50,    50,    '=SUM(B3:G3)' ],
          [ 'East',  45,    75,    50,    15,    75,    100,   '=SUM(B4:G4)' ],
          [ 'West',  15,    15,    55,    35,    20,    50,    '=SUM(B5:G5)' ],
      ];
      
      # Add bold format to the first row
      $worksheet3->set_row( 0, undef, $bold );
      
      # Syntax: set_column($col1, $col2, $width, $XF, $hidden, $level, $collapsed)
      $worksheet3->set_column( 'A:A', 10, $bold );
      $worksheet3->set_column( 'B:G', 5, undef, 0, 1 );
      $worksheet3->set_column( 'H:H', 10 );
      
      # Write the data and a formula
      $worksheet3->write_col( 'A1', $data );
      $worksheet3->write( 'H6', '=SUM(H2:H5)', $bold );
      
      
      ###############################################################################
      #
      # Example 4: Show all possible outline levels.
      #
      my $levels = [
          "Level 1", "Level 2", "Level 3", "Level 4", "Level 5", "Level 6",
          "Level 7", "Level 6", "Level 5", "Level 4", "Level 3", "Level 2",
          "Level 1"
      ];
      
      
      $worksheet4->write_col( 'A1', $levels );
      
      $worksheet4->set_row( 0,  undef, undef, undef, 1 );
      $worksheet4->set_row( 1,  undef, undef, undef, 2 );
      $worksheet4->set_row( 2,  undef, undef, undef, 3 );
      $worksheet4->set_row( 3,  undef, undef, undef, 4 );
      $worksheet4->set_row( 4,  undef, undef, undef, 5 );
      $worksheet4->set_row( 5,  undef, undef, undef, 6 );
      $worksheet4->set_row( 6,  undef, undef, undef, 7 );
      $worksheet4->set_row( 7,  undef, undef, undef, 6 );
      $worksheet4->set_row( 8,  undef, undef, undef, 5 );
      $worksheet4->set_row( 9,  undef, undef, undef, 4 );
      $worksheet4->set_row( 10, undef, undef, undef, 3 );
      $worksheet4->set_row( 11, undef, undef, undef, 2 );
      $worksheet4->set_row( 12, undef, undef, undef, 1 );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/outline.pl>
  
  =head2 Example: outline_collapsed.pl
  
  
  
  Example of how to use Excel::Writer::XLSX to generate Excel outlines and
  grouping.
  
  These examples focus mainly on collapsed outlines. See also the
  outlines.pl example program for more general examples.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/outline_collapsed.jpg" width="640" height="420" alt="Output from outline_collapsed.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to use Excel::Writer::XLSX to generate Excel outlines and
      # grouping.
      #
      # These examples focus mainly on collapsed outlines. See also the
      # outlines.pl example program for more general examples.
      #
      # reverse ('(c)'), March 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add some worksheets
      my $workbook   = Excel::Writer::XLSX->new( 'outline_collapsed.xlsx' );
      my $worksheet1 = $workbook->add_worksheet( 'Outlined Rows' );
      my $worksheet2 = $workbook->add_worksheet( 'Collapsed Rows 1' );
      my $worksheet3 = $workbook->add_worksheet( 'Collapsed Rows 2' );
      my $worksheet4 = $workbook->add_worksheet( 'Collapsed Rows 3' );
      my $worksheet5 = $workbook->add_worksheet( 'Outline Columns' );
      my $worksheet6 = $workbook->add_worksheet( 'Collapsed Columns' );
      
      
      # Add a general format
      my $bold = $workbook->add_format( bold => 1 );
      
      
      #
      # This function will generate the same data and sub-totals on each worksheet.
      #
      sub create_sub_totals {
      
          my $worksheet = $_[0];
      
          # Add a column format for clarity
          $worksheet->set_column( 'A:A', 20 );
      
          # Add the data, labels and formulas
          $worksheet->write( 'A1', 'Region', $bold );
          $worksheet->write( 'A2', 'North' );
          $worksheet->write( 'A3', 'North' );
          $worksheet->write( 'A4', 'North' );
          $worksheet->write( 'A5', 'North' );
          $worksheet->write( 'A6', 'North Total', $bold );
      
          $worksheet->write( 'B1', 'Sales', $bold );
          $worksheet->write( 'B2', 1000 );
          $worksheet->write( 'B3', 1200 );
          $worksheet->write( 'B4', 900 );
          $worksheet->write( 'B5', 1200 );
          $worksheet->write( 'B6', '=SUBTOTAL(9,B2:B5)', $bold );
      
          $worksheet->write( 'A7',  'South' );
          $worksheet->write( 'A8',  'South' );
          $worksheet->write( 'A9',  'South' );
          $worksheet->write( 'A10', 'South' );
          $worksheet->write( 'A11', 'South Total', $bold );
      
          $worksheet->write( 'B7',  400 );
          $worksheet->write( 'B8',  600 );
          $worksheet->write( 'B9',  500 );
          $worksheet->write( 'B10', 600 );
          $worksheet->write( 'B11', '=SUBTOTAL(9,B7:B10)', $bold );
      
          $worksheet->write( 'A12', 'Grand Total',         $bold );
          $worksheet->write( 'B12', '=SUBTOTAL(9,B2:B10)', $bold );
      
      }
      
      
      ###############################################################################
      #
      # Example 1: Create a worksheet with outlined rows. It also includes SUBTOTAL()
      # functions so that it looks like the type of automatic outlines that are
      # generated when you use the Excel Data->SubTotals menu item.
      #
      
      # The syntax is: set_row($row, $height, $XF, $hidden, $level, $collapsed)
      $worksheet1->set_row( 1, undef, undef, 0, 2 );
      $worksheet1->set_row( 2, undef, undef, 0, 2 );
      $worksheet1->set_row( 3, undef, undef, 0, 2 );
      $worksheet1->set_row( 4, undef, undef, 0, 2 );
      $worksheet1->set_row( 5, undef, undef, 0, 1 );
      
      $worksheet1->set_row( 6,  undef, undef, 0, 2 );
      $worksheet1->set_row( 7,  undef, undef, 0, 2 );
      $worksheet1->set_row( 8,  undef, undef, 0, 2 );
      $worksheet1->set_row( 9,  undef, undef, 0, 2 );
      $worksheet1->set_row( 10, undef, undef, 0, 1 );
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals( $worksheet1 );
      
      
      ###############################################################################
      #
      # Example 2: Create a worksheet with collapsed outlined rows.
      # This is the same as the example 1  except that the all rows are collapsed.
      # Note: We need to indicate the row that contains the collapsed symbol '+' with
      # the optional parameter, $collapsed.
      
      $worksheet2->set_row( 1, undef, undef, 1, 2 );
      $worksheet2->set_row( 2, undef, undef, 1, 2 );
      $worksheet2->set_row( 3, undef, undef, 1, 2 );
      $worksheet2->set_row( 4, undef, undef, 1, 2 );
      $worksheet2->set_row( 5, undef, undef, 1, 1 );
      
      $worksheet2->set_row( 6,  undef, undef, 1, 2 );
      $worksheet2->set_row( 7,  undef, undef, 1, 2 );
      $worksheet2->set_row( 8,  undef, undef, 1, 2 );
      $worksheet2->set_row( 9,  undef, undef, 1, 2 );
      $worksheet2->set_row( 10, undef, undef, 1, 1 );
      
      $worksheet2->set_row( 11, undef, undef, 0, 0, 1 );
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals( $worksheet2 );
      
      
      ###############################################################################
      #
      # Example 3: Create a worksheet with collapsed outlined rows.
      # Same as the example 1  except that the two sub-totals are collapsed.
      
      $worksheet3->set_row( 1, undef, undef, 1, 2 );
      $worksheet3->set_row( 2, undef, undef, 1, 2 );
      $worksheet3->set_row( 3, undef, undef, 1, 2 );
      $worksheet3->set_row( 4, undef, undef, 1, 2 );
      $worksheet3->set_row( 5, undef, undef, 0, 1, 1 );
      
      $worksheet3->set_row( 6,  undef, undef, 1, 2 );
      $worksheet3->set_row( 7,  undef, undef, 1, 2 );
      $worksheet3->set_row( 8,  undef, undef, 1, 2 );
      $worksheet3->set_row( 9,  undef, undef, 1, 2 );
      $worksheet3->set_row( 10, undef, undef, 0, 1, 1 );
      
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals( $worksheet3 );
      
      
      ###############################################################################
      #
      # Example 4: Create a worksheet with outlined rows.
      # Same as the example 1  except that the two sub-totals are collapsed.
      
      $worksheet4->set_row( 1, undef, undef, 1, 2 );
      $worksheet4->set_row( 2, undef, undef, 1, 2 );
      $worksheet4->set_row( 3, undef, undef, 1, 2 );
      $worksheet4->set_row( 4, undef, undef, 1, 2 );
      $worksheet4->set_row( 5, undef, undef, 1, 1, 1 );
      
      $worksheet4->set_row( 6,  undef, undef, 1, 2 );
      $worksheet4->set_row( 7,  undef, undef, 1, 2 );
      $worksheet4->set_row( 8,  undef, undef, 1, 2 );
      $worksheet4->set_row( 9,  undef, undef, 1, 2 );
      $worksheet4->set_row( 10, undef, undef, 1, 1, 1 );
      
      $worksheet4->set_row( 11, undef, undef, 0, 0, 1 );
      
      # Write the sub-total data that is common to the row examples.
      create_sub_totals( $worksheet4 );
      
      
      ###############################################################################
      #
      # Example 5: Create a worksheet with outlined columns.
      #
      my $data = [
          [ 'Month', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Total' ],
          [ 'North', 50,    20,    15,    25,    65,    80,,   '=SUM(B2:G2)' ],
          [ 'South', 10,    20,    30,    50,    50,    50,,   '=SUM(B3:G3)' ],
          [ 'East',  45,    75,    50,    15,    75,    100,,  '=SUM(B4:G4)' ],
          [ 'West',  15,    15,    55,    35,    20,    50,,   '=SUM(B5:G6)' ],
      ];
      
      # Add bold format to the first row
      $worksheet5->set_row( 0, undef, $bold );
      
      # Syntax: set_column($col1, $col2, $width, $XF, $hidden, $level, $collapsed)
      $worksheet5->set_column( 'A:A', 10, $bold );
      $worksheet5->set_column( 'B:G', 5, undef, 0, 1 );
      $worksheet5->set_column( 'H:H', 10 );
      
      # Write the data and a formula
      $worksheet5->write_col( 'A1', $data );
      $worksheet5->write( 'H6', '=SUM(H2:H5)', $bold );
      
      
      ###############################################################################
      #
      # Example 6: Create a worksheet with collapsed outlined columns.
      # This is the same as the previous example except collapsed columns.
      
      # Add bold format to the first row
      $worksheet6->set_row( 0, undef, $bold );
      
      # Syntax: set_column($col1, $col2, $width, $XF, $hidden, $level, $collapsed)
      $worksheet6->set_column( 'A:A', 10, $bold );
      $worksheet6->set_column( 'B:G', 5,  undef, 1, 1 );
      $worksheet6->set_column( 'H:H', 10, undef, 0, 0, 1 );
      
      # Write the data and a formula
      $worksheet6->write_col( 'A1', $data );
      $worksheet6->write( 'H6', '=SUM(H2:H5)', $bold );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/outline_collapsed.pl>
  
  =head2 Example: panes.pl
  
  
  
  Example of using the Excel::Writer::XLSX module to create worksheet panes.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/panes.jpg" width="640" height="420" alt="Output from panes.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # Example of using the Excel::Writer::XLSX module to create worksheet panes.
      #
      # reverse ('(c)'), May 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'panes.xlsx' );
      
      my $worksheet1 = $workbook->add_worksheet( 'Panes 1' );
      my $worksheet2 = $workbook->add_worksheet( 'Panes 2' );
      my $worksheet3 = $workbook->add_worksheet( 'Panes 3' );
      my $worksheet4 = $workbook->add_worksheet( 'Panes 4' );
      
      # Freeze panes
      $worksheet1->freeze_panes( 1, 0 );    # 1 row
      
      $worksheet2->freeze_panes( 0, 1 );    # 1 column
      $worksheet3->freeze_panes( 1, 1 );    # 1 row and column
      
      # Split panes.
      # The divisions must be specified in terms of row and column dimensions.
      # The default row height is 15 and the default column width is 8.43
      #
      $worksheet4->split_panes( 15, 8.43 );    # 1 row and column
      
      
      #######################################################################
      #
      # Set up some formatting and text to highlight the panes
      #
      
      my $header = $workbook->add_format(
          align    => 'center',
          valign   => 'vcenter',
          fg_color => '#C3FFC0',
      );
      
      my $center = $workbook->add_format( align => 'center' );
      
      
      #######################################################################
      #
      # Sheet 1
      #
      
      $worksheet1->set_column( 'A:I', 16 );
      $worksheet1->set_row( 0, 20 );
      $worksheet1->set_selection( 'C3' );
      
      for my $i ( 0 .. 8 ) {
          $worksheet1->write( 0, $i, 'Scroll down', $header );
      }
      
      for my $i ( 1 .. 100 ) {
          for my $j ( 0 .. 8 ) {
              $worksheet1->write( $i, $j, $i + 1, $center );
          }
      }
      
      
      #######################################################################
      #
      # Sheet 2
      #
      
      $worksheet2->set_column( 'A:A', 16 );
      $worksheet2->set_selection( 'C3' );
      
      for my $i ( 0 .. 49 ) {
          $worksheet2->set_row( $i, 15 );
          $worksheet2->write( $i, 0, 'Scroll right', $header );
      }
      
      for my $i ( 0 .. 49 ) {
          for my $j ( 1 .. 25 ) {
              $worksheet2->write( $i, $j, $j, $center );
          }
      }
      
      
      #######################################################################
      #
      # Sheet 3
      #
      
      $worksheet3->set_column( 'A:Z', 16 );
      $worksheet3->set_selection( 'C3' );
      
      $worksheet3->write( 0, 0, '', $header );
      
      for my $i ( 1 .. 25 ) {
          $worksheet3->write( 0, $i, 'Scroll down', $header );
      }
      
      for my $i ( 1 .. 49 ) {
          $worksheet3->write( $i, 0, 'Scroll right', $header );
      }
      
      for my $i ( 1 .. 49 ) {
          for my $j ( 1 .. 25 ) {
              $worksheet3->write( $i, $j, $j, $center );
          }
      }
      
      
      #######################################################################
      #
      # Sheet 4
      #
      
      $worksheet4->set_selection( 'C3' );
      
      for my $i ( 1 .. 25 ) {
          $worksheet4->write( 0, $i, 'Scroll', $center );
      }
      
      for my $i ( 1 .. 49 ) {
          $worksheet4->write( $i, 0, 'Scroll', $center );
      }
      
      for my $i ( 1 .. 49 ) {
          for my $j ( 1 .. 25 ) {
              $worksheet4->write( $i, $j, $j, $center );
          }
      }
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/panes.pl>
  
  =head2 Example: properties.pl
  
  
  
  An example of adding document properties to a Excel::Writer::XLSX file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/properties.jpg" width="640" height="420" alt="Output from properties.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # An example of adding document properties to a Excel::Writer::XLSX file.
      #
      # reverse ('(c)'), August 2008, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'properties.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      $workbook->set_properties(
          title    => 'This is an example spreadsheet',
          subject  => 'With document properties',
          author   => 'John McNamara',
          manager  => 'Dr. Heinz Doofenshmirtz',
          company  => 'of Wolves',
          category => 'Example spreadsheets',
          keywords => 'Sample, Example, Properties',
          comments => 'Created with Perl and Excel::Writer::XLSX',
          status   => 'Quo',
      );
      
      
      $worksheet->set_column( 'A:A', 70 );
      $worksheet->write( 'A1', qq{Select 'Office Button -> Prepare -> Properties' to see the file properties.} );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/properties.pl>
  
  =head2 Example: protection.pl
  
  
  
  Example of cell locking and formula hiding in an Excel worksheet via
  the Excel::Writer::XLSX module.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/protection.jpg" width="640" height="420" alt="Output from protection.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ########################################################################
      #
      # Example of cell locking and formula hiding in an Excel worksheet via
      # the Excel::Writer::XLSX module.
      #
      # reverse ('(c)'), August 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'protection.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Create some format objects
      my $unlocked = $workbook->add_format( locked => 0 );
      my $hidden   = $workbook->add_format( hidden => 1 );
      
      # Format the columns
      $worksheet->set_column( 'A:A', 45 );
      $worksheet->set_selection( 'B3' );
      
      # Protect the worksheet
      $worksheet->protect();
      
      # Examples of cell locking and hiding.
      $worksheet->write( 'A1', 'Cell B1 is locked. It cannot be edited.' );
      $worksheet->write_formula( 'B1', '=1+2', undef, 3 );    # Locked by default.
      
      $worksheet->write( 'A2', 'Cell B2 is unlocked. It can be edited.' );
      $worksheet->write_formula( 'B2', '=1+2', $unlocked, 3 );
      
      $worksheet->write( 'A3', "Cell B3 is hidden. The formula isn't visible." );
      $worksheet->write_formula( 'B3', '=1+2', $hidden, 3 );
      
      $worksheet->write( 'A5', 'Use Menu->Tools->Protection->Unprotect Sheet' );
      $worksheet->write( 'A6', 'to remove the worksheet protection.' );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/protection.pl>
  
  =head2 Example: rich_strings.pl
  
  
  
  An Excel::Writer::XLSX example showing how to use "rich strings", i.e.,
  strings with multiple formatting.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/rich_strings.jpg" width="640" height="420" alt="Output from rich_strings.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # An Excel::Writer::XLSX example showing how to use "rich strings", i.e.,
      # strings with multiple formatting.
      #
      # reverse ('(c)'), February 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'rich_strings.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->set_column( 'A:A', 30 );
      
      # Set some formats to use.
      my $bold   = $workbook->add_format( bold        => 1 );
      my $italic = $workbook->add_format( italic      => 1 );
      my $red    = $workbook->add_format( color       => 'red' );
      my $blue   = $workbook->add_format( color       => 'blue' );
      my $center = $workbook->add_format( align       => 'center' );
      my $super  = $workbook->add_format( font_script => 1 );
      
      
      # Write some strings with multiple formats.
      $worksheet->write_rich_string( 'A1',
          'This is ', $bold, 'bold', ' and this is ', $italic, 'italic' );
      
      $worksheet->write_rich_string( 'A3',
          'This is ', $red, 'red', ' and this is ', $blue, 'blue' );
      
      $worksheet->write_rich_string( 'A5',
          'Some ', $bold, 'bold text', ' centered', $center );
      
      $worksheet->write_rich_string( 'A7',
          $italic, 'j = k', $super, '(n-1)', $center );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/rich_strings.pl>
  
  =head2 Example: right_to_left.pl
  
  
  
  Example of how to change the default worksheet direction from
  left-to-right to right-to-left as required by some eastern verions
  of Excel.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/right_to_left.jpg" width="640" height="420" alt="Output from right_to_left.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # Example of how to change the default worksheet direction from
      # left-to-right to right-to-left as required by some eastern verions
      # of Excel.
      #
      # reverse ('(c)'), January 2006, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook   = Excel::Writer::XLSX->new( 'right_to_left.xlsx' );
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      
      $worksheet2->right_to_left();
      
      $worksheet1->write( 0, 0, 'Hello' );    #  A1, B1, C1, ...
      $worksheet2->write( 0, 0, 'Hello' );    # ..., C1, B1, A1
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/right_to_left.pl>
  
  =head2 Example: sales.pl
  
  
  
  Example of a sales worksheet to demonstrate several different features.
  Also uses functions from the L<Excel::Writer::XLSX::Utility> module.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/sales.jpg" width="640" height="420" alt="Output from sales.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of a sales worksheet to demonstrate several different features.
      # Also uses functions from the L<Excel::Writer::XLSX::Utility> module.
      #
      # reverse ('(c)'), October 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      use Excel::Writer::XLSX::Utility;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'sales.xlsx' );
      my $worksheet = $workbook->add_worksheet( 'May Sales' );
      
      
      # Set up some formats
      my %heading = (
          bold     => 1,
          pattern  => 1,
          fg_color => '#C3FFC0',
          border   => 1,
          align    => 'center',
      );
      
      my %total = (
          bold       => 1,
          top        => 1,
          num_format => '$#,##0.00'
      );
      
      my $heading      = $workbook->add_format( %heading );
      my $total_format = $workbook->add_format( %total );
      my $price_format = $workbook->add_format( num_format => '$#,##0.00' );
      my $date_format  = $workbook->add_format( num_format => 'mmm d yyy' );
      
      
      # Write the main headings
      $worksheet->freeze_panes( 1 );    # Freeze the first row
      $worksheet->write( 'A1', 'Item',     $heading );
      $worksheet->write( 'B1', 'Quantity', $heading );
      $worksheet->write( 'C1', 'Price',    $heading );
      $worksheet->write( 'D1', 'Total',    $heading );
      $worksheet->write( 'E1', 'Date',     $heading );
      
      # Set the column widths
      $worksheet->set_column( 'A:A', 25 );
      $worksheet->set_column( 'B:B', 10 );
      $worksheet->set_column( 'C:E', 16 );
      
      
      # Extract the sales data from the __DATA__ section at the end of the file.
      # In reality this information would probably come from a database
      my @sales;
      
      foreach my $line ( <DATA> ) {
          chomp $line;
          next if $line eq '';
      
          # Simple-minded processing of CSV data. Refer to the Text::CSV_XS
          # and Text::xSV modules for a more complete CSV handling.
          my @items = split /,/, $line;
          push @sales, \@items;
      }
      
      
      # Write out the items from each row
      my $row = 1;
      foreach my $sale ( @sales ) {
      
          $worksheet->write( $row, 0, @$sale[0] );
          $worksheet->write( $row, 1, @$sale[1] );
          $worksheet->write( $row, 2, @$sale[2], $price_format );
      
          # Create a formula like '=B2*C2'
          my $formula =
            '=' . xl_rowcol_to_cell( $row, 1 ) . "*" . xl_rowcol_to_cell( $row, 2 );
      
          $worksheet->write( $row, 3, $formula, $price_format );
      
          # Parse the date
          my $date = xl_decode_date_US( @$sale[3] );
          $worksheet->write( $row, 4, $date, $date_format );
          $row++;
      }
      
      # Create a formula to sum the totals, like '=SUM(D2:D6)'
      my $total = '=SUM(D2:' . xl_rowcol_to_cell( $row - 1, 3 ) . ")";
      
      $worksheet->write( $row, 3, $total, $total_format );
      
      
      __DATA__
      586 card,20,125.50,5/12/01
      Flat Screen Monitor,1,1300.00,5/12/01
      64 MB dimms,45,49.99,5/13/01
      15 GB HD,12,300.00,5/13/01
      Speakers (pair),5,15.50,5/14/01
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/sales.pl>
  
  =head2 Example: shape1.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  add shapes to an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape1.jpg" width="640" height="420" alt="Output from shape1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # add shapes to an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape1.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Add a circle, with centered text.
      my $ellipse = $workbook->add_shape(
          type   => 'ellipse',
          text   => "Hello\nWorld",
          width  => 60,
          height => 60
      );
      
      $worksheet->insert_shape( 'A1', $ellipse, 50, 50 );
      
      # Add a plus sign.
      my $plus = $workbook->add_shape( type => 'plus', width => 20, height => 20 );
      $worksheet->insert_shape( 'D8', $plus );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape1.pl>
  
  =head2 Example: shape2.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  modify shape properties in an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape2.jpg" width="640" height="420" alt="Output from shape2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # modify shape properties in an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape2.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->hide_gridlines( 2 );
      
      my $plain = $workbook->add_shape(
          type   => 'smileyFace',
          text   => "Plain",
          width  => 100,
          height => 100,
      );
      
      my $bbformat = $workbook->add_format(
          color => 'red',
          font  => 'Lucida Calligraphy',
      );
      
      $bbformat->set_bold();
      $bbformat->set_underline();
      $bbformat->set_italic();
      
      my $decor = $workbook->add_shape(
          type        => 'smileyFace',
          text        => "Decorated",
          rotation    => 45,
          width       => 200,
          height      => 100,
          format      => $bbformat,
          line_type   => 'sysDot',
          line_weight => 3,
          fill        => 'FFFF00',
          line        => '3366FF',
      );
      
      $worksheet->insert_shape( 'A1', $plain, 50,  50 );
      $worksheet->insert_shape( 'A1', $decor, 250, 50 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape2.pl>
  
  =head2 Example: shape3.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  scale shapes in an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape3.jpg" width="640" height="420" alt="Output from shape3.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # scale shapes in an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape3.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      my $normal = $workbook->add_shape(
          name   => 'chip',
          type   => 'diamond',
          text   => "Normal",
          width  => 100,
          height => 100,
      );
      
      $worksheet->insert_shape( 'A1', $normal, 50, 50 );
      $normal->set_text( 'Scaled 3w x 2h' );
      $normal->set_name( 'Hope' );
      $worksheet->insert_shape( 'A1', $normal, 250, 50, 3, 2 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape3.pl>
  
  =head2 Example: shape4.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  demonstrate stenciling in an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape4.jpg" width="640" height="420" alt="Output from shape4.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # demonstrate stenciling in an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape4.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->hide_gridlines( 2 );
      
      my $type  = 'rect';
      my $shape = $workbook->add_shape(
          type   => $type,
          width  => 90,
          height => 90,
      );
      
      for my $n ( 1 .. 10 ) {
      
          # Change the last 5 rectangles to stars. Previously inserted shapes stay
          # as rectangles.
          $type = 'star5' if $n == 6;
          $shape->set_type( $type );
          $shape->set_text( "$type $n" );
          $worksheet->insert_shape( 'A1', $shape, $n * 100, 50 );
      }
      
      
      my $stencil = $workbook->add_shape(
          stencil => 1,                    # The default.
          width   => 90,
          height  => 90,
          text    => 'started as a box',
      );
      $worksheet->insert_shape( 'A1', $stencil, 100, 150 );
      
      $stencil->set_stencil( 0 );
      $worksheet->insert_shape( 'A1', $stencil, 200, 150 );
      $worksheet->insert_shape( 'A1', $stencil, 300, 150 );
      
      # Ooops!  Changed my mind.  Change the rectangle to an ellipse (circle),
      # for the last two shapes.
      $stencil->set_type( 'ellipse' );
      $stencil->set_text( 'Now its a circle' );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape4.pl>
  
  =head2 Example: shape5.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  add shapes (objects and top/bottom connectors) to an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape5.jpg" width="640" height="420" alt="Output from shape5.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # add shapes (objects and top/bottom connectors) to an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape5.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      my $s1 = $workbook->add_shape( type => 'ellipse', width => 60, height => 60 );
      $worksheet->insert_shape( 'A1', $s1, 50, 50 );
      
      my $s2 = $workbook->add_shape( type => 'plus', width => 20, height => 20 );
      $worksheet->insert_shape( 'A1', $s2, 250, 200 );
      
      # Create a connector to link the two shapes.
      my $cxn_shape = $workbook->add_shape( type => 'bentConnector3' );
      
      # Link the start of the connector to the right side.
      $cxn_shape->set_start( $s1->get_id() );
      $cxn_shape->set_start_index( 4 );  # 4th connection pt, clockwise from top(0).
      $cxn_shape->set_start_side( 'b' ); # r)ight or b)ottom.
      
      # Link the end of the connector to the left side.
      $cxn_shape->set_end( $s2->get_id() );
      $cxn_shape->set_end_index( 0 );     # clockwise from top(0).
      $cxn_shape->set_end_side( 't' );    # t)top.
      
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape5.pl>
  
  =head2 Example: shape6.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  add shapes (objects and right/left connectors) to an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape6.jpg" width="640" height="420" alt="Output from shape6.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # add shapes (objects and right/left connectors) to an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape6.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      my $s1 = $workbook->add_shape( type => 'chevron', width => 60, height => 60 );
      $worksheet->insert_shape( 'A1', $s1, 50, 50 );
      
      my $s2 = $workbook->add_shape( type => 'pentagon', width => 20, height => 20 );
      $worksheet->insert_shape( 'A1', $s2, 250, 200 );
      
      # Create a connector to link the two shapes.
      my $cxn_shape = $workbook->add_shape( type => 'curvedConnector3' );
      
      # Link the start of the connector to the right side.
      $cxn_shape->set_start( $s1->get_id() );
      $cxn_shape->set_start_index( 2 );    # 2nd connection pt, clockwise from top(0).
      $cxn_shape->set_start_side( 'r' );   # r)ight or b)ottom.
      
      # Link the end of the connector to the left side.
      $cxn_shape->set_end( $s2->get_id() );
      $cxn_shape->set_end_index( 4 );      # 4th connection pt, clockwise from top(0).
      $cxn_shape->set_end_side( 'l' );     # l)eft or t)op.
      
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape6.pl>
  
  =head2 Example: shape7.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  add shapes and one-to-many connectors to an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape7.jpg" width="640" height="420" alt="Output from shape7.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # add shapes and one-to-many connectors to an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape7.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Add a circle, with centered text. c is for circle, not center.
      my $cw = 60;
      my $ch = 60;
      my $cx = 210;
      my $cy = 190;
      
      my $ellipse = $workbook->add_shape(
          type   => 'ellipse',
          id     => 2,
          text   => "Hello\nWorld",
          width  => $cw,
          height => $ch
      );
      $worksheet->insert_shape( 'A1', $ellipse, $cx, $cy );
      
      # Add a plus sign at 4 different positions around the circle.
      my $pw = 20;
      my $ph = 20;
      my $px = 120;
      my $py = 250;
      my $plus =
        $workbook->add_shape( type => 'plus', id => 3, width => $pw, height => $ph );
      my $p1 = $worksheet->insert_shape( 'A1', $plus, 350, 350 );
      my $p2 = $worksheet->insert_shape( 'A1', $plus, 150, 350 );
      my $p3 = $worksheet->insert_shape( 'A1', $plus, 350, 150 );
      $plus->set_adjustments( 35 );    # change shape of plus symbol.
      my $p4 = $worksheet->insert_shape( 'A1', $plus, 150, 150 );
      
      my $cxn_shape = $workbook->add_shape( type => 'bentConnector3', fill => 0 );
      
      $cxn_shape->set_start( $ellipse->get_id() );
      $cxn_shape->set_start_index( 4 );    # 4nd connection pt, clockwise from top(0).
      $cxn_shape->set_start_side( 'b' );   # r)ight or b)ottom.
      
      $cxn_shape->set_end( $p1->get_id() );
      $cxn_shape->set_end_index( 0 );
      $cxn_shape->set_end_side( 't' );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      $cxn_shape->set_end( $p2->get_id() );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      $cxn_shape->set_end( $p3->get_id() );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      $cxn_shape->set_end( $p4->get_id() );
      $cxn_shape->set_adjustments( -50, 45, 120 );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape7.pl>
  
  =head2 Example: shape8.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  add shapes and one-to-many connectors to an Excel xlsx file.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape8.jpg" width="640" height="420" alt="Output from shape8.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # add shapes and one-to-many connectors to an Excel xlsx file.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'shape8.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Add a circle, with centered text. c is for circle, not center.
      my $cw = 60;
      my $ch = 60;
      my $cx = 210;
      my $cy = 190;
      
      my $ellipse = $workbook->add_shape(
          type   => 'ellipse',
          id     => 2,
          text   => "Hello\nWorld",
          width  => $cw,
          height => $ch
      );
      $worksheet->insert_shape( 'A1', $ellipse, $cx, $cy );
      
      # Add a plus sign at 4 different positions around the circle.
      my $pw = 20;
      my $ph = 20;
      my $px = 120;
      my $py = 250;
      my $plus =
        $workbook->add_shape( type => 'plus', id => 3, width => $pw, height => $ph );
      my $p1 = $worksheet->insert_shape( 'A1', $plus, 350, 150 );    #  2:00
      my $p2 = $worksheet->insert_shape( 'A1', $plus, 350, 350 );    #  4:00
      my $p3 = $worksheet->insert_shape( 'A1', $plus, 150, 350 );    #  8:00
      my $p4 = $worksheet->insert_shape( 'A1', $plus, 150, 150 );    # 10:00
      
      my $cxn_shape = $workbook->add_shape( type => 'bentConnector3', fill => 0 );
      
      $cxn_shape->set_start( $ellipse->get_id() );
      $cxn_shape->set_start_index( 2 );    # 2nd connection pt, clockwise from top(0).
      $cxn_shape->set_start_side( 'r' );   # r)ight or b)ottom.
      
      $cxn_shape->set_end( $p1->get_id() );
      $cxn_shape->set_end_index( 3 );      # 3rd connection point on plus, right side
      $cxn_shape->set_end_side( 'l' );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      $cxn_shape->set_end( $p2->get_id() );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      $cxn_shape->set_end( $p3->get_id() );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      $cxn_shape->set_end( $p4->get_id() );
      $cxn_shape->set_adjustments( -50, 45, 120 );
      $worksheet->insert_shape( 'A1', $cxn_shape, 0, 0 );
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape8.pl>
  
  =head2 Example: shape_all.pl
  
  
  
  A simple example of how to use the Excel::Writer::XLSX module to
  add all shapes (as currently implemented) to an Excel xlsx file.
  
  The list at the end consists of all the shape types defined as
  ST_ShapeType in ECMA-376, Office Open XML File Formats Part 4.
  
  The grouping by worksheet name is for illustration only. It isn't
  part of the ECMA-376 standard.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/shape_all.jpg" width="640" height="420" alt="Output from shape_all.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # A simple example of how to use the Excel::Writer::XLSX module to
      # add all shapes (as currently implemented) to an Excel xlsx file.
      #
      # The list at the end consists of all the shape types defined as
      # ST_ShapeType in ECMA-376, Office Open XML File Formats Part 4.
      #
      # The grouping by worksheet name is for illustration only. It isn't
      # part of the ECMA-376 standard.
      #
      # reverse ('(c)'), May 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook = Excel::Writer::XLSX->new( 'shape_all.xlsx' );
      
      my ( $worksheet, $last_sheet, $shape, $r ) = ( 0, '', '', undef, 0 );
      
      while ( <DATA> ) {
          chomp;
          next unless m/^\w/;    # Skip blank lines and comments.
      
          my ( $sheet, $name ) = split( /\t/, $_ );
          if ( $last_sheet ne $sheet ) {
              $worksheet = $workbook->add_worksheet( $sheet );
              $r         = 2;
          }
          $last_sheet = $sheet;
          $shape      = $workbook->add_shape(
              type   => $name,
              text   => $name,
              width  => 90,
              height => 90
          );
      
          # Connectors can not have labels, so write the connector name in the cell
          # to the left.
          $worksheet->write( $r, 0, $name ) if $sheet eq 'Connector';
          $worksheet->insert_shape( $r, 2, $shape, 0, 0 );
          $r += 5;
      }
      
      __END__
      Action	actionButtonBackPrevious
      Action	actionButtonBeginning
      Action	actionButtonBlank
      Action	actionButtonDocument
      Action	actionButtonEnd
      Action	actionButtonForwardNext
      Action	actionButtonHelp
      Action	actionButtonHome
      Action	actionButtonInformation
      Action	actionButtonMovie
      Action	actionButtonReturn
      Action	actionButtonSound
      Arrow	bentArrow
      Arrow	bentUpArrow
      Arrow	circularArrow
      Arrow	curvedDownArrow
      Arrow	curvedLeftArrow
      Arrow	curvedRightArrow
      Arrow	curvedUpArrow
      Arrow	downArrow
      Arrow	leftArrow
      Arrow	leftCircularArrow
      Arrow	leftRightArrow
      Arrow	leftRightCircularArrow
      Arrow	leftRightUpArrow
      Arrow	leftUpArrow
      Arrow	notchedRightArrow
      Arrow	quadArrow
      Arrow	rightArrow
      Arrow	stripedRightArrow
      Arrow	swooshArrow
      Arrow	upArrow
      Arrow	upDownArrow
      Arrow	uturnArrow
      Basic	blockArc
      Basic	can
      Basic	chevron
      Basic	cube
      Basic	decagon
      Basic	diamond
      Basic	dodecagon
      Basic	donut
      Basic	ellipse
      Basic	funnel
      Basic	gear6
      Basic	gear9
      Basic	heart
      Basic	heptagon
      Basic	hexagon
      Basic	homePlate
      Basic	lightningBolt
      Basic	line
      Basic	lineInv
      Basic	moon
      Basic	nonIsoscelesTrapezoid
      Basic	noSmoking
      Basic	octagon
      Basic	parallelogram
      Basic	pentagon
      Basic	pie
      Basic	pieWedge
      Basic	plaque
      Basic	rect
      Basic	round1Rect
      Basic	round2DiagRect
      Basic	round2SameRect
      Basic	roundRect
      Basic	rtTriangle
      Basic	smileyFace
      Basic	snip1Rect
      Basic	snip2DiagRect
      Basic	snip2SameRect
      Basic	snipRoundRect
      Basic	star10
      Basic	star12
      Basic	star16
      Basic	star24
      Basic	star32
      Basic	star4
      Basic	star5
      Basic	star6
      Basic	star7
      Basic	star8
      Basic	sun
      Basic	teardrop
      Basic	trapezoid
      Basic	triangle
      Callout	accentBorderCallout1
      Callout	accentBorderCallout2
      Callout	accentBorderCallout3
      Callout	accentCallout1
      Callout	accentCallout2
      Callout	accentCallout3
      Callout	borderCallout1
      Callout	borderCallout2
      Callout	borderCallout3
      Callout	callout1
      Callout	callout2
      Callout	callout3
      Callout	cloudCallout
      Callout	downArrowCallout
      Callout	leftArrowCallout
      Callout	leftRightArrowCallout
      Callout	quadArrowCallout
      Callout	rightArrowCallout
      Callout	upArrowCallout
      Callout	upDownArrowCallout
      Callout	wedgeEllipseCallout
      Callout	wedgeRectCallout
      Callout	wedgeRoundRectCallout
      Chart	chartPlus
      Chart	chartStar
      Chart	chartX
      Connector	bentConnector2
      Connector	bentConnector3
      Connector	bentConnector4
      Connector	bentConnector5
      Connector	curvedConnector2
      Connector	curvedConnector3
      Connector	curvedConnector4
      Connector	curvedConnector5
      Connector	straightConnector1
      FlowChart	flowChartAlternateProcess
      FlowChart	flowChartCollate
      FlowChart	flowChartConnector
      FlowChart	flowChartDecision
      FlowChart	flowChartDelay
      FlowChart	flowChartDisplay
      FlowChart	flowChartDocument
      FlowChart	flowChartExtract
      FlowChart	flowChartInputOutput
      FlowChart	flowChartInternalStorage
      FlowChart	flowChartMagneticDisk
      FlowChart	flowChartMagneticDrum
      FlowChart	flowChartMagneticTape
      FlowChart	flowChartManualInput
      FlowChart	flowChartManualOperation
      FlowChart	flowChartMerge
      FlowChart	flowChartMultidocument
      FlowChart	flowChartOfflineStorage
      FlowChart	flowChartOffpageConnector
      FlowChart	flowChartOnlineStorage
      FlowChart	flowChartOr
      FlowChart	flowChartPredefinedProcess
      FlowChart	flowChartPreparation
      FlowChart	flowChartProcess
      FlowChart	flowChartPunchedCard
      FlowChart	flowChartPunchedTape
      FlowChart	flowChartSort
      FlowChart	flowChartSummingJunction
      FlowChart	flowChartTerminator
      Math	mathDivide
      Math	mathEqual
      Math	mathMinus
      Math	mathMultiply
      Math	mathNotEqual
      Math	mathPlus
      Star_Banner	arc
      Star_Banner	bevel
      Star_Banner	bracePair
      Star_Banner	bracketPair
      Star_Banner	chord
      Star_Banner	cloud
      Star_Banner	corner
      Star_Banner	diagStripe
      Star_Banner	doubleWave
      Star_Banner	ellipseRibbon
      Star_Banner	ellipseRibbon2
      Star_Banner	foldedCorner
      Star_Banner	frame
      Star_Banner	halfFrame
      Star_Banner	horizontalScroll
      Star_Banner	irregularSeal1
      Star_Banner	irregularSeal2
      Star_Banner	leftBrace
      Star_Banner	leftBracket
      Star_Banner	leftRightRibbon
      Star_Banner	plus
      Star_Banner	ribbon
      Star_Banner	ribbon2
      Star_Banner	rightBrace
      Star_Banner	rightBracket
      Star_Banner	verticalScroll
      Star_Banner	wave
      Tabs	cornerTabs
      Tabs	plaqueTabs
      Tabs	squareTabs
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/shape_all.pl>
  
  =head2 Example: sparklines1.pl
  
  
  
  Example of how to add sparklines to an Excel::Writer::XLSX file.
  
  Sparklines are small charts that fit in a single cell and are
  used to show trends in data. See sparklines2.pl for examples
  of more complex sparkline formatting.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/sparklines1.jpg" width="640" height="420" alt="Output from sparklines1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to add sparklines to an Excel::Writer::XLSX file.
      #
      # Sparklines are small charts that fit in a single cell and are
      # used to show trends in data. See sparklines2.pl for examples
      # of more complex sparkline formatting.
      #
      # reverse ('(c)'), November 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook  = Excel::Writer::XLSX->new( 'sparklines1.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Some sample data to plot.
      my $data = [
      
          [ -2, 2,  3,  -1, 0 ],
          [ 30, 20, 33, 20, 15 ],
          [ 1,  -1, -1, 1,  -1 ],
      
      ];
      
      # Write the sample data to the worksheet.
      $worksheet->write_col( 'A1', $data );
      
      
      # Add a line sparkline (the default) with markers.
      $worksheet->add_sparkline(
          {
              location => 'F1',
              range    => 'Sheet1!A1:E1',
              markers  => 1,
          }
      );
      
      # Add a column sparkline with non-default style.
      $worksheet->add_sparkline(
          {
              location => 'F2',
              range    => 'Sheet1!A2:E2',
              type     => 'column',
              style    => 12,
          }
      );
      
      # Add a win/loss sparkline with negative values highlighted.
      $worksheet->add_sparkline(
          {
              location        => 'F3',
              range           => 'Sheet1!A3:E3',
              type            => 'win_loss',
              negative_points => 1,
          }
      );
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/sparklines1.pl>
  
  =head2 Example: sparklines2.pl
  
  
  
  Example of how to add sparklines to an Excel::Writer::XLSX file.
  
  Sparklines are small charts that fit in a single cell and are
  used to show trends in data. This example shows the majority of
  options that can be applied to sparklines.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/sparklines2.jpg" width="640" height="420" alt="Output from sparklines2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to add sparklines to an Excel::Writer::XLSX file.
      #
      # Sparklines are small charts that fit in a single cell and are
      # used to show trends in data. This example shows the majority of
      # options that can be applied to sparklines.
      #
      # reverse ('(c)'), November 2011, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook    = Excel::Writer::XLSX->new( 'sparklines2.xlsx' );
      my $worksheet1  = $workbook->add_worksheet();
      my $worksheet2  = $workbook->add_worksheet();
      my $bold        = $workbook->add_format( bold => 1 );
      my $str;
      my $row = 1;
      
      # Set the columns widths to make the output clearer.
      $worksheet1->set_column( 'A:A', 14 );
      $worksheet1->set_column( 'B:B', 50 );
      $worksheet1->set_zoom( 150 );
      
      # Headings.
      $worksheet1->write( 'A1', 'Sparkline',   $bold );
      $worksheet1->write( 'B1', 'Description', $bold );
      
      
      ###############################################################################
      #
      $str = 'A default "line" sparkline.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A2',
              range    => 'Sheet2!A1:J1',
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'A default "column" sparkline.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A3',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'A default "win/loss" sparkline.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A4',
              range    => 'Sheet2!A3:J3',
              type     => 'win_loss',
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      $row++;
      
      
      ###############################################################################
      #
      $str = 'Line with markers.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A6',
              range    => 'Sheet2!A1:J1',
              markers  => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Line with high and low points.';
      
      $worksheet1->add_sparkline(
          {
              location   => 'A7',
              range      => 'Sheet2!A1:J1',
              high_point => 1,
              low_point  => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Line with first and last point markers.';
      
      $worksheet1->add_sparkline(
          {
              location    => 'A8',
              range       => 'Sheet2!A1:J1',
              first_point => 1,
              last_point  => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Line with negative point markers.';
      
      $worksheet1->add_sparkline(
          {
              location        => 'A9',
              range           => 'Sheet2!A1:J1',
              negative_points => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Line with axis.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A10',
              range    => 'Sheet2!A1:J1',
              axis     => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      $row++;
      
      
      ###############################################################################
      #
      $str = 'Column with default style (1).';
      
      $worksheet1->add_sparkline(
          {
              location => 'A12',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Column with style 2.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A13',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
              style    => 2,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Column with style 3.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A14',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
              style    => 3,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Column with style 4.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A15',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
              style    => 4,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Column with style 5.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A16',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
              style    => 5,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Column with style 6.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A17',
              range    => 'Sheet2!A2:J2',
              type     => 'column',
              style    => 6,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Column with a user defined colour.';
      
      $worksheet1->add_sparkline(
          {
              location     => 'A18',
              range        => 'Sheet2!A2:J2',
              type         => 'column',
              series_color => '#E965E0',
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      $row++;
      
      
      ###############################################################################
      #
      $str = 'A win/loss sparkline.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A20',
              range    => 'Sheet2!A3:J3',
              type     => 'win_loss',
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'A win/loss sparkline with negative points highlighted.';
      
      $worksheet1->add_sparkline(
          {
              location        => 'A21',
              range           => 'Sheet2!A3:J3',
              type            => 'win_loss',
              negative_points => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      $row++;
      
      
      ###############################################################################
      #
      $str = 'A left to right column (the default).';
      
      $worksheet1->add_sparkline(
          {
              location => 'A23',
              range    => 'Sheet2!A4:J4',
              type     => 'column',
              style    => 20,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'A right to left column.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A24',
              range    => 'Sheet2!A4:J4',
              type     => 'column',
              style    => 20,
              reverse  => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      ###############################################################################
      #
      $str = 'Sparkline and text in one cell.';
      
      $worksheet1->add_sparkline(
          {
              location => 'A25',
              range    => 'Sheet2!A4:J4',
              type     => 'column',
              style    => 20,
          }
      );
      
      $worksheet1->write( $row,   0, 'Growth' );
      $worksheet1->write( $row++, 1, $str );
      $row++;
      
      
      ###############################################################################
      #
      $str = 'A grouped sparkline. Changes are applied to all three.';
      
      $worksheet1->add_sparkline(
          {
              location => [ 'A27',          'A28',          'A29' ],
              range    => [ 'Sheet2!A5:J5', 'Sheet2!A6:J6', 'Sheet2!A7:J7' ],
              markers  => 1,
          }
      );
      
      $worksheet1->write( $row++, 1, $str );
      
      
      
      
      ###############################################################################
      #
      # Create a second worksheet with data to plot.
      #
      
      $worksheet2->set_column( 'A:J', 11 );
      
      my $data = [
      
          # Simple line data.
          [ -2, 2, 3, -1, 0, -2, 3, 2, 1, 0 ],
      
          # Simple column data.
          [ 30, 20, 33, 20, 15, 5, 5, 15, 10, 15 ],
      
          # Simple win/loss data.
          [ 1, 1, -1, -1, 1, -1, 1, 1, 1, -1 ],
      
          # Unbalanced histogram.
          [ 5, 6, 7, 10, 15, 20, 30, 50, 70, 100 ],
      
          # Data for the grouped sparkline example.
          [ -2, 2,  3, -1, 0, -2, 3, 2, 1, 0 ],
          [ 3,  -1, 0, -2, 3, 2,  1, 0, 2, 1 ],
          [ 0,  -2, 3, 2,  1, 0,  1, 2, 3, 1 ],
      
      
      ];
      
      # Write the sample data to the worksheet.
      $worksheet2->write_col( 'A1', $data );
      
      
      __END__
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/sparklines2.pl>
  
  =head2 Example: stats_ext.pl
  
  
  
  Example of formatting using the Excel::Writer::XLSX module
  
  This is a simple example of how to use functions that reference cells in
  other worksheets within the same workbook.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/stats_ext.jpg" width="640" height="420" alt="Output from stats_ext.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of formatting using the Excel::Writer::XLSX module
      #
      # This is a simple example of how to use functions that reference cells in
      # other worksheets within the same workbook.
      #
      # reverse ('(c)'), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook   = Excel::Writer::XLSX->new( 'stats_ext.xlsx' );
      my $worksheet1 = $workbook->add_worksheet( 'Test results' );
      my $worksheet2 = $workbook->add_worksheet( 'Data' );
      
      # Set the column width for columns 1
      $worksheet1->set_column( 'A:A', 20 );
      
      
      # Create a format for the headings
      my $heading = $workbook->add_format();
      $heading->set_bold();
      
      # Create a numerical format
      my $numformat = $workbook->add_format();
      $numformat->set_num_format( '0.00' );
      
      
      # Write some statistical functions
      $worksheet1->write( 'A1', 'Count', $heading );
      $worksheet1->write( 'B1', '=COUNT(Data!B2:B9)' );
      
      $worksheet1->write( 'A2', 'Sum', $heading );
      $worksheet1->write( 'B2', '=SUM(Data!B2:B9)' );
      
      $worksheet1->write( 'A3', 'Average', $heading );
      $worksheet1->write( 'B3', '=AVERAGE(Data!B2:B9)' );
      
      $worksheet1->write( 'A4', 'Min', $heading );
      $worksheet1->write( 'B4', '=MIN(Data!B2:B9)' );
      
      $worksheet1->write( 'A5', 'Max', $heading );
      $worksheet1->write( 'B5', '=MAX(Data!B2:B9)' );
      
      $worksheet1->write( 'A6', 'Standard Deviation', $heading );
      $worksheet1->write( 'B6', '=STDEV(Data!B2:B9)' );
      
      $worksheet1->write( 'A7', 'Kurtosis', $heading );
      $worksheet1->write( 'B7', '=KURT(Data!B2:B9)' );
      
      
      # Write the sample data
      $worksheet2->write( 'A1', 'Sample', $heading );
      $worksheet2->write( 'A2', 1 );
      $worksheet2->write( 'A3', 2 );
      $worksheet2->write( 'A4', 3 );
      $worksheet2->write( 'A5', 4 );
      $worksheet2->write( 'A6', 5 );
      $worksheet2->write( 'A7', 6 );
      $worksheet2->write( 'A8', 7 );
      $worksheet2->write( 'A9', 8 );
      
      $worksheet2->write( 'B1', 'Length', $heading );
      $worksheet2->write( 'B2', 25.4,     $numformat );
      $worksheet2->write( 'B3', 25.4,     $numformat );
      $worksheet2->write( 'B4', 24.8,     $numformat );
      $worksheet2->write( 'B5', 25.0,     $numformat );
      $worksheet2->write( 'B6', 25.3,     $numformat );
      $worksheet2->write( 'B7', 24.9,     $numformat );
      $worksheet2->write( 'B8', 25.2,     $numformat );
      $worksheet2->write( 'B9', 24.8,     $numformat );
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/stats_ext.pl>
  
  =head2 Example: stocks.pl
  
  
  
  Example of formatting using the Excel::Writer::XLSX module
  
  This example shows how to use a conditional numerical format
  with colours to indicate if a share price has gone up or down.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/stocks.jpg" width="640" height="420" alt="Output from stocks.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of formatting using the Excel::Writer::XLSX module
      #
      # This example shows how to use a conditional numerical format
      # with colours to indicate if a share price has gone up or down.
      #
      # reverse ('(c)'), March 2001, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      # Create a new workbook and add a worksheet
      my $workbook  = Excel::Writer::XLSX->new( 'stocks.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      # Set the column width for columns 1, 2, 3 and 4
      $worksheet->set_column( 0, 3, 15 );
      
      
      # Create a format for the column headings
      my $header = $workbook->add_format();
      $header->set_bold();
      $header->set_size( 12 );
      $header->set_color( 'blue' );
      
      
      # Create a format for the stock price
      my $f_price = $workbook->add_format();
      $f_price->set_align( 'left' );
      $f_price->set_num_format( '$0.00' );
      
      
      # Create a format for the stock volume
      my $f_volume = $workbook->add_format();
      $f_volume->set_align( 'left' );
      $f_volume->set_num_format( '#,##0' );
      
      
      # Create a format for the price change. This is an example of a conditional
      # format. The number is formatted as a percentage. If it is positive it is
      # formatted in green, if it is negative it is formatted in red and if it is
      # zero it is formatted as the default font colour (in this case black).
      # Note: the [Green] format produces an unappealing lime green. Try
      # [Color 10] instead for a dark green.
      #
      my $f_change = $workbook->add_format();
      $f_change->set_align( 'left' );
      $f_change->set_num_format( '[Green]0.0%;[Red]-0.0%;0.0%' );
      
      
      # Write out the data
      $worksheet->write( 0, 0, 'Company', $header );
      $worksheet->write( 0, 1, 'Price',   $header );
      $worksheet->write( 0, 2, 'Volume',  $header );
      $worksheet->write( 0, 3, 'Change',  $header );
      
      $worksheet->write( 1, 0, 'Damage Inc.' );
      $worksheet->write( 1, 1, 30.25, $f_price );       # $30.25
      $worksheet->write( 1, 2, 1234567, $f_volume );    # 1,234,567
      $worksheet->write( 1, 3, 0.085, $f_change );      # 8.5% in green
      
      $worksheet->write( 2, 0, 'Dump Corp.' );
      $worksheet->write( 2, 1, 1.56, $f_price );        # $1.56
      $worksheet->write( 2, 2, 7564, $f_volume );       # 7,564
      $worksheet->write( 2, 3, -0.015, $f_change );     # -1.5% in red
      
      $worksheet->write( 3, 0, 'Rev Ltd.' );
      $worksheet->write( 3, 1, 0.13, $f_price );        # $0.13
      $worksheet->write( 3, 2, 321, $f_volume );        # 321
      $worksheet->write( 3, 3, 0, $f_change );          # 0 in the font color (black)
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/stocks.pl>
  
  =head2 Example: tab_colors.pl
  
  
  
  Example of how to set Excel worksheet tab colours.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/tab_colors.jpg" width="640" height="420" alt="Output from tab_colors.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      #######################################################################
      #
      # Example of how to set Excel worksheet tab colours.
      #
      # reverse ('(c)'), May 2006, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'tab_colors.xlsx' );
      
      my $worksheet1 = $workbook->add_worksheet();
      my $worksheet2 = $workbook->add_worksheet();
      my $worksheet3 = $workbook->add_worksheet();
      my $worksheet4 = $workbook->add_worksheet();
      
      # Worksheet1 will have the default tab colour.
      $worksheet2->set_tab_color( 'red' );
      $worksheet3->set_tab_color( 'green' );
      $worksheet4->set_tab_color( '#FF6600'); # Orange
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/tab_colors.pl>
  
  =head2 Example: tables.pl
  
  
  
  Example of how to add tables to an Excel::Writer::XLSX worksheet.
  
  Tables in Excel are used to group rows and columns of data into a single
  structure that can be referenced in a formula or formatted collectively.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/tables.jpg" width="640" height="420" alt="Output from tables.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ###############################################################################
      #
      # Example of how to add tables to an Excel::Writer::XLSX worksheet.
      #
      # Tables in Excel are used to group rows and columns of data into a single
      # structure that can be referenced in a formula or formatted collectively.
      #
      # reverse ('(c)'), September 2012, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      my $workbook    = Excel::Writer::XLSX->new( 'tables.xlsx' );
      my $worksheet1  = $workbook->add_worksheet();
      my $worksheet2  = $workbook->add_worksheet();
      my $worksheet3  = $workbook->add_worksheet();
      my $worksheet4  = $workbook->add_worksheet();
      my $worksheet5  = $workbook->add_worksheet();
      my $worksheet6  = $workbook->add_worksheet();
      my $worksheet7  = $workbook->add_worksheet();
      my $worksheet8  = $workbook->add_worksheet();
      my $worksheet9  = $workbook->add_worksheet();
      my $worksheet10 = $workbook->add_worksheet();
      my $worksheet11 = $workbook->add_worksheet();
      my $worksheet12 = $workbook->add_worksheet();
      
      my $currency_format = $workbook->add_format( num_format => '$#,##0' );
      
      
      # Some sample data for the table.
      my $data = [
          [ 'Apples',  10000, 5000, 8000, 6000 ],
          [ 'Pears',   2000,  3000, 4000, 5000 ],
          [ 'Bananas', 6000,  6000, 6500, 6000 ],
          [ 'Oranges', 500,   300,  200,  700 ],
      
      ];
      
      
      ###############################################################################
      #
      # Example 1.
      #
      my $caption = 'Default table with no data.';
      
      # Set the columns widths.
      $worksheet1->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet1->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet1->add_table( 'B3:F7' );
      
      
      ###############################################################################
      #
      # Example 2.
      #
      $caption = 'Default table with data.';
      
      # Set the columns widths.
      $worksheet2->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet2->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet2->add_table( 'B3:F7', { data => $data } );
      
      
      ###############################################################################
      #
      # Example 3.
      #
      $caption = 'Table without default autofilter.';
      
      # Set the columns widths.
      $worksheet3->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet3->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet3->add_table( 'B3:F7', { autofilter => 0 } );
      
      # Table data can also be written separately, as an array or individual cells.
      $worksheet3->write_col( 'B4', $data );
      
      
      ###############################################################################
      #
      # Example 4.
      #
      $caption = 'Table without default header row.';
      
      # Set the columns widths.
      $worksheet4->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet4->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet4->add_table( 'B4:F7', { header_row => 0 } );
      
      # Table data can also be written separately, as an array or individual cells.
      $worksheet4->write_col( 'B4', $data );
      
      
      ###############################################################################
      #
      # Example 5.
      #
      $caption = 'Default table with "First Column" and "Last Column" options.';
      
      # Set the columns widths.
      $worksheet5->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet5->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet5->add_table( 'B3:F7', { first_column => 1, last_column => 1 } );
      
      # Table data can also be written separately, as an array or individual cells.
      $worksheet5->write_col( 'B4', $data );
      
      
      ###############################################################################
      #
      # Example 6.
      #
      $caption = 'Table with banded columns but without default banded rows.';
      
      # Set the columns widths.
      $worksheet6->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet6->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet6->add_table( 'B3:F7', { banded_rows => 0, banded_columns => 1 } );
      
      # Table data can also be written separately, as an array or individual cells.
      $worksheet6->write_col( 'B4', $data );
      
      
      ###############################################################################
      #
      # Example 7.
      #
      $caption = 'Table with user defined column headers';
      
      # Set the columns widths.
      $worksheet7->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet7->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet7->add_table(
          'B3:F7',
          {
              data    => $data,
              columns => [
                  { header => 'Product' },
                  { header => 'Quarter 1' },
                  { header => 'Quarter 2' },
                  { header => 'Quarter 3' },
                  { header => 'Quarter 4' },
              ]
          }
      );
      
      
      ###############################################################################
      #
      # Example 8.
      #
      $caption = 'Table with user defined column headers';
      
      # Set the columns widths.
      $worksheet8->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet8->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet8->add_table(
          'B3:G7',
          {
              data    => $data,
              columns => [
                  { header => 'Product' },
                  { header => 'Quarter 1' },
                  { header => 'Quarter 2' },
                  { header => 'Quarter 3' },
                  { header => 'Quarter 4' },
                  {
                      header  => 'Year',
                      formula => '=SUM(Table8[@[Quarter 1]:[Quarter 4]])'
                  },
              ]
          }
      );
      
      
      ###############################################################################
      #
      # Example 9.
      #
      $caption = 'Table with totals row (but no caption or totals).';
      
      # Set the columns widths.
      $worksheet9->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet9->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet9->add_table(
          'B3:G8',
          {
              data      => $data,
              total_row => 1,
              columns   => [
                  { header => 'Product' },
                  { header => 'Quarter 1' },
                  { header => 'Quarter 2' },
                  { header => 'Quarter 3' },
                  { header => 'Quarter 4' },
                  {
                      header  => 'Year',
                      formula => '=SUM(Table9[@[Quarter 1]:[Quarter 4]])'
                  },
              ]
          }
      );
      
      
      ###############################################################################
      #
      # Example 10.
      #
      $caption = 'Table with totals row with user captions and functions.';
      
      # Set the columns widths.
      $worksheet10->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet10->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet10->add_table(
          'B3:G8',
          {
              data      => $data,
              total_row => 1,
              columns   => [
                  { header => 'Product',   total_string   => 'Totals' },
                  { header => 'Quarter 1', total_function => 'sum' },
                  { header => 'Quarter 2', total_function => 'sum' },
                  { header => 'Quarter 3', total_function => 'sum' },
                  { header => 'Quarter 4', total_function => 'sum' },
                  {
                      header         => 'Year',
                      formula        => '=SUM(Table10[@[Quarter 1]:[Quarter 4]])',
                      total_function => 'sum'
                  },
              ]
          }
      );
      
      
      ###############################################################################
      #
      # Example 11.
      #
      $caption = 'Table with alternative Excel style.';
      
      # Set the columns widths.
      $worksheet11->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet11->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet11->add_table(
          'B3:G8',
          {
              data      => $data,
              style     => 'Table Style Light 11',
              total_row => 1,
              columns   => [
                  { header => 'Product',   total_string   => 'Totals' },
                  { header => 'Quarter 1', total_function => 'sum' },
                  { header => 'Quarter 2', total_function => 'sum' },
                  { header => 'Quarter 3', total_function => 'sum' },
                  { header => 'Quarter 4', total_function => 'sum' },
                  {
                      header         => 'Year',
                      formula        => '=SUM(Table11[@[Quarter 1]:[Quarter 4]])',
                      total_function => 'sum'
                  },
              ]
          }
      );
      
      
      ###############################################################################
      #
      # Example 12.
      #
      $caption = 'Table with column formats.';
      
      # Set the columns widths.
      $worksheet12->set_column( 'B:G', 12 );
      
      # Write the caption.
      $worksheet12->write( 'B1', $caption );
      
      # Add a table to the worksheet.
      $worksheet12->add_table(
          'B3:G8',
          {
              data      => $data,
              total_row => 1,
              columns   => [
                  { header => 'Product', total_string => 'Totals' },
                  {
                      header         => 'Quarter 1',
                      total_function => 'sum',
                      format         => $currency_format,
                  },
                  {
                      header         => 'Quarter 2',
                      total_function => 'sum',
                      format         => $currency_format,
                  },
                  {
                      header         => 'Quarter 3',
                      total_function => 'sum',
                      format         => $currency_format,
                  },
                  {
                      header         => 'Quarter 4',
                      total_function => 'sum',
                      format         => $currency_format,
                  },
                  {
                      header         => 'Year',
                      formula        => '=SUM(Table12[@[Quarter 1]:[Quarter 4]])',
                      total_function => 'sum',
                      format         => $currency_format,
                  },
              ]
          }
      );
      
      
      __END__
      
      
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/tables.pl>
  
  =head2 Example: write_handler1.pl
  
  
  
  Example of how to add a user defined data handler to the
  Excel::Writer::XLSX write() method.
  
  The following example shows how to add a handler for a 7 digit ID number.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/write_handler1.jpg" width="640" height="420" alt="Output from write_handler1.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the
      # Excel::Writer::XLSX write() method.
      #
      # The following example shows how to add a handler for a 7 digit ID number.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      
      my $workbook  = Excel::Writer::XLSX->new( 'write_handler1.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      ###############################################################################
      #
      # Add a handler for 7 digit id numbers. This is useful when you want a string
      # such as 0000001 written as a string instead of a number and thus preserve
      # the leading zeroes.
      #
      # Note: you can get the same effect using the keep_leading_zeros() method but
      # this serves as a simple example.
      #
      $worksheet->add_write_handler( qr[^\d{7}$], \&write_my_id );
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found.
      #
      sub write_my_id {
      
          my $worksheet = shift;
      
          return $worksheet->write_string( @_ );
      }
      
      
      # This format maintains the cell as text even if it is edited.
      my $id_format = $workbook->add_format( num_format => '@' );
      
      
      # Write some numbers in the user defined format
      $worksheet->write( 'A1', '0000000', $id_format );
      $worksheet->write( 'A2', '0000001', $id_format );
      $worksheet->write( 'A3', '0004000', $id_format );
      $worksheet->write( 'A4', '1234567', $id_format );
      
      # Write some numbers that don't match the defined format
      $worksheet->write( 'A6', '000000', $id_format );
      $worksheet->write( 'A7', '000001', $id_format );
      $worksheet->write( 'A8', '004000', $id_format );
      $worksheet->write( 'A9', '123456', $id_format );
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/write_handler1.pl>
  
  =head2 Example: write_handler2.pl
  
  
  
  Example of how to add a user defined data handler to the
  Excel::Writer::XLSX write() method.
  
  The following example shows how to add a handler for a 7 digit ID number.
  It adds an additional constraint to the write_handler1.pl in that it only
  filters data that isn't in the third column.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/write_handler2.jpg" width="640" height="420" alt="Output from write_handler2.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the
      # Excel::Writer::XLSX write() method.
      #
      # The following example shows how to add a handler for a 7 digit ID number.
      # It adds an additional constraint to the write_handler1.pl in that it only
      # filters data that isn't in the third column.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      
      my $workbook  = Excel::Writer::XLSX->new( 'write_handler2.xlsx' );
      my $worksheet = $workbook->add_worksheet();
      
      
      ###############################################################################
      #
      # Add a handler for 7 digit id numbers. This is useful when you want a string
      # such as 0000001 written as a string instead of a number and thus preserve
      # the leading zeroes.
      #
      # Note: you can get the same effect using the keep_leading_zeros() method but
      # this serves as a simple example.
      #
      $worksheet->add_write_handler( qr[^\d{7}$], \&write_my_id );
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found. The handler
      # is set up so that it only filters data if it is in the third column.
      #
      sub write_my_id {
      
          my $worksheet = shift;
          my $col       = $_[1];
      
          # col is zero based
          if ( $col != 2 ) {
              return $worksheet->write_string( @_ );
          }
          else {
      
              # Reject the match and return control to write()
              return undef;
          }
      
      }
      
      
      # This format maintains the cell as text even if it is edited.
      my $id_format = $workbook->add_format( num_format => '@' );
      
      
      # Write some numbers in the user defined format
      $worksheet->write( 'A1', '0000000', $id_format );
      $worksheet->write( 'B1', '0000001', $id_format );
      $worksheet->write( 'C1', '0000002', $id_format );
      $worksheet->write( 'D1', '0000003', $id_format );
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/write_handler2.pl>
  
  =head2 Example: write_handler3.pl
  
  
  
  Example of how to add a user defined data handler to the
  Excel::Writer::XLSX write() method.
  
  The following example shows how to add a handler for dates in a specific
  format.
  
  See write_handler4.pl for a more rigorous example with error handling.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/write_handler3.jpg" width="640" height="420" alt="Output from write_handler3.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the
      # Excel::Writer::XLSX write() method.
      #
      # The following example shows how to add a handler for dates in a specific
      # format.
      #
      # See write_handler4.pl for a more rigorous example with error handling.
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      
      my $workbook    = Excel::Writer::XLSX->new( 'write_handler3.xlsx' );
      my $worksheet   = $workbook->add_worksheet();
      my $date_format = $workbook->add_format( num_format => 'dd/mm/yy' );
      
      
      ###############################################################################
      #
      # Add a handler to match dates in the following format: d/m/yyyy
      #
      # The day and month can be single or double digits.
      #
      $worksheet->add_write_handler( qr[^\d{1,2}/\d{1,2}/\d{4}$], \&write_my_date );
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found.
      # See write_handler4.pl for a more rigorous example with error handling.
      #
      sub write_my_date {
      
          my $worksheet = shift;
          my @args      = @_;
      
          my $token = $args[2];
          $token =~ qr[^(\d{1,2})/(\d{1,2})/(\d{4})$];
      
          # Change to the date format required by write_date_time().
          my $date = sprintf "%4d-%02d-%02dT", $3, $2, $1;
      
          $args[2] = $date;
      
          return $worksheet->write_date_time( @args );
      }
      
      
      # Write some dates in the user defined format
      $worksheet->write( 'A1', '22/12/2004', $date_format );
      $worksheet->write( 'A2', '1/1/1995',   $date_format );
      $worksheet->write( 'A3', '01/01/1995', $date_format );
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/write_handler3.pl>
  
  =head2 Example: write_handler4.pl
  
  
  
  Example of how to add a user defined data handler to the
  Excel::Writer::XLSX write() method.
  
  The following example shows how to add a handler for dates in a specific
  format.
  
  This is a more rigorous version of write_handler3.pl.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/write_handler4.jpg" width="640" height="420" alt="Output from write_handler4.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl -w
      
      ###############################################################################
      #
      # Example of how to add a user defined data handler to the
      # Excel::Writer::XLSX write() method.
      #
      # The following example shows how to add a handler for dates in a specific
      # format.
      #
      # This is a more rigorous version of write_handler3.pl.
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use Excel::Writer::XLSX;
      
      
      my $workbook    = Excel::Writer::XLSX->new( 'write_handler4.xlsx' );
      my $worksheet   = $workbook->add_worksheet();
      my $date_format = $workbook->add_format( num_format => 'dd/mm/yy' );
      
      
      ###############################################################################
      #
      # Add a handler to match dates in the following formats: d/m/yy, d/m/yyyy
      #
      # The day and month can be single or double digits and the year can be  2 or 4
      # digits.
      #
      $worksheet->add_write_handler( qr[^\d{1,2}/\d{1,2}/\d{2,4}$], \&write_my_date );
      
      
      ###############################################################################
      #
      # The following function processes the data when a match is found.
      #
      sub write_my_date {
      
          my $worksheet = shift;
          my @args      = @_;
      
          my $token = $args[2];
      
          if ( $token =~ qr[^(\d{1,2})/(\d{1,2})/(\d{2,4})$] ) {
      
              my $day  = $1;
              my $mon  = $2;
              my $year = $3;
      
              # Use a window for 2 digit dates. This will keep some ragged Perl
              # programmer employed in thirty years time. :-)
              if ( length $year == 2 ) {
                  if ( $year < 50 ) {
                      $year += 2000;
                  }
                  else {
                      $year += 1900;
                  }
              }
      
              my $date = sprintf "%4d-%02d-%02dT", $year, $mon, $day;
      
              # Convert the ISO ISO8601 style string to an Excel date
              $date = $worksheet->convert_date_time( $date );
      
              if ( defined $date ) {
      
                  # Date was valid
                  $args[2] = $date;
                  return $worksheet->write_number( @args );
              }
              else {
      
                  # Not a valid date therefore write as a string
                  return $worksheet->write_string( @args );
              }
          }
          else {
      
              # Shouldn't happen if the same match is used in the re and sub.
              return undef;
          }
      }
      
      
      # Write some dates in the user defined format
      $worksheet->write( 'A1', '22/12/2004', $date_format );
      $worksheet->write( 'A2', '22/12/04',   $date_format );
      $worksheet->write( 'A3', '2/12/04',    $date_format );
      $worksheet->write( 'A4', '2/5/04',     $date_format );
      $worksheet->write( 'A5', '2/5/95',     $date_format );
      $worksheet->write( 'A6', '2/5/1995',   $date_format );
      
      # Some erroneous dates
      $worksheet->write( 'A8', '2/5/1895',  $date_format ); # Date out of Excel range
      $worksheet->write( 'A9', '29/2/2003', $date_format ); # Invalid leap day
      $worksheet->write( 'A10', '50/50/50', $date_format ); # Matches but isn't a date
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/write_handler4.pl>
  
  =head2 Example: write_to_scalar.pl
  
  
  
  An example of writing an Excel::Writer::XLSX file to a perl scalar.
  
  
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # An example of writing an Excel::Writer::XLSX file to a perl scalar.
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      # Use a scalar as a filehandle.
      open my $fh, '>', \my $str or die "Failed to open filehandle: $!";
      
      
      # Spreadsheet::WriteExce accepts filehandle as well as file names.
      my $workbook  = Excel::Writer::XLSX->new( $fh );
      my $worksheet = $workbook->add_worksheet();
      
      $worksheet->write( 0, 0, 'Hi Excel!' );
      
      $workbook->close();
      
      
      # The Excel file in now in $str. Remember to binmode() the output
      # filehandle before printing it.
      open my $out_fh, '>', 'write_to_scalar.xlsx'
        or die "Failed to open out filehandle: $!";
      
      binmode $out_fh;
      print   $out_fh $str;
      close   $out_fh;
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/write_to_scalar.pl>
  
  =head2 Example: unicode_2022_jp.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Japanese from a file with ISO-2022-JP
  encoded text.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_2022_jp.jpg" width="640" height="420" alt="Output from unicode_2022_jp.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Japanese from a file with ISO-2022-JP
      # encoded text.
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_2022_jp.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_2022_jp.txt';
      
      open FH, '<:encoding(iso-2022-jp)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_2022_jp.pl>
  
  =head2 Example: unicode_8859_11.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Thai from a file with ISO-8859-11 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_8859_11.jpg" width="640" height="420" alt="Output from unicode_8859_11.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Thai from a file with ISO-8859-11 encoded text.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_8859_11.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_8859_11.txt';
      
      open FH, '<:encoding(iso-8859-11)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_8859_11.pl>
  
  =head2 Example: unicode_8859_7.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Greek from a file with ISO-8859-7 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_8859_7.jpg" width="640" height="420" alt="Output from unicode_8859_7.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Greek from a file with ISO-8859-7 encoded text.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_8859_7.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_8859_7.txt';
      
      open FH, '<:encoding(iso-8859-7)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_8859_7.pl>
  
  =head2 Example: unicode_big5.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Chinese from a file with BIG5 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_big5.jpg" width="640" height="420" alt="Output from unicode_big5.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Chinese from a file with BIG5 encoded text.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_big5.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 80 );
      
      
      my $file = 'unicode_big5.txt';
      
      open FH, '<:encoding(big5)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_big5.pl>
  
  =head2 Example: unicode_cp1251.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Russian from a file with CP1251 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_cp1251.jpg" width="640" height="420" alt="Output from unicode_cp1251.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Russian from a file with CP1251 encoded text.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_cp1251.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_cp1251.txt';
      
      open FH, '<:encoding(cp1251)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_cp1251.pl>
  
  =head2 Example: unicode_cp1256.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Arabic text from a CP-1256 encoded file.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_cp1256.jpg" width="640" height="420" alt="Output from unicode_cp1256.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Arabic text from a CP-1256 encoded file.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_cp1256.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_cp1256.txt';
      
      open FH, '<:encoding(cp1256)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_cp1256.pl>
  
  =head2 Example: unicode_cyrillic.pl
  
  
  
  A simple example of writing some Russian cyrillic text using
  Excel::Writer::XLSX.
  
  
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_cyrillic.jpg" width="640" height="420" alt="Output from unicode_cyrillic.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of writing some Russian cyrillic text using
      # Excel::Writer::XLSX.
      #
      #
      #
      #
      # reverse ('(c)'), March 2005, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      # In this example we generate utf8 strings from character data but in a
      # real application we would expect them to come from an external source.
      #
      
      
      # Create a Russian worksheet name in utf8.
      my $sheet = pack "U*", 0x0421, 0x0442, 0x0440, 0x0430, 0x043D, 0x0438,
        0x0446, 0x0430;
      
      
      # Create a Russian string.
      my $str = pack "U*", 0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441,
        0x0442, 0x0432, 0x0443, 0x0439, 0x0020, 0x041C,
        0x0438, 0x0440, 0x0021;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_cyrillic.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet( $sheet . '1' );
      
      $worksheet->set_column( 'A:A', 18 );
      $worksheet->write( 'A1', $str );
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_cyrillic.pl>
  
  =head2 Example: unicode_koi8r.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Russian from a file with KOI8-R encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_koi8r.jpg" width="640" height="420" alt="Output from unicode_koi8r.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Russian from a file with KOI8-R encoded text.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_koi8r.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_koi8r.txt';
      
      open FH, '<:encoding(koi8-r)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_koi8r.pl>
  
  =head2 Example: unicode_polish_utf8.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Polish from a file with UTF8 encoded text.
  
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_polish_utf8.jpg" width="640" height="420" alt="Output from unicode_polish_utf8.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Polish from a file with UTF8 encoded text.
      #
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_polish_utf8.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_polish_utf8.txt';
      
      open FH, '<:encoding(utf8)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_polish_utf8.pl>
  
  =head2 Example: unicode_shift_jis.pl
  
  
  
  A simple example of converting some Unicode text to an Excel file using
  Excel::Writer::XLSX.
  
  This example generates some Japenese text from a file with Shift-JIS
  encoded text.
  
  
  
  =begin html
  
  <p><center><img src="http://jmcnamara.github.io/excel-writer-xlsx/images/examples/unicode_shift_jis.jpg" width="640" height="420" alt="Output from unicode_shift_jis.pl" /></center></p>
  
  =end html
  
  Source code for this example:
  
      #!/usr/bin/perl
      
      ##############################################################################
      #
      # A simple example of converting some Unicode text to an Excel file using
      # Excel::Writer::XLSX.
      #
      # This example generates some Japenese text from a file with Shift-JIS
      # encoded text.
      #
      # reverse ('(c)'), September 2004, John McNamara, jmcnamara@cpan.org
      #
      
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
      
      
      my $workbook = Excel::Writer::XLSX->new( 'unicode_shift_jis.xlsx' );
      
      die "Couldn't create new Excel file: $!.\n" unless defined $workbook;
      
      my $worksheet = $workbook->add_worksheet();
      $worksheet->set_column( 'A:A', 50 );
      
      
      my $file = 'unicode_shift_jis.txt';
      
      open FH, '<:encoding(shiftjis)', $file or die "Couldn't open $file: $!\n";
      
      my $row = 0;
      
      while ( <FH> ) {
          next if /^#/;    # Ignore the comments in the sample file.
          chomp;
          $worksheet->write( $row++, 0, $_ );
      }
      
      
      __END__
      
  
  
  Download this example: L<http://cpansearch.perl.org/src/JMCNAMARA/Excel-Writer-XLSX-0.89/examples/unicode_shift_jis.pl>
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  Contributed examples contain the original author's name.
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =cut
EXCEL_WRITER_XLSX_EXAMPLES

$fatpacked{"Excel/Writer/XLSX/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_FORMAT';
  package Excel::Writer::XLSX::Format;
  
  ###############################################################################
  #
  # Format - A class for defining Excel formatting.
  #
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  use 5.008002;
  use Exporter;
  use strict;
  use warnings;
  use Carp;
  
  
  our @ISA     = qw(Exporter);
  our $VERSION = '0.89';
  our $AUTOLOAD;
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor
  #
  sub new {
  
      my $class = shift;
  
      my $self = {
          _xf_format_indices  => shift,
          _dxf_format_indices => shift,
          _xf_index           => undef,
          _dxf_index          => undef,
  
          _num_format       => 0,
          _num_format_index => 0,
          _font_index       => 0,
          _has_font         => 0,
          _has_dxf_font     => 0,
          _font             => 'Calibri',
          _size             => 11,
          _bold             => 0,
          _italic           => 0,
          _color            => 0x0,
          _underline        => 0,
          _font_strikeout   => 0,
          _font_outline     => 0,
          _font_shadow      => 0,
          _font_script      => 0,
          _font_family      => 2,
          _font_charset     => 0,
          _font_scheme      => 'minor',
          _font_condense    => 0,
          _font_extend      => 0,
          _theme            => 0,
          _hyperlink        => 0,
  
          _hidden => 0,
          _locked => 1,
  
          _text_h_align  => 0,
          _text_wrap     => 0,
          _text_v_align  => 0,
          _text_justlast => 0,
          _rotation      => 0,
  
          _fg_color     => 0x00,
          _bg_color     => 0x00,
          _pattern      => 0,
          _has_fill     => 0,
          _has_dxf_fill => 0,
          _fill_index   => 0,
          _fill_count   => 0,
  
          _border_index   => 0,
          _has_border     => 0,
          _has_dxf_border => 0,
          _border_count   => 0,
  
          _bottom       => 0,
          _bottom_color => 0x0,
          _diag_border  => 0,
          _diag_color   => 0x0,
          _diag_type    => 0,
          _left         => 0,
          _left_color   => 0x0,
          _right        => 0,
          _right_color  => 0x0,
          _top          => 0,
          _top_color    => 0x0,
  
          _indent        => 0,
          _shrink        => 0,
          _merge_range   => 0,
          _reading_order => 0,
          _just_distrib  => 0,
          _color_indexed => 0,
          _font_only     => 0,
  
      };
  
      bless $self, $class;
  
      # Set properties passed to Workbook::add_format()
      $self->set_format_properties(@_) if @_;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # copy($format)
  #
  # Copy the attributes of another Excel::Writer::XLSX::Format object.
  #
  sub copy {
      my $self  = shift;
      my $other = $_[0];
  
  
      return unless defined $other;
      return unless ( ref( $self ) eq ref( $other ) );
  
      # Store properties that we don't want over-ridden.
      my $xf_index           = $self->{_xf_index};
      my $dxf_index          = $self->{_dxf_index};
      my $xf_format_indices  = $self->{_xf_format_indices};
      my $dxf_format_indices = $self->{_dxf_format_indices};
      my $palette            = $self->{_palette};
  
      # Copy properties.
      %$self             = %$other;
  
      # Restore original properties.
      $self->{_xf_index}           = $xf_index;
      $self->{_dxf_index}          = $dxf_index;
      $self->{_xf_format_indices}  = $xf_format_indices;
      $self->{_dxf_format_indices} = $dxf_format_indices;
      $self->{_palette}            = $palette;
  }
  
  
  ###############################################################################
  #
  # get_align_properties()
  #
  # Return properties for an Style xf <alignment> sub-element.
  #
  sub get_align_properties {
  
      my $self = shift;
  
      my @align;    # Attributes to return
  
      # Check if any alignment options in the format have been changed.
      my $changed =
        (      $self->{_text_h_align} != 0
            || $self->{_text_v_align} != 0
            || $self->{_indent} != 0
            || $self->{_rotation} != 0
            || $self->{_text_wrap} != 0
            || $self->{_shrink} != 0
            || $self->{_reading_order} != 0 ) ? 1 : 0;
  
      return unless $changed;
  
  
  
      # Indent is only allowed for horizontal left, right and distributed. If it
      # is defined for any other alignment or no alignment has been set then
      # default to left alignment.
      if (   $self->{_indent}
          && $self->{_text_h_align} != 1
          && $self->{_text_h_align} != 3
          && $self->{_text_h_align} != 7 )
      {
          $self->{_text_h_align} = 1;
      }
  
      # Check for properties that are mutually exclusive.
      $self->{_shrink}       = 0 if $self->{_text_wrap};
      $self->{_shrink}       = 0 if $self->{_text_h_align} == 4;    # Fill
      $self->{_shrink}       = 0 if $self->{_text_h_align} == 5;    # Justify
      $self->{_shrink}       = 0 if $self->{_text_h_align} == 7;    # Distributed
      $self->{_just_distrib} = 0 if $self->{_text_h_align} != 7;    # Distributed
      $self->{_just_distrib} = 0 if $self->{_indent};
  
      my $continuous = 'centerContinuous';
  
      push @align, 'horizontal', 'left'        if $self->{_text_h_align} == 1;
      push @align, 'horizontal', 'center'      if $self->{_text_h_align} == 2;
      push @align, 'horizontal', 'right'       if $self->{_text_h_align} == 3;
      push @align, 'horizontal', 'fill'        if $self->{_text_h_align} == 4;
      push @align, 'horizontal', 'justify'     if $self->{_text_h_align} == 5;
      push @align, 'horizontal', $continuous   if $self->{_text_h_align} == 6;
      push @align, 'horizontal', 'distributed' if $self->{_text_h_align} == 7;
  
      push @align, 'justifyLastLine', 1 if $self->{_just_distrib};
  
      # Property 'vertical' => 'bottom' is a default. It sets applyAlignment
      # without an alignment sub-element.
      push @align, 'vertical', 'top'         if $self->{_text_v_align} == 1;
      push @align, 'vertical', 'center'      if $self->{_text_v_align} == 2;
      push @align, 'vertical', 'justify'     if $self->{_text_v_align} == 4;
      push @align, 'vertical', 'distributed' if $self->{_text_v_align} == 5;
  
      push @align, 'indent',       $self->{_indent}   if $self->{_indent};
      push @align, 'textRotation', $self->{_rotation} if $self->{_rotation};
  
      push @align, 'wrapText',     1 if $self->{_text_wrap};
      push @align, 'shrinkToFit',  1 if $self->{_shrink};
  
      push @align, 'readingOrder', 1 if $self->{_reading_order} == 1;
      push @align, 'readingOrder', 2 if $self->{_reading_order} == 2;
  
      return $changed, @align;
  }
  
  
  ###############################################################################
  #
  # get_protection_properties()
  #
  # Return properties for an Excel XML <Protection> element.
  #
  sub get_protection_properties {
  
      my $self = shift;
  
      my @attribs;
  
      push @attribs, 'locked', 0 if !$self->{_locked};
      push @attribs, 'hidden', 1 if $self->{_hidden};
  
      return @attribs;
  }
  
  
  ###############################################################################
  #
  # get_format_key()
  #
  # Returns a unique hash key for the Format object.
  #
  sub get_format_key {
  
      my $self = shift;
  
      my $key = join ':',
        (
          $self->get_font_key(), $self->get_border_key,
          $self->get_fill_key(), $self->get_alignment_key(),
          $self->{_num_format},  $self->{_locked},
          $self->{_hidden}
        );
  
      return $key;
  }
  
  ###############################################################################
  #
  # get_font_key()
  #
  # Returns a unique hash key for a font. Used by Workbook.
  #
  sub get_font_key {
  
      my $self = shift;
  
      my $key = join ':', (
          $self->{_bold},
          $self->{_color},
          $self->{_font_charset},
          $self->{_font_family},
          $self->{_font_outline},
          $self->{_font_script},
          $self->{_font_shadow},
          $self->{_font_strikeout},
          $self->{_font},
          $self->{_italic},
          $self->{_size},
          $self->{_underline},
  
      );
  
      return $key;
  }
  
  
  ###############################################################################
  #
  # get_border_key()
  #
  # Returns a unique hash key for a border style. Used by Workbook.
  #
  sub get_border_key {
  
      my $self = shift;
  
      my $key = join ':', (
          $self->{_bottom},
          $self->{_bottom_color},
          $self->{_diag_border},
          $self->{_diag_color},
          $self->{_diag_type},
          $self->{_left},
          $self->{_left_color},
          $self->{_right},
          $self->{_right_color},
          $self->{_top},
          $self->{_top_color},
  
      );
  
      return $key;
  }
  
  
  ###############################################################################
  #
  # get_fill_key()
  #
  # Returns a unique hash key for a fill style. Used by Workbook.
  #
  sub get_fill_key {
  
      my $self = shift;
  
      my $key = join ':', (
          $self->{_pattern},
          $self->{_bg_color},
          $self->{_fg_color},
  
      );
  
      return $key;
  }
  
  
  ###############################################################################
  #
  # get_alignment_key()
  #
  # Returns a unique hash key for alignment formats.
  #
  sub get_alignment_key {
  
      my $self = shift;
  
      my $key = join ':', (
          $self->{_text_h_align},
          $self->{_text_v_align},
          $self->{_indent},
          $self->{_rotation},
          $self->{_text_wrap},
          $self->{_shrink},
          $self->{_reading_order},
  
      );
  
      return $key;
  }
  
  
  ###############################################################################
  #
  # get_xf_index()
  #
  # Returns the index used by Worksheet->_XF()
  #
  sub get_xf_index {
      my $self = shift;
  
      if ( defined $self->{_xf_index} ) {
          return $self->{_xf_index};
      }
      else {
          my $key  = $self->get_format_key();
          my $indices_href = ${ $self->{_xf_format_indices} };
  
          if ( exists $indices_href->{$key} ) {
              return $indices_href->{$key};
          }
          else {
              my $index = 1 + scalar keys %$indices_href;
              $indices_href->{$key} = $index;
              $self->{_xf_index} = $index;
              return $index;
          }
      }
  }
  
  
  ###############################################################################
  #
  # get_dxf_index()
  #
  # Returns the index used by Worksheet->_XF()
  #
  sub get_dxf_index {
      my $self = shift;
  
      if ( defined $self->{_dxf_index} ) {
          return $self->{_dxf_index};
      }
      else {
          my $key  = $self->get_format_key();
          my $indices_href = ${ $self->{_dxf_format_indices} };
  
          if ( exists $indices_href->{$key} ) {
              return $indices_href->{$key};
          }
          else {
              my $index = scalar keys %$indices_href;
              $indices_href->{$key} = $index;
              $self->{_dxf_index} = $index;
              return $index;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _get_color()
  #
  # Used in conjunction with the set_xxx_color methods to convert a color
  # string into a number. Color range is 0..63 but we will restrict it
  # to 8..63 to comply with Gnumeric. Colors 0..7 are repeated in 8..15.
  #
  sub _get_color {
  
      my %colors = (
          aqua    => 0x0F,
          cyan    => 0x0F,
          black   => 0x08,
          blue    => 0x0C,
          brown   => 0x10,
          magenta => 0x0E,
          fuchsia => 0x0E,
          gray    => 0x17,
          grey    => 0x17,
          green   => 0x11,
          lime    => 0x0B,
          navy    => 0x12,
          orange  => 0x35,
          pink    => 0x21,
          purple  => 0x14,
          red     => 0x0A,
          silver  => 0x16,
          white   => 0x09,
          yellow  => 0x0D,
      );
  
      # Return RGB style colors for processing later.
      if ( $_[0] =~ m/^#[0-9A-F]{6}$/i ) {
          return $_[0];
      }
  
      # Return the default color if undef,
      return 0x00 unless defined $_[0];
  
      # or the color string converted to an integer,
      return $colors{ lc( $_[0] ) } if exists $colors{ lc( $_[0] ) };
  
      # or the default color if string is unrecognised,
      return 0x00 if ( $_[0] =~ m/\D/ );
  
      # or an index < 8 mapped into the correct range,
      return $_[0] + 8 if $_[0] < 8;
  
      # or the default color if arg is outside range,
      return 0x00 if $_[0] > 63;
  
      # or an integer in the valid range
      return $_[0];
  }
  
  
  ###############################################################################
  #
  # set_type()
  #
  # Set the XF object type as 0 = cell XF or 0xFFF5 = style XF.
  #
  sub set_type {
  
      my $self = shift;
      my $type = $_[0];
  
      if (defined $_[0] and $_[0] eq 0) {
          $self->{_type} = 0x0000;
      }
      else {
          $self->{_type} = 0xFFF5;
      }
  }
  
  
  ###############################################################################
  #
  # set_align()
  #
  # Set cell alignment.
  #
  sub set_align {
  
      my $self     = shift;
      my $location = $_[0];
  
      return if not defined $location;    # No default
      return if $location =~ m/\d/;       # Ignore numbers
  
      $location = lc( $location );
  
      $self->set_text_h_align( 1 ) if $location eq 'left';
      $self->set_text_h_align( 2 ) if $location eq 'centre';
      $self->set_text_h_align( 2 ) if $location eq 'center';
      $self->set_text_h_align( 3 ) if $location eq 'right';
      $self->set_text_h_align( 4 ) if $location eq 'fill';
      $self->set_text_h_align( 5 ) if $location eq 'justify';
      $self->set_text_h_align( 6 ) if $location eq 'center_across';
      $self->set_text_h_align( 6 ) if $location eq 'centre_across';
      $self->set_text_h_align( 6 ) if $location eq 'merge';              # Legacy.
      $self->set_text_h_align( 7 ) if $location eq 'distributed';
      $self->set_text_h_align( 7 ) if $location eq 'equal_space';        # S::PE.
      $self->set_text_h_align( 7 ) if $location eq 'justify_distributed';
  
      $self->{_just_distrib} = 1 if $location eq 'justify_distributed';
  
      $self->set_text_v_align( 1 ) if $location eq 'top';
      $self->set_text_v_align( 2 ) if $location eq 'vcentre';
      $self->set_text_v_align( 2 ) if $location eq 'vcenter';
      $self->set_text_v_align( 3 ) if $location eq 'bottom';
      $self->set_text_v_align( 4 ) if $location eq 'vjustify';
      $self->set_text_v_align( 5 ) if $location eq 'vdistributed';
      $self->set_text_v_align( 5 ) if $location eq 'vequal_space';    # S::PE.
  }
  
  
  ###############################################################################
  #
  # set_valign()
  #
  # Set vertical cell alignment. This is required by the set_properties() method
  # to differentiate between the vertical and horizontal properties.
  #
  sub set_valign {
  
      my $self = shift;
      $self->set_align( @_ );
  }
  
  
  ###############################################################################
  #
  # set_center_across()
  #
  # Implements the Excel5 style "merge".
  #
  sub set_center_across {
  
      my $self = shift;
  
      $self->set_text_h_align( 6 );
  }
  
  
  ###############################################################################
  #
  # set_merge()
  #
  # This was the way to implement a merge in Excel5. However it should have been
  # called "center_across" and not "merge".
  # This is now deprecated. Use set_center_across() or better merge_range().
  #
  #
  sub set_merge {
  
      my $self = shift;
  
      $self->set_text_h_align( 6 );
  }
  
  
  ###############################################################################
  #
  # set_bold()
  #
  #
  sub set_bold {
  
      my $self = shift;
      my $bold = defined $_[0] ? $_[0] : 1;
  
      $self->{_bold} = $bold ? 1 : 0;
  }
  
  
  ###############################################################################
  #
  # set_border($style)
  #
  # Set cells borders to the same style
  #
  sub set_border {
  
      my $self  = shift;
      my $style = $_[0];
  
      $self->set_bottom( $style );
      $self->set_top( $style );
      $self->set_left( $style );
      $self->set_right( $style );
  }
  
  
  ###############################################################################
  #
  # set_border_color($color)
  #
  # Set cells border to the same color
  #
  sub set_border_color {
  
      my $self  = shift;
      my $color = $_[0];
  
      $self->set_bottom_color( $color );
      $self->set_top_color( $color );
      $self->set_left_color( $color );
      $self->set_right_color( $color );
  }
  
  
  ###############################################################################
  #
  # set_rotation($angle)
  #
  # Set the rotation angle of the text. An alignment property.
  #
  sub set_rotation {
  
      my $self     = shift;
      my $rotation = $_[0];
  
      # Argument should be a number
      return if $rotation !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  
      # The arg type can be a double but the Excel dialog only allows integers.
      $rotation = int $rotation;
  
      if ( $rotation == 270 ) {
          $rotation = 255;
      }
      elsif ( $rotation >= -90 and $rotation <= 90 ) {
          $rotation = -$rotation + 90 if $rotation < 0;
      }
      else {
          carp "Rotation $rotation outside range: -90 <= angle <= 90";
          $rotation = 0;
      }
  
      $self->{_rotation} = $rotation;
  }
  
  
  ###############################################################################
  #
  # set_hyperlink()
  #
  # Set the properties for the hyperlink style. TODO. This doesn't currently
  # work. Fix it when styles are supported.
  #
  sub set_hyperlink {
  
      my $self = shift;
  
      $self->{_hyperlink} = 1;
  
      $self->set_underline( 1 );
      $self->set_theme( 10 );
      $self->set_align( 'top' );
  }
  
  
  ###############################################################################
  #
  # set_format_properties()
  #
  # Convert hashes of properties to method calls.
  #
  sub set_format_properties {
  
      my $self = shift;
  
      my %properties = @_;    # Merge multiple hashes into one
  
      while ( my ( $key, $value ) = each( %properties ) ) {
  
          # Strip leading "-" from Tk style properties e.g. -color => 'red'.
          $key =~ s/^-//;
  
          # Create a sub to set the property.
          my $sub = \&{"set_$key"};
          $sub->( $self, $value );
      }
  }
  
  # Renamed rarely used set_properties() to set_format_properties() to avoid
  # confusion with Workbook method of the same name. The following acts as an
  # alias for any code that uses the old name.
  *set_properties = *set_format_properties;
  
  
  ###############################################################################
  #
  # AUTOLOAD. Deus ex machina.
  #
  # Dynamically create set methods that aren't already defined.
  #
  sub AUTOLOAD {
  
      my $self = shift;
  
      # Ignore calls to DESTROY
      return if $AUTOLOAD =~ /::DESTROY$/;
  
      # Check for a valid method names, i.e. "set_xxx_yyy".
      $AUTOLOAD =~ /.*::set(\w+)/ or die "Unknown method: $AUTOLOAD\n";
  
      # Match the attribute, i.e. "_xxx_yyy".
      my $attribute = $1;
  
      # Check that the attribute exists
      exists $self->{$attribute} or die "Unknown method: $AUTOLOAD\n";
  
      # The attribute value
      my $value;
  
  
      # There are two types of set methods: set_property() and
      # set_property_color(). When a method is AUTOLOADED we store a new anonymous
      # sub in the appropriate slot in the symbol table. The speeds up subsequent
      # calls to the same method.
      #
      no strict 'refs';    # To allow symbol table hackery
  
      if ( $AUTOLOAD =~ /.*::set\w+color$/ ) {
  
          # For "set_property_color" methods
          $value = _get_color( $_[0] );
  
          *{$AUTOLOAD} = sub {
              my $self = shift;
  
              $self->{$attribute} = _get_color( $_[0] );
          };
      }
      else {
  
          $value = $_[0];
          $value = 1 if not defined $value;    # The default value is always 1
  
          *{$AUTOLOAD} = sub {
              my $self  = shift;
              my $value = shift;
  
              $value = 1 if not defined $value;
              $self->{$attribute} = $value;
          };
      }
  
  
      $self->{$attribute} = $value;
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Format - A class for defining Excel formatting.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_FORMAT

$fatpacked{"Excel/Writer/XLSX/Package/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_APP';
  package Excel::Writer::XLSX::Package::App;
  
  ###############################################################################
  #
  # App - A class for writing the Excel XLSX app.xml file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_part_names}    = [];
      $self->{_heading_pairs} = [];
      $self->{_properties}    = {};
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
      $self->_write_properties();
      $self->_write_application();
      $self->_write_doc_security();
      $self->_write_scale_crop();
      $self->_write_heading_pairs();
      $self->_write_titles_of_parts();
      $self->_write_manager();
      $self->_write_company();
      $self->_write_links_up_to_date();
      $self->_write_shared_doc();
      $self->_write_hyperlink_base();
      $self->_write_hyperlinks_changed();
      $self->_write_app_version();
  
      $self->xml_end_tag( 'Properties' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _add_part_name()
  #
  # Add the name of a workbook Part such as 'Sheet1' or 'Print_Titles'.
  #
  sub _add_part_name {
  
      my $self      = shift;
      my $part_name = shift;
  
      push @{ $self->{_part_names} }, $part_name;
  }
  
  
  ###############################################################################
  #
  # _add_heading_pair()
  #
  # Add the name of a workbook Heading Pair such as 'Worksheets', 'Charts' or
  # 'Named Ranges'.
  #
  sub _add_heading_pair {
  
      my $self         = shift;
      my $heading_pair = shift;
  
      return unless $heading_pair->[1];  # Ignore empty pairs such as chartsheets.
  
      my @vector = (
          [ 'lpstr', $heading_pair->[0] ],    # Data name
          [ 'i4',    $heading_pair->[1] ],    # Data size
      );
  
      push @{ $self->{_heading_pairs} }, @vector;
  }
  
  
  ###############################################################################
  #
  # _set_properties()
  #
  # Set the document properties.
  #
  sub _set_properties {
  
      my $self       = shift;
      my $properties = shift;
  
      $self->{_properties} = $properties;
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_properties()
  #
  # Write the <Properties> element.
  #
  sub _write_properties {
  
      my $self     = shift;
      my $schema   = 'http://schemas.openxmlformats.org/officeDocument/2006/';
      my $xmlns    = $schema . 'extended-properties';
      my $xmlns_vt = $schema . 'docPropsVTypes';
  
      my @attributes = (
          'xmlns'    => $xmlns,
          'xmlns:vt' => $xmlns_vt,
      );
  
      $self->xml_start_tag( 'Properties', @attributes );
  }
  
  ###############################################################################
  #
  # _write_application()
  #
  # Write the <Application> element.
  #
  sub _write_application {
  
      my $self = shift;
      my $data = 'Microsoft Excel';
  
      $self->xml_data_element( 'Application', $data );
  }
  
  
  ###############################################################################
  #
  # _write_doc_security()
  #
  # Write the <DocSecurity> element.
  #
  sub _write_doc_security {
  
      my $self = shift;
      my $data = 0;
  
      $self->xml_data_element( 'DocSecurity', $data );
  }
  
  
  ###############################################################################
  #
  # _write_scale_crop()
  #
  # Write the <ScaleCrop> element.
  #
  sub _write_scale_crop {
  
      my $self = shift;
      my $data = 'false';
  
      $self->xml_data_element( 'ScaleCrop', $data );
  }
  
  
  ###############################################################################
  #
  # _write_heading_pairs()
  #
  # Write the <HeadingPairs> element.
  #
  sub _write_heading_pairs {
  
      my $self = shift;
  
      $self->xml_start_tag( 'HeadingPairs' );
  
      $self->_write_vt_vector( 'variant', $self->{_heading_pairs} );
  
      $self->xml_end_tag( 'HeadingPairs' );
  }
  
  
  ###############################################################################
  #
  # _write_titles_of_parts()
  #
  # Write the <TitlesOfParts> element.
  #
  sub _write_titles_of_parts {
  
      my $self = shift;
  
      $self->xml_start_tag( 'TitlesOfParts' );
  
      my @parts_data;
  
      for my $part_name ( @{ $self->{_part_names} } ) {
          push @parts_data, [ 'lpstr', $part_name ];
      }
  
      $self->_write_vt_vector( 'lpstr', \@parts_data );
  
      $self->xml_end_tag( 'TitlesOfParts' );
  }
  
  
  ###############################################################################
  #
  # _write_vt_vector()
  #
  # Write the <vt:vector> element.
  #
  sub _write_vt_vector {
  
      my $self      = shift;
      my $base_type = shift;
      my $data      = shift;
      my $size      = @$data;
  
      my @attributes = (
          'size'     => $size,
          'baseType' => $base_type,
      );
  
      $self->xml_start_tag( 'vt:vector', @attributes );
  
      for my $aref ( @$data ) {
          $self->xml_start_tag( 'vt:variant' ) if $base_type eq 'variant';
          $self->_write_vt_data( @$aref );
          $self->xml_end_tag( 'vt:variant' ) if $base_type eq 'variant';
      }
  
      $self->xml_end_tag( 'vt:vector' );
  }
  
  
  ##############################################################################
  #
  # _write_vt_data()
  #
  # Write the <vt:*> elements such as <vt:lpstr> and <vt:if>.
  #
  sub _write_vt_data {
  
      my $self = shift;
      my $type = shift;
      my $data = shift;
  
      $self->xml_data_element( "vt:$type", $data );
  }
  
  
  ###############################################################################
  #
  # _write_company()
  #
  # Write the <Company> element.
  #
  sub _write_company {
  
      my $self = shift;
      my $data = $self->{_properties}->{company} || '';
  
      $self->xml_data_element( 'Company', $data );
  }
  
  
  ###############################################################################
  #
  # _write_manager()
  #
  # Write the <Manager> element.
  #
  sub _write_manager {
  
      my $self = shift;
      my $data = $self->{_properties}->{manager};
  
      return unless $data;
  
      $self->xml_data_element( 'Manager', $data );
  }
  
  
  ###############################################################################
  #
  # _write_links_up_to_date()
  #
  # Write the <LinksUpToDate> element.
  #
  sub _write_links_up_to_date {
  
      my $self = shift;
      my $data = 'false';
  
      $self->xml_data_element( 'LinksUpToDate', $data );
  }
  
  
  ###############################################################################
  #
  # _write_shared_doc()
  #
  # Write the <SharedDoc> element.
  #
  sub _write_shared_doc {
  
      my $self = shift;
      my $data = 'false';
  
      $self->xml_data_element( 'SharedDoc', $data );
  }
  
  
  ###############################################################################
  #
  # _write_hyperlink_base()
  #
  # Write the <HyperlinkBase> element.
  #
  sub _write_hyperlink_base {
  
      my $self = shift;
      my $data = $self->{_properties}->{hyperlink_base};
  
      return unless $data;
  
      $self->xml_data_element( 'HyperlinkBase', $data );
  }
  
  
  ###############################################################################
  #
  # _write_hyperlinks_changed()
  #
  # Write the <HyperlinksChanged> element.
  #
  sub _write_hyperlinks_changed {
  
      my $self = shift;
      my $data = 'false';
  
      $self->xml_data_element( 'HyperlinksChanged', $data );
  }
  
  
  ###############################################################################
  #
  # _write_app_version()
  #
  # Write the <AppVersion> element.
  #
  sub _write_app_version {
  
      my $self = shift;
      my $data = '12.0000';
  
      $self->xml_data_element( 'AppVersion', $data );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App - A class for writing the Excel XLSX app.xml file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_APP

$fatpacked{"Excel/Writer/XLSX/Package/Comments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_COMMENTS';
  package Excel::Writer::XLSX::Package::Comments;
  
  ###############################################################################
  #
  # Comments - A class for writing the Excel XLSX Comments files.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  use Excel::Writer::XLSX::Utility qw(xl_rowcol_to_cell);
  
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_author_ids} = {};
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self          = shift;
      my $comments_data = shift;
  
      $self->xml_declaration;
  
      # Write the comments element.
      $self->_write_comments();
  
      # Write the authors element.
      $self->_write_authors( $comments_data );
  
      # Write the commentList element.
      $self->_write_comment_list( $comments_data );
  
      $self->xml_end_tag( 'comments' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_comments()
  #
  # Write the <comments> element.
  #
  sub _write_comments {
  
      my $self  = shift;
      my $xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main';
  
      my @attributes = ( 'xmlns' => $xmlns );
  
      $self->xml_start_tag( 'comments', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_authors()
  #
  # Write the <authors> element.
  #
  sub _write_authors {
  
      my $self         = shift;
      my $comment_data = shift;
      my $author_count = 0;
  
      $self->xml_start_tag( 'authors' );
  
      for my $comment ( @$comment_data ) {
          my $author = $comment->[3];
  
          if ( defined $author && !exists $self->{_author_ids}->{$author} ) {
  
              # Store the author id.
              $self->{_author_ids}->{$author} = $author_count++;
  
              # Write the author element.
              $self->_write_author( $author );
          }
      }
  
      $self->xml_end_tag( 'authors' );
  }
  
  
  ##############################################################################
  #
  # _write_author()
  #
  # Write the <author> element.
  #
  sub _write_author {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'author', $data );
  }
  
  
  ##############################################################################
  #
  # _write_comment_list()
  #
  # Write the <commentList> element.
  #
  sub _write_comment_list {
  
      my $self         = shift;
      my $comment_data = shift;
  
      $self->xml_start_tag( 'commentList' );
  
      for my $comment ( @$comment_data ) {
          my $row    = $comment->[0];
          my $col    = $comment->[1];
          my $text   = $comment->[2];
          my $author = $comment->[3];
  
          # Look up the author id.
          my $author_id = undef;
          $author_id = $self->{_author_ids}->{$author} if defined $author;
  
          # Write the comment element.
          $self->_write_comment( $row, $col, $text, $author_id );
      }
  
      $self->xml_end_tag( 'commentList' );
  }
  
  
  ##############################################################################
  #
  # _write_comment()
  #
  # Write the <comment> element.
  #
  sub _write_comment {
  
      my $self      = shift;
      my $row       = shift;
      my $col       = shift;
      my $text      = shift;
      my $author_id = shift;
      my $ref       = xl_rowcol_to_cell( $row, $col );
  
      my @attributes = ( 'ref' => $ref );
  
      push @attributes, ( 'authorId' => $author_id ) if defined $author_id;
  
  
      $self->xml_start_tag( 'comment', @attributes );
  
      # Write the text element.
      $self->_write_text( $text );
  
  
      $self->xml_end_tag( 'comment' );
  }
  
  
  ##############################################################################
  #
  # _write_text()
  #
  # Write the <text> element.
  #
  sub _write_text {
  
      my $self = shift;
      my $text = shift;
  
      $self->xml_start_tag( 'text' );
  
      # Write the text r element.
      $self->_write_text_r( $text );
  
      $self->xml_end_tag( 'text' );
  }
  
  
  ##############################################################################
  #
  # _write_text_r()
  #
  # Write the <r> element.
  #
  sub _write_text_r {
  
      my $self = shift;
      my $text = shift;
  
      $self->xml_start_tag( 'r' );
  
      # Write the rPr element.
      $self->_write_r_pr();
  
      # Write the text r element.
      $self->_write_text_t( $text );
  
      $self->xml_end_tag( 'r' );
  }
  
  
  ##############################################################################
  #
  # _write_text_t()
  #
  # Write the text <t> element.
  #
  sub _write_text_t {
  
      my $self = shift;
      my $text = shift;
  
      my @attributes = ();
  
      if ( $text =~ /^\s/ || $text =~ /\s$/ ) {
          push @attributes, ( 'xml:space' => 'preserve' );
      }
  
      $self->xml_data_element( 't', $text, @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_r_pr()
  #
  # Write the <rPr> element.
  #
  sub _write_r_pr {
  
      my $self = shift;
  
      $self->xml_start_tag( 'rPr' );
  
      # Write the sz element.
      $self->_write_sz();
  
      # Write the color element.
      $self->_write_color();
  
      # Write the rFont element.
      $self->_write_r_font();
  
      # Write the family element.
      $self->_write_family();
  
      $self->xml_end_tag( 'rPr' );
  }
  
  
  ##############################################################################
  #
  # _write_sz()
  #
  # Write the <sz> element.
  #
  sub _write_sz {
  
      my $self = shift;
      my $val  = 8;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'sz', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_color()
  #
  # Write the <color> element.
  #
  sub _write_color {
  
      my $self    = shift;
      my $indexed = 81;
  
      my @attributes = ( 'indexed' => $indexed );
  
      $self->xml_empty_tag( 'color', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_r_font()
  #
  # Write the <rFont> element.
  #
  sub _write_r_font {
  
      my $self = shift;
      my $val  = 'Tahoma';
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'rFont', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_family()
  #
  # Write the <family> element.
  #
  sub _write_family {
  
      my $self = shift;
      my $val  = 2;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'family', @attributes );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Comments - A class for writing the Excel XLSX Comments files.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_COMMENTS

$fatpacked{"Excel/Writer/XLSX/Package/ContentTypes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_CONTENTTYPES';
  package Excel::Writer::XLSX::Package::ContentTypes;
  
  ###############################################################################
  #
  # Excel::Writer::XLSX::Package::ContentTypes - A class for writing the Excel
  # XLS [Content_Types] file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Package data.
  #
  ###############################################################################
  
  my $app_package  = 'application/vnd.openxmlformats-package.';
  my $app_document = 'application/vnd.openxmlformats-officedocument.';
  
  our @defaults = (
      [ 'rels', $app_package . 'relationships+xml' ],
      [ 'xml',  'application/xml' ],
  );
  
  our @overrides = (
      [ '/docProps/app.xml',    $app_document . 'extended-properties+xml' ],
      [ '/docProps/core.xml',   $app_package . 'core-properties+xml' ],
      [ '/xl/styles.xml',       $app_document . 'spreadsheetml.styles+xml' ],
      [ '/xl/theme/theme1.xml', $app_document . 'theme+xml' ],
      [ '/xl/workbook.xml',     $app_document . 'spreadsheetml.sheet.main+xml' ],
  );
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_defaults}  = [@defaults];
      $self->{_overrides} = [@overrides];
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
      $self->_write_types();
      $self->_write_defaults();
      $self->_write_overrides();
  
      $self->xml_end_tag( 'Types' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _add_default()
  #
  # Add elements to the ContentTypes defaults.
  #
  sub _add_default {
  
      my $self         = shift;
      my $part_name    = shift;
      my $content_type = shift;
  
      push @{ $self->{_defaults} }, [ $part_name, $content_type ];
  
  }
  
  
  ###############################################################################
  #
  # _add_override()
  #
  # Add elements to the ContentTypes overrides.
  #
  sub _add_override {
  
      my $self         = shift;
      my $part_name    = shift;
      my $content_type = shift;
  
      push @{ $self->{_overrides} }, [ $part_name, $content_type ];
  
  }
  
  
  ###############################################################################
  #
  # _add_worksheet_name()
  #
  # Add the name of a worksheet to the ContentTypes overrides.
  #
  sub _add_worksheet_name {
  
      my $self           = shift;
      my $worksheet_name = shift;
  
      $worksheet_name = "/xl/worksheets/$worksheet_name.xml";
  
      $self->_add_override( $worksheet_name,
          $app_document . 'spreadsheetml.worksheet+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_chartsheet_name()
  #
  # Add the name of a chartsheet to the ContentTypes overrides.
  #
  sub _add_chartsheet_name {
  
      my $self            = shift;
      my $chartsheet_name = shift;
  
      $chartsheet_name = "/xl/chartsheets/$chartsheet_name.xml";
  
      $self->_add_override( $chartsheet_name,
          $app_document . 'spreadsheetml.chartsheet+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_chart_name()
  #
  # Add the name of a chart to the ContentTypes overrides.
  #
  sub _add_chart_name {
  
      my $self       = shift;
      my $chart_name = shift;
  
      $chart_name = "/xl/charts/$chart_name.xml";
  
      $self->_add_override( $chart_name, $app_document . 'drawingml.chart+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_drawing_name()
  #
  # Add the name of a drawing to the ContentTypes overrides.
  #
  sub _add_drawing_name {
  
      my $self         = shift;
      my $drawing_name = shift;
  
      $drawing_name = "/xl/drawings/$drawing_name.xml";
  
      $self->_add_override( $drawing_name, $app_document . 'drawing+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_vml_name()
  #
  # Add the name of a VML drawing to the ContentTypes defaults.
  #
  sub _add_vml_name {
  
      my $self = shift;
  
      $self->_add_default( 'vml', $app_document . 'vmlDrawing' );
  }
  
  
  ###############################################################################
  #
  # _add_comment_name()
  #
  # Add the name of a comment to the ContentTypes overrides.
  #
  sub _add_comment_name {
  
      my $self         = shift;
      my $comment_name = shift;
  
      $comment_name = "/xl/$comment_name.xml";
  
      $self->_add_override( $comment_name,
          $app_document . 'spreadsheetml.comments+xml' );
  }
  
  ###############################################################################
  #
  # _Add_shared_strings()
  #
  # Add the sharedStrings link to the ContentTypes overrides.
  #
  sub _add_shared_strings {
  
      my $self = shift;
  
      $self->_add_override( '/xl/sharedStrings.xml',
          $app_document . 'spreadsheetml.sharedStrings+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_calc_chain()
  #
  # Add the calcChain link to the ContentTypes overrides.
  #
  sub _add_calc_chain {
  
      my $self = shift;
  
      $self->_add_override( '/xl/calcChain.xml',
          $app_document . 'spreadsheetml.calcChain+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_image_types()
  #
  # Add the image default types.
  #
  sub _add_image_types {
  
      my $self  = shift;
      my %types = @_;
  
      for my $type ( keys %types ) {
          $self->_add_default( $type, 'image/' . $type );
      }
  }
  
  
  ###############################################################################
  #
  # _add_table_name()
  #
  # Add the name of a table to the ContentTypes overrides.
  #
  sub _add_table_name {
  
      my $self       = shift;
      my $table_name = shift;
  
      $table_name = "/xl/tables/$table_name.xml";
  
      $self->_add_override( $table_name,
          $app_document . 'spreadsheetml.table+xml' );
  }
  
  
  ###############################################################################
  #
  # _add_vba_project()
  #
  # Add a vbaProject to the ContentTypes defaults.
  #
  sub _add_vba_project {
  
      my $self = shift;
  
      # Change the workbook.xml content-type from xlsx to xlsm.
      for my $aref ( @{ $self->{_overrides} } ) {
          if ( $aref->[0] eq '/xl/workbook.xml' ) {
              $aref->[1] = 'application/vnd.ms-excel.sheet.macroEnabled.main+xml';
          }
      }
  
      $self->_add_default( 'bin', 'application/vnd.ms-office.vbaProject' );
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_defaults()
  #
  # Write out all of the <Default> types.
  #
  sub _write_defaults {
  
      my $self = shift;
  
      for my $aref ( @{ $self->{_defaults} } ) {
          #<<<
          $self->xml_empty_tag(
              'Default',
              'Extension',   $aref->[0],
              'ContentType', $aref->[1] );
          #>>>
      }
  }
  
  
  ###############################################################################
  #
  # _write_overrides()
  #
  # Write out all of the <Override> types.
  #
  sub _write_overrides {
  
      my $self = shift;
  
      for my $aref ( @{ $self->{_overrides} } ) {
          #<<<
          $self->xml_empty_tag(
              'Override',
              'PartName',    $aref->[0],
              'ContentType', $aref->[1] );
          #>>>
      }
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_types()
  #
  # Write the <Types> element.
  #
  sub _write_types {
  
      my $self  = shift;
      my $xmlns = 'http://schemas.openxmlformats.org/package/2006/content-types';
  
      my @attributes = ( 'xmlns' => $xmlns, );
  
      $self->xml_start_tag( 'Types', @attributes );
  }
  
  ###############################################################################
  #
  # _write_default()
  #
  # Write the <Default> element.
  #
  sub _write_default {
  
      my $self         = shift;
      my $extension    = shift;
      my $content_type = shift;
  
      my @attributes = (
          'Extension'   => $extension,
          'ContentType' => $content_type,
      );
  
      $self->xml_empty_tag( 'Default', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_override()
  #
  # Write the <Override> element.
  #
  sub _write_override {
  
      my $self         = shift;
      my $part_name    = shift;
      my $content_type = shift;
      my $writer       = $self;
  
      my @attributes = (
          'PartName'    => $part_name,
          'ContentType' => $content_type,
      );
  
      $self->xml_empty_tag( 'Override', @attributes );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Excel::Writer::XLSX::Package::ContentTypes - A class for writing the Excel XLSX [Content_Types] file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_CONTENTTYPES

$fatpacked{"Excel/Writer/XLSX/Package/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_CORE';
  package Excel::Writer::XLSX::Package::Core;
  
  ###############################################################################
  #
  # Core - A class for writing the Excel XLSX core.xml file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_properties} = {};
      $self->{_localtime}  = [ localtime() ];
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
      $self->_write_cp_core_properties();
      $self->_write_dc_title();
      $self->_write_dc_subject();
      $self->_write_dc_creator();
      $self->_write_cp_keywords();
      $self->_write_dc_description();
      $self->_write_cp_last_modified_by();
      $self->_write_dcterms_created();
      $self->_write_dcterms_modified();
      $self->_write_cp_category();
      $self->_write_cp_content_status();
  
      $self->xml_end_tag( 'cp:coreProperties' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _set_properties()
  #
  # Set the document properties.
  #
  sub _set_properties {
  
      my $self       = shift;
      my $properties = shift;
  
      $self->{_properties} = $properties;
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _localtime_to_iso8601_date()
  #
  # Convert a localtime() date to a ISO 8601 style "2010-01-01T00:00:00Z" date.
  #
  sub _localtime_to_iso8601_date {
  
      my $self = shift;
      my $localtime = shift || $self->{_localtime};
  
      my ( $seconds, $minutes, $hours, $day, $month, $year ) = @$localtime;
  
      $month++;
      $year += 1900;
  
      my $date = sprintf "%4d-%02d-%02dT%02d:%02d:%02dZ", $year, $month, $day,
        $hours, $minutes, $seconds;
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_cp_core_properties()
  #
  # Write the <cp:coreProperties> element.
  #
  sub _write_cp_core_properties {
  
      my $self = shift;
      my $xmlns_cp =
        'http://schemas.openxmlformats.org/package/2006/metadata/core-properties';
      my $xmlns_dc       = 'http://purl.org/dc/elements/1.1/';
      my $xmlns_dcterms  = 'http://purl.org/dc/terms/';
      my $xmlns_dcmitype = 'http://purl.org/dc/dcmitype/';
      my $xmlns_xsi      = 'http://www.w3.org/2001/XMLSchema-instance';
  
      my @attributes = (
          'xmlns:cp'       => $xmlns_cp,
          'xmlns:dc'       => $xmlns_dc,
          'xmlns:dcterms'  => $xmlns_dcterms,
          'xmlns:dcmitype' => $xmlns_dcmitype,
          'xmlns:xsi'      => $xmlns_xsi,
      );
  
      $self->xml_start_tag( 'cp:coreProperties', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_dc_creator()
  #
  # Write the <dc:creator> element.
  #
  sub _write_dc_creator {
  
      my $self = shift;
      my $data = $self->{_properties}->{author} || '';
  
      $self->xml_data_element( 'dc:creator', $data );
  }
  
  
  ###############################################################################
  #
  # _write_cp_last_modified_by()
  #
  # Write the <cp:lastModifiedBy> element.
  #
  sub _write_cp_last_modified_by {
  
      my $self = shift;
      my $data = $self->{_properties}->{author} || '';
  
      $self->xml_data_element( 'cp:lastModifiedBy', $data );
  }
  
  
  ###############################################################################
  #
  # _write_dcterms_created()
  #
  # Write the <dcterms:created> element.
  #
  sub _write_dcterms_created {
  
      my $self     = shift;
      my $date     = $self->{_properties}->{created};
      my $xsi_type = 'dcterms:W3CDTF';
  
      $date = $self->_localtime_to_iso8601_date( $date );
  
      my @attributes = ( 'xsi:type' => $xsi_type, );
  
      $self->xml_data_element( 'dcterms:created', $date, @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_dcterms_modified()
  #
  # Write the <dcterms:modified> element.
  #
  sub _write_dcterms_modified {
  
      my $self     = shift;
      my $date     = $self->{_properties}->{created};
      my $xsi_type = 'dcterms:W3CDTF';
  
      $date = $self->_localtime_to_iso8601_date( $date );
  
      my @attributes = ( 'xsi:type' => $xsi_type, );
  
      $self->xml_data_element( 'dcterms:modified', $date, @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_dc_title()
  #
  # Write the <dc:title> element.
  #
  sub _write_dc_title {
  
      my $self = shift;
      my $data = $self->{_properties}->{title};
  
      return unless $data;
  
      $self->xml_data_element( 'dc:title', $data );
  }
  
  
  ##############################################################################
  #
  # _write_dc_subject()
  #
  # Write the <dc:subject> element.
  #
  sub _write_dc_subject {
  
      my $self = shift;
      my $data = $self->{_properties}->{subject};
  
      return unless $data;
  
      $self->xml_data_element( 'dc:subject', $data );
  }
  
  
  ##############################################################################
  #
  # _write_cp_keywords()
  #
  # Write the <cp:keywords> element.
  #
  sub _write_cp_keywords {
  
      my $self = shift;
      my $data = $self->{_properties}->{keywords};
  
      return unless $data;
  
      $self->xml_data_element( 'cp:keywords', $data );
  }
  
  
  ##############################################################################
  #
  # _write_dc_description()
  #
  # Write the <dc:description> element.
  #
  sub _write_dc_description {
  
      my $self = shift;
      my $data = $self->{_properties}->{comments};
  
      return unless $data;
  
      $self->xml_data_element( 'dc:description', $data );
  }
  
  
  ##############################################################################
  #
  # _write_cp_category()
  #
  # Write the <cp:category> element.
  #
  sub _write_cp_category {
  
      my $self = shift;
      my $data = $self->{_properties}->{category};
  
      return unless $data;
  
      $self->xml_data_element( 'cp:category', $data );
  }
  
  
  ##############################################################################
  #
  # _write_cp_content_status()
  #
  # Write the <cp:contentStatus> element.
  #
  sub _write_cp_content_status {
  
      my $self = shift;
      my $data = $self->{_properties}->{status};
  
      return unless $data;
  
      $self->xml_data_element( 'cp:contentStatus', $data );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Core - A class for writing the Excel XLSX core.xml file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_CORE

$fatpacked{"Excel/Writer/XLSX/Package/Packager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_PACKAGER';
  package Excel::Writer::XLSX::Package::Packager;
  
  ###############################################################################
  #
  # Packager - A class for creating the Excel XLSX package.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Exporter;
  use Carp;
  use File::Copy;
  use Excel::Writer::XLSX::Package::App;
  use Excel::Writer::XLSX::Package::Comments;
  use Excel::Writer::XLSX::Package::ContentTypes;
  use Excel::Writer::XLSX::Package::Core;
  use Excel::Writer::XLSX::Package::Relationships;
  use Excel::Writer::XLSX::Package::SharedStrings;
  use Excel::Writer::XLSX::Package::Styles;
  use Excel::Writer::XLSX::Package::Table;
  use Excel::Writer::XLSX::Package::Theme;
  use Excel::Writer::XLSX::Package::VML;
  
  our @ISA     = qw(Exporter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_package_dir}      = '';
      $self->{_workbook}         = undef;
      $self->{_sheet_names}      = [];
      $self->{_worksheet_count}  = 0;
      $self->{_chartsheet_count} = 0;
      $self->{_chart_count}      = 0;
      $self->{_drawing_count}    = 0;
      $self->{_table_count}      = 0;
      $self->{_named_ranges}     = [];
  
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _set_package_dir()
  #
  # Set the XLSX OPC package directory.
  #
  sub _set_package_dir {
  
      my $self = shift;
  
      $self->{_package_dir} = shift;
  }
  
  
  ###############################################################################
  #
  # _add_workbook()
  #
  # Add the Excel::Writer::XLSX::Workbook object to the package.
  #
  sub _add_workbook {
  
      my $self        = shift;
      my $workbook    = shift;
      my @sheet_names = @{ $workbook->{_sheetnames} };
  
      $self->{_workbook}          = $workbook;
      $self->{_sheet_names}       = \@sheet_names;
      $self->{_chart_count}       = scalar @{ $workbook->{_charts} };
      $self->{_drawing_count}     = scalar @{ $workbook->{_drawings} };
      $self->{_num_vml_files}     = $workbook->{_num_vml_files};
      $self->{_num_comment_files} = $workbook->{_num_comment_files};
      $self->{_named_ranges}      = $workbook->{_named_ranges};
  
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          if ( $worksheet->{_is_chartsheet} ) {
              $self->{_chartsheet_count}++;
          }
          else {
              $self->{_worksheet_count}++;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _create_package()
  #
  # Write the xml files that make up the XLXS OPC package.
  #
  sub _create_package {
  
      my $self = shift;
  
      $self->_write_worksheet_files();
      $self->_write_chartsheet_files();
      $self->_write_workbook_file();
      $self->_write_chart_files();
      $self->_write_drawing_files();
      $self->_write_vml_files();
      $self->_write_comment_files();
      $self->_write_table_files();
      $self->_write_shared_strings_file();
      $self->_write_app_file();
      $self->_write_core_file();
      $self->_write_content_types_file();
      $self->_write_styles_file();
      $self->_write_theme_file();
      $self->_write_root_rels_file();
      $self->_write_workbook_rels_file();
      $self->_write_worksheet_rels_files();
      $self->_write_chartsheet_rels_files();
      $self->_write_drawing_rels_files();
      $self->_add_image_files();
      $self->_add_vba_project();
  }
  
  
  ###############################################################################
  #
  # _write_workbook_file()
  #
  # Write the workbook.xml file.
  #
  sub _write_workbook_file {
  
      my $self     = shift;
      my $dir      = $self->{_package_dir};
      my $workbook = $self->{_workbook};
  
      _mkdir( $dir . '/xl' );
  
      $workbook->_set_xml_writer( $dir . '/xl/workbook.xml' );
      $workbook->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_worksheet_files()
  #
  # Write the worksheet files.
  #
  sub _write_worksheet_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      _mkdir( $dir . '/xl' );
      _mkdir( $dir . '/xl/worksheets' );
  
      my $index = 1;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          next if $worksheet->{_is_chartsheet};
  
          $worksheet->_set_xml_writer(
              $dir . '/xl/worksheets/sheet' . $index++ . '.xml' );
          $worksheet->_assemble_xml_file();
  
      }
  }
  
  
  ###############################################################################
  #
  # _write_chartsheet_files()
  #
  # Write the chartsheet files.
  #
  sub _write_chartsheet_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      my $index = 1;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          next unless $worksheet->{_is_chartsheet};
  
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/chartsheets' );
  
          $worksheet->_set_xml_writer(
              $dir . '/xl/chartsheets/sheet' . $index++ . '.xml' );
          $worksheet->_assemble_xml_file();
  
      }
  }
  
  
  ###############################################################################
  #
  # _write_chart_files()
  #
  # Write the chart files.
  #
  sub _write_chart_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      return unless @{ $self->{_workbook}->{_charts} };
  
      _mkdir( $dir . '/xl' );
      _mkdir( $dir . '/xl/charts' );
  
      my $index = 1;
      for my $chart ( @{ $self->{_workbook}->{_charts} } ) {
          $chart->_set_xml_writer(
              $dir . '/xl/charts/chart' . $index++ . '.xml' );
          $chart->_assemble_xml_file();
  
      }
  }
  
  
  ###############################################################################
  #
  # _write_drawing_files()
  #
  # Write the drawing files.
  #
  sub _write_drawing_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      return unless $self->{_drawing_count};
  
      _mkdir( $dir . '/xl' );
      _mkdir( $dir . '/xl/drawings' );
  
      my $index = 1;
      for my $drawing ( @{ $self->{_workbook}->{_drawings} } ) {
          $drawing->_set_xml_writer(
              $dir . '/xl/drawings/drawing' . $index++ . '.xml' );
          $drawing->_assemble_xml_file();
      }
  }
  
  
  ###############################################################################
  #
  # _write_vml_files()
  #
  # Write the comment VML files.
  #
  sub _write_vml_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      my $index = 1;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
  
          next if !$worksheet->{_has_vml} and !$worksheet->{_has_header_vml};
  
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/drawings' );
  
          if ( $worksheet->{_has_vml} ) {
              my $vml = Excel::Writer::XLSX::Package::VML->new();
  
              $vml->_set_xml_writer(
                  $dir . '/xl/drawings/vmlDrawing' . $index . '.vml' );
              $vml->_assemble_xml_file(
                  $worksheet->{_vml_data_id},    $worksheet->{_vml_shape_id},
                  $worksheet->{_comments_array}, $worksheet->{_buttons_array},
                  undef
              );
  
              $index++;
          }
  
          if ( $worksheet->{_has_header_vml} ) {
              my $vml = Excel::Writer::XLSX::Package::VML->new();
  
              $vml->_set_xml_writer(
                  $dir . '/xl/drawings/vmlDrawing' . $index . '.vml' );
              $vml->_assemble_xml_file(
                  $worksheet->{_vml_header_id},
                  $worksheet->{_vml_header_id} * 1024,
                  undef, undef, $worksheet->{_header_images_array}
              );
  
              $self->_write_vml_drawing_rels_file($worksheet, $index);
  
              $index++;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _write_comment_files()
  #
  # Write the comment files.
  #
  sub _write_comment_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      my $index = 1;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          next unless $worksheet->{_has_comments};
  
          my $comment = Excel::Writer::XLSX::Package::Comments->new();
  
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/drawings' );
  
          $comment->_set_xml_writer( $dir . '/xl/comments' . $index++ . '.xml' );
          $comment->_assemble_xml_file( $worksheet->{_comments_array} );
      }
  }
  
  
  ###############################################################################
  #
  # _write_shared_strings_file()
  #
  # Write the sharedStrings.xml file.
  #
  sub _write_shared_strings_file {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
      my $sst  = Excel::Writer::XLSX::Package::SharedStrings->new();
  
      my $total    = $self->{_workbook}->{_str_total};
      my $unique   = $self->{_workbook}->{_str_unique};
      my $sst_data = $self->{_workbook}->{_str_array};
  
      return unless $total > 0;
  
      _mkdir( $dir . '/xl' );
  
      $sst->_set_string_count( $total );
      $sst->_set_unique_count( $unique );
      $sst->_add_strings( $sst_data );
  
      $sst->_set_xml_writer( $dir . '/xl/sharedStrings.xml' );
      $sst->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_app_file()
  #
  # Write the app.xml file.
  #
  sub _write_app_file {
  
      my $self       = shift;
      my $dir        = $self->{_package_dir};
      my $properties = $self->{_workbook}->{_doc_properties};
      my $app        = Excel::Writer::XLSX::Package::App->new();
  
      _mkdir( $dir . '/docProps' );
  
      # Add the Worksheet heading pairs.
      $app->_add_heading_pair( [ 'Worksheets', $self->{_worksheet_count} ] );
  
      # Add the Chartsheet heading pairs.
      $app->_add_heading_pair( [ 'Charts', $self->{_chartsheet_count} ] );
  
      # Add the Worksheet parts.
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          next if $worksheet->{_is_chartsheet};
          $app->_add_part_name( $worksheet->get_name() );
      }
  
      # Add the Chartsheet parts.
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          next unless $worksheet->{_is_chartsheet};
          $app->_add_part_name( $worksheet->get_name() );
      }
  
      # Add the Named Range heading pairs.
      if ( my $range_count = scalar @{ $self->{_named_ranges} } ) {
          $app->_add_heading_pair( [ 'Named Ranges', $range_count ] );
      }
  
      # Add the Named Ranges parts.
      for my $named_range ( @{ $self->{_named_ranges} } ) {
          $app->_add_part_name( $named_range );
      }
  
      $app->_set_properties( $properties );
  
      $app->_set_xml_writer( $dir . '/docProps/app.xml' );
      $app->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_core_file()
  #
  # Write the core.xml file.
  #
  sub _write_core_file {
  
      my $self       = shift;
      my $dir        = $self->{_package_dir};
      my $properties = $self->{_workbook}->{_doc_properties};
      my $core       = Excel::Writer::XLSX::Package::Core->new();
  
      _mkdir( $dir . '/docProps' );
  
      $core->_set_properties( $properties );
      $core->_set_xml_writer( $dir . '/docProps/core.xml' );
      $core->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_content_types_file()
  #
  # Write the ContentTypes.xml file.
  #
  sub _write_content_types_file {
  
      my $self    = shift;
      my $dir     = $self->{_package_dir};
      my $content = Excel::Writer::XLSX::Package::ContentTypes->new();
  
      $content->_add_image_types( %{ $self->{_workbook}->{_image_types} } );
  
      my $worksheet_index  = 1;
      my $chartsheet_index = 1;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          if ( $worksheet->{_is_chartsheet} ) {
              $content->_add_chartsheet_name( 'sheet' . $chartsheet_index++ );
          }
          else {
              $content->_add_worksheet_name( 'sheet' . $worksheet_index++ );
          }
      }
  
      for my $i ( 1 .. $self->{_chart_count} ) {
          $content->_add_chart_name( 'chart' . $i );
      }
  
      for my $i ( 1 .. $self->{_drawing_count} ) {
          $content->_add_drawing_name( 'drawing' . $i );
      }
  
      if ( $self->{_num_vml_files} ) {
          $content->_add_vml_name();
      }
  
      for my $i ( 1 .. $self->{_table_count} ) {
          $content->_add_table_name( 'table' . $i );
      }
  
      for my $i ( 1 .. $self->{_num_comment_files} ) {
          $content->_add_comment_name( 'comments' . $i );
      }
  
      # Add the sharedString rel if there is string data in the workbook.
      if ( $self->{_workbook}->{_str_total} ) {
          $content->_add_shared_strings();
      }
  
      # Add vbaProject if present.
      if ( $self->{_workbook}->{_vba_project} ) {
          $content->_add_vba_project();
      }
  
      $content->_set_xml_writer( $dir . '/[Content_Types].xml' );
      $content->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_styles_file()
  #
  # Write the style xml file.
  #
  sub _write_styles_file {
  
      my $self             = shift;
      my $dir              = $self->{_package_dir};
      my $xf_formats       = $self->{_workbook}->{_xf_formats};
      my $palette          = $self->{_workbook}->{_palette};
      my $font_count       = $self->{_workbook}->{_font_count};
      my $num_format_count = $self->{_workbook}->{_num_format_count};
      my $border_count     = $self->{_workbook}->{_border_count};
      my $fill_count       = $self->{_workbook}->{_fill_count};
      my $custom_colors    = $self->{_workbook}->{_custom_colors};
      my $dxf_formats      = $self->{_workbook}->{_dxf_formats};
  
      my $rels = Excel::Writer::XLSX::Package::Styles->new();
  
      _mkdir( $dir . '/xl' );
  
      $rels->_set_style_properties(
          $xf_formats,
          $palette,
          $font_count,
          $num_format_count,
          $border_count,
          $fill_count,
          $custom_colors,
          $dxf_formats,
  
      );
  
      $rels->_set_xml_writer( $dir . '/xl/styles.xml' );
      $rels->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_theme_file()
  #
  # Write the style xml file.
  #
  sub _write_theme_file {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
      my $rels = Excel::Writer::XLSX::Package::Theme->new();
  
      _mkdir( $dir . '/xl' );
      _mkdir( $dir . '/xl/theme' );
  
      $rels->_set_xml_writer( $dir . '/xl/theme/theme1.xml' );
      $rels->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_table_files()
  #
  # Write the table files.
  #
  sub _write_table_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      my $index = 1;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          my @table_props = @{ $worksheet->{_tables} };
  
          next unless @table_props;
  
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/tables' );
  
          for my $table_props ( @table_props ) {
  
              my $table = Excel::Writer::XLSX::Package::Table->new();
  
              $table->_set_xml_writer(
                  $dir . '/xl/tables/table' . $index++ . '.xml' );
  
              $table->_set_properties( $table_props );
  
              $table->_assemble_xml_file();
  
              $self->{_table_count}++;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _write_root_rels_file()
  #
  # Write the _rels/.rels xml file.
  #
  sub _write_root_rels_file {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
      my $rels = Excel::Writer::XLSX::Package::Relationships->new();
  
      _mkdir( $dir . '/_rels' );
  
      $rels->_add_document_relationship( '/officeDocument', 'xl/workbook.xml' );
      $rels->_add_package_relationship( '/metadata/core-properties',
          'docProps/core.xml' );
      $rels->_add_document_relationship( '/extended-properties',
          'docProps/app.xml' );
  
      $rels->_set_xml_writer( $dir . '/_rels/.rels' );
      $rels->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_workbook_rels_file()
  #
  # Write the _rels/.rels xml file.
  #
  sub _write_workbook_rels_file {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
      my $rels = Excel::Writer::XLSX::Package::Relationships->new();
  
      _mkdir( $dir . '/xl' );
      _mkdir( $dir . '/xl/_rels' );
  
      my $worksheet_index  = 1;
      my $chartsheet_index = 1;
  
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
          if ( $worksheet->{_is_chartsheet} ) {
              $rels->_add_document_relationship( '/chartsheet',
                  'chartsheets/sheet' . $chartsheet_index++ . '.xml' );
          }
          else {
              $rels->_add_document_relationship( '/worksheet',
                  'worksheets/sheet' . $worksheet_index++ . '.xml' );
          }
      }
  
      $rels->_add_document_relationship( '/theme',  'theme/theme1.xml' );
      $rels->_add_document_relationship( '/styles', 'styles.xml' );
  
      # Add the sharedString rel if there is string data in the workbook.
      if ( $self->{_workbook}->{_str_total} ) {
          $rels->_add_document_relationship( '/sharedStrings',
              'sharedStrings.xml' );
      }
  
      # Add vbaProject if present.
      if ( $self->{_workbook}->{_vba_project} ) {
          $rels->_add_ms_package_relationship( '/vbaProject', 'vbaProject.bin' );
      }
  
      $rels->_set_xml_writer( $dir . '/xl/_rels/workbook.xml.rels' );
      $rels->_assemble_xml_file();
  }
  
  
  ###############################################################################
  #
  # _write_worksheet_rels_files()
  #
  # Write the worksheet .rels files for worksheets that contain links to external
  # data such as hyperlinks or drawings.
  #
  sub _write_worksheet_rels_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
      my $index = 0;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
  
          next if $worksheet->{_is_chartsheet};
  
          $index++;
  
          my @external_links = (
              @{ $worksheet->{_external_hyper_links} },
              @{ $worksheet->{_external_drawing_links} },
              @{ $worksheet->{_external_vml_links} },
              @{ $worksheet->{_external_table_links} },
              @{ $worksheet->{_external_comment_links} },
          );
  
          next unless @external_links;
  
          # Create the worksheet .rels dirs.
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/worksheets' );
          _mkdir( $dir . '/xl/worksheets/_rels' );
  
          my $rels = Excel::Writer::XLSX::Package::Relationships->new();
  
          for my $link_data ( @external_links ) {
              $rels->_add_worksheet_relationship( @$link_data );
          }
  
          # Create the .rels file such as /xl/worksheets/_rels/sheet1.xml.rels.
          $rels->_set_xml_writer(
              $dir . '/xl/worksheets/_rels/sheet' . $index . '.xml.rels' );
          $rels->_assemble_xml_file();
      }
  }
  
  
  ###############################################################################
  #
  # _write_chartsheet_rels_files()
  #
  # Write the chartsheet .rels files for links to drawing files.
  #
  sub _write_chartsheet_rels_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
  
      my $index = 0;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
  
          next unless $worksheet->{_is_chartsheet};
  
          $index++;
  
          my @external_links = @{ $worksheet->{_external_drawing_links} };
  
          next unless @external_links;
  
          # Create the chartsheet .rels dir.
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/chartsheets' );
          _mkdir( $dir . '/xl/chartsheets/_rels' );
  
          my $rels = Excel::Writer::XLSX::Package::Relationships->new();
  
          for my $link_data ( @external_links ) {
              $rels->_add_worksheet_relationship( @$link_data );
          }
  
          # Create the .rels file such as /xl/chartsheets/_rels/sheet1.xml.rels.
          $rels->_set_xml_writer(
              $dir . '/xl/chartsheets/_rels/sheet' . $index . '.xml.rels' );
          $rels->_assemble_xml_file();
      }
  }
  
  
  ###############################################################################
  #
  # _write_drawing_rels_files()
  #
  # Write the drawing .rels files for worksheets that contain charts or drawings.
  #
  sub _write_drawing_rels_files {
  
      my $self = shift;
      my $dir  = $self->{_package_dir};
  
  
      my $index = 0;
      for my $worksheet ( @{ $self->{_workbook}->{_worksheets} } ) {
  
          if ( @{ $worksheet->{_drawing_links} } || $worksheet->{_has_shapes} ) {
              $index++;
          }
  
          next unless @{ $worksheet->{_drawing_links} };
  
          # Create the drawing .rels dir.
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/drawings' );
          _mkdir( $dir . '/xl/drawings/_rels' );
  
          my $rels = Excel::Writer::XLSX::Package::Relationships->new();
  
          for my $drawing_data ( @{ $worksheet->{_drawing_links} } ) {
              $rels->_add_document_relationship( @$drawing_data );
          }
  
          # Create the .rels file such as /xl/drawings/_rels/sheet1.xml.rels.
          $rels->_set_xml_writer(
              $dir . '/xl/drawings/_rels/drawing' . $index . '.xml.rels' );
          $rels->_assemble_xml_file();
      }
  }
  
  
  ###############################################################################
  #
  # _write_vml_drawing_rels_files()
  #
  # Write the vmlDdrawing .rels files for worksheets with images in header or
  # footers.
  #
  sub _write_vml_drawing_rels_file {
  
      my $self      = shift;
      my $worksheet = shift;
      my $index     = shift;
      my $dir       = $self->{_package_dir};
  
  
      # Create the drawing .rels dir.
      _mkdir( $dir . '/xl' );
      _mkdir( $dir . '/xl/drawings' );
      _mkdir( $dir . '/xl/drawings/_rels' );
  
      my $rels = Excel::Writer::XLSX::Package::Relationships->new();
  
      for my $drawing_data ( @{ $worksheet->{_vml_drawing_links} } ) {
          $rels->_add_document_relationship( @$drawing_data );
      }
  
      # Create the .rels file such as /xl/drawings/_rels/vmlDrawing1.vml.rels.
      $rels->_set_xml_writer(
          $dir . '/xl/drawings/_rels/vmlDrawing' . $index . '.vml.rels' );
      $rels->_assemble_xml_file();
  
  }
  
  
  ###############################################################################
  #
  # _add_image_files()
  #
  # Write the /xl/media/image?.xml files.
  #
  sub _add_image_files {
  
      my $self     = shift;
      my $dir      = $self->{_package_dir};
      my $workbook = $self->{_workbook};
      my $index    = 1;
  
      for my $image ( @{ $workbook->{_images} } ) {
          my $filename  = $image->[0];
          my $extension = '.' . $image->[1];
  
          _mkdir( $dir . '/xl' );
          _mkdir( $dir . '/xl/media' );
  
          copy( $filename, $dir . '/xl/media/image' . $index++ . $extension );
      }
  }
  
  
  ###############################################################################
  #
  # _add_vba_project()
  #
  # Write the vbaProject.bin file.
  #
  sub _add_vba_project {
  
      my $self        = shift;
      my $dir         = $self->{_package_dir};
      my $vba_project = $self->{_workbook}->{_vba_project};
  
      return unless $vba_project;
  
      _mkdir( $dir . '/xl' );
  
      copy( $vba_project, $dir . '/xl/vbaProject.bin' );
  }
  
  
  ###############################################################################
  #
  # _mkdir()
  #
  # Wrapper function for Perl's mkdir to allow error trapping.
  #
  sub _mkdir {
  
      my $dir = shift;
  
      return if -e $dir;
  
      my $ret = mkdir( $dir );
  
      if ( !$ret ) {
          croak "Couldn't create sub directory $dir: $!";
      }
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Packager - A class for creating the Excel XLSX package.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX> to create an Excel XLSX container file.
  
  From Wikipedia: I<The Open Packaging Conventions (OPC) is a container-file technology initially created by Microsoft to store a combination of XML and non-XML files that together form a single entity such as an Open XML Paper Specification (OpenXPS) document>. L<http://en.wikipedia.org/wiki/Open_Packaging_Conventions>.
  
  At its simplest an Excel XLSX file contains the following elements:
  
       ____ [Content_Types].xml
      |
      |____ docProps
      | |____ app.xml
      | |____ core.xml
      |
      |____ xl
      | |____ workbook.xml
      | |____ worksheets
      | | |____ sheet1.xml
      | |
      | |____ styles.xml
      | |
      | |____ theme
      | | |____ theme1.xml
      | |
      | |_____rels
      |   |____ workbook.xml.rels
      |
      |_____rels
        |____ .rels
  
  
  The C<Excel::Writer::XLSX::Package::Packager> class co-ordinates the classes that represent the elements of the package and writes them into the XLSX file.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_PACKAGER

$fatpacked{"Excel/Writer/XLSX/Package/Relationships.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_RELATIONSHIPS';
  package Excel::Writer::XLSX::Package::Relationships;
  
  ###############################################################################
  #
  # Relationships - A class for writing the Excel XLSX Rels file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  our $schema_root     = 'http://schemas.openxmlformats.org';
  our $package_schema  = $schema_root . '/package/2006/relationships';
  our $document_schema = $schema_root . '/officeDocument/2006/relationships';
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_rels} = [];
      $self->{_id}   = 1;
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
      $self->_write_relationships();
  }
  
  
  ###############################################################################
  #
  # _add_document_relationship()
  #
  # Add container relationship to XLSX .rels xml files.
  #
  sub _add_document_relationship {
  
      my $self   = shift;
      my $type   = shift;
      my $target = shift;
  
      $type   = $document_schema . $type;
  
      push @{ $self->{_rels} }, [ $type, $target ];
  }
  
  
  ###############################################################################
  #
  # _add_package_relationship()
  #
  # Add container relationship to XLSX .rels xml files.
  #
  sub _add_package_relationship {
  
      my $self   = shift;
      my $type   = shift;
      my $target = shift;
  
      $type   = $package_schema . $type;
  
      push @{ $self->{_rels} }, [ $type, $target ];
  }
  
  
  ###############################################################################
  #
  # _add_ms_package_relationship()
  #
  # Add container relationship to XLSX .rels xml files. Uses MS schema.
  #
  sub _add_ms_package_relationship {
  
      my $self   = shift;
      my $type   = shift;
      my $target = shift;
      my $schema = 'http://schemas.microsoft.com/office/2006/relationships';
  
      $type   = $schema . $type;
  
      push @{ $self->{_rels} }, [ $type, $target ];
  }
  
  
  ###############################################################################
  #
  # _add_worksheet_relationship()
  #
  # Add worksheet relationship to sheet.rels xml files.
  #
  sub _add_worksheet_relationship {
  
      my $self        = shift;
      my $type        = shift;
      my $target      = shift;
      my $target_mode = shift;
  
      $type   = $document_schema . $type;
  
      push @{ $self->{_rels} }, [ $type, $target, $target_mode ];
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_relationships()
  #
  # Write the <Relationships> element.
  #
  sub _write_relationships {
  
      my $self = shift;
  
      my @attributes = ( 'xmlns' => $package_schema, );
  
      $self->xml_start_tag( 'Relationships', @attributes );
  
      for my $rel ( @{ $self->{_rels} } ) {
          $self->_write_relationship( @$rel );
      }
  
      $self->xml_end_tag( 'Relationships' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ##############################################################################
  #
  # _write_relationship()
  #
  # Write the <Relationship> element.
  #
  sub _write_relationship {
  
      my $self        = shift;
      my $type        = shift;
      my $target      = shift;
      my $target_mode = shift;
  
      my @attributes = (
          'Id'     => 'rId' . $self->{_id}++,
          'Type'   => $type,
          'Target' => $target,
      );
  
      push @attributes, ( 'TargetMode' => $target_mode ) if $target_mode;
  
      $self->xml_empty_tag( 'Relationship', @attributes );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Relationships - A class for writing the Excel XLSX Rels file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_RELATIONSHIPS

$fatpacked{"Excel/Writer/XLSX/Package/SharedStrings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_SHAREDSTRINGS';
  package Excel::Writer::XLSX::Package::SharedStrings;
  
  ###############################################################################
  #
  # SharedStrings - A class for writing the Excel XLSX sharedStrings file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Encode;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_strings}      = [];
      $self->{_string_count} = 0;
      $self->{_unique_count} = 0;
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
  
      # Write the sst table.
      $self->_write_sst( $self->{_string_count}, $self->{_unique_count} );
  
      # Write the sst strings.
      $self->_write_sst_strings();
  
      # Close the sst tag.
      $self->xml_end_tag( 'sst' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _set_string_count()
  #
  # Set the total sst string count.
  #
  sub _set_string_count {
  
      my $self = shift;
  
      $self->{_string_count} = shift;
  }
  
  
  ###############################################################################
  #
  # _set_unique_count()
  #
  # Set the total of unique sst strings.
  #
  sub _set_unique_count {
  
      my $self = shift;
  
      $self->{_unique_count} = shift;
  }
  
  
  ###############################################################################
  #
  # _add_strings()
  #
  # Add the array ref of strings to be written.
  #
  sub _add_strings {
  
      my $self = shift;
  
      $self->{_strings} = shift;
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_sst()
  #
  # Write the <sst> element.
  #
  sub _write_sst {
  
      my $self         = shift;
      my $count        = shift;
      my $unique_count = shift;
      my $schema       = 'http://schemas.openxmlformats.org';
      my $xmlns        = $schema . '/spreadsheetml/2006/main';
  
      my @attributes = (
          'xmlns'       => $xmlns,
          'count'       => $count,
          'uniqueCount' => $unique_count,
      );
  
      $self->xml_start_tag( 'sst', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_sst_strings()
  #
  # Write the sst string elements.
  #
  sub _write_sst_strings {
  
      my $self = shift;
  
      for my $string ( @{ $self->{_strings} } ) {
          $self->_write_si( $string );
      }
  }
  
  
  ##############################################################################
  #
  # _write_si()
  #
  # Write the <si> element.
  #
  sub _write_si {
  
      my $self       = shift;
      my $string     = shift;
      my @attributes = ();
  
      # Excel escapes control characters with _xHHHH_ and also escapes any
      # literal strings of that type by encoding the leading underscore. So
      # "\0" -> _x0000_ and "_x0000_" -> _x005F_x0000_.
      # The following substitutions deal with those cases.
  
      # Escape the escape.
      $string =~ s/(_x[0-9a-fA-F]{4}_)/_x005F$1/g;
  
      # Convert control character to the _xHHHH_ escape.
      $string =~ s/([\x00-\x08\x0B-\x1F])/sprintf "_x%04X_", ord($1)/eg;
  
  
      # Add attribute to preserve leading or trailing whitespace.
      if ( $string =~ /^\s/ || $string =~ /\s$/ ) {
          push @attributes, ( 'xml:space' => 'preserve' );
      }
  
  
      # Write any rich strings without further tags.
      if ( $string =~ m{^<r>} && $string =~ m{</r>$} ) {
  
          # Prevent utf8 strings from getting double encoded.
          $string = decode_utf8( $string );
  
          $self->xml_rich_si_element( $string );
      }
      else {
          $self->xml_si_element( $string, @attributes );
      }
  
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  SharedStrings - A class for writing the Excel XLSX sharedStrings.xml file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_SHAREDSTRINGS

$fatpacked{"Excel/Writer/XLSX/Package/Styles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_STYLES';
  package Excel::Writer::XLSX::Package::Styles;
  
  ###############################################################################
  #
  # Styles - A class for writing the Excel XLSX styles file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_xf_formats}       = undef;
      $self->{_palette}          = [];
      $self->{_font_count}       = 0;
      $self->{_num_format_count} = 0;
      $self->{_border_count}     = 0;
      $self->{_fill_count}       = 0;
      $self->{_custom_colors}    = [];
      $self->{_dxf_formats}      = [];
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
  
      # Add the style sheet.
      $self->_write_style_sheet();
  
      # Write the number formats.
      $self->_write_num_fmts();
  
      # Write the fonts.
      $self->_write_fonts();
  
      # Write the fills.
      $self->_write_fills();
  
      # Write the borders element.
      $self->_write_borders();
  
      # Write the cellStyleXfs element.
      $self->_write_cell_style_xfs();
  
      # Write the cellXfs element.
      $self->_write_cell_xfs();
  
      # Write the cellStyles element.
      $self->_write_cell_styles();
  
      # Write the dxfs element.
      $self->_write_dxfs();
  
      # Write the tableStyles element.
      $self->_write_table_styles();
  
      # Write the colors element.
      $self->_write_colors();
  
      # Close the style sheet tag.
      $self->xml_end_tag( 'styleSheet' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _set_style_properties()
  #
  # Pass in the Format objects and other properties used to set the styles.
  #
  sub _set_style_properties {
  
      my $self = shift;
  
      $self->{_xf_formats}       = shift;
      $self->{_palette}          = shift;
      $self->{_font_count}       = shift;
      $self->{_num_format_count} = shift;
      $self->{_border_count}     = shift;
      $self->{_fill_count}       = shift;
      $self->{_custom_colors}    = shift;
      $self->{_dxf_formats}      = shift;
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _get_palette_color()
  #
  # Convert from an Excel internal colour index to a XML style #RRGGBB index
  # based on the default or user defined values in the Workbook palette.
  #
  sub _get_palette_color {
  
      my $self    = shift;
      my $index   = shift;
      my $palette = $self->{_palette};
  
      # Handle colours in #XXXXXX RGB format.
      if ( $index =~ m/^#([0-9A-F]{6})$/i ) {
          return "FF" . uc( $1 );
      }
  
      # Adjust the colour index.
      $index -= 8;
  
      # Palette is passed in from the Workbook class.
      my @rgb = @{ $palette->[$index] };
  
      return sprintf "FF%02X%02X%02X", @rgb[0, 1, 2];
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_style_sheet()
  #
  # Write the <styleSheet> element.
  #
  sub _write_style_sheet {
  
      my $self  = shift;
      my $xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main';
  
      my @attributes = ( 'xmlns' => $xmlns );
  
      $self->xml_start_tag( 'styleSheet', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_num_fmts()
  #
  # Write the <numFmts> element.
  #
  sub _write_num_fmts {
  
      my $self  = shift;
      my $count = $self->{_num_format_count};
  
      return unless $count;
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'numFmts', @attributes );
  
      # Write the numFmts elements.
      for my $format ( @{ $self->{_xf_formats} } ) {
  
          # Ignore built-in number formats, i.e., < 164.
          next unless $format->{_num_format_index} >= 164;
          $self->_write_num_fmt( $format->{_num_format_index},
              $format->{_num_format} );
      }
  
      $self->xml_end_tag( 'numFmts' );
  }
  
  
  ##############################################################################
  #
  # _write_num_fmt()
  #
  # Write the <numFmt> element.
  #
  sub _write_num_fmt {
  
      my $self        = shift;
      my $num_fmt_id  = shift;
      my $format_code = shift;
  
      my %format_codes = (
          0  => 'General',
          1  => '0',
          2  => '0.00',
          3  => '#,##0',
          4  => '#,##0.00',
          5  => '($#,##0_);($#,##0)',
          6  => '($#,##0_);[Red]($#,##0)',
          7  => '($#,##0.00_);($#,##0.00)',
          8  => '($#,##0.00_);[Red]($#,##0.00)',
          9  => '0%',
          10 => '0.00%',
          11 => '0.00E+00',
          12 => '# ?/?',
          13 => '# ??/??',
          14 => 'm/d/yy',
          15 => 'd-mmm-yy',
          16 => 'd-mmm',
          17 => 'mmm-yy',
          18 => 'h:mm AM/PM',
          19 => 'h:mm:ss AM/PM',
          20 => 'h:mm',
          21 => 'h:mm:ss',
          22 => 'm/d/yy h:mm',
          37 => '(#,##0_);(#,##0)',
          38 => '(#,##0_);[Red](#,##0)',
          39 => '(#,##0.00_);(#,##0.00)',
          40 => '(#,##0.00_);[Red](#,##0.00)',
          41 => '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
          42 => '_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)',
          43 => '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
          44 => '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)',
          45 => 'mm:ss',
          46 => '[h]:mm:ss',
          47 => 'mm:ss.0',
          48 => '##0.0E+0',
          49 => '@',
      );
  
      # Set the format code for built-in number formats.
      if ( $num_fmt_id < 164 ) {
          if ( exists $format_codes{$num_fmt_id} ) {
              $format_code = $format_codes{$num_fmt_id};
          }
          else {
              $format_code = 'General';
          }
      }
  
      my @attributes = (
          'numFmtId'   => $num_fmt_id,
          'formatCode' => $format_code,
      );
  
      $self->xml_empty_tag( 'numFmt', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_fonts()
  #
  # Write the <fonts> element.
  #
  sub _write_fonts {
  
      my $self  = shift;
      my $count = $self->{_font_count};
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'fonts', @attributes );
  
      # Write the font elements for format objects that have them.
      for my $format ( @{ $self->{_xf_formats} } ) {
          $self->_write_font( $format ) if $format->{_has_font};
      }
  
      $self->xml_end_tag( 'fonts' );
  }
  
  
  ##############################################################################
  #
  # _write_font()
  #
  # Write the <font> element.
  #
  sub _write_font {
  
      my $self       = shift;
      my $format     = shift;
      my $dxf_format = shift;
  
      $self->xml_start_tag( 'font' );
  
      # The condense and extend elements are mainly used in dxf formats.
      $self->_write_condense() if $format->{_font_condense};
      $self->_write_extend()   if $format->{_font_extend};
  
      $self->xml_empty_tag( 'b' )       if $format->{_bold};
      $self->xml_empty_tag( 'i' )       if $format->{_italic};
      $self->xml_empty_tag( 'strike' )  if $format->{_font_strikeout};
      $self->xml_empty_tag( 'outline' ) if $format->{_font_outline};
      $self->xml_empty_tag( 'shadow' )  if $format->{_font_shadow};
  
      # Handle the underline variants.
      $self->_write_underline( $format->{_underline} ) if $format->{_underline};
  
      $self->_write_vert_align( 'superscript' ) if $format->{_font_script} == 1;
      $self->_write_vert_align( 'subscript' )   if $format->{_font_script} == 2;
  
      if ( !$dxf_format ) {
          $self->xml_empty_tag( 'sz', 'val', $format->{_size} );
      }
  
      my $theme = $format->{_theme};
  
  
      if ( $theme == -1 ) {
          # Ignore for excel2003_style.
      }
      elsif ( $theme ) {
          $self->_write_color( 'theme' => $theme );
      }
      elsif ( my $index = $format->{_color_indexed} ) {
          $self->_write_color( 'indexed' => $index );
      }
      elsif ( my $color = $format->{_color} ) {
          $color = $self->_get_palette_color( $color );
  
          $self->_write_color( 'rgb' => $color );
      }
      elsif ( !$dxf_format ) {
          $self->_write_color( 'theme' => 1 );
      }
  
      if ( !$dxf_format ) {
          $self->xml_empty_tag( 'name',   'val', $format->{_font} );
  
          if ($format->{_font_family}) {
              $self->xml_empty_tag( 'family', 'val', $format->{_font_family} );
          }
  
          if ($format->{_font_charset}) {
              $self->xml_empty_tag( 'charset', 'val', $format->{_font_charset} );
          }
  
          if ( $format->{_font} eq 'Calibri' && !$format->{_hyperlink} ) {
              $self->xml_empty_tag(
  
                  'scheme',
                  'val' => $format->{_font_scheme}
              );
          }
      }
  
      $self->xml_end_tag( 'font' );
  }
  
  
  ###############################################################################
  #
  # _write_underline()
  #
  # Write the underline font element.
  #
  sub _write_underline {
  
      my $self      = shift;
      my $underline = shift;
      my @attributes;
  
      # Handle the underline variants.
      if ( $underline == 2 ) {
          @attributes = ( val => 'double' );
      }
      elsif ( $underline == 33 ) {
          @attributes = ( val => 'singleAccounting' );
      }
      elsif ( $underline == 34 ) {
          @attributes = ( val => 'doubleAccounting' );
      }
      else {
          @attributes = ();    # Default to single underline.
      }
  
      $self->xml_empty_tag( 'u', @attributes );
  
  }
  
  
  ##############################################################################
  #
  # _write_vert_align()
  #
  # Write the <vertAlign> font sub-element.
  #
  sub _write_vert_align {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'vertAlign', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_color()
  #
  # Write the <color> element.
  #
  sub _write_color {
  
      my $self  = shift;
      my $name  = shift;
      my $value = shift;
  
      my @attributes = ( $name => $value );
  
      $self->xml_empty_tag( 'color', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_fills()
  #
  # Write the <fills> element.
  #
  sub _write_fills {
  
      my $self  = shift;
      my $count = $self->{_fill_count};
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'fills', @attributes );
  
      # Write the default fill element.
      $self->_write_default_fill( 'none' );
      $self->_write_default_fill( 'gray125' );
  
      # Write the fill elements for format objects that have them.
      for my $format ( @{ $self->{_xf_formats} } ) {
          $self->_write_fill( $format ) if $format->{_has_fill};
      }
  
      $self->xml_end_tag( 'fills' );
  }
  
  
  ##############################################################################
  #
  # _write_default_fill()
  #
  # Write the <fill> element for the default fills.
  #
  sub _write_default_fill {
  
      my $self         = shift;
      my $pattern_type = shift;
  
      $self->xml_start_tag( 'fill' );
  
      $self->xml_empty_tag( 'patternFill', 'patternType', $pattern_type );
  
      $self->xml_end_tag( 'fill' );
  }
  
  
  ##############################################################################
  #
  # _write_fill()
  #
  # Write the <fill> element.
  #
  sub _write_fill {
  
      my $self       = shift;
      my $format     = shift;
      my $dxf_format = shift;
      my $pattern    = $format->{_pattern};
      my $bg_color   = $format->{_bg_color};
      my $fg_color   = $format->{_fg_color};
  
      # Colors for dxf formats are handled differently from normal formats since
      # the normal format reverses the meaning of BG and FG for solid fills.
      if ( $dxf_format ) {
          $bg_color = $format->{_dxf_bg_color};
          $fg_color = $format->{_dxf_fg_color};
      }
  
  
      my @patterns = qw(
        none
        solid
        mediumGray
        darkGray
        lightGray
        darkHorizontal
        darkVertical
        darkDown
        darkUp
        darkGrid
        darkTrellis
        lightHorizontal
        lightVertical
        lightDown
        lightUp
        lightGrid
        lightTrellis
        gray125
        gray0625
  
      );
  
  
      $self->xml_start_tag( 'fill' );
  
      # The "none" pattern is handled differently for dxf formats.
      if ( $dxf_format && $format->{_pattern} <= 1 ) {
          $self->xml_start_tag( 'patternFill' );
      }
      else {
          $self->xml_start_tag(
              'patternFill',
              'patternType',
              $patterns[ $format->{_pattern} ]
  
          );
      }
  
      if ( $fg_color ) {
          $fg_color = $self->_get_palette_color( $fg_color );
          $self->xml_empty_tag( 'fgColor', 'rgb' => $fg_color );
      }
  
      if ( $bg_color ) {
          $bg_color = $self->_get_palette_color( $bg_color );
          $self->xml_empty_tag( 'bgColor', 'rgb' => $bg_color );
      }
      else {
          if ( !$dxf_format ) {
              $self->xml_empty_tag( 'bgColor', 'indexed' => 64 );
          }
      }
  
      $self->xml_end_tag( 'patternFill' );
      $self->xml_end_tag( 'fill' );
  }
  
  
  ##############################################################################
  #
  # _write_borders()
  #
  # Write the <borders> element.
  #
  sub _write_borders {
  
      my $self  = shift;
      my $count = $self->{_border_count};
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'borders', @attributes );
  
      # Write the border elements for format objects that have them.
      for my $format ( @{ $self->{_xf_formats} } ) {
          $self->_write_border( $format ) if $format->{_has_border};
      }
  
      $self->xml_end_tag( 'borders' );
  }
  
  
  ##############################################################################
  #
  # _write_border()
  #
  # Write the <border> element.
  #
  sub _write_border {
  
      my $self       = shift;
      my $format     = shift;
      my $dxf_format = shift;
      my @attributes = ();
  
  
      # Diagonal borders add attributes to the <border> element.
      if ( $format->{_diag_type} == 1 ) {
          push @attributes, ( diagonalUp => 1 );
      }
      elsif ( $format->{_diag_type} == 2 ) {
          push @attributes, ( diagonalDown => 1 );
      }
      elsif ( $format->{_diag_type} == 3 ) {
          push @attributes, ( diagonalUp   => 1 );
          push @attributes, ( diagonalDown => 1 );
      }
  
      # Ensure that a default diag border is set if the diag type is set.
      if ( $format->{_diag_type} && !$format->{_diag_border} ) {
          $format->{_diag_border} = 1;
      }
  
      # Write the start border tag.
      $self->xml_start_tag( 'border', @attributes );
  
      # Write the <border> sub elements.
      $self->_write_sub_border(
          'left',
          $format->{_left},
          $format->{_left_color}
  
      );
  
      $self->_write_sub_border(
          'right',
          $format->{_right},
          $format->{_right_color}
  
      );
  
      $self->_write_sub_border(
          'top',
          $format->{_top},
          $format->{_top_color}
  
      );
  
      $self->_write_sub_border(
          'bottom',
          $format->{_bottom},
          $format->{_bottom_color}
  
      );
  
      # Condition DXF formats don't allow diagonal borders
      if ( !$dxf_format ) {
          $self->_write_sub_border(
              'diagonal',
              $format->{_diag_border},
              $format->{_diag_color}
  
          );
      }
  
      if ( $dxf_format ) {
          $self->_write_sub_border( 'vertical' );
          $self->_write_sub_border( 'horizontal' );
      }
  
      $self->xml_end_tag( 'border' );
  }
  
  
  ##############################################################################
  #
  # _write_sub_border()
  #
  # Write the <border> sub elements such as <right>, <top>, etc.
  #
  sub _write_sub_border {
  
      my $self  = shift;
      my $type  = shift;
      my $style = shift;
      my $color = shift;
      my @attributes;
  
      if ( !$style ) {
          $self->xml_empty_tag( $type );
          return;
      }
  
      my @border_styles = qw(
        none
        thin
        medium
        dashed
        dotted
        thick
        double
        hair
        mediumDashed
        dashDot
        mediumDashDot
        dashDotDot
        mediumDashDotDot
        slantDashDot
  
      );
  
  
      push @attributes, ( style => $border_styles[$style] );
  
      $self->xml_start_tag( $type, @attributes );
  
      if ( $color ) {
          $color = $self->_get_palette_color( $color );
          $self->xml_empty_tag( 'color', 'rgb' => $color );
      }
      else {
          $self->xml_empty_tag( 'color', 'auto' => 1 );
      }
  
      $self->xml_end_tag( $type );
  }
  
  
  ##############################################################################
  #
  # _write_cell_style_xfs()
  #
  # Write the <cellStyleXfs> element.
  #
  sub _write_cell_style_xfs {
  
      my $self  = shift;
      my $count = 1;
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'cellStyleXfs', @attributes );
  
      # Write the style_xf element.
      $self->_write_style_xf();
  
      $self->xml_end_tag( 'cellStyleXfs' );
  }
  
  
  ##############################################################################
  #
  # _write_cell_xfs()
  #
  # Write the <cellXfs> element.
  #
  sub _write_cell_xfs {
  
      my $self    = shift;
      my @formats = @{ $self->{_xf_formats} };
  
      # Workaround for when the last format is used for the comment font
      # and shouldn't be used for cellXfs.
      my $last_format = $formats[-1];
  
      if ( $last_format->{_font_only} ) {
          pop @formats;
      }
  
      my $count = scalar @formats;
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'cellXfs', @attributes );
  
      # Write the xf elements.
      for my $format ( @formats ) {
          $self->_write_xf( $format );
      }
  
      $self->xml_end_tag( 'cellXfs' );
  }
  
  
  ##############################################################################
  #
  # _write_style_xf()
  #
  # Write the style <xf> element.
  #
  sub _write_style_xf {
  
      my $self       = shift;
      my $num_fmt_id = 0;
      my $font_id    = 0;
      my $fill_id    = 0;
      my $border_id  = 0;
  
      my @attributes = (
          'numFmtId' => $num_fmt_id,
          'fontId'   => $font_id,
          'fillId'   => $fill_id,
          'borderId' => $border_id,
      );
  
      $self->xml_empty_tag( 'xf', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_xf()
  #
  # Write the <xf> element.
  #
  sub _write_xf {
  
      my $self        = shift;
      my $format      = shift;
      my $num_fmt_id  = $format->{_num_format_index};
      my $font_id     = $format->{_font_index};
      my $fill_id     = $format->{_fill_index};
      my $border_id   = $format->{_border_index};
      my $xf_id       = 0;
      my $has_align   = 0;
      my $has_protect = 0;
  
      my @attributes = (
          'numFmtId' => $num_fmt_id,
          'fontId'   => $font_id,
          'fillId'   => $fill_id,
          'borderId' => $border_id,
          'xfId'     => $xf_id,
      );
  
  
      if ( $format->{_num_format_index} > 0 ) {
          push @attributes, ( 'applyNumberFormat' => 1 );
      }
  
      # Add applyFont attribute if XF format uses a font element.
      if ( $format->{_font_index} > 0 ) {
          push @attributes, ( 'applyFont' => 1 );
      }
  
      # Add applyFill attribute if XF format uses a fill element.
      if ( $format->{_fill_index} > 0 ) {
          push @attributes, ( 'applyFill' => 1 );
      }
  
      # Add applyBorder attribute if XF format uses a border element.
      if ( $format->{_border_index} > 0 ) {
          push @attributes, ( 'applyBorder' => 1 );
      }
  
      # Check if XF format has alignment properties set.
      my ( $apply_align, @align ) = $format->get_align_properties();
  
      # Check if an alignment sub-element should be written.
      $has_align = 1 if $apply_align && @align;
  
      # We can also have applyAlignment without a sub-element.
      if ( $apply_align ) {
          push @attributes, ( 'applyAlignment' => 1 );
      }
  
      # Check for cell protection properties.
      my @protection = $format->get_protection_properties();
  
      if ( @protection ) {
          push @attributes, ( 'applyProtection' => 1 );
          $has_protect = 1;
      }
  
      # Write XF with sub-elements if required.
      if ( $has_align || $has_protect ) {
          $self->xml_start_tag( 'xf', @attributes );
          $self->xml_empty_tag( 'alignment',  @align )      if $has_align;
          $self->xml_empty_tag( 'protection', @protection ) if $has_protect;
          $self->xml_end_tag( 'xf' );
      }
      else {
          $self->xml_empty_tag( 'xf', @attributes );
      }
  }
  
  
  ##############################################################################
  #
  # _write_cell_styles()
  #
  # Write the <cellStyles> element.
  #
  sub _write_cell_styles {
  
      my $self  = shift;
      my $count = 1;
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'cellStyles', @attributes );
  
      # Write the cellStyle element.
      $self->_write_cell_style();
  
      $self->xml_end_tag( 'cellStyles' );
  }
  
  
  ##############################################################################
  #
  # _write_cell_style()
  #
  # Write the <cellStyle> element.
  #
  sub _write_cell_style {
  
      my $self       = shift;
      my $name       = 'Normal';
      my $xf_id      = 0;
      my $builtin_id = 0;
  
      my @attributes = (
          'name'      => $name,
          'xfId'      => $xf_id,
          'builtinId' => $builtin_id,
      );
  
      $self->xml_empty_tag( 'cellStyle', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_dxfs()
  #
  # Write the <dxfs> element.
  #
  sub _write_dxfs {
  
      my $self    = shift;
      my $formats = $self->{_dxf_formats};
  
      my $count = scalar @{$formats};
  
      my @attributes = ( 'count' => $count );
  
      if ( $count ) {
          $self->xml_start_tag( 'dxfs', @attributes );
  
          # Write the font elements for format objects that have them.
          for my $format ( @{ $self->{_dxf_formats} } ) {
              $self->xml_start_tag( 'dxf' );
              $self->_write_font( $format, 1 ) if $format->{_has_dxf_font};
  
              if ( $format->{_num_format_index} ) {
                  $self->_write_num_fmt( $format->{_num_format_index},
                      $format->{_num_format} );
              }
  
              $self->_write_fill( $format, 1 ) if $format->{_has_dxf_fill};
              $self->_write_border( $format, 1 ) if $format->{_has_dxf_border};
              $self->xml_end_tag( 'dxf' );
          }
  
          $self->xml_end_tag( 'dxfs' );
      }
      else {
          $self->xml_empty_tag( 'dxfs', @attributes );
      }
  
  }
  
  
  ##############################################################################
  #
  # _write_table_styles()
  #
  # Write the <tableStyles> element.
  #
  sub _write_table_styles {
  
      my $self                = shift;
      my $count               = 0;
      my $default_table_style = 'TableStyleMedium9';
      my $default_pivot_style = 'PivotStyleLight16';
  
      my @attributes = (
          'count'             => $count,
          'defaultTableStyle' => $default_table_style,
          'defaultPivotStyle' => $default_pivot_style,
      );
  
      $self->xml_empty_tag( 'tableStyles', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_colors()
  #
  # Write the <colors> element.
  #
  sub _write_colors {
  
      my $self          = shift;
      my @custom_colors = @{ $self->{_custom_colors} };
  
      return unless @custom_colors;
  
      $self->xml_start_tag( 'colors' );
      $self->_write_mru_colors( @custom_colors );
      $self->xml_end_tag( 'colors' );
  }
  
  
  ##############################################################################
  #
  # _write_mru_colors()
  #
  # Write the <mruColors> element for the most recently used colours.
  #
  sub _write_mru_colors {
  
      my $self          = shift;
      my @custom_colors = @_;
  
      # Limit the mruColors to the last 10.
      my $count = @custom_colors;
      if ( $count > 10 ) {
          splice @custom_colors, 0, ( $count - 10 );
      }
  
      $self->xml_start_tag( 'mruColors' );
  
      # Write the custom colors in reverse order.
      for my $color ( reverse @custom_colors ) {
          $self->_write_color( 'rgb' => $color );
      }
  
      $self->xml_end_tag( 'mruColors' );
  }
  
  
  ##############################################################################
  #
  # _write_condense()
  #
  # Write the <condense> element.
  #
  sub _write_condense {
  
      my $self = shift;
      my $val  = 0;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'condense', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_extend()
  #
  # Write the <extend> element.
  #
  sub _write_extend {
  
      my $self = shift;
      my $val  = 0;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'extend', @attributes );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Styles - A class for writing the Excel XLSX styles file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_STYLES

$fatpacked{"Excel/Writer/XLSX/Package/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_TABLE';
  package Excel::Writer::XLSX::Package::Table;
  
  ###############################################################################
  #
  # Table - A class for writing the Excel XLSX Table file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      $self->{_properties} = {};
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration;
  
      # Write the table element.
      $self->_write_table();
  
      # Write the autoFilter element.
      $self->_write_auto_filter();
  
      # Write the tableColumns element.
      $self->_write_table_columns();
  
      # Write the tableStyleInfo element.
      $self->_write_table_style_info();
  
  
      # Close the table tag.
      $self->xml_end_tag( 'table' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _set_properties()
  #
  # Set the document properties.
  #
  sub _set_properties {
  
      my $self       = shift;
      my $properties = shift;
  
      $self->{_properties} = $properties;
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ##############################################################################
  #
  # _write_table()
  #
  # Write the <table> element.
  #
  sub _write_table {
  
      my $self             = shift;
      my $schema           = 'http://schemas.openxmlformats.org/';
      my $xmlns            = $schema . 'spreadsheetml/2006/main';
      my $id               = $self->{_properties}->{_id};
      my $name             = $self->{_properties}->{_name};
      my $display_name     = $self->{_properties}->{_name};
      my $ref              = $self->{_properties}->{_range};
      my $totals_row_shown = $self->{_properties}->{_totals_row_shown};
      my $header_row_count = $self->{_properties}->{_header_row_count};
  
      my @attributes = (
          'xmlns'       => $xmlns,
          'id'          => $id,
          'name'        => $name,
          'displayName' => $display_name,
          'ref'         => $ref,
      );
  
      push @attributes, ( 'headerRowCount' => 0 ) if !$header_row_count;
  
      if ( $totals_row_shown ) {
          push @attributes, ( 'totalsRowCount' => 1 );
      }
      else {
          push @attributes, ( 'totalsRowShown' => 0 );
      }
  
  
      $self->xml_start_tag( 'table', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_auto_filter()
  #
  # Write the <autoFilter> element.
  #
  sub _write_auto_filter {
  
      my $self       = shift;
      my $autofilter = $self->{_properties}->{_autofilter};
  
      return unless $autofilter;
  
      my @attributes = ( 'ref' => $autofilter, );
  
      $self->xml_empty_tag( 'autoFilter', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_table_columns()
  #
  # Write the <tableColumns> element.
  #
  sub _write_table_columns {
  
      my $self    = shift;
      my @columns = @{ $self->{_properties}->{_columns} };
  
      my $count = scalar @columns;
  
      my @attributes = ( 'count' => $count, );
  
      $self->xml_start_tag( 'tableColumns', @attributes );
  
      for my $col_data ( @columns ) {
  
          # Write the tableColumn element.
          $self->_write_table_column( $col_data );
      }
  
      $self->xml_end_tag( 'tableColumns' );
  }
  
  
  ##############################################################################
  #
  # _write_table_column()
  #
  # Write the <tableColumn> element.
  #
  sub _write_table_column {
  
      my $self     = shift;
      my $col_data = shift;
  
      my @attributes = (
          'id'   => $col_data->{_id},
          'name' => $col_data->{_name},
      );
  
  
      if ( $col_data->{_total_string} ) {
          push @attributes, ( totalsRowLabel => $col_data->{_total_string} );
      }
      elsif ( $col_data->{_total_function} ) {
          push @attributes, ( totalsRowFunction => $col_data->{_total_function} );
      }
  
  
      if ( defined $col_data->{_format} ) {
          push @attributes, ( dataDxfId => $col_data->{_format} );
      }
  
      if ( $col_data->{_formula} ) {
          $self->xml_start_tag( 'tableColumn', @attributes );
  
          # Write the calculatedColumnFormula element.
          $self->_write_calculated_column_formula( $col_data->{_formula} );
  
          $self->xml_end_tag( 'tableColumn' );
      }
      else {
          $self->xml_empty_tag( 'tableColumn', @attributes );
      }
  
  }
  
  
  ##############################################################################
  #
  # _write_table_style_info()
  #
  # Write the <tableStyleInfo> element.
  #
  sub _write_table_style_info {
  
      my $self  = shift;
      my $props = $self->{_properties};
  
      my $name                = $props->{_style};
      my $show_first_column   = $props->{_show_first_col};
      my $show_last_column    = $props->{_show_last_col};
      my $show_row_stripes    = $props->{_show_row_stripes};
      my $show_column_stripes = $props->{_show_col_stripes};
  
      my @attributes = (
          'name'              => $name,
          'showFirstColumn'   => $show_first_column,
          'showLastColumn'    => $show_last_column,
          'showRowStripes'    => $show_row_stripes,
          'showColumnStripes' => $show_column_stripes,
      );
  
      $self->xml_empty_tag( 'tableStyleInfo', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_calculated_column_formula()
  #
  # Write the <calculatedColumnFormula> element.
  #
  sub _write_calculated_column_formula {
  
      my $self    = shift;
      my $formula = shift;
  
      $self->xml_data_element( 'calculatedColumnFormula', $formula );
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Table - A class for writing the Excel XLSX Table file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_TABLE

$fatpacked{"Excel/Writer/XLSX/Package/Theme.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_THEME';
  package Excel::Writer::XLSX::Package::Theme;
  
  ###############################################################################
  #
  # Theme - A class for writing the Excel XLSX Theme file.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  
  ###############################################################################
  #
  # NOTE: This class doesn't try to create the Excel theme1.xml programmatically.
  #       Instead it just writes a stored default theme. This is mainly to
  #       facilitate easier comparisons during testing. The theme1.xml file
  #       isn't actually required.
  
  use 5.008002;
  use strict;
  use warnings;
  use Exporter;
  use Carp;
  use IO::File;
  use utf8;
  
  our @ISA     = qw(Exporter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
  
      my $self = {};
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->_write_theme_file();
  }
  
  
  ###############################################################################
  #
  # _set_xml_writer()
  #
  # Set the filehandle only. This class doesn't use a real XML writer class.
  #
  sub _set_xml_writer {
  
      my $self     = shift;
      my $filename = shift;
  
      my $fh = IO::File->new( $filename, 'w' );
      croak "Couldn't open file $filename for writing.\n" unless $fh;
  
      binmode $fh, ':utf8';
  
      $self->{_fh} = $fh;
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  # Sparklines styles. Used by the Worksheet class.
  our @spark_styles = (
      {   # 0
          series   => { _theme => "4", _tint => "-0.499984740745262" },
          negative => { _theme => "5" },
          markers  => { _theme => "4", _tint => "-0.499984740745262" },
          first    => { _theme => "4", _tint => "0.39997558519241921" },
          last     => { _theme => "4", _tint => "0.39997558519241921" },
          high     => { _theme => "4" },
          low      => { _theme => "4" },
      },
      {   # 1
          series   => { _theme => "4", _tint => "-0.499984740745262" },
          negative => { _theme => "5" },
          markers  => { _theme => "4", _tint => "-0.499984740745262" },
          first    => { _theme => "4", _tint => "0.39997558519241921" },
          last     => { _theme => "4", _tint => "0.39997558519241921" },
          high     => { _theme => "4" },
          low      => { _theme => "4" },
      },
      {   # 2
          series   => { _theme => "5", _tint => "-0.499984740745262" },
          negative => { _theme => "6" },
          markers  => { _theme => "5", _tint => "-0.499984740745262" },
          first    => { _theme => "5", _tint => "0.39997558519241921" },
          last     => { _theme => "5", _tint => "0.39997558519241921" },
          high     => { _theme => "5" },
          low      => { _theme => "5" },
      },
      {   # 3
          series   => { _theme => "6", _tint => "-0.499984740745262" },
          negative => { _theme => "7" },
          markers  => { _theme => "6", _tint => "-0.499984740745262" },
          first    => { _theme => "6", _tint => "0.39997558519241921" },
          last     => { _theme => "6", _tint => "0.39997558519241921" },
          high     => { _theme => "6" },
          low      => { _theme => "6" },
      },
      {   # 4
          series   => { _theme => "7", _tint => "-0.499984740745262" },
          negative => { _theme => "8" },
          markers  => { _theme => "7", _tint => "-0.499984740745262" },
          first    => { _theme => "7", _tint => "0.39997558519241921" },
          last     => { _theme => "7", _tint => "0.39997558519241921" },
          high     => { _theme => "7" },
          low      => { _theme => "7" },
      },
      {   # 5
          series   => { _theme => "8", _tint => "-0.499984740745262" },
          negative => { _theme => "9" },
          markers  => { _theme => "8", _tint => "-0.499984740745262" },
          first    => { _theme => "8", _tint => "0.39997558519241921" },
          last     => { _theme => "8", _tint => "0.39997558519241921" },
          high     => { _theme => "8" },
          low      => { _theme => "8" },
      },
      {   # 6
          series   => { _theme => "9", _tint => "-0.499984740745262" },
          negative => { _theme => "4" },
          markers  => { _theme => "9", _tint => "-0.499984740745262" },
          first    => { _theme => "9", _tint => "0.39997558519241921" },
          last     => { _theme => "9", _tint => "0.39997558519241921" },
          high     => { _theme => "9" },
          low      => { _theme => "9" },
      },
      {   # 7
          series   => { _theme => "4", _tint => "-0.249977111117893" },
          negative => { _theme => "5" },
          markers  => { _theme => "5", _tint => "-0.249977111117893" },
          first    => { _theme => "5", _tint => "-0.249977111117893" },
          last     => { _theme => "5", _tint => "-0.249977111117893" },
          high     => { _theme => "5", _tint => "-0.249977111117893" },
          low      => { _theme => "5", _tint => "-0.249977111117893" },
      },
      {   # 8
          series   => { _theme => "5", _tint => "-0.249977111117893" },
          negative => { _theme => "6" },
          markers  => { _theme => "6", _tint => "-0.249977111117893" },
          first    => { _theme => "6", _tint => "-0.249977111117893" },
          last     => { _theme => "6", _tint => "-0.249977111117893" },
          high     => { _theme => "6", _tint => "-0.249977111117893" },
          low      => { _theme => "6", _tint => "-0.249977111117893" },
      },
      {   # 9
          series   => { _theme => "6", _tint => "-0.249977111117893" },
          negative => { _theme => "7" },
          markers  => { _theme => "7", _tint => "-0.249977111117893" },
          first    => { _theme => "7", _tint => "-0.249977111117893" },
          last     => { _theme => "7", _tint => "-0.249977111117893" },
          high     => { _theme => "7", _tint => "-0.249977111117893" },
          low      => { _theme => "7", _tint => "-0.249977111117893" },
      },
      {   # 10
          series   => { _theme => "7", _tint => "-0.249977111117893" },
          negative => { _theme => "8" },
          markers  => { _theme => "8", _tint => "-0.249977111117893" },
          first    => { _theme => "8", _tint => "-0.249977111117893" },
          last     => { _theme => "8", _tint => "-0.249977111117893" },
          high     => { _theme => "8", _tint => "-0.249977111117893" },
          low      => { _theme => "8", _tint => "-0.249977111117893" },
      },
      {   # 11
          series   => { _theme => "8", _tint => "-0.249977111117893" },
          negative => { _theme => "9" },
          markers  => { _theme => "9", _tint => "-0.249977111117893" },
          first    => { _theme => "9", _tint => "-0.249977111117893" },
          last     => { _theme => "9", _tint => "-0.249977111117893" },
          high     => { _theme => "9", _tint => "-0.249977111117893" },
          low      => { _theme => "9", _tint => "-0.249977111117893" },
      },
      {   # 12
          series   => { _theme => "9", _tint => "-0.249977111117893" },
          negative => { _theme => "4" },
          markers  => { _theme => "4", _tint => "-0.249977111117893" },
          first    => { _theme => "4", _tint => "-0.249977111117893" },
          last     => { _theme => "4", _tint => "-0.249977111117893" },
          high     => { _theme => "4", _tint => "-0.249977111117893" },
          low      => { _theme => "4", _tint => "-0.249977111117893" },
      },
      {   # 13
          series   => { _theme => "4" },
          negative => { _theme => "5" },
          markers  => { _theme => "4", _tint => "-0.249977111117893" },
          first    => { _theme => "4", _tint => "-0.249977111117893" },
          last     => { _theme => "4", _tint => "-0.249977111117893" },
          high     => { _theme => "4", _tint => "-0.249977111117893" },
          low      => { _theme => "4", _tint => "-0.249977111117893" },
      },
      {   # 14
          series   => { _theme => "5" },
          negative => { _theme => "6" },
          markers  => { _theme => "5", _tint => "-0.249977111117893" },
          first    => { _theme => "5", _tint => "-0.249977111117893" },
          last     => { _theme => "5", _tint => "-0.249977111117893" },
          high     => { _theme => "5", _tint => "-0.249977111117893" },
          low      => { _theme => "5", _tint => "-0.249977111117893" },
      },
      {   # 15
          series   => { _theme => "6" },
          negative => { _theme => "7" },
          markers  => { _theme => "6", _tint => "-0.249977111117893" },
          first    => { _theme => "6", _tint => "-0.249977111117893" },
          last     => { _theme => "6", _tint => "-0.249977111117893" },
          high     => { _theme => "6", _tint => "-0.249977111117893" },
          low      => { _theme => "6", _tint => "-0.249977111117893" },
      },
      {   # 16
          series   => { _theme => "7" },
          negative => { _theme => "8" },
          markers  => { _theme => "7", _tint => "-0.249977111117893" },
          first    => { _theme => "7", _tint => "-0.249977111117893" },
          last     => { _theme => "7", _tint => "-0.249977111117893" },
          high     => { _theme => "7", _tint => "-0.249977111117893" },
          low      => { _theme => "7", _tint => "-0.249977111117893" },
      },
      {   # 17
          series   => { _theme => "8" },
          negative => { _theme => "9" },
          markers  => { _theme => "8", _tint => "-0.249977111117893" },
          first    => { _theme => "8", _tint => "-0.249977111117893" },
          last     => { _theme => "8", _tint => "-0.249977111117893" },
          high     => { _theme => "8", _tint => "-0.249977111117893" },
          low      => { _theme => "8", _tint => "-0.249977111117893" },
      },
      {   # 18
          series   => { _theme => "9" },
          negative => { _theme => "4" },
          markers  => { _theme => "9", _tint => "-0.249977111117893" },
          first    => { _theme => "9", _tint => "-0.249977111117893" },
          last     => { _theme => "9", _tint => "-0.249977111117893" },
          high     => { _theme => "9", _tint => "-0.249977111117893" },
          low      => { _theme => "9", _tint => "-0.249977111117893" },
      },
      {   # 19
          series   => { _theme => "4", _tint => "0.39997558519241921" },
          negative => { _theme => "0", _tint => "-0.499984740745262" },
          markers  => { _theme => "4", _tint => "0.79998168889431442" },
          first    => { _theme => "4", _tint => "-0.249977111117893" },
          last     => { _theme => "4", _tint => "-0.249977111117893" },
          high     => { _theme => "4", _tint => "-0.499984740745262" },
          low      => { _theme => "4", _tint => "-0.499984740745262" },
      },
      {   # 20
          series   => { _theme => "5", _tint => "0.39997558519241921" },
          negative => { _theme => "0", _tint => "-0.499984740745262" },
          markers  => { _theme => "5", _tint => "0.79998168889431442" },
          first    => { _theme => "5", _tint => "-0.249977111117893" },
          last     => { _theme => "5", _tint => "-0.249977111117893" },
          high     => { _theme => "5", _tint => "-0.499984740745262" },
          low      => { _theme => "5", _tint => "-0.499984740745262" },
      },
      {   # 21
          series   => { _theme => "6", _tint => "0.39997558519241921" },
          negative => { _theme => "0", _tint => "-0.499984740745262" },
          markers  => { _theme => "6", _tint => "0.79998168889431442" },
          first    => { _theme => "6", _tint => "-0.249977111117893" },
          last     => { _theme => "6", _tint => "-0.249977111117893" },
          high     => { _theme => "6", _tint => "-0.499984740745262" },
          low      => { _theme => "6", _tint => "-0.499984740745262" },
      },
      {   # 22
          series   => { _theme => "7", _tint => "0.39997558519241921" },
          negative => { _theme => "0", _tint => "-0.499984740745262" },
          markers  => { _theme => "7", _tint => "0.79998168889431442" },
          first    => { _theme => "7", _tint => "-0.249977111117893" },
          last     => { _theme => "7", _tint => "-0.249977111117893" },
          high     => { _theme => "7", _tint => "-0.499984740745262" },
          low      => { _theme => "7", _tint => "-0.499984740745262" },
      },
      {   # 23
          series   => { _theme => "8", _tint => "0.39997558519241921" },
          negative => { _theme => "0", _tint => "-0.499984740745262" },
          markers  => { _theme => "8", _tint => "0.79998168889431442" },
          first    => { _theme => "8", _tint => "-0.249977111117893" },
          last     => { _theme => "8", _tint => "-0.249977111117893" },
          high     => { _theme => "8", _tint => "-0.499984740745262" },
          low      => { _theme => "8", _tint => "-0.499984740745262" },
      },
      {   # 24
          series   => { _theme => "9", _tint => "0.39997558519241921" },
          negative => { _theme => "0", _tint => "-0.499984740745262" },
          markers  => { _theme => "9", _tint => "0.79998168889431442" },
          first    => { _theme => "9", _tint => "-0.249977111117893" },
          last     => { _theme => "9", _tint => "-0.249977111117893" },
          high     => { _theme => "9", _tint => "-0.499984740745262" },
          low      => { _theme => "9", _tint => "-0.499984740745262" },
      },
      {   # 25
          series   => { _theme => "1", _tint => "0.499984740745262" },
          negative => { _theme => "1", _tint => "0.249977111117893" },
          markers  => { _theme => "1", _tint => "0.249977111117893" },
          first    => { _theme => "1", _tint => "0.249977111117893" },
          last     => { _theme => "1", _tint => "0.249977111117893" },
          high     => { _theme => "1", _tint => "0.249977111117893" },
          low      => { _theme => "1", _tint => "0.249977111117893" },
      },
      {   # 26
          series   => { _theme => "1", _tint => "0.34998626667073579" },
          negative => { _theme => "0", _tint => "-0.249977111117893" },
          markers  => { _theme => "0", _tint => "-0.249977111117893" },
          first    => { _theme => "0", _tint => "-0.249977111117893" },
          last     => { _theme => "0", _tint => "-0.249977111117893" },
          high     => { _theme => "0", _tint => "-0.249977111117893" },
          low      => { _theme => "0", _tint => "-0.249977111117893" },
      },
      {   # 27
          series   => { _rgb => "FF323232" },
          negative => { _rgb => "FFD00000" },
          markers  => { _rgb => "FFD00000" },
          first    => { _rgb => "FFD00000" },
          last     => { _rgb => "FFD00000" },
          high     => { _rgb => "FFD00000" },
          low      => { _rgb => "FFD00000" },
      },
      {   # 28
          series   => { _rgb => "FF000000" },
          negative => { _rgb => "FF0070C0" },
          markers  => { _rgb => "FF0070C0" },
          first    => { _rgb => "FF0070C0" },
          last     => { _rgb => "FF0070C0" },
          high     => { _rgb => "FF0070C0" },
          low      => { _rgb => "FF0070C0" },
      },
      {   # 29
          series   => { _rgb => "FF376092" },
          negative => { _rgb => "FFD00000" },
          markers  => { _rgb => "FFD00000" },
          first    => { _rgb => "FFD00000" },
          last     => { _rgb => "FFD00000" },
          high     => { _rgb => "FFD00000" },
          low      => { _rgb => "FFD00000" },
      },
      {   # 30
          series   => { _rgb => "FF0070C0" },
          negative => { _rgb => "FF000000" },
          markers  => { _rgb => "FF000000" },
          first    => { _rgb => "FF000000" },
          last     => { _rgb => "FF000000" },
          high     => { _rgb => "FF000000" },
          low      => { _rgb => "FF000000" },
      },
      {   # 31
          series   => { _rgb => "FF5F5F5F" },
          negative => { _rgb => "FFFFB620" },
          markers  => { _rgb => "FFD70077" },
          first    => { _rgb => "FF5687C2" },
          last     => { _rgb => "FF359CEB" },
          high     => { _rgb => "FF56BE79" },
          low      => { _rgb => "FFFF5055" },
      },
      {   # 32
          series   => { _rgb => "FF5687C2" },
          negative => { _rgb => "FFFFB620" },
          markers  => { _rgb => "FFD70077" },
          first    => { _rgb => "FF777777" },
          last     => { _rgb => "FF359CEB" },
          high     => { _rgb => "FF56BE79" },
          low      => { _rgb => "FFFF5055" },
      },
      {   # 33
          series   => { _rgb => "FFC6EFCE" },
          negative => { _rgb => "FFFFC7CE" },
          markers  => { _rgb => "FF8CADD6" },
          first    => { _rgb => "FFFFDC47" },
          last     => { _rgb => "FFFFEB9C" },
          high     => { _rgb => "FF60D276" },
          low      => { _rgb => "FFFF5367" },
      },
      {   # 34
          series   => { _rgb => "FF00B050" },
          negative => { _rgb => "FFFF0000" },
          markers  => { _rgb => "FF0070C0" },
          first    => { _rgb => "FFFFC000" },
          last     => { _rgb => "FFFFC000" },
          high     => { _rgb => "FF00B050" },
          low      => { _rgb => "FFFF0000" },
      },
      {   # 35
          series   => { _theme => "3" },
          negative => { _theme => "9" },
          markers  => { _theme => "8" },
          first    => { _theme => "4" },
          last     => { _theme => "5" },
          high     => { _theme => "6" },
          low      => { _theme => "7" },
      },
      {   # 36
          series   => { _theme => "1" },
          negative => { _theme => "9" },
          markers  => { _theme => "8" },
          first    => { _theme => "4" },
          last     => { _theme => "5" },
          high     => { _theme => "6" },
          low      => { _theme => "7" },
      },
  );
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_theme_file()
  #
  # Write a default theme.xml file.
  #
  sub _write_theme_file {
  
      my $self   = shift;
      my $theme  = << 'XML_DATA';
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="1F497D"/></a:dk2><a:lt2><a:srgbClr val="EEECE1"/></a:lt2><a:accent1><a:srgbClr val="4F81BD"/></a:accent1><a:accent2><a:srgbClr val="C0504D"/></a:accent2><a:accent3><a:srgbClr val="9BBB59"/></a:accent3><a:accent4><a:srgbClr val="8064A2"/></a:accent4><a:accent5><a:srgbClr val="4BACC6"/></a:accent5><a:accent6><a:srgbClr val="F79646"/></a:accent6><a:hlink><a:srgbClr val="0000FF"/></a:hlink><a:folHlink><a:srgbClr val="800080"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Cambria"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" "/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:majorFont><a:minorFont><a:latin typeface="Calibri"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" "/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000"/><a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/></a:theme>
  XML_DATA
  
      local $\ = undef; # Protect print from -l on commandline.
      print { $self->{_fh} } $theme;
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Theme - A class for writing the Excel XLSX Theme file.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_THEME

$fatpacked{"Excel/Writer/XLSX/Package/VML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_VML';
  package Excel::Writer::XLSX::Package::VML;
  
  ###############################################################################
  #
  # VML - A class for writing the Excel XLSX VML files.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Excel::Writer::XLSX::Package::XMLwriter;
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $fh    = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self               = shift;
      my $data_id            = shift;
      my $vml_shape_id       = shift;
      my $comments_data      = shift;
      my $buttons_data       = shift;
      my $header_images_data = shift;
      my $z_index            = 1;
  
  
      $self->_write_xml_namespace;
  
      # Write the o:shapelayout element.
      $self->_write_shapelayout( $data_id );
  
      if ( defined $buttons_data && @$buttons_data ) {
  
          # Write the v:shapetype element.
          $self->_write_button_shapetype();
  
          for my $button ( @$buttons_data ) {
  
              # Write the v:shape element.
              $self->_write_button_shape( ++$vml_shape_id, $z_index++, $button );
          }
      }
  
      if ( defined $comments_data && @$comments_data ) {
  
          # Write the v:shapetype element.
          $self->_write_comment_shapetype();
  
          for my $comment ( @$comments_data ) {
  
              # Write the v:shape element.
              $self->_write_comment_shape( ++$vml_shape_id, $z_index++,
                  $comment );
          }
      }
  
      if ( defined $header_images_data && @$header_images_data ) {
  
          # Write the v:shapetype element.
          $self->_write_image_shapetype();
  
          my $index = 1;
          for my $image ( @$header_images_data ) {
  
              # Write the v:shape element.
              $self->_write_image_shape( ++$vml_shape_id, $index++, $image );
          }
      }
  
  
      $self->xml_end_tag( 'xml' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _pixels_to_points()
  #
  # Convert comment vertices from pixels to points.
  #
  sub _pixels_to_points {
  
      my $self     = shift;
      my $vertices = shift;
  
      my (
          $col_start, $row_start, $x1,    $y1,
          $col_end,   $row_end,   $x2,    $y2,
          $left,      $top,       $width, $height
      ) = @$vertices;
  
      for my $pixels ( $left, $top, $width, $height ) {
          $pixels *= 0.75;
      }
  
      return ( $left, $top, $width, $height );
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_xml_namespace()
  #
  # Write the <xml> element. This is the root element of VML.
  #
  sub _write_xml_namespace {
  
      my $self    = shift;
      my $schema  = 'urn:schemas-microsoft-com:';
      my $xmlns   = $schema . 'vml';
      my $xmlns_o = $schema . 'office:office';
      my $xmlns_x = $schema . 'office:excel';
  
      my @attributes = (
          'xmlns:v' => $xmlns,
          'xmlns:o' => $xmlns_o,
          'xmlns:x' => $xmlns_x,
      );
  
      $self->xml_start_tag( 'xml', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_shapelayout()
  #
  # Write the <o:shapelayout> element.
  #
  sub _write_shapelayout {
  
      my $self    = shift;
      my $data_id = shift;
      my $ext     = 'edit';
  
      my @attributes = ( 'v:ext' => $ext );
  
      $self->xml_start_tag( 'o:shapelayout', @attributes );
  
      # Write the o:idmap element.
      $self->_write_idmap( $data_id );
  
      $self->xml_end_tag( 'o:shapelayout' );
  }
  
  
  ##############################################################################
  #
  # _write_idmap()
  #
  # Write the <o:idmap> element.
  #
  sub _write_idmap {
  
      my $self    = shift;
      my $ext     = 'edit';
      my $data_id = shift;
  
      my @attributes = (
          'v:ext' => $ext,
          'data'  => $data_id,
      );
  
      $self->xml_empty_tag( 'o:idmap', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_comment_shapetype()
  #
  # Write the <v:shapetype> element.
  #
  sub _write_comment_shapetype {
  
      my $self      = shift;
      my $id        = '_x0000_t202';
      my $coordsize = '21600,21600';
      my $spt       = 202;
      my $path      = 'm,l,21600r21600,l21600,xe';
  
      my @attributes = (
          'id'        => $id,
          'coordsize' => $coordsize,
          'o:spt'     => $spt,
          'path'      => $path,
      );
  
      $self->xml_start_tag( 'v:shapetype', @attributes );
  
      # Write the v:stroke element.
      $self->_write_stroke();
  
      # Write the v:path element.
      $self->_write_comment_path( 't', 'rect' );
  
      $self->xml_end_tag( 'v:shapetype' );
  }
  
  
  ##############################################################################
  #
  # _write_button_shapetype()
  #
  # Write the <v:shapetype> element.
  #
  sub _write_button_shapetype {
  
      my $self      = shift;
      my $id        = '_x0000_t201';
      my $coordsize = '21600,21600';
      my $spt       = 201;
      my $path      = 'm,l,21600r21600,l21600,xe';
  
      my @attributes = (
          'id'        => $id,
          'coordsize' => $coordsize,
          'o:spt'     => $spt,
          'path'      => $path,
      );
  
      $self->xml_start_tag( 'v:shapetype', @attributes );
  
      # Write the v:stroke element.
      $self->_write_stroke();
  
      # Write the v:path element.
      $self->_write_button_path( 't', 'rect' );
  
      # Write the o:lock element.
      $self->_write_shapetype_lock();
  
      $self->xml_end_tag( 'v:shapetype' );
  }
  
  
  ##############################################################################
  #
  # _write_image_shapetype()
  #
  # Write the <v:shapetype> element.
  #
  sub _write_image_shapetype {
  
      my $self             = shift;
      my $id               = '_x0000_t75';
      my $coordsize        = '21600,21600';
      my $spt              = 75;
      my $o_preferrelative = 't';
      my $path             = 'm@4@5l@4@11@9@11@9@5xe';
      my $filled           = 'f';
      my $stroked          = 'f';
  
      my @attributes = (
          'id'               => $id,
          'coordsize'        => $coordsize,
          'o:spt'            => $spt,
          'o:preferrelative' => $o_preferrelative,
          'path'             => $path,
          'filled'           => $filled,
          'stroked'          => $stroked,
      );
  
      $self->xml_start_tag( 'v:shapetype', @attributes );
  
      # Write the v:stroke element.
      $self->_write_stroke();
  
      # Write the v:formulas element.
      $self->_write_formulas();
  
      # Write the v:path element.
      $self->_write_image_path();
  
      # Write the o:lock element.
      $self->_write_aspect_ratio_lock();
  
      $self->xml_end_tag( 'v:shapetype' );
  }
  
  
  ##############################################################################
  #
  # _write_stroke()
  #
  # Write the <v:stroke> element.
  #
  sub _write_stroke {
  
      my $self      = shift;
      my $joinstyle = 'miter';
  
      my @attributes = ( 'joinstyle' => $joinstyle );
  
      $self->xml_empty_tag( 'v:stroke', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_comment_path()
  #
  # Write the <v:path> element.
  #
  sub _write_comment_path {
  
      my $self            = shift;
      my $gradientshapeok = shift;
      my $connecttype     = shift;
      my @attributes      = ();
  
      push @attributes, ( 'gradientshapeok' => 't' ) if $gradientshapeok;
      push @attributes, ( 'o:connecttype' => $connecttype );
  
      $self->xml_empty_tag( 'v:path', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_button_path()
  #
  # Write the <v:path> element.
  #
  sub _write_button_path {
  
      my $self        = shift;
      my $shadowok    = 'f';
      my $extrusionok = 'f';
      my $strokeok    = 'f';
      my $fillok      = 'f';
      my $connecttype = 'rect';
  
      my @attributes = (
          'shadowok'      => $shadowok,
          'o:extrusionok' => $extrusionok,
          'strokeok'      => $strokeok,
          'fillok'        => $fillok,
          'o:connecttype' => $connecttype,
      );
  
      $self->xml_empty_tag( 'v:path', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_image_path()
  #
  # Write the <v:path> element.
  #
  sub _write_image_path {
  
      my $self            = shift;
      my $extrusionok     = 'f';
      my $gradientshapeok = 't';
      my $connecttype     = 'rect';
  
      my @attributes = (
          'o:extrusionok'   => $extrusionok,
          'gradientshapeok' => $gradientshapeok,
          'o:connecttype'   => $connecttype,
      );
  
      $self->xml_empty_tag( 'v:path', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_shapetype_lock()
  #
  # Write the <o:lock> element.
  #
  sub _write_shapetype_lock {
  
      my $self      = shift;
      my $ext       = 'edit';
      my $shapetype = 't';
  
      my @attributes = (
          'v:ext'     => $ext,
          'shapetype' => $shapetype,
      );
  
      $self->xml_empty_tag( 'o:lock', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_rotation_lock()
  #
  # Write the <o:lock> element.
  #
  sub _write_rotation_lock {
  
      my $self     = shift;
      my $ext      = 'edit';
      my $rotation = 't';
  
      my @attributes = (
          'v:ext'    => $ext,
          'rotation' => $rotation,
      );
  
      $self->xml_empty_tag( 'o:lock', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_aspect_ratio_lock()
  #
  # Write the <o:lock> element.
  #
  sub _write_aspect_ratio_lock {
  
      my $self        = shift;
      my $ext         = 'edit';
      my $aspectratio = 't';
  
      my @attributes = (
          'v:ext'       => $ext,
          'aspectratio' => $aspectratio,
      );
  
      $self->xml_empty_tag( 'o:lock', @attributes );
  }
  
  ##############################################################################
  #
  # _write_comment_shape()
  #
  # Write the <v:shape> element.
  #
  sub _write_comment_shape {
  
      my $self       = shift;
      my $id         = shift;
      my $z_index    = shift;
      my $comment    = shift;
      my $type       = '#_x0000_t202';
      my $insetmode  = 'auto';
      my $visibility = 'hidden';
  
      # Set the shape index.
      $id = '_x0000_s' . $id;
  
      # Get the comment parameters
      my $row       = $comment->[0];
      my $col       = $comment->[1];
      my $string    = $comment->[2];
      my $author    = $comment->[3];
      my $visible   = $comment->[4];
      my $fillcolor = $comment->[5];
      my $vertices  = $comment->[6];
  
      my ( $left, $top, $width, $height ) = $self->_pixels_to_points( $vertices );
  
      # Set the visibility.
      $visibility = 'visible' if $visible;
  
      my $style =
          'position:absolute;'
        . 'margin-left:'
        . $left . 'pt;'
        . 'margin-top:'
        . $top . 'pt;'
        . 'width:'
        . $width . 'pt;'
        . 'height:'
        . $height . 'pt;'
        . 'z-index:'
        . $z_index . ';'
        . 'visibility:'
        . $visibility;
  
  
      my @attributes = (
          'id'          => $id,
          'type'        => $type,
          'style'       => $style,
          'fillcolor'   => $fillcolor,
          'o:insetmode' => $insetmode,
      );
  
      $self->xml_start_tag( 'v:shape', @attributes );
  
      # Write the v:fill element.
      $self->_write_comment_fill();
  
      # Write the v:shadow element.
      $self->_write_shadow();
  
      # Write the v:path element.
      $self->_write_comment_path( undef, 'none' );
  
      # Write the v:textbox element.
      $self->_write_comment_textbox();
  
      # Write the x:ClientData element.
      $self->_write_comment_client_data( $row, $col, $visible, $vertices );
  
      $self->xml_end_tag( 'v:shape' );
  }
  
  
  ##############################################################################
  #
  # _write_button_shape()
  #
  # Write the <v:shape> element.
  #
  sub _write_button_shape {
  
      my $self       = shift;
      my $id         = shift;
      my $z_index    = shift;
      my $button     = shift;
      my $type       = '#_x0000_t201';
  
      # Set the shape index.
      $id = '_x0000_s' . $id;
  
      # Get the button parameters
      my $row       = $button->{_row};
      my $col       = $button->{_col};
      my $vertices  = $button->{_vertices};
  
      my ( $left, $top, $width, $height ) = $self->_pixels_to_points( $vertices );
  
      my $style =
          'position:absolute;'
        . 'margin-left:'
        . $left . 'pt;'
        . 'margin-top:'
        . $top . 'pt;'
        . 'width:'
        . $width . 'pt;'
        . 'height:'
        . $height . 'pt;'
        . 'z-index:'
        . $z_index . ';'
        . 'mso-wrap-style:tight';
  
  
      my @attributes = (
          'id'          => $id,
          'type'        => $type,
          'style'       => $style,
          'o:button'    => 't',
          'fillcolor'   => 'buttonFace [67]',
          'strokecolor' => 'windowText [64]',
          'o:insetmode' => 'auto',
      );
  
      $self->xml_start_tag( 'v:shape', @attributes );
  
      # Write the v:fill element.
      $self->_write_button_fill();
  
      # Write the o:lock element.
      $self->_write_rotation_lock();
  
      # Write the v:textbox element.
      $self->_write_button_textbox( $button->{_font} );
  
      # Write the x:ClientData element.
      $self->_write_button_client_data( $button );
  
      $self->xml_end_tag( 'v:shape' );
  }
  
  
  ##############################################################################
  #
  # _write_image_shape()
  #
  # Write the <v:shape> element.
  #
  sub _write_image_shape {
  
      my $self       = shift;
      my $id         = shift;
      my $index      = shift;
      my $image_data = shift;
      my $type       = '#_x0000_t75';
  
      # Set the shape index.
      $id = '_x0000_s' . $id;
  
      # Get the image parameters
      my $width    = $image_data->[0];
      my $height   = $image_data->[1];
      my $name     = $image_data->[2];
      my $position = $image_data->[3];
      my $x_dpi    = $image_data->[4];
      my $y_dpi    = $image_data->[5];
  
      # Scale the height/width by the resolution, relative to 72dpi.
      $width  = $width  * 72 / $x_dpi;
      $height = $height * 72 / $y_dpi;
  
      # Excel uses a rounding based around 72 and 96 dpi.
      $width  = 72/96 * int($width  * 96/72 + 0.25);
      $height = 72/96 * int($height * 96/72 + 0.25);
  
      my $style =
          'position:absolute;'
        . 'margin-left:0;'
        . 'margin-top:0;'
        . 'width:'
        . $width . 'pt;'
        . 'height:'
        . $height . 'pt;'
        . 'z-index:'
        . $index;
  
      my @attributes = (
          'id'     => $position,
          'o:spid' => $id,
          'type'   => $type,
          'style'  => $style,
      );
  
      $self->xml_start_tag( 'v:shape', @attributes );
  
      # Write the v:imagedata element.
      $self->_write_imagedata( $index, $name );
  
      # Write the o:lock element.
      $self->_write_rotation_lock();
  
      $self->xml_end_tag( 'v:shape' );
  }
  
  ##############################################################################
  #
  # _write_comment_fill()
  #
  # Write the <v:fill> element.
  #
  sub _write_comment_fill {
  
      my $self    = shift;
      my $color_2 = '#ffffe1';
  
      my @attributes = ( 'color2' => $color_2 );
  
      $self->xml_empty_tag( 'v:fill', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_button_fill()
  #
  # Write the <v:fill> element.
  #
  sub _write_button_fill {
  
      my $self             = shift;
      my $color_2          = 'buttonFace [67]';
      my $detectmouseclick = 't';
  
      my @attributes = (
          'color2'             => $color_2,
          'o:detectmouseclick' => $detectmouseclick,
      );
  
      $self->xml_empty_tag( 'v:fill', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_shadow()
  #
  # Write the <v:shadow> element.
  #
  sub _write_shadow {
  
      my $self     = shift;
      my $on       = 't';
      my $color    = 'black';
      my $obscured = 't';
  
      my @attributes = (
          'on'       => $on,
          'color'    => $color,
          'obscured' => $obscured,
      );
  
      $self->xml_empty_tag( 'v:shadow', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_comment_textbox()
  #
  # Write the <v:textbox> element.
  #
  sub _write_comment_textbox {
  
      my $self  = shift;
      my $style = 'mso-direction-alt:auto';
  
      my @attributes = ( 'style' => $style );
  
      $self->xml_start_tag( 'v:textbox', @attributes );
  
      # Write the div element.
      $self->_write_div( 'left' );
  
      $self->xml_end_tag( 'v:textbox' );
  }
  
  
  ##############################################################################
  #
  # _write_button_textbox()
  #
  # Write the <v:textbox> element.
  #
  sub _write_button_textbox {
  
      my $self  = shift;
      my $font  = shift;
      my $style = 'mso-direction-alt:auto';
  
      my @attributes = ( 'style' => $style, 'o:singleclick' => 'f' );
  
      $self->xml_start_tag( 'v:textbox', @attributes );
  
      # Write the div element.
      $self->_write_div( 'center', $font );
  
      $self->xml_end_tag( 'v:textbox' );
  }
  
  
  ##############################################################################
  #
  # _write_div()
  #
  # Write the <div> element.
  #
  sub _write_div {
  
      my $self  = shift;
      my $align = shift;
      my $font  = shift;
      my $style = 'text-align:' . $align;
  
      my @attributes = ( 'style' => $style );
  
      $self->xml_start_tag( 'div', @attributes );
  
  
      if ( $font ) {
  
          # Write the font element.
          $self->_write_font( $font );
      }
  
      $self->xml_end_tag( 'div' );
  }
  
  ##############################################################################
  #
  # _write_font()
  #
  # Write the <font> element.
  #
  sub _write_font {
  
      my $self    = shift;
      my $font    = shift;
      my $caption = $font->{_caption};
      my $face    = 'Calibri';
      my $size    = 220;
      my $color   = '#000000';
  
      my @attributes = (
          'face'  => $face,
          'size'  => $size,
          'color' => $color,
      );
  
      $self->xml_data_element( 'font', $caption, @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_comment_client_data()
  #
  # Write the <x:ClientData> element.
  #
  sub _write_comment_client_data {
  
      my $self        = shift;
      my $row         = shift;
      my $col         = shift;
      my $visible     = shift;
      my $vertices    = shift;
      my $object_type = 'Note';
  
      my @attributes = ( 'ObjectType' => $object_type );
  
      $self->xml_start_tag( 'x:ClientData', @attributes );
  
      # Write the x:MoveWithCells element.
      $self->_write_move_with_cells();
  
      # Write the x:SizeWithCells element.
      $self->_write_size_with_cells();
  
      # Write the x:Anchor element.
      $self->_write_anchor( $vertices );
  
      # Write the x:AutoFill element.
      $self->_write_auto_fill();
  
      # Write the x:Row element.
      $self->_write_row( $row );
  
      # Write the x:Column element.
      $self->_write_column( $col );
  
      # Write the x:Visible element.
      $self->_write_visible() if $visible;
  
      $self->xml_end_tag( 'x:ClientData' );
  }
  
  
  ##############################################################################
  #
  # _write_button_client_data()
  #
  # Write the <x:ClientData> element.
  #
  sub _write_button_client_data {
  
      my $self      = shift;
      my $button    = shift;
      my $row       = $button->{_row};
      my $col       = $button->{_col};
      my $macro     = $button->{_macro};
      my $vertices  = $button->{_vertices};
  
  
      my $object_type = 'Button';
  
      my @attributes = ( 'ObjectType' => $object_type );
  
      $self->xml_start_tag( 'x:ClientData', @attributes );
  
      # Write the x:Anchor element.
      $self->_write_anchor( $vertices );
  
      # Write the x:PrintObject element.
      $self->_write_print_object();
  
      # Write the x:AutoFill element.
      $self->_write_auto_fill();
  
      # Write the x:FmlaMacro element.
      $self->_write_fmla_macro( $macro );
  
      # Write the x:TextHAlign element.
      $self->_write_text_halign();
  
      # Write the x:TextVAlign element.
      $self->_write_text_valign();
  
      $self->xml_end_tag( 'x:ClientData' );
  }
  
  
  ##############################################################################
  #
  # _write_move_with_cells()
  #
  # Write the <x:MoveWithCells> element.
  #
  sub _write_move_with_cells {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'x:MoveWithCells' );
  }
  
  
  ##############################################################################
  #
  # _write_size_with_cells()
  #
  # Write the <x:SizeWithCells> element.
  #
  sub _write_size_with_cells {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'x:SizeWithCells' );
  }
  
  
  ##############################################################################
  #
  # _write_visible()
  #
  # Write the <x:Visible> element.
  #
  sub _write_visible {
  
      my $self = shift;
  
      $self->xml_empty_tag( 'x:Visible' );
  }
  
  
  ##############################################################################
  #
  # _write_anchor()
  #
  # Write the <x:Anchor> element.
  #
  sub _write_anchor {
  
      my $self     = shift;
      my $vertices = shift;
  
      my ( $col_start, $row_start, $x1, $y1, $col_end, $row_end, $x2, $y2 ) =
        @$vertices;
  
      my $data = join ", ",
        ( $col_start, $x1, $row_start, $y1, $col_end, $x2, $row_end, $y2 );
  
      $self->xml_data_element( 'x:Anchor', $data );
  }
  
  
  ##############################################################################
  #
  # _write_auto_fill()
  #
  # Write the <x:AutoFill> element.
  #
  sub _write_auto_fill {
  
      my $self = shift;
      my $data = 'False';
  
      $self->xml_data_element( 'x:AutoFill', $data );
  }
  
  
  ##############################################################################
  #
  # _write_row()
  #
  # Write the <x:Row> element.
  #
  sub _write_row {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'x:Row', $data );
  }
  
  
  ##############################################################################
  #
  # _write_column()
  #
  # Write the <x:Column> element.
  #
  sub _write_column {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'x:Column', $data );
  }
  
  
  ##############################################################################
  #
  # _write_print_object()
  #
  # Write the <x:PrintObject> element.
  #
  sub _write_print_object {
  
      my $self = shift;
      my $data = 'False';
  
      $self->xml_data_element( 'x:PrintObject', $data );
  }
  
  
  ##############################################################################
  #
  # _write_text_halign()
  #
  # Write the <x:TextHAlign> element.
  #
  sub _write_text_halign {
  
      my $self = shift;
      my $data = 'Center';
  
      $self->xml_data_element( 'x:TextHAlign', $data );
  }
  
  
  ##############################################################################
  #
  # _write_text_valign()
  #
  # Write the <x:TextVAlign> element.
  #
  sub _write_text_valign {
  
      my $self = shift;
      my $data = 'Center';
  
      $self->xml_data_element( 'x:TextVAlign', $data );
  }
  
  
  ##############################################################################
  #
  # _write_fmla_macro()
  #
  # Write the <x:FmlaMacro> element.
  #
  sub _write_fmla_macro {
  
      my $self = shift;
      my $data = shift;
  
      $self->xml_data_element( 'x:FmlaMacro', $data );
  }
  
  ##############################################################################
  #
  # _write_imagedata()
  #
  # Write the <v:imagedata> element.
  #
  sub _write_imagedata {
  
      my $self    = shift;
      my $index   = shift;
      my $o_title = shift;
  
      my @attributes = (
          'o:relid' => 'rId' . $index,
          'o:title' => $o_title,
      );
  
      $self->xml_empty_tag( 'v:imagedata', @attributes );
  }
  
  
  
  ##############################################################################
  #
  # _write_formulas()
  #
  # Write the <v:formulas> element.
  #
  sub _write_formulas {
  
      my $self                 = shift;
  
      $self->xml_start_tag( 'v:formulas' );
  
      # Write the v:f elements.
      $self->_write_f('if lineDrawn pixelLineWidth 0');
      $self->_write_f('sum @0 1 0');
      $self->_write_f('sum 0 0 @1');
      $self->_write_f('prod @2 1 2');
      $self->_write_f('prod @3 21600 pixelWidth');
      $self->_write_f('prod @3 21600 pixelHeight');
      $self->_write_f('sum @0 0 1');
      $self->_write_f('prod @6 1 2');
      $self->_write_f('prod @7 21600 pixelWidth');
      $self->_write_f('sum @8 21600 0');
      $self->_write_f('prod @7 21600 pixelHeight');
      $self->_write_f('sum @10 21600 0');
  
      $self->xml_end_tag( 'v:formulas' );
  }
  
  
  ##############################################################################
  #
  # _write_f()
  #
  # Write the <v:f> element.
  #
  sub _write_f {
  
      my $self = shift;
      my $eqn  = shift;
  
      my @attributes = ( 'eqn' => $eqn );
  
      $self->xml_empty_tag( 'v:f', @attributes );
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  VML - A class for writing the Excel XLSX VML files.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_VML

$fatpacked{"Excel/Writer/XLSX/Package/XMLwriter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_PACKAGE_XMLWRITER';
  package Excel::Writer::XLSX::Package::XMLwriter;
  
  ###############################################################################
  #
  # XMLwriter - A base class for the Excel::Writer::XLSX writer classes.
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Exporter;
  use Carp;
  use IO::File;
  
  our @ISA     = qw(Exporter);
  our $VERSION = '0.89';
  
  #
  # NOTE: this module is a light weight re-implementation of XML::Writer. See
  # the Pod docs below for a full explanation. The methods  are implemented
  # for speed rather than readability since they are used heavily in tight
  # loops by Excel::Writer::XLSX.
  #
  
  # Note "local $\ = undef" protect print statements from -l on commandline.
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
  
      # FH may be undef and set later in _set_xml_writer(), see below.
      my $fh = shift;
  
      my $self = { _fh => $fh };
  
      bless $self, $class;
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _set_xml_writer()
  #
  # Set the XML writer filehandle for the object. This can either be done
  # in the constructor (usually for testing since the file name isn't generally
  # known at that stage) or later via this method.
  #
  sub _set_xml_writer {
  
      my $self     = shift;
      my $filename = shift;
  
      my $fh = IO::File->new( $filename, 'w' );
      croak "Couldn't open file $filename for writing.\n" unless $fh;
  
      binmode $fh, ':utf8';
  
      $self->{_fh} = $fh;
  }
  
  
  ###############################################################################
  #
  # xml_declaration()
  #
  # Write the XML declaration.
  #
  sub xml_declaration {
  
      my $self = shift;
      local $\ = undef;
  
      print { $self->{_fh} }
        qq(<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n);
  
  }
  
  
  ###############################################################################
  #
  # xml_start_tag()
  #
  # Write an XML start tag with optional attributes.
  #
  sub xml_start_tag {
  
      my $self = shift;
      my $tag  = shift;
  
      while ( @_ ) {
          my $key   = shift @_;
          my $value = shift @_;
          $value = _escape_attributes( $value );
  
          $tag .= qq( $key="$value");
      }
  
      local $\ = undef;
      print { $self->{_fh} } "<$tag>";
  }
  
  
  ###############################################################################
  #
  # xml_start_tag_unencoded()
  #
  # Write an XML start tag with optional, unencoded, attributes.
  # This is a minor speed optimisation for elements that don't need encoding.
  #
  sub xml_start_tag_unencoded {
  
      my $self = shift;
      my $tag  = shift;
  
      while ( @_ ) {
          my $key   = shift @_;
          my $value = shift @_;
  
          $tag .= qq( $key="$value");
      }
  
      local $\ = undef;
      print { $self->{_fh} } "<$tag>";
  }
  
  
  ###############################################################################
  #
  # xml_end_tag()
  #
  # Write an XML end tag.
  #
  sub xml_end_tag {
  
      my $self = shift;
      my $tag  = shift;
      local $\ = undef;
  
      print { $self->{_fh} } "</$tag>";
  }
  
  
  ###############################################################################
  #
  # xml_empty_tag()
  #
  # Write an empty XML tag with optional attributes.
  #
  sub xml_empty_tag {
  
      my $self = shift;
      my $tag  = shift;
  
      while ( @_ ) {
          my $key   = shift @_;
          my $value = shift @_;
          $value = _escape_attributes( $value );
  
          $tag .= qq( $key="$value");
      }
  
      local $\ = undef;
  
      print { $self->{_fh} } "<$tag/>";
  }
  
  
  ###############################################################################
  #
  # xml_empty_tag_unencoded()
  #
  # Write an empty XML tag with optional, unencoded, attributes.
  # This is a minor speed optimisation for elements that don't need encoding.
  #
  sub xml_empty_tag_unencoded {
  
      my $self = shift;
      my $tag  = shift;
  
      while ( @_ ) {
          my $key   = shift @_;
          my $value = shift @_;
  
          $tag .= qq( $key="$value");
      }
  
      local $\ = undef;
  
      print { $self->{_fh} } "<$tag/>";
  }
  
  
  ###############################################################################
  #
  # xml_data_element()
  #
  # Write an XML element containing data with optional attributes.
  # XML characters in the data are encoded.
  #
  sub xml_data_element {
  
      my $self    = shift;
      my $tag     = shift;
      my $data    = shift;
      my $end_tag = $tag;
  
      while ( @_ ) {
          my $key   = shift @_;
          my $value = shift @_;
          $value = _escape_attributes( $value );
  
          $tag .= qq( $key="$value");
      }
  
      $data = _escape_data( $data );
  
      local $\ = undef;
      print { $self->{_fh} } "<$tag>$data</$end_tag>";
  }
  
  
  ###############################################################################
  #
  # xml_data_element_unencoded()
  #
  # Write an XML unencoded element containing data with optional attributes.
  # This is a minor speed optimisation for elements that don't need encoding.
  #
  sub xml_data_element_unencoded {
  
      my $self    = shift;
      my $tag     = shift;
      my $data    = shift;
      my $end_tag = $tag;
  
      while ( @_ ) {
          my $key   = shift @_;
          my $value = shift @_;
  
          $tag .= qq( $key="$value");
      }
  
      local $\ = undef;
      print { $self->{_fh} } "<$tag>$data</$end_tag>";
  }
  
  
  ###############################################################################
  #
  # xml_string_element()
  #
  # Optimised tag writer for <c> cell string elements in the inner loop.
  #
  sub xml_string_element {
  
      my $self  = shift;
      my $index = shift;
      my $attr  = '';
  
      while ( @_ ) {
          my $key   = shift;
          my $value = shift;
          $attr .= qq( $key="$value");
      }
  
      local $\ = undef;
      print { $self->{_fh} } "<c$attr t=\"s\"><v>$index</v></c>";
  }
  
  
  ###############################################################################
  #
  # xml_si_element()
  #
  # Optimised tag writer for shared strings <si> elements.
  #
  sub xml_si_element {
  
      my $self   = shift;
      my $string = shift;
      my $attr   = '';
  
  
      while ( @_ ) {
          my $key   = shift;
          my $value = shift;
          $attr .= qq( $key="$value");
      }
  
      $string = _escape_data( $string );
  
      local $\ = undef;
      print { $self->{_fh} } "<si><t$attr>$string</t></si>";
  }
  
  
  ###############################################################################
  #
  # xml_rich_si_element()
  #
  # Optimised tag writer for shared strings <si> rich string elements.
  #
  sub xml_rich_si_element {
  
      my $self   = shift;
      my $string = shift;
  
  
      local $\ = undef;
      print { $self->{_fh} } "<si>$string</si>";
  }
  
  
  ###############################################################################
  #
  # xml_number_element()
  #
  # Optimised tag writer for <c> cell number elements in the inner loop.
  #
  sub xml_number_element {
  
      my $self   = shift;
      my $number = shift;
      my $attr   = '';
  
      while ( @_ ) {
          my $key   = shift;
          my $value = shift;
          $attr .= qq( $key="$value");
      }
  
      local $\ = undef;
      print { $self->{_fh} } "<c$attr><v>$number</v></c>";
  }
  
  
  ###############################################################################
  #
  # xml_formula_element()
  #
  # Optimised tag writer for <c> cell formula elements in the inner loop.
  #
  sub xml_formula_element {
  
      my $self    = shift;
      my $formula = shift;
      my $result  = shift;
      my $attr    = '';
  
      while ( @_ ) {
          my $key   = shift;
          my $value = shift;
          $attr .= qq( $key="$value");
      }
  
      $formula = _escape_data( $formula );
  
      local $\ = undef;
      print { $self->{_fh} } "<c$attr><f>$formula</f><v>$result</v></c>";
  }
  
  
  ###############################################################################
  #
  # xml_inline_string()
  #
  # Optimised tag writer for inlineStr cell elements in the inner loop.
  #
  sub xml_inline_string {
  
      my $self     = shift;
      my $string   = shift;
      my $preserve = shift;
      my $attr     = '';
      my $t_attr   = '';
  
      # Set the <t> attribute to preserve whitespace.
      $t_attr = ' xml:space="preserve"' if $preserve;
  
      while ( @_ ) {
          my $key   = shift;
          my $value = shift;
          $attr .= qq( $key="$value");
      }
  
      $string = _escape_data( $string );
  
      local $\ = undef;
      print { $self->{_fh} }
        "<c$attr t=\"inlineStr\"><is><t$t_attr>$string</t></is></c>";
  }
  
  
  ###############################################################################
  #
  # xml_rich_inline_string()
  #
  # Optimised tag writer for rich inlineStr cell elements in the inner loop.
  #
  sub xml_rich_inline_string {
  
      my $self   = shift;
      my $string = shift;
      my $attr   = '';
  
      while ( @_ ) {
          my $key   = shift;
          my $value = shift;
          $attr .= qq( $key="$value");
      }
  
      local $\ = undef;
      print { $self->{_fh} } "<c$attr t=\"inlineStr\"><is>$string</is></c>";
  }
  
  
  ###############################################################################
  #
  # xml_get_fh()
  #
  # Return the output filehandle.
  #
  sub xml_get_fh {
  
      my $self = shift;
  
      return $self->{_fh};
  }
  
  
  ###############################################################################
  #
  # _escape_attributes()
  #
  # Escape XML characters in attributes.
  #
  sub _escape_attributes {
  
      my $str = $_[0];
  
      return $str if $str !~ m/["&<>\n]/;
  
      for ( $str ) {
          s/&/&amp;/g;
          s/"/&quot;/g;
          s/</&lt;/g;
          s/>/&gt;/g;
          s/\n/&#xA;/g;
      }
  
      return $str;
  }
  
  
  ###############################################################################
  #
  # _escape_data()
  #
  # Escape XML characters in data sections. Note, this is different from
  # _escape_attributes() in that double quotes are not escaped by Excel.
  #
  sub _escape_data {
  
      my $str = $_[0];
  
      return $str if $str !~ m/[&<>]/;
  
      for ( $str ) {
          s/&/&amp;/g;
          s/</&lt;/g;
          s/>/&gt;/g;
      }
  
      return $str;
  }
  
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  XMLwriter - A base class for the Excel::Writer::XLSX writer classes.
  
  =head1 DESCRIPTION
  
  This module is used by L<Excel::Writer::XLSX> for writing XML documents. It is a light weight re-implementation of L<XML::Writer>.
  
  XMLwriter is approximately twice as fast as L<XML::Writer>. This speed is achieved at the expense of error and correctness checking. In addition not all of the L<XML::Writer> methods are implemented. As such, XMLwriter is not recommended for use outside of Excel::Writer::XLSX.
  
  =head1 SEE ALSO
  
  L<XML::Writer>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  See the documentation for L<Excel::Writer::XLSX>.
  
  =cut
EXCEL_WRITER_XLSX_PACKAGE_XMLWRITER

$fatpacked{"Excel/Writer/XLSX/Shape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_SHAPE';
  package Excel::Writer::XLSX::Shape;
  
  ###############################################################################
  #
  # Shape - A class for writing Excel shapes.
  #
  # Used in conjunction with Excel::Writer::XLSX.
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use Exporter;
  
  our @ISA     = qw(Exporter);
  our $VERSION = '0.89';
  our $AUTOLOAD;
  
  ###############################################################################
  #
  # new()
  #
  sub new {
  
      my $class      = shift;
      my $fh         = shift;
      my $self       = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
  
      my %properties = @_;
  
      $self->{_name} = undef;
      $self->{_type} = 'rect';
  
      # Is a Connector shape. 1/0 Value is a hash lookup from type.
      $self->{_connect} = 0;
  
      # Is a Drawing. Always 0, since a single shape never fills an entire sheet.
      $self->{_drawing} = 0;
  
      # OneCell or Absolute: options to move and/or size with cells.
      $self->{_editAs} = '';
  
      # Auto-incremented, unless supplied by user.
      $self->{_id} = 0;
  
      # Shape text (usually centered on shape geometry).
      $self->{_text} = 0;
  
      # Shape stencil mode.  A copy (child) is created when inserted.
      # The link to parent is broken.
      $self->{_stencil} = 1;
  
      # Index to _shapes array when inserted.
      $self->{_element} = -1;
  
      # Shape ID of starting connection, if any.
      $self->{_start} = undef;
  
      # Shape vertex, starts at 0, numbered clockwise from 12 o'clock.
      $self->{_start_index} = undef;
  
      $self->{_end}       = undef;
      $self->{_end_index} = undef;
  
      # Number and size of adjustments for shapes (usually connectors).
      $self->{_adjustments} = [];
  
      # Start and end sides. t)op, b)ottom, l)eft, or r)ight.
      $self->{_start_side} = '';
      $self->{_end_side}   = '';
  
      # Flip shape Horizontally. eg. arrow left to arrow right.
      $self->{_flip_h} = 0;
  
      # Flip shape Vertically. eg. up arrow to down arrow.
      $self->{_flip_v} = 0;
  
      # shape rotation (in degrees 0-360).
      $self->{_rotation} = 0;
  
      # An alternate way to create a text box, because Excel allows it.
      # It is just a rectangle with text.
      $self->{_txBox} = 0;
  
      # Shape outline colour, or 0 for noFill (default black).
      $self->{_line} = '000000';
  
      # Line type: dash, sysDot, dashDot, lgDash, lgDashDot, lgDashDotDot.
      $self->{_line_type} = '';
  
      # Line weight (integer).
      $self->{_line_weight} = 1;
  
      # Shape fill colour, or 0 for noFill (default noFill).
      $self->{_fill} = 0;
  
      # Formatting for shape text, if any.
      $self->{_format} = {};
  
      # copy of colour palette table from Workbook.pm.
      $self->{_palette} = [];
  
      # Vertical alignment: t, ctr, b.
      $self->{_valign} = 'ctr';
  
      # Alignment: l, ctr, r, just
      $self->{_align} = 'ctr';
  
      $self->{_x_offset} = 0;
      $self->{_y_offset} = 0;
  
      # Scale factors, which also may be set when the shape is inserted.
      $self->{_scale_x} = 1;
      $self->{_scale_y} = 1;
  
      # Default size, which can be modified and/or scaled.
      $self->{_width}  = 50;
      $self->{_height} = 50;
  
      # Initial assignment. May be modified when prepared.
      $self->{_column_start} = 0;
      $self->{_row_start}    = 0;
      $self->{_x1}           = 0;
      $self->{_y1}           = 0;
      $self->{_column_end}   = 0;
      $self->{_row_end}      = 0;
      $self->{_x2}           = 0;
      $self->{_y2}           = 0;
      $self->{_x_abs}        = 0;
      $self->{_y_abs}        = 0;
  
      # Override default properties with passed arguments
      while ( my ( $key, $value ) = each( %properties ) ) {
  
          # Strip leading "-" from Tk style properties e.g. -color => 'red'.
          $key =~ s/^-//;
  
          # Add leading underscore "_" to internal hash keys, if not supplied.
          $key = "_" . $key unless $key =~ m/^_/;
  
          $self->{$key} = $value;
      }
  
      bless $self, $class;
      return $self;
  }
  
  
  ###############################################################################
  #
  # set_properties( name => 'Shape 1', type => 'rect' )
  #
  # Set shape properties.
  #
  sub set_properties {
  
      my $self       = shift;
      my %properties = @_;
  
      # Update properties with passed arguments.
      while ( my ( $key, $value ) = each( %properties ) ) {
  
          # Strip leading "-" from Tk style properties e.g. -color => 'red'.
          $key =~ s/^-//;
  
          # Add leading underscore "_" to internal hash keys, if not supplied.
          $key = "_" . $key unless $key =~ m/^_/;
  
          if ( !exists $self->{$key} ) {
              warn "Unknown shape property: $key. Property not set.\n";
              next;
          }
  
          $self->{$key} = $value;
      }
  }
  
  
  ###############################################################################
  #
  # set_adjustment( adj1, adj2, adj3, ... )
  #
  # Set the shape adjustments array (as a reference).
  #
  sub set_adjustments {
  
      my $self = shift;
      $self->{_adjustments} = \@_;
  }
  
  
  ###############################################################################
  #
  # AUTOLOAD. Deus ex machina.
  #
  # Dynamically create set/get methods that aren't already defined.
  #
  sub AUTOLOAD {
  
      my $self = shift;
  
      # Ignore calls to DESTROY.
      return if $AUTOLOAD =~ /::DESTROY$/;
  
      # Check for a valid method names, i.e. "set_xxx_Cy".
      $AUTOLOAD =~ /.*::(get|set)(\w+)/ or die "Unknown method: $AUTOLOAD\n";
  
      # Match the function (get or set) and attribute, i.e. "_xxx_yyy".
      my $gs        = $1;
      my $attribute = $2;
  
      # Check that the attribute exists.
      exists $self->{$attribute} or die "Unknown method: $AUTOLOAD\n";
  
      # The attribute value
      my $value;
  
      # set_property() pattern.
      # When a method is AUTOLOADED we store a new anonymous
      # sub in the appropriate slot in the symbol table. The speeds up subsequent
      # calls to the same method.
      #
      no strict 'refs';    # To allow symbol table hackery
  
      $value = $_[0];
      $value = 1 if not defined $value;    # The default value is always 1
  
      if ( $gs eq 'set' ) {
          *{$AUTOLOAD} = sub {
              my $self  = shift;
              my $value = shift;
  
              $value = 1 if not defined $value;
              $self->{$attribute} = $value;
          };
  
          $self->{$attribute} = $value;
      }
      else {
          *{$AUTOLOAD} = sub {
              my $self = shift;
              return $self->{$attribute};
          };
  
          # Let AUTOLOAD return the attribute for the first invocation
          return $self->{$attribute};
      }
  }
  
  
  ###############################################################################
  #
  # _get_palette_color()
  #
  # Convert from an Excel internal colour index to a XML style #RRGGBB index
  # based on the default or user defined values in the Workbook palette.
  # Note: This version doesn't add an alpha channel.
  #
  sub _get_palette_color {
  
      my $self    = shift;
      my $index   = shift;
      my $palette = $self->{_palette};
  
      # Adjust the colour index.
      $index -= 8;
  
      # Palette is passed in from the Workbook class.
      my @rgb = @{ $palette->[$index] };
  
      return sprintf "%02X%02X%02X", @rgb[0, 1, 2];
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Shape - A class for creating Excel Drawing shapes
  
  =head1 SYNOPSIS
  
  To create a simple Excel file containing shapes using L<Excel::Writer::XLSX>:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'shape.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # Add a default rectangle shape.
      my $rect = $workbook->add_shape();
  
      # Add an ellipse with centered text.
      my $ellipse = $workbook->add_shape(
          type => 'ellipse',
          text => "Hello\nWorld"
      );
  
      # Add a plus shape.
      my $plus = $workbook->add_shape( type => 'plus');
  
      # Insert the shapes in the worksheet.
      $worksheet->insert_shape( 'B3', $rect );
      $worksheet->insert_shape( 'C3', $ellipse );
      $worksheet->insert_shape( 'D3', $plus );
  
  
  =head1 DESCRIPTION
  
  The C<Excel::Writer::XLSX::Shape> module is used to create Shape objects for L<Excel::Writer::XLSX>.
  
  A Shape object is created via the Workbook C<add_shape()> method:
  
      my $shape_rect = $workbook->add_shape( type => 'rect' );
  
  Once the object is created it can be inserted into a worksheet using the C<insert_shape()> method:
  
      $worksheet->insert_shape('A1', $shape_rect);
  
  A Shape can be inserted multiple times if required.
  
      $worksheet->insert_shape('A1', $shape_rect);
      $worksheet->insert_shape('B2', $shape_rect, 20, 30);
  
  
  =head1 METHODS
  
  =head2 add_shape( %properties )
  
  The C<add_shape()> Workbook method specifies the properties of the Shape in hash C<< property => value >> format:
  
      my $shape = $workbook->add_shape( %properties );
  
  The available properties are shown below.
  
  =head2 insert_shape( $row, $col, $shape, $x, $y, $scale_x, $scale_y )
  
  The C<insert_shape()> Worksheet method sets the location and scale of the shape object within the worksheet.
  
      # Insert the shape into the worksheet.
      $worksheet->insert_shape( 'E2', $shape );
  
  Using the cell location and the C<$x> and C<$y> cell offsets it is possible to position a shape anywhere on the canvas of a worksheet.
  
  A more detailed explanation of the C<insert_shape()> method is given in the main L<Excel::Writer::XLSX> documentation.
  
  
  =head1 SHAPE PROPERTIES
  
  Any shape property can be queried or modified by the corresponding get/set method:
  
      my $ellipse = $workbook->add_shape( %properties );
      $ellipse->set_type( 'plus' );    # No longer an ellipse!
      my $type = $ellipse->get_type();  # Find out what it really is.
  
  Multiple shape properties may also be modified in one go by using the C<set_properties()> method:
  
      $shape->set_properties( type => 'ellipse', text => 'Hello' );
  
  The properties of a shape object that can be defined via C<add_shape()> are shown below.
  
  =head2 name
  
  Defines the name of the shape. This is an optional property and the shape will be given a default name if not supplied. The name is generally only used by Excel Macros to refer to the object.
  
  =head2 type
  
  Defines the type of the object such as C<rect>, C<ellipse> or C<triangle>:
  
      my $ellipse = $workbook->add_shape( type => 'ellipse' );
  
  The default type is C<rect>.
  
  The full list of available shapes is shown below.
  
  See also the C<shapes_all.pl> program in the C<examples> directory of the distro. It creates an example workbook with all supported shapes labelled with their shape names.
  
  
  =over 4
  
  =item * Basic Shapes
  
      blockArc              can            chevron       cube          decagon
      diamond               dodecagon      donut         ellipse       funnel
      gear6                 gear9          heart         heptagon      hexagon
      homePlate             lightningBolt  line          lineInv       moon
      nonIsoscelesTrapezoid noSmoking      octagon       parallelogram pentagon
      pie                   pieWedge       plaque        rect          round1Rect
      round2DiagRect        round2SameRect roundRect     rtTriangle    smileyFace
      snip1Rect             snip2DiagRect  snip2SameRect snipRoundRect star10
      star12                star16         star24        star32        star4
      star5                 star6          star7         star8         sun
      teardrop              trapezoid      triangle
  
  =item * Arrow Shapes
  
      bentArrow        bentUpArrow       circularArrow     curvedDownArrow
      curvedLeftArrow  curvedRightArrow  curvedUpArrow     downArrow
      leftArrow        leftCircularArrow leftRightArrow    leftRightCircularArrow
      leftRightUpArrow leftUpArrow       notchedRightArrow quadArrow
      rightArrow       stripedRightArrow swooshArrow       upArrow
      upDownArrow      uturnArrow
  
  =item * Connector Shapes
  
      bentConnector2   bentConnector3   bentConnector4
      bentConnector5   curvedConnector2 curvedConnector3
      curvedConnector4 curvedConnector5 straightConnector1
  
  =item * Callout Shapes
  
      accentBorderCallout1  accentBorderCallout2  accentBorderCallout3
      accentCallout1        accentCallout2        accentCallout3
      borderCallout1        borderCallout2        borderCallout3
      callout1              callout2              callout3
      cloudCallout          downArrowCallout      leftArrowCallout
      leftRightArrowCallout quadArrowCallout      rightArrowCallout
      upArrowCallout        upDownArrowCallout    wedgeEllipseCallout
      wedgeRectCallout      wedgeRoundRectCallout
  
  =item * Flow Chart Shapes
  
      flowChartAlternateProcess  flowChartCollate        flowChartConnector
      flowChartDecision          flowChartDelay          flowChartDisplay
      flowChartDocument          flowChartExtract        flowChartInputOutput
      flowChartInternalStorage   flowChartMagneticDisk   flowChartMagneticDrum
      flowChartMagneticTape      flowChartManualInput    flowChartManualOperation
      flowChartMerge             flowChartMultidocument  flowChartOfflineStorage
      flowChartOffpageConnector  flowChartOnlineStorage  flowChartOr
      flowChartPredefinedProcess flowChartPreparation    flowChartProcess
      flowChartPunchedCard       flowChartPunchedTape    flowChartSort
      flowChartSummingJunction   flowChartTerminator
  
  =item * Action Shapes
  
      actionButtonBackPrevious actionButtonBeginning actionButtonBlank
      actionButtonDocument     actionButtonEnd       actionButtonForwardNext
      actionButtonHelp         actionButtonHome      actionButtonInformation
      actionButtonMovie        actionButtonReturn    actionButtonSound
  
  =item * Chart Shapes
  
  Not to be confused with Excel Charts.
  
      chartPlus chartStar chartX
  
  =item * Math Shapes
  
      mathDivide mathEqual mathMinus mathMultiply mathNotEqual mathPlus
  
  =item * Stars and Banners
  
      arc            bevel          bracePair  bracketPair chord
      cloud          corner         diagStripe doubleWave  ellipseRibbon
      ellipseRibbon2 foldedCorner   frame      halfFrame   horizontalScroll
      irregularSeal1 irregularSeal2 leftBrace  leftBracket leftRightRibbon
      plus           ribbon         ribbon2    rightBrace  rightBracket
      verticalScroll wave
  
  =item * Tab Shapes
  
      cornerTabs plaqueTabs squareTabs
  
  =back
  
  =head2 text
  
  This property is used to make the shape act like a text box.
  
      my $rect = $workbook->add_shape( type => 'rect', text => "Hello\nWorld" );
  
  The text is super-imposed over the shape. The text can be wrapped using the newline character C<\n>.
  
  =head2 id
  
  Identification number for internal identification. This number will be auto-assigned, if not assigned, or if it is a duplicate.
  
  =head2 format
  
  Workbook format for decorating the shape text (font family, size, and decoration).
  
  =head2 start, start_index
  
  Shape indices of the starting point for a connector and the index of the connection. Index numbers are zero-based, start from the top dead centre and are counted clockwise.
  
  Indices are typically created for vertices and centre points of shapes. They are the blue connection points that appear when connection shapes are selected manually in Excel.
  
  =head2 end, end_index
  
  Same as above but for end points and end connections.
  
  
  =head2 start_side, end_side
  
  This is either the letter C<b> or C<r> for the bottom or right side of the shape to be connected to and from.
  
  If the C<start>, C<start_index>, and C<start_side> parameters are defined for a connection shape, the shape will be auto located and linked to the starting and ending shapes respectively. This can be very useful for flow and organisation charts.
  
  =head2 flip_h, flip_v
  
  Set this value to 1, to flip the shape horizontally and/or vertically.
  
  =head2 rotation
  
  Shape rotation, in degrees, from 0 to 360.
  
  =head2 line, fill
  
  Shape colour for the outline and fill. Colours may be specified as a colour index, or in RGB format, i.e. C<AA00FF>.
  
  See C<COLOURS IN EXCEL> in the main documentation for more information.
  
  =head2 line_type
  
  Line type for shape outline. The default is solid. The list of possible values is:
  
      dash, sysDot, dashDot, lgDash, lgDashDot, lgDashDotDot, solid
  
  =head2 valign, align
  
  Text alignment within the shape.
  
  Vertical alignment can be:
  
      Setting     Meaning
      =======     =======
      t           Top
      ctr         Centre
      b           Bottom
  
  Horizontal alignment can be:
  
      Setting     Meaning
      =======     =======
      l           Left
      r           Right
      ctr         Centre
      just        Justified
  
  The default is to centre both horizontally and vertically.
  
  =head2 scale_x, scale_y
  
  Scale factor in x and y dimension, for scaling the shape width and height. The default value is 1.
  
  Scaling may be set on the shape object or via C<insert_shape()>.
  
  =head2 adjustments
  
  Adjustment of shape vertices. Most shapes do not use this. For some shapes, there is a single adjustment to modify the geometry. For instance, the plus shape has one adjustment to control the width of the spokes.
  
  Connectors can have a number of adjustments to control the shape routing. Typically, a connector will have 3 to 5 handles for routing the shape. The adjustment is in percent of the distance from the starting shape to the ending shape, alternating between the x and y dimension. Adjustments may be negative, to route the shape away from the endpoint.
  
  =head2 stencil
  
  Shapes work in stencil mode by default. That is, once a shape is inserted, its connection is separated from its master. The master shape may be modified after an instance is inserted, and only subsequent insertions will show the modifications.
  
  This is helpful for Org charts, where an employee shape may be created once, and then the text of the shape is modified for each employee.
  
  The C<insert_shape()> method returns a reference to the inserted shape (the child).
  
  Stencil mode can be turned off, allowing for shape(s) to be modified after insertion. In this case the C<insert_shape()> method returns a reference to the inserted shape (the master). This is not very useful for inserting multiple shapes, since the x/y coordinates also gets modified.
  
  =head1 TIPS
  
  Use C<< $worksheet->hide_gridlines(2) >> to prepare a blank canvas without gridlines.
  
  Shapes do not need to fit on one page. Excel will split a large drawing into multiple pages if required. Use the page break preview to show page boundaries superimposed on the drawing.
  
  Connected shapes will auto-locate in Excel if you move either the starting shape or the ending shape separately. However, if you select both shapes (lasso or control-click), the connector will move with it, and the shape adjustments will not re-calculate.
  
  =head1 EXAMPLE
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
      use Excel::Writer::XLSX;
  
      my $workbook  = Excel::Writer::XLSX->new( 'shape.xlsx' );
      my $worksheet = $workbook->add_worksheet();
  
      # Add a default rectangle shape.
      my $rect = $workbook->add_shape();
  
      # Add an ellipse with centered text.
      my $ellipse = $workbook->add_shape(
          type => 'ellipse',
          text => "Hello\nWorld"
      );
  
      # Add a plus shape.
      my $plus = $workbook->add_shape( type => 'plus');
  
      # Insert the shapes in the worksheet.
      $worksheet->insert_shape( 'B3', $rect );
      $worksheet->insert_shape( 'C3', $ellipse );
      $worksheet->insert_shape( 'D3', $plus );
  
  
  See also the C<shapes_*.pl> program in the C<examples> directory of the distro.
  
  =head1 TODO
  
  =over 4
  
  =item * Add shapes which have custom geometries.
  
  =item * Provide better integration of workbook formats for shapes.
  
  =item * Add further validation of shape properties to prevent creation of workbooks that will not open.
  
  =item * Auto connect shapes that are not anchored to cell A1.
  
  =item * Add automatic shape connection to shape vertices besides the object centre.
  
  =item * Improve automatic shape connection to shapes with concave sides (e.g. chevron).
  
  =back
  
  =head1 AUTHOR
  
  Dave Clarke dclarke@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_SHAPE

$fatpacked{"Excel/Writer/XLSX/Utility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_UTILITY';
  package Excel::Writer::XLSX::Utility;
  
  ###############################################################################
  #
  # Utility - Helper functions for Excel::Writer::XLSX.
  #
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use Exporter;
  use warnings;
  use autouse 'Date::Calc'  => qw(Delta_DHMS Decode_Date_EU Decode_Date_US);
  use autouse 'Date::Manip' => qw(ParseDate Date_Init);
  
  our $VERSION = '0.89';
  
  # Row and column functions
  my @rowcol = qw(
    xl_rowcol_to_cell
    xl_cell_to_rowcol
    xl_col_to_name
    xl_range
    xl_range_formula
    xl_inc_row
    xl_dec_row
    xl_inc_col
    xl_dec_col
  );
  
  # Date and Time functions
  my @dates = qw(
    xl_date_list
    xl_date_1904
    xl_parse_time
    xl_parse_date
    xl_parse_date_init
    xl_decode_date_EU
    xl_decode_date_US
  );
  
  our @ISA         = qw(Exporter);
  our @EXPORT_OK   = ();
  our @EXPORT      = ( @rowcol, @dates, 'quote_sheetname' );
  our %EXPORT_TAGS = (
      rowcol => \@rowcol,
      dates  => \@dates
  );
  
  
  ###############################################################################
  #
  # xl_rowcol_to_cell($row, $col, $row_absolute, $col_absolute)
  #
  sub xl_rowcol_to_cell {
  
      my $row     = $_[0] + 1;          # Change from 0-indexed to 1 indexed.
      my $col     = $_[1];
      my $row_abs = $_[2] ? '$' : '';
      my $col_abs = $_[3] ? '$' : '';
  
  
      my $col_str = xl_col_to_name( $col, $col_abs );
  
      return $col_str . $row_abs . $row;
  }
  
  
  ###############################################################################
  #
  # xl_cell_to_rowcol($string)
  #
  # Returns: ($row, $col, $row_absolute, $col_absolute)
  #
  # The $row_absolute and $col_absolute parameters aren't documented because they
  # mainly used internally and aren't very useful to the user.
  #
  sub xl_cell_to_rowcol {
  
      my $cell = shift;
  
      return ( 0, 0, 0, 0 ) unless $cell;
  
      $cell =~ /(\$?)([A-Z]{1,3})(\$?)(\d+)/;
  
      my $col_abs = $1 eq "" ? 0 : 1;
      my $col     = $2;
      my $row_abs = $3 eq "" ? 0 : 1;
      my $row     = $4;
  
      # Convert base26 column string to number
      # All your Base are belong to us.
      my @chars = split //, $col;
      my $expn = 0;
      $col = 0;
  
      while ( @chars ) {
          my $char = pop( @chars );    # LS char first
          $col += ( ord( $char ) - ord( 'A' ) + 1 ) * ( 26**$expn );
          $expn++;
      }
  
      # Convert 1-index to zero-index
      $row--;
      $col--;
  
      return $row, $col, $row_abs, $col_abs;
  }
  
  
  ###############################################################################
  #
  # xl_col_to_name($col, $col_absolute)
  #
  sub xl_col_to_name {
  
      my $col     = $_[0];
      my $col_abs = $_[1] ? '$' : '';
      my $col_str = '';
  
      # Change from 0-indexed to 1 indexed.
      $col++;
  
      while ( $col ) {
  
          # Set remainder from 1 .. 26
          my $remainder = $col % 26 || 26;
  
          # Convert the $remainder to a character. C-ishly.
          my $col_letter = chr( ord( 'A' ) + $remainder - 1 );
  
          # Accumulate the column letters, right to left.
          $col_str = $col_letter . $col_str;
  
          # Get the next order of magnitude.
          $col = int( ( $col - 1 ) / 26 );
      }
  
      return $col_abs . $col_str;
  }
  
  
  ###############################################################################
  #
  # xl_range($row_1, $row_2, $col_1, $col_2, $row_abs_1, $row_abs_2, $col_abs_1, $col_abs_2)
  #
  sub xl_range {
  
      my ( $row_1,     $row_2,     $col_1,     $col_2 )     = @_[ 0 .. 3 ];
      my ( $row_abs_1, $row_abs_2, $col_abs_1, $col_abs_2 ) = @_[ 4 .. 7 ];
  
      my $range1 = xl_rowcol_to_cell( $row_1, $col_1, $row_abs_1, $col_abs_1 );
      my $range2 = xl_rowcol_to_cell( $row_2, $col_2, $row_abs_2, $col_abs_2 );
  
      return $range1 . ':' . $range2;
  }
  
  
  ###############################################################################
  #
  # xl_range_formula($sheetname, $row_1, $row_2, $col_1, $col_2)
  #
  sub xl_range_formula {
  
      my ( $sheetname, $row_1, $row_2, $col_1, $col_2 ) = @_;
  
      $sheetname = quote_sheetname( $sheetname );
  
      my $range = xl_range( $row_1, $row_2, $col_1, $col_2, 1, 1, 1, 1 );
  
      return '=' . $sheetname . '!' . $range
  }
  
  
  ###############################################################################
  #
  # quote_sheetname()
  #
  # Sheetnames used in references should be quoted if they contain any spaces,
  # special characters or if they look like something that isn't a sheet name.
  #
  sub quote_sheetname {
  
      my $sheetname = $_[0];
  
      # Use Excel's conventions and quote the sheet name if it contains any
      # non-word character or if it isn't already quoted.
      if ( $sheetname =~ /\W/ && $sheetname !~ /^'/ ) {
          # Double quote any single quotes.
          $sheetname =~ s/'/''/g;
          $sheetname = q(') . $sheetname . q(');
      }
  
      return $sheetname;
  }
  
  
  ###############################################################################
  #
  # xl_inc_row($string)
  #
  sub xl_inc_row {
  
      my $cell = shift;
      my ( $row, $col, $row_abs, $col_abs ) = xl_cell_to_rowcol( $cell );
  
      return xl_rowcol_to_cell( ++$row, $col, $row_abs, $col_abs );
  }
  
  
  ###############################################################################
  #
  # xl_dec_row($string)
  #
  # Decrements the row number of an Excel cell reference in A1 notation.
  # For example C4 to C3
  #
  # Returns: a cell reference string.
  #
  sub xl_dec_row {
  
      my $cell = shift;
      my ( $row, $col, $row_abs, $col_abs ) = xl_cell_to_rowcol( $cell );
  
      return xl_rowcol_to_cell( --$row, $col, $row_abs, $col_abs );
  }
  
  
  ###############################################################################
  #
  # xl_inc_col($string)
  #
  # Increments the column number of an Excel cell reference in A1 notation.
  # For example C3 to D3
  #
  # Returns: a cell reference string.
  #
  sub xl_inc_col {
  
      my $cell = shift;
      my ( $row, $col, $row_abs, $col_abs ) = xl_cell_to_rowcol( $cell );
  
      return xl_rowcol_to_cell( $row, ++$col, $row_abs, $col_abs );
  }
  
  
  ###############################################################################
  #
  # xl_dec_col($string)
  #
  sub xl_dec_col {
  
      my $cell = shift;
      my ( $row, $col, $row_abs, $col_abs ) = xl_cell_to_rowcol( $cell );
  
      return xl_rowcol_to_cell( $row, --$col, $row_abs, $col_abs );
  }
  
  
  ###############################################################################
  #
  # xl_date_list($years, $months, $days, $hours, $minutes, $seconds)
  #
  sub xl_date_list {
  
      return undef unless @_;
  
      my $years   = $_[0];
      my $months  = $_[1] || 1;
      my $days    = $_[2] || 1;
      my $hours   = $_[3] || 0;
      my $minutes = $_[4] || 0;
      my $seconds = $_[5] || 0;
  
      my @date = ( $years, $months, $days, $hours, $minutes, $seconds );
      my @epoch = ( 1899, 12, 31, 0, 0, 0 );
  
      ( $days, $hours, $minutes, $seconds ) = Delta_DHMS( @epoch, @date );
  
      my $date =
        $days + ( $hours * 3600 + $minutes * 60 + $seconds ) / ( 24 * 60 * 60 );
  
      # Add a day for Excel's missing leap day in 1900
      $date++ if ( $date > 59 );
  
      return $date;
  }
  
  
  ###############################################################################
  #
  # xl_parse_time($string)
  #
  sub xl_parse_time {
  
      my $time = shift;
  
      if ( $time =~ /(\d+):(\d\d):?((?:\d\d)(?:\.\d+)?)?(?:\s+)?(am|pm)?/i ) {
  
          my $hours    = $1;
          my $minutes  = $2;
          my $seconds  = $3 || 0;
          my $meridian = lc( $4 || '' );
  
          # Normalise midnight and midday
          $hours = 0 if ( $hours == 12 && $meridian ne '' );
  
          # Add 12 hours to the pm times. Note: 12.00 pm has been set to 0.00.
          $hours += 12 if $meridian eq 'pm';
  
          # Calculate the time as a fraction of 24 hours in seconds
          return ( $hours * 3600 + $minutes * 60 + $seconds ) / ( 24 * 60 * 60 );
  
      }
      else {
          return undef;    # Not a valid time string
      }
  }
  
  
  ###############################################################################
  #
  # xl_parse_date($string)
  #
  sub xl_parse_date {
  
      my $date = ParseDate( $_[0] );
  
      # Unpack the return value from ParseDate()
      my ( $years, $months, $days, $hours, undef, $minutes, undef, $seconds ) =
        unpack( "A4     A2      A2     A2      C        A2      C       A2",
          $date );
  
      # Convert to Excel date
      return xl_date_list( $years, $months, $days, $hours, $minutes, $seconds );
  }
  
  
  ###############################################################################
  #
  # xl_parse_date_init("variable=value", ...)
  #
  sub xl_parse_date_init {
  
      Date_Init( @_ );    # How lazy is that.
  }
  
  
  ###############################################################################
  #
  # xl_decode_date_EU($string)
  #
  sub xl_decode_date_EU {
  
      return undef unless @_;
  
      my $date = shift;
      my @date;
      my $time = 0;
  
      # Remove and decode the time portion of the string
      if ( $date =~ s/(\d+:\d\d:?(\d\d(\.\d+)?)?(\s+)?(am|pm)?)//i ) {
          $time = xl_parse_time( $1 );
      }
  
      # Return if the string is now blank, i.e. it contained a time only.
      return $time if $date =~ /^\s*$/;
  
      # Decode the date portion of the string
      @date = Decode_Date_EU( $date );
      return undef unless @date;
  
      return xl_date_list( @date ) + $time;
  }
  
  
  ###############################################################################
  #
  # xl_decode_date_US($string)
  #
  sub xl_decode_date_US {
  
      return undef unless @_;
  
      my $date = shift;
      my @date;
      my $time = 0;
  
      # Remove and decode the time portion of the string
      if ( $date =~ s/(\d+:\d\d:?(\d\d(\.\d+)?)?(\s+)?(am|pm)?)//i ) {
          $time = xl_parse_time( $1 );
      }
  
      # Return if the string is now blank, i.e. it contained a time only.
      return $time if $date =~ /^\s*$/;
  
      # Decode the date portion of the string
      @date = Decode_Date_US( $date );
      return undef unless @date;
  
      return xl_date_list( @date ) + $time;
  }
  
  
  ###############################################################################
  #
  # xl_decode_date_US($string)
  #
  sub xl_date_1904 {
  
      my $date = $_[0] || 0;
  
      if ( $date < 1462 ) {
  
          # before 1904
          $date = 0;
      }
      else {
          $date -= 1462;
      }
  
      return $date;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Utility - Helper functions for L<Excel::Writer::XLSX>.
  
  =head1 SYNOPSIS
  
  Functions to help with some common tasks when using L<Excel::Writer::XLSX>.
  
  These functions mainly relate to dealing with rows and columns in A1 notation and to handling dates and times.
  
      use Excel::Writer::XLSX::Utility;                     # Import everything
  
      ($row, $col)    = xl_cell_to_rowcol( 'C2' );          # (1, 2)
      $str            = xl_rowcol_to_cell( 1, 2 );          # C2
      $str            = xl_col_to_name( 702 );              # AAA
      $str            = xl_inc_col( 'Z1'  );                # AA1
      $str            = xl_dec_col( 'AA1' );                # Z1
  
      $date           = xl_date_list(2002, 1, 1);           # 37257
      $date           = xl_parse_date( '11 July 1997' );    # 35622
      $time           = xl_parse_time( '3:21:36 PM' );      # 0.64
      $date           = xl_decode_date_EU( '13 May 2002' ); # 37389
  
  =head1 DESCRIPTION
  
  This module provides a set of functions to help with some common tasks encountered when using the L<Excel::Writer::XLSX> module. The two main categories of function are:
  
  Row and column functions: these are used to deal with Excel's A1 representation of cells. The functions in this category are:
  
      xl_rowcol_to_cell
      xl_cell_to_rowcol
      xl_col_to_name
      xl_range
      xl_range_formula
      xl_inc_row
      xl_dec_row
      xl_inc_col
      xl_dec_col
  
  Date and Time functions: these are used to convert dates and times to the numeric format used by Excel. The functions in this category are:
  
      xl_date_list
      xl_date_1904
      xl_parse_time
      xl_parse_date
      xl_parse_date_init
      xl_decode_date_EU
      xl_decode_date_US
  
  All of these functions are exported by default. However, you can use import lists if you wish to limit the functions that are imported:
  
      use Excel::Writer::XLSX::Utility;                  # Import everything
      use Excel::Writer::XLSX::Utility qw(xl_date_list); # xl_date_list only
      use Excel::Writer::XLSX::Utility qw(:rowcol);      # Row/col functions
      use Excel::Writer::XLSX::Utility qw(:dates);       # Date functions
  
  =head1 ROW AND COLUMN FUNCTIONS
  
  L<Excel::Writer::XLSX> supports two forms of notation to designate the position of cells: Row-column notation and A1 notation.
  
  Row-column notation uses a zero based index for both row and column while A1 notation uses the standard Excel alphanumeric sequence of column letter and 1-based row. Columns range from A to XFD, i.e. 0 to 16,383, rows range from 0 to 1,048,575 in Excel 2007+. For example:
  
      (0, 0)      # The top left cell in row-column notation.
      ('A1')      # The top left cell in A1 notation.
  
      (1999, 29)  # Row-column notation.
      ('AD2000')  # The same cell in A1 notation.
  
  Row-column notation is useful if you are referring to cells programmatically:
  
      for my $i ( 0 .. 9 ) {
          $worksheet->write( $i, 0, 'Hello' );    # Cells A1 to A10
      }
  
  A1 notation is useful for setting up a worksheet manually and for working with formulas:
  
      $worksheet->write( 'H1', 200 );
      $worksheet->write( 'H2', '=H7+1' );
  
  The functions in the following sections can be used for dealing with A1 notation, for example:
  
      ( $row, $col ) = xl_cell_to_rowcol('C2');    # (1, 2)
      $str           = xl_rowcol_to_cell( 1, 2 );  # C2
  
  
  Cell references in Excel can be either relative or absolute. Absolute references are prefixed by the dollar symbol as shown below:
  
      A1      # Column and row are relative
      $A1     # Column is absolute and row is relative
      A$1     # Column is relative and row is absolute
      $A$1    # Column and row are absolute
  
  An absolute reference only makes a difference if the cell is copied. Refer to the Excel documentation for further details. All of the following functions support absolute references.
  
  =head2 xl_rowcol_to_cell($row, $col, $row_absolute, $col_absolute)
  
      Parameters: $row:           Integer
                  $col:           Integer
                  $row_absolute:  Boolean (1/0) [optional, default is 0]
                  $col_absolute:  Boolean (1/0) [optional, default is 0]
  
      Returns:    A string in A1 cell notation
  
  
  This function converts a zero based row and column cell reference to a A1 style string:
  
      $str = xl_rowcol_to_cell( 0, 0 );    # A1
      $str = xl_rowcol_to_cell( 0, 1 );    # B1
      $str = xl_rowcol_to_cell( 1, 0 );    # A2
  
  
  The optional parameters C<$row_absolute> and C<$col_absolute> can be used to indicate if the row or column is absolute:
  
      $str = xl_rowcol_to_cell( 0, 0, 0, 1 );    # $A1
      $str = xl_rowcol_to_cell( 0, 0, 1, 0 );    # A$1
      $str = xl_rowcol_to_cell( 0, 0, 1, 1 );    # $A$1
  
  See above for an explanation of absolute cell references.
  
  =head2 xl_cell_to_rowcol($string)
  
  
      Parameters: $string         String in A1 format
  
      Returns:    List            ($row, $col)
  
  This function converts an Excel cell reference in A1 notation to a zero based row and column. The function will also handle Excel's absolute, C<$>, cell notation.
  
      my ( $row, $col ) = xl_cell_to_rowcol('A1');      # (0, 0)
      my ( $row, $col ) = xl_cell_to_rowcol('B1');      # (0, 1)
      my ( $row, $col ) = xl_cell_to_rowcol('C2');      # (1, 2)
      my ( $row, $col ) = xl_cell_to_rowcol('$C2');     # (1, 2)
      my ( $row, $col ) = xl_cell_to_rowcol('C$2');     # (1, 2)
      my ( $row, $col ) = xl_cell_to_rowcol('$C$2');    # (1, 2)
  
  =head2 xl_col_to_name($col, $col_absolute)
  
      Parameters: $col:           Integer
                  $col_absolute:  Boolean (1/0) [optional, default is 0]
  
      Returns:    A column string name.
  
  
  This function converts a zero based column reference to a string:
  
      $str = xl_col_to_name(0);      # A
      $str = xl_col_to_name(1);      # B
      $str = xl_col_to_name(702);    # AAA
  
  
  The optional parameter C<$col_absolute> can be used to indicate if the column is absolute:
  
      $str = xl_col_to_name( 0, 0 );    # A
      $str = xl_col_to_name( 0, 1 );    # $A
      $str = xl_col_to_name( 1, 1 );    # $B
  
  =head2 xl_range($row_1, $row_2, $col_1, $col_2, $row_abs_1, $row_abs_2, $col_abs_1, $col_abs_2)
  
      Parameters: $sheetname      String
                  $row_1:         Integer
                  $row_2:         Integer
                  $col_1:         Integer
                  $col_2:         Integer
                  $row_abs_1:     Boolean (1/0) [optional, default is 0]
                  $row_abs_2:     Boolean (1/0) [optional, default is 0]
                  $col_abs_1:     Boolean (1/0) [optional, default is 0]
                  $col_abs_2:     Boolean (1/0) [optional, default is 0]
  
      Returns:    A worksheet range formula as a string.
  
  This function converts zero based row and column cell references to an A1 style range string:
  
      my $str = xl_range( 0, 9, 0, 0 );          # A1:A10
      my $str = xl_range( 1, 8, 2, 2 );          # C2:C9
      my $str = xl_range( 0, 3, 0, 4 );          # A1:E4
      my $str = xl_range( 0, 3, 0, 4, 1 );       # A$1:E4
      my $str = xl_range( 0, 3, 0, 4, 1, 1 );    # A$1:E$4
  
  =head2 xl_range_formula($sheetname, $row_1, $row_2, $col_1, $col_2)
  
      Parameters: $sheetname      String
                  $row_1:         Integer
                  $row_2:         Integer
                  $col_1:         Integer
                  $col_2:         Integer
  
      Returns:    A worksheet range formula as a string.
  
  This function converts zero based row and column cell references to an A1 style formula string:
  
      my $str = xl_range_formula( 'Sheet1', 0, 9,  0, 0 ); # =Sheet1!$A$1:$A$10
      my $str = xl_range_formula( 'Sheet2', 6, 65, 1, 1 ); # =Sheet2!$B$7:$B$66
      my $str = xl_range_formula( 'New data', 1, 8, 2, 2 );# ='New data'!$C$2:$C$9
  
  This is useful for setting ranges in Chart objects:
  
      $chart->add_series(
          categories => xl_range_formula( 'Sheet1', 1, 9, 0, 0 ),
          values     => xl_range_formula( 'Sheet1', 1, 9, 1, 1 ),
      );
  
      # Which is the same as:
  
      $chart->add_series(
          categories => '=Sheet1!$A$2:$A$10',
          values     => '=Sheet1!$B$2:$B$10',
      );
  
  =head2 xl_inc_row($string)
  
  
      Parameters: $string, a string in A1 format
  
      Returns:    Incremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and increments the row. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_inc_row( 'A1' );      # A2
      my $str = xl_inc_row( 'B$2' );     # B$3
      my $str = xl_inc_row( '$C3' );     # $C4
      my $str = xl_inc_row( '$D$4' );    # $D$5
  
  =head2 xl_dec_row($string)
  
  
      Parameters: $string, a string in A1 format
  
      Returns:    Decremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and decrements the row. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_dec_row( 'A2' );      # A1
      my $str = xl_dec_row( 'B$3' );     # B$2
      my $str = xl_dec_row( '$C4' );     # $C3
      my $str = xl_dec_row( '$D$5' );    # $D$4
  
  =head2 xl_inc_col($string)
  
  
      Parameters: $string, a string in A1 format
  
      Returns:    Incremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and increments the column. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_inc_col( 'A1' );      # B1
      my $str = xl_inc_col( 'Z1' );      # AA1
      my $str = xl_inc_col( '$B1' );     # $C1
      my $str = xl_inc_col( '$D$5' );    # $E$5
  
  =head2 xl_dec_col($string)
  
      Parameters: $string, a string in A1 format
  
      Returns:    Decremented string in A1 format
  
  This functions takes a cell reference string in A1 notation and decrements the column. The function will also handle Excel's absolute, C<$>, cell notation:
  
      my $str = xl_dec_col( 'B1' );      # A1
      my $str = xl_dec_col( 'AA1' );     # Z1
      my $str = xl_dec_col( '$C1' );     # $B1
      my $str = xl_dec_col( '$E$5' );    # $D$5
  
  =head1 TIME AND DATE FUNCTIONS
  
  Dates and times in Excel are represented by real numbers, for example "Jan 1 2001 12:30 AM" is represented by the number 36892.521.
  
  The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day in seconds.
  
  A date or time in Excel is like any other number. To display the number as a date you must apply a number format to it: Refer to the C<set_num_format()> method in the Excel::Writer::XLSX documentation:
  
      $date = xl_date_list( 2001, 1, 1, 12, 30 );
      $format->set_num_format( 'mmm d yyyy hh:mm AM/PM' );
      $worksheet->write( 'A1', $date, $format );    # Jan 1 2001 12:30 AM
  
  The date handling functions below are supplied for historical reasons. In the current version of the module it is easier to just use the C<write_date_time()> function to write dates or times. See the DATES AND TIME IN EXCEL section of the main L<Excel::Writer::XLSX> documentation for details.
  
  In addition to using the functions below you must install the L<Date::Manip> and L<Date::Calc> modules. See L<REQUIREMENTS> and the individual requirements of each functions.
  
  For a C<DateTime.pm> solution see the L<DateTime::Format::Excel> module.
  
  =head2 xl_date_list($years, $months, $days, $hours, $minutes, $seconds)
  
  
      Parameters: $years:         Integer
                  $months:        Integer [optional, default is 1]
                  $days:          Integer [optional, default is 1]
                  $hours:         Integer [optional, default is 0]
                  $minutes:       Integer [optional, default is 0]
                  $seconds:       Float   [optional, default is 0]
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Calc
  
  This function converts an array of data into a number that represents an Excel date. All of the parameters are optional except for C<$years>.
  
      $date1 = xl_date_list( 2002, 1, 2 );                # 2 Jan 2002
      $date2 = xl_date_list( 2002, 1, 2, 12 );            # 2 Jan 2002 12:00 pm
      $date3 = xl_date_list( 2002, 1, 2, 12, 30 );        # 2 Jan 2002 12:30 pm
      $date4 = xl_date_list( 2002, 1, 2, 12, 30, 45 );    # 2 Jan 2002 12:30:45 pm
  
  This function can be used in conjunction with functions that parse date and time strings. In fact it is used in most of the following functions.
  
  =head2 xl_parse_time($string)
  
  
      Parameters: $string, a textual representation of a time
  
      Returns:    A number that represents an Excel time
                  or undef for an invalid time.
  
  This function converts a time string into a number that represents an Excel time. The following time formats are valid:
  
      hh:mm       [AM|PM]
      hh:mm       [AM|PM]
      hh:mm:ss    [AM|PM]
      hh:mm:ss.ss [AM|PM]
  
  
  The meridian, AM or PM, is optional and case insensitive. A 24 hour time is assumed if the meridian is omitted.
  
      $time1 = xl_parse_time( '12:18' );
      $time2 = xl_parse_time( '12:18:14' );
      $time3 = xl_parse_time( '12:18:14 AM' );
      $time4 = xl_parse_time( '1:18:14 AM' );
  
  Time in Excel is expressed as a fraction of the day in seconds. Therefore you can calculate an Excel time as follows:
  
      $time = ( $hours * 3600 + $minutes * 60 + $seconds ) / ( 24 * 60 * 60 );
  
  =head2 xl_parse_date($string)
  
  
      Parameters: $string, a textual representation of a date and time
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Manip and Date::Calc
  
  This function converts a date and time string into a number that represents an Excel date.
  
  The parsing is performed using the C<ParseDate()> function of the L<Date::Manip> module. Refer to the C<Date::Manip> documentation for further information about the date and time formats that can be parsed. In order to use this function you will probably have to initialise some C<Date::Manip> variables via the C<xl_parse_date_init()> function, see below.
  
      xl_parse_date_init( "TZ=GMT", "DateFormat=non-US" );
  
      $date1 = xl_parse_date( "11/7/97" );
      $date2 = xl_parse_date( "Friday 11 July 1997" );
      $date3 = xl_parse_date( "10:30 AM Friday 11 July 1997" );
      $date4 = xl_parse_date( "Today" );
      $date5 = xl_parse_date( "Yesterday" );
  
  Note, if you parse a string that represents a time but not a date this function will add the current date. If you want the time without the date you can do something like the following:
  
      $time  = xl_parse_date( "10:30 AM" );
      $time -= int( $time );
  
  =head2 xl_parse_date_init("variable=value", ...)
  
  
      Parameters: A list of Date::Manip variable strings
  
      Returns:    A list of all the Date::Manip strings
  
      Requires:   Date::Manip
  
  This function is used to initialise variables required by the L<Date::Manip> module. You should call this function before calling C<xl_parse_date()>. It need only be called once.
  
  This function is a thin wrapper for the C<Date::Manip::Date_Init()> function. You can use C<Date_Init()>  directly if you wish. Refer to the C<Date::Manip> documentation for further information.
  
      xl_parse_date_init( "TZ=MST", "DateFormat=US" );
      $date1 = xl_parse_date( "11/7/97" );    # November 7th 1997
  
      xl_parse_date_init( "TZ=GMT", "DateFormat=non-US" );
      $date1 = xl_parse_date( "11/7/97" );    # July 11th 1997
  
  =head2 xl_decode_date_EU($string)
  
  
      Parameters: $string, a textual representation of a date and time
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Calc
  
  This function converts a date and time string into a number that represents an Excel date.
  
  The date parsing is performed using the C<Decode_Date_EU()> function of the L<Date::Calc> module. Refer to the C<Date::Calc> documentation for further information about the date formats that can be parsed. Also note the following from the C<Date::Calc> documentation:
  
  "If the year is given as one or two digits only (i.e., if the year is less than 100), it is mapped to the window 1970 -2069 as follows:"
  
       0 <= $year <  70  ==>  $year += 2000;
      70 <= $year < 100  ==>  $year += 1900;
  
  The time portion of the string is parsed using the C<xl_parse_time()> function described above.
  
  Note: the EU in the function name means that a European date format is assumed if it is not clear from the string. See the first example below.
  
      $date1 = xl_decode_date_EU( "11/7/97" );                    #11 July 1997
      $date2 = xl_decode_date_EU( "Sat 12 Sept 1998" );
      $date3 = xl_decode_date_EU( "4:30 AM Sat 12 Sept 1998" );
  
  =head2 xl_decode_date_US($string)
  
  
      Parameters: $string, a textual representation of a date and time
  
      Returns:    A number that represents an Excel date
                  or undef for an invalid date.
  
      Requires:   Date::Calc
  
  This function converts a date and time string into a number that represents an Excel date.
  
  The date parsing is performed using the C<Decode_Date_US()> function of the L<Date::Calc> module. Refer to the C<Date::Calc> documentation for further information about the date formats that can be parsed. Also note the following from the C<Date::Calc> documentation:
  
  "If the year is given as one or two digits only (i.e., if the year is less than 100), it is mapped to the window 1970 -2069 as follows:"
  
       0 <= $year <  70  ==>  $year += 2000;
      70 <= $year < 100  ==>  $year += 1900;
  
  The time portion of the string is parsed using the C<xl_parse_time()> function described above.
  
  Note: the US in the function name means that an American date format is assumed if it is not clear from the string. See the first example below.
  
      $date1 = xl_decode_date_US( "11/7/97" );                 # 7 November 1997
      $date2 = xl_decode_date_US( "Sept 12 Saturday 1998" );
      $date3 = xl_decode_date_US( "4:30 AM Sept 12 Sat 1998" );
  
  =head2 xl_date_1904($date)
  
  
      Parameters: $date, an Excel date with a 1900 epoch
  
      Returns:    an Excel date with a 1904 epoch or zero if
                  the $date is before 1904
  
  
  This function converts an Excel date based on the 1900 epoch into a date based on the 1904 epoch.
  
      $date1 = xl_date_list( 2002, 1, 13 );    # 13 Jan 2002, 1900 epoch
      $date2 = xl_date_1904( $date1 );         # 13 Jan 2002, 1904 epoch
  
  See also the C<set_1904()> workbook method in the L<Excel::Writer::XLSX> documentation.
  
  =head1 REQUIREMENTS
  
  The date and time functions require functions from the L<Date::Manip> and L<Date::Calc> modules. The required functions are "autoused" from these modules so that you do not have to install them unless you wish to use the date and time routines. Therefore it is possible to use the row and column functions without having C<Date::Manip> and C<Date::Calc> installed.
  
  For more information about "autousing" refer to the documentation on the C<autouse> pragma.
  
  =head1 BUGS
  
  When using the autoused functions from C<Date::Manip> and C<Date::Calc> on Perl 5.6.0 with C<-w> you will get a warning like this:
  
      "Subroutine xxx redefined ..."
  
  The current workaround for this is to put C<use warnings;> near the beginning of your program.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
  
EXCEL_WRITER_XLSX_UTILITY

$fatpacked{"Excel/Writer/XLSX/Workbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_WORKBOOK';
  package Excel::Writer::XLSX::Workbook;
  
  ###############################################################################
  #
  # Workbook - A class for writing Excel Workbooks.
  #
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use IO::File;
  use File::Find;
  use File::Temp qw(tempfile);
  use File::Basename 'fileparse';
  use Archive::Zip;
  use Excel::Writer::XLSX::Worksheet;
  use Excel::Writer::XLSX::Chartsheet;
  use Excel::Writer::XLSX::Format;
  use Excel::Writer::XLSX::Shape;
  use Excel::Writer::XLSX::Chart;
  use Excel::Writer::XLSX::Package::Packager;
  use Excel::Writer::XLSX::Package::XMLwriter;
  use Excel::Writer::XLSX::Utility qw(xl_cell_to_rowcol xl_rowcol_to_cell);
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class = shift;
      my $self  = Excel::Writer::XLSX::Package::XMLwriter->new();
  
      $self->{_filename} = $_[0] || '';
      my $options = $_[1] || {};
  
      $self->{_tempdir}            = undef;
      $self->{_date_1904}          = 0;
      $self->{_activesheet}        = 0;
      $self->{_firstsheet}         = 0;
      $self->{_selected}           = 0;
      $self->{_fileclosed}         = 0;
      $self->{_filehandle}         = undef;
      $self->{_internal_fh}        = 0;
      $self->{_sheet_name}         = 'Sheet';
      $self->{_chart_name}         = 'Chart';
      $self->{_sheetname_count}    = 0;
      $self->{_chartname_count}    = 0;
      $self->{_worksheets}         = [];
      $self->{_charts}             = [];
      $self->{_drawings}           = [];
      $self->{_sheetnames}         = [];
      $self->{_formats}            = [];
      $self->{_xf_formats}         = [];
      $self->{_xf_format_indices}  = {};
      $self->{_dxf_formats}        = [];
      $self->{_dxf_format_indices} = {};
      $self->{_palette}            = [];
      $self->{_font_count}         = 0;
      $self->{_num_format_count}   = 0;
      $self->{_defined_names}      = [];
      $self->{_named_ranges}       = [];
      $self->{_custom_colors}      = [];
      $self->{_doc_properties}     = {};
      $self->{_localtime}          = [ localtime() ];
      $self->{_num_vml_files}      = 0;
      $self->{_num_comment_files}  = 0;
      $self->{_optimization}       = 0;
      $self->{_x_window}           = 240;
      $self->{_y_window}           = 15;
      $self->{_window_width}       = 16095;
      $self->{_window_height}      = 9660;
      $self->{_tab_ratio}          = 500;
      $self->{_excel2003_style}    = 0;
  
      $self->{_default_format_properties} = {};
  
      if ( exists $options->{tempdir} ) {
          $self->{_tempdir} = $options->{tempdir};
      }
  
      if ( exists $options->{date_1904} ) {
          $self->{_date_1904} = $options->{date_1904};
      }
  
      if ( exists $options->{optimization} ) {
          $self->{_optimization} = $options->{optimization};
      }
  
      if ( exists $options->{default_format_properties} ) {
          $self->{_default_format_properties} =
            $options->{default_format_properties};
      }
  
      if ( exists $options->{excel2003_style} ) {
          $self->{_excel2003_style} = 1;
      }
  
      # Structures for the shared strings data.
      $self->{_str_total}  = 0;
      $self->{_str_unique} = 0;
      $self->{_str_table}  = {};
      $self->{_str_array}  = [];
  
      # Formula calculation default settings.
      $self->{_calc_id}      = 124519;
      $self->{_calc_mode}    = 'auto';
      $self->{_calc_on_load} = 1;
  
  
      bless $self, $class;
  
      # Add the default cell format.
      if ( $self->{_excel2003_style} ) {
          $self->add_format( xf_index => 0, font_family => 0 );
      }
      else {
          $self->add_format( xf_index => 0 );
      }
  
      # Check for a filename unless it is an existing filehandle
      if ( not ref $self->{_filename} and $self->{_filename} eq '' ) {
          carp 'Filename required by Excel::Writer::XLSX->new()';
          return undef;
      }
  
  
      # If filename is a reference we assume that it is a valid filehandle.
      if ( ref $self->{_filename} ) {
  
          $self->{_filehandle}  = $self->{_filename};
          $self->{_internal_fh} = 0;
      }
      elsif ( $self->{_filename} eq '-' ) {
  
          # Support special filename/filehandle '-' for backward compatibility.
          binmode STDOUT;
          $self->{_filehandle}  = \*STDOUT;
          $self->{_internal_fh} = 0;
      }
      else {
          my $fh = IO::File->new( $self->{_filename}, 'w' );
  
          return undef unless defined $fh;
  
          $self->{_filehandle}  = $fh;
          $self->{_internal_fh} = 1;
      }
  
  
      # Set colour palette.
      $self->set_color_palette();
  
      return $self;
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      # Prepare format object for passing to Style.pm.
      $self->_prepare_format_properties();
  
      $self->xml_declaration;
  
      # Write the root workbook element.
      $self->_write_workbook();
  
      # Write the XLSX file version.
      $self->_write_file_version();
  
      # Write the workbook properties.
      $self->_write_workbook_pr();
  
      # Write the workbook view properties.
      $self->_write_book_views();
  
      # Write the worksheet names and ids.
      $self->_write_sheets();
  
      # Write the workbook defined names.
      $self->_write_defined_names();
  
      # Write the workbook calculation properties.
      $self->_write_calc_pr();
  
      # Write the workbook extension storage.
      #$self->_write_ext_lst();
  
      # Close the workbook tag.
      $self->xml_end_tag( 'workbook' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # close()
  #
  # Calls finalization methods.
  #
  sub close {
  
      my $self = shift;
  
      # In case close() is called twice, by user and by DESTROY.
      return if $self->{_fileclosed};
  
      # Test filehandle in case new() failed and the user didn't check.
      return undef if !defined $self->{_filehandle};
  
      $self->{_fileclosed} = 1;
      $self->_store_workbook();
  
      # Return the file close value.
      if ( $self->{_internal_fh} ) {
          return $self->{_filehandle}->close();
      }
      else {
          # Return true and let users deal with their own filehandles.
          return 1;
      }
  }
  
  
  ###############################################################################
  #
  # DESTROY()
  #
  # Close the workbook if it hasn't already been explicitly closed.
  #
  sub DESTROY {
  
      my $self = shift;
  
      local ( $@, $!, $^E, $? );
  
      $self->close() if not $self->{_fileclosed};
  }
  
  
  ###############################################################################
  #
  # sheets(slice,...)
  #
  # An accessor for the _worksheets[] array
  #
  # Returns: an optionally sliced list of the worksheet objects in a workbook.
  #
  sub sheets {
  
      my $self = shift;
  
      if ( @_ ) {
  
          # Return a slice of the array
          return @{ $self->{_worksheets} }[@_];
      }
      else {
  
          # Return the entire list
          return @{ $self->{_worksheets} };
      }
  }
  
  
  ###############################################################################
  #
  # worksheets()
  #
  # An accessor for the _worksheets[] array.
  # This method is now deprecated. Use the sheets() method instead.
  #
  # Returns: an array reference
  #
  sub worksheets {
  
      my $self = shift;
  
      return $self->{_worksheets};
  }
  
  
  ###############################################################################
  #
  # add_worksheet($name)
  #
  # Add a new worksheet to the Excel workbook.
  #
  # Returns: reference to a worksheet object
  #
  sub add_worksheet {
  
      my $self  = shift;
      my $index = @{ $self->{_worksheets} };
      my $name  = $self->_check_sheetname( $_[0] );
      my $fh    = undef;
  
      # Porters take note, the following scheme of passing references to Workbook
      # data (in the \$self->{_foo} cases) instead of a reference to the Workbook
      # itself is a workaround to avoid circular references between Workbook and
      # Worksheet objects. Feel free to implement this in any way the suits your
      # language.
      #
      my @init_data = (
          $fh,
          $name,
          $index,
  
          \$self->{_activesheet},
          \$self->{_firstsheet},
  
          \$self->{_str_total},
          \$self->{_str_unique},
          \$self->{_str_table},
  
          $self->{_date_1904},
          $self->{_palette},
          $self->{_optimization},
          $self->{_tempdir},
          $self->{_excel2003_style},
  
      );
  
      my $worksheet = Excel::Writer::XLSX::Worksheet->new( @init_data );
      $self->{_worksheets}->[$index] = $worksheet;
      $self->{_sheetnames}->[$index] = $name;
  
      return $worksheet;
  }
  
  
  ###############################################################################
  #
  # add_chart( %args )
  #
  # Create a chart for embedding or as a new sheet.
  #
  sub add_chart {
  
      my $self  = shift;
      my %arg   = @_;
      my $name  = '';
      my $index = @{ $self->{_worksheets} };
      my $fh    = undef;
  
      # Type must be specified so we can create the required chart instance.
      my $type = $arg{type};
      if ( !defined $type ) {
          croak "Must define chart type in add_chart()";
      }
  
      # Ensure that the chart defaults to non embedded.
      my $embedded = $arg{embedded} || 0;
  
      # Check the worksheet name for non-embedded charts.
      if ( !$embedded ) {
          $name = $self->_check_sheetname( $arg{name}, 1 );
      }
  
  
      my @init_data = (
  
          $fh,
          $name,
          $index,
  
          \$self->{_activesheet},
          \$self->{_firstsheet},
  
          \$self->{_str_total},
          \$self->{_str_unique},
          \$self->{_str_table},
  
          $self->{_date_1904},
          $self->{_palette},
          $self->{_optimization},
      );
  
  
      my $chart = Excel::Writer::XLSX::Chart->factory( $type, $arg{subtype} );
  
      # If the chart isn't embedded let the workbook control it.
      if ( !$embedded ) {
  
          my $drawing    = Excel::Writer::XLSX::Drawing->new();
          my $chartsheet = Excel::Writer::XLSX::Chartsheet->new( @init_data );
  
          $chart->{_palette} = $self->{_palette};
  
          $chartsheet->{_chart}   = $chart;
          $chartsheet->{_drawing} = $drawing;
  
          $self->{_worksheets}->[$index] = $chartsheet;
          $self->{_sheetnames}->[$index] = $name;
  
          push @{ $self->{_charts} }, $chart;
  
          return $chartsheet;
      }
      else {
  
          # Set the embedded chart name if present.
          $chart->{_chart_name} = $arg{name} if $arg{name};
  
          # Set index to 0 so that the activate() and set_first_sheet() methods
          # point back to the first worksheet if used for embedded charts.
          $chart->{_index}   = 0;
          $chart->{_palette} = $self->{_palette};
          $chart->_set_embedded_config_data();
          push @{ $self->{_charts} }, $chart;
  
          return $chart;
      }
  
  }
  
  
  ###############################################################################
  #
  # _check_sheetname( $name )
  #
  # Check for valid worksheet names. We check the length, if it contains any
  # invalid characters and if the name is unique in the workbook.
  #
  sub _check_sheetname {
  
      my $self         = shift;
      my $name         = shift || "";
      my $chart        = shift || 0;
      my $invalid_char = qr([\[\]:*?/\\]);
  
      # Increment the Sheet/Chart number used for default sheet names below.
      if ( $chart ) {
          $self->{_chartname_count}++;
      }
      else {
          $self->{_sheetname_count}++;
      }
  
      # Supply default Sheet/Chart name if none has been defined.
      if ( $name eq "" ) {
  
          if ( $chart ) {
              $name = $self->{_chart_name} . $self->{_chartname_count};
          }
          else {
              $name = $self->{_sheet_name} . $self->{_sheetname_count};
          }
      }
  
      # Check that sheet name is <= 31. Excel limit.
      croak "Sheetname $name must be <= 31 chars" if length $name > 31;
  
      # Check that sheetname doesn't contain any invalid characters
      if ( $name =~ $invalid_char ) {
          croak 'Invalid character []:*?/\\ in worksheet name: ' . $name;
      }
  
      # Check that the worksheet name doesn't already exist since this is a fatal
      # error in Excel 97. The check must also exclude case insensitive matches.
      foreach my $worksheet ( @{ $self->{_worksheets} } ) {
          my $name_a = $name;
          my $name_b = $worksheet->{_name};
  
          if ( lc( $name_a ) eq lc( $name_b ) ) {
              croak "Worksheet name '$name', with case ignored, is already used.";
          }
      }
  
      return $name;
  }
  
  
  ###############################################################################
  #
  # add_format(%properties)
  #
  # Add a new format to the Excel workbook.
  #
  sub add_format {
  
      my $self = shift;
  
      my @init_data =
        ( \$self->{_xf_format_indices}, \$self->{_dxf_format_indices} );
  
      # Change default format style for Excel2003/XLS format.
      if ( $self->{_excel2003_style} ) {
          push @init_data, ( font => 'Arial', size => 10, theme => -1 );
      }
  
      # Add the default format properties.
      push @init_data, %{ $self->{_default_format_properties} };
  
      # Add the user defined properties.
      push @init_data, @_;
  
      my $format = Excel::Writer::XLSX::Format->new( @init_data );
  
      push @{ $self->{_formats} }, $format;    # Store format reference
  
      return $format;
  }
  
  
  ###############################################################################
  #
  # add_shape(%properties)
  #
  # Add a new shape to the Excel workbook.
  #
  sub add_shape {
  
      my $self  = shift;
      my $fh    = undef;
      my $shape = Excel::Writer::XLSX::Shape->new( $fh, @_ );
  
      $shape->{_palette} = $self->{_palette};
  
  
      push @{ $self->{_shapes} }, $shape;    # Store shape reference.
  
      return $shape;
  }
  
  ###############################################################################
  #
  # set_1904()
  #
  # Set the date system: 0 = 1900 (the default), 1 = 1904
  #
  sub set_1904 {
  
      my $self = shift;
  
      if ( defined( $_[0] ) ) {
          $self->{_date_1904} = $_[0];
      }
      else {
          $self->{_date_1904} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # get_1904()
  #
  # Return the date system: 0 = 1900, 1 = 1904
  #
  sub get_1904 {
  
      my $self = shift;
  
      return $self->{_date_1904};
  }
  
  
  ###############################################################################
  #
  # set_custom_color()
  #
  # Change the RGB components of the elements in the colour palette.
  #
  sub set_custom_color {
  
      my $self = shift;
  
  
      # Match a HTML #xxyyzz style parameter
      if ( defined $_[1] and $_[1] =~ /^#(\w\w)(\w\w)(\w\w)/ ) {
          @_ = ( $_[0], hex $1, hex $2, hex $3 );
      }
  
  
      my $index = $_[0] || 0;
      my $red   = $_[1] || 0;
      my $green = $_[2] || 0;
      my $blue  = $_[3] || 0;
  
      my $aref = $self->{_palette};
  
      # Check that the colour index is the right range
      if ( $index < 8 or $index > 64 ) {
          carp "Color index $index outside range: 8 <= index <= 64";
          return 0;
      }
  
      # Check that the colour components are in the right range
      if (   ( $red < 0 or $red > 255 )
          || ( $green < 0 or $green > 255 )
          || ( $blue < 0  or $blue > 255 ) )
      {
          carp "Color component outside range: 0 <= color <= 255";
          return 0;
      }
  
      $index -= 8;    # Adjust colour index (wingless dragonfly)
  
      # Set the RGB value.
      my @rgb = ( $red, $green, $blue );
      $aref->[$index] = [@rgb];
  
      # Store the custom colors for the style.xml file.
      push @{ $self->{_custom_colors} }, sprintf "FF%02X%02X%02X", @rgb;
  
      return $index + 8;
  }
  
  
  ###############################################################################
  #
  # set_color_palette()
  #
  # Sets the colour palette to the Excel defaults.
  #
  sub set_color_palette {
  
      my $self = shift;
  
      $self->{_palette} = [
          [ 0x00, 0x00, 0x00, 0x00 ],    # 8
          [ 0xff, 0xff, 0xff, 0x00 ],    # 9
          [ 0xff, 0x00, 0x00, 0x00 ],    # 10
          [ 0x00, 0xff, 0x00, 0x00 ],    # 11
          [ 0x00, 0x00, 0xff, 0x00 ],    # 12
          [ 0xff, 0xff, 0x00, 0x00 ],    # 13
          [ 0xff, 0x00, 0xff, 0x00 ],    # 14
          [ 0x00, 0xff, 0xff, 0x00 ],    # 15
          [ 0x80, 0x00, 0x00, 0x00 ],    # 16
          [ 0x00, 0x80, 0x00, 0x00 ],    # 17
          [ 0x00, 0x00, 0x80, 0x00 ],    # 18
          [ 0x80, 0x80, 0x00, 0x00 ],    # 19
          [ 0x80, 0x00, 0x80, 0x00 ],    # 20
          [ 0x00, 0x80, 0x80, 0x00 ],    # 21
          [ 0xc0, 0xc0, 0xc0, 0x00 ],    # 22
          [ 0x80, 0x80, 0x80, 0x00 ],    # 23
          [ 0x99, 0x99, 0xff, 0x00 ],    # 24
          [ 0x99, 0x33, 0x66, 0x00 ],    # 25
          [ 0xff, 0xff, 0xcc, 0x00 ],    # 26
          [ 0xcc, 0xff, 0xff, 0x00 ],    # 27
          [ 0x66, 0x00, 0x66, 0x00 ],    # 28
          [ 0xff, 0x80, 0x80, 0x00 ],    # 29
          [ 0x00, 0x66, 0xcc, 0x00 ],    # 30
          [ 0xcc, 0xcc, 0xff, 0x00 ],    # 31
          [ 0x00, 0x00, 0x80, 0x00 ],    # 32
          [ 0xff, 0x00, 0xff, 0x00 ],    # 33
          [ 0xff, 0xff, 0x00, 0x00 ],    # 34
          [ 0x00, 0xff, 0xff, 0x00 ],    # 35
          [ 0x80, 0x00, 0x80, 0x00 ],    # 36
          [ 0x80, 0x00, 0x00, 0x00 ],    # 37
          [ 0x00, 0x80, 0x80, 0x00 ],    # 38
          [ 0x00, 0x00, 0xff, 0x00 ],    # 39
          [ 0x00, 0xcc, 0xff, 0x00 ],    # 40
          [ 0xcc, 0xff, 0xff, 0x00 ],    # 41
          [ 0xcc, 0xff, 0xcc, 0x00 ],    # 42
          [ 0xff, 0xff, 0x99, 0x00 ],    # 43
          [ 0x99, 0xcc, 0xff, 0x00 ],    # 44
          [ 0xff, 0x99, 0xcc, 0x00 ],    # 45
          [ 0xcc, 0x99, 0xff, 0x00 ],    # 46
          [ 0xff, 0xcc, 0x99, 0x00 ],    # 47
          [ 0x33, 0x66, 0xff, 0x00 ],    # 48
          [ 0x33, 0xcc, 0xcc, 0x00 ],    # 49
          [ 0x99, 0xcc, 0x00, 0x00 ],    # 50
          [ 0xff, 0xcc, 0x00, 0x00 ],    # 51
          [ 0xff, 0x99, 0x00, 0x00 ],    # 52
          [ 0xff, 0x66, 0x00, 0x00 ],    # 53
          [ 0x66, 0x66, 0x99, 0x00 ],    # 54
          [ 0x96, 0x96, 0x96, 0x00 ],    # 55
          [ 0x00, 0x33, 0x66, 0x00 ],    # 56
          [ 0x33, 0x99, 0x66, 0x00 ],    # 57
          [ 0x00, 0x33, 0x00, 0x00 ],    # 58
          [ 0x33, 0x33, 0x00, 0x00 ],    # 59
          [ 0x99, 0x33, 0x00, 0x00 ],    # 60
          [ 0x99, 0x33, 0x66, 0x00 ],    # 61
          [ 0x33, 0x33, 0x99, 0x00 ],    # 62
          [ 0x33, 0x33, 0x33, 0x00 ],    # 63
      ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # set_tempdir()
  #
  # Change the default temp directory.
  #
  sub set_tempdir {
  
      my $self = shift;
      my $dir  = shift;
  
      croak "$dir is not a valid directory" if defined $dir and not -d $dir;
  
      $self->{_tempdir} = $dir;
  
  }
  
  
  ###############################################################################
  #
  # define_name()
  #
  # Create a defined name in Excel. We handle global/workbook level names and
  # local/worksheet names.
  #
  sub define_name {
  
      my $self        = shift;
      my $name        = shift;
      my $formula     = shift;
      my $sheet_index = undef;
      my $sheetname   = '';
      my $full_name   = $name;
  
      # Remove the = sign from the formula if it exists.
      $formula =~ s/^=//;
  
      # Local defined names are formatted like "Sheet1!name".
      if ( $name =~ /^(.*)!(.*)$/ ) {
          $sheetname   = $1;
          $name        = $2;
          $sheet_index = $self->_get_sheet_index( $sheetname );
      }
      else {
          $sheet_index = -1;    # Use -1 to indicate global names.
      }
  
      # Warn if the sheet index wasn't found.
      if ( !defined $sheet_index ) {
          carp "Unknown sheet name $sheetname in defined_name()";
          return -1;
      }
  
      # Warn if the name contains invalid chars as defined by Excel help.
      if ( $name !~ m/^[\w\\][\w\\.]*$/ || $name =~ m/^\d/ ) {
          carp "Invalid character in name '$name' used in defined_name()";
          return -1;
      }
  
      # Warn if the name looks like a cell name.
      if ( $name =~ m/^[a-zA-Z][a-zA-Z]?[a-dA-D]?[0-9]+$/ ) {
          carp "Invalid name '$name' looks like a cell name in defined_name()";
          return -1;
      }
  
      # Warn if the name looks like a R1C1.
      if ( $name =~ m/^[rcRC]$/ || $name =~ m/^[rcRC]\d+[rcRC]\d+$/ ) {
          carp "Invalid name '$name' like a RC cell ref in defined_name()";
          return -1;
      }
  
      push @{ $self->{_defined_names} }, [ $name, $sheet_index, $formula ];
  }
  
  
  ###############################################################################
  #
  # set_properties()
  #
  # Set the document properties such as Title, Author etc. These are written to
  # property sets in the OLE container.
  #
  sub set_properties {
  
      my $self  = shift;
      my %param = @_;
  
      # Ignore if no args were passed.
      return -1 unless @_;
  
      # List of valid input parameters.
      my %valid = (
          title          => 1,
          subject        => 1,
          author         => 1,
          keywords       => 1,
          comments       => 1,
          last_author    => 1,
          created        => 1,
          category       => 1,
          manager        => 1,
          company        => 1,
          status         => 1,
          hyperlink_base => 1,
      );
  
      # Check for valid input parameters.
      for my $parameter ( keys %param ) {
          if ( not exists $valid{$parameter} ) {
              carp "Unknown parameter '$parameter' in set_properties()";
              return -1;
          }
      }
  
      # Set the creation time unless specified by the user.
      if ( !exists $param{created} ) {
          $param{created} = $self->{_localtime};
      }
  
  
      $self->{_doc_properties} = \%param;
  }
  
  
  ###############################################################################
  #
  # add_vba_project()
  #
  # Add a vbaProject binary to the XLSX file.
  #
  sub add_vba_project {
  
      my $self        = shift;
      my $vba_project = shift;
  
      croak "No vbaProject.bin specified in add_vba_project()"
        if not $vba_project;
  
      croak "Couldn't locate $vba_project in add_vba_project(): $!"
        unless -e $vba_project;
  
      $self->{_vba_project} = $vba_project;
  }
  
  
  ###############################################################################
  #
  # set_vba_name()
  #
  # Set the VBA name for the workbook.
  #
  sub set_vba_name {
  
      my $self         = shift;
      my $vba_codemame = shift;
  
      if ( $vba_codemame ) {
          $self->{_vba_codename} = $vba_codemame;
      }
      else {
          $self->{_vba_codename} = 'ThisWorkbook';
      }
  }
  
  
  ###############################################################################
  #
  # set_calc_mode()
  #
  # Set the Excel caclcuation mode for the workbook.
  #
  sub set_calc_mode {
  
      my $self    = shift;
      my $mode    = shift || 'auto';
      my $calc_id = shift;
  
      $self->{_calc_mode} = $mode;
  
      if ( $mode eq 'manual' ) {
          $self->{_calc_mode}    = 'manual';
          $self->{_calc_on_load} = 0;
      }
      elsif ( $mode eq 'auto_except_tables' ) {
          $self->{_calc_mode} = 'autoNoTable';
      }
  
      $self->{_calc_id} = $calc_id if defined $calc_id;
  }
  
  
  ###############################################################################
  #
  # _store_workbook()
  #
  # Assemble worksheets into a workbook.
  #
  sub _store_workbook {
  
      my $self     = shift;
      my $tempdir  = File::Temp->newdir( DIR => $self->{_tempdir} );
      my $packager = Excel::Writer::XLSX::Package::Packager->new();
      my $zip      = Archive::Zip->new();
  
  
      # Add a default worksheet if non have been added.
      $self->add_worksheet() if not @{ $self->{_worksheets} };
  
      # Ensure that at least one worksheet has been selected.
      if ( $self->{_activesheet} == 0 ) {
          $self->{_worksheets}->[0]->{_selected} = 1;
          $self->{_worksheets}->[0]->{_hidden}   = 0;
      }
  
      # Set the active sheet.
      for my $sheet ( @{ $self->{_worksheets} } ) {
          $sheet->{_active} = 1 if $sheet->{_index} == $self->{_activesheet};
      }
  
      # Convert the SST strings data structure.
      $self->_prepare_sst_string_data();
  
      # Prepare the worksheet VML elements such as comments and buttons.
      $self->_prepare_vml_objects();
  
      # Set the defined names for the worksheets such as Print Titles.
      $self->_prepare_defined_names();
  
      # Prepare the drawings, charts and images.
      $self->_prepare_drawings();
  
      # Add cached data to charts.
      $self->_add_chart_data();
  
      # Prepare the worksheet tables.
      $self->_prepare_tables();
  
      # Package the workbook.
      $packager->_add_workbook( $self );
      $packager->_set_package_dir( $tempdir );
      $packager->_create_package();
  
      # Free up the Packager object.
      $packager = undef;
  
      # Add the files to the zip archive. Due to issues with Archive::Zip in
      # taint mode we can't use addTree() so we have to build the file list
      # with File::Find and pass each one to addFile().
      my @xlsx_files;
  
      my $wanted = sub { push @xlsx_files, $File::Find::name if -f };
  
      File::Find::find(
          {
              wanted          => $wanted,
              untaint         => 1,
              untaint_pattern => qr|^(.+)$|
          },
          $tempdir
      );
  
      # Store the xlsx component files with the temp dir name removed.
      for my $filename ( @xlsx_files ) {
          my $short_name = $filename;
          $short_name =~ s{^\Q$tempdir\E/?}{};
          $zip->addFile( $filename, $short_name );
      }
  
  
      if ( $self->{_internal_fh} ) {
  
          if ( $zip->writeToFileHandle( $self->{_filehandle} ) != 0 ) {
              carp 'Error writing zip container for xlsx file.';
          }
      }
      else {
  
          # Archive::Zip needs to rewind a filehandle to write the zip headers.
          # This won't work for arbitrary user defined filehandles so we use
          # a temp file based filehandle to create the zip archive and then
          # stream that to the filehandle.
          my $tmp_fh = tempfile( DIR => $self->{_tempdir} );
          my $is_seekable = 1;
  
          if ( $zip->writeToFileHandle( $tmp_fh, $is_seekable ) != 0 ) {
              carp 'Error writing zip container for xlsx file.';
          }
  
          my $buffer;
          seek $tmp_fh, 0, 0;
  
          while ( read( $tmp_fh, $buffer, 4_096 ) ) {
              local $\ = undef;    # Protect print from -l on commandline.
              print { $self->{_filehandle} } $buffer;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _prepare_sst_string_data()
  #
  # Convert the SST string data from a hash to an array.
  #
  sub _prepare_sst_string_data {
  
      my $self = shift;
  
      my @strings;
      $#strings = $self->{_str_unique} - 1;    # Pre-extend array
  
      while ( my $key = each %{ $self->{_str_table} } ) {
          $strings[ $self->{_str_table}->{$key} ] = $key;
      }
  
      # The SST data could be very large, free some memory (maybe).
      $self->{_str_table} = undef;
      $self->{_str_array} = \@strings;
  
  }
  
  
  ###############################################################################
  #
  # _prepare_format_properties()
  #
  # Prepare all of the format properties prior to passing them to Styles.pm.
  #
  sub _prepare_format_properties {
  
      my $self = shift;
  
      # Separate format objects into XF and DXF formats.
      $self->_prepare_formats();
  
      # Set the font index for the format objects.
      $self->_prepare_fonts();
  
      # Set the number format index for the format objects.
      $self->_prepare_num_formats();
  
      # Set the border index for the format objects.
      $self->_prepare_borders();
  
      # Set the fill index for the format objects.
      $self->_prepare_fills();
  
  
  }
  
  
  ###############################################################################
  #
  # _prepare_formats()
  #
  # Iterate through the XF Format objects and separate them into XF and DXF
  # formats.
  #
  sub _prepare_formats {
  
      my $self = shift;
  
      for my $format ( @{ $self->{_formats} } ) {
          my $xf_index  = $format->{_xf_index};
          my $dxf_index = $format->{_dxf_index};
  
          if ( defined $xf_index ) {
              $self->{_xf_formats}->[$xf_index] = $format;
          }
  
          if ( defined $dxf_index ) {
              $self->{_dxf_formats}->[$dxf_index] = $format;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _set_default_xf_indices()
  #
  # Set the default index for each format. This is mainly used for testing.
  #
  sub _set_default_xf_indices {
  
      my $self = shift;
  
      for my $format ( @{ $self->{_formats} } ) {
          $format->get_xf_index();
      }
  }
  
  
  ###############################################################################
  #
  # _prepare_fonts()
  #
  # Iterate through the XF Format objects and give them an index to non-default
  # font elements.
  #
  sub _prepare_fonts {
  
      my $self = shift;
  
      my %fonts;
      my $index = 0;
  
      for my $format ( @{ $self->{_xf_formats} } ) {
          my $key = $format->get_font_key();
  
          if ( exists $fonts{$key} ) {
  
              # Font has already been used.
              $format->{_font_index} = $fonts{$key};
              $format->{_has_font}   = 0;
          }
          else {
  
              # This is a new font.
              $fonts{$key}           = $index;
              $format->{_font_index} = $index;
              $format->{_has_font}   = 1;
              $index++;
          }
      }
  
      $self->{_font_count} = $index;
  
      # For the DXF formats we only need to check if the properties have changed.
      for my $format ( @{ $self->{_dxf_formats} } ) {
  
          # The only font properties that can change for a DXF format are: color,
          # bold, italic, underline and strikethrough.
          if (   $format->{_color}
              || $format->{_bold}
              || $format->{_italic}
              || $format->{_underline}
              || $format->{_font_strikeout} )
          {
              $format->{_has_dxf_font} = 1;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _prepare_num_formats()
  #
  # Iterate through the XF Format objects and give them an index to non-default
  # number format elements.
  #
  # User defined records start from index 0xA4.
  #
  sub _prepare_num_formats {
  
      my $self = shift;
  
      my %num_formats;
      my $index            = 164;
      my $num_format_count = 0;
  
      for my $format ( @{ $self->{_xf_formats} }, @{ $self->{_dxf_formats} } ) {
          my $num_format = $format->{_num_format};
  
          # Check if $num_format is an index to a built-in number format.
          # Also check for a string of zeros, which is a valid number format
          # string but would evaluate to zero.
          #
          if ( $num_format =~ m/^\d+$/ && $num_format !~ m/^0+\d/ ) {
  
              # Index to a built-in number format.
              $format->{_num_format_index} = $num_format;
              next;
          }
  
  
          if ( exists( $num_formats{$num_format} ) ) {
  
              # Number format has already been used.
              $format->{_num_format_index} = $num_formats{$num_format};
          }
          else {
  
              # Add a new number format.
              $num_formats{$num_format} = $index;
              $format->{_num_format_index} = $index;
              $index++;
  
              # Only increase font count for XF formats (not for DXF formats).
              if ( $format->{_xf_index} ) {
                  $num_format_count++;
              }
          }
      }
  
      $self->{_num_format_count} = $num_format_count;
  }
  
  
  ###############################################################################
  #
  # _prepare_borders()
  #
  # Iterate through the XF Format objects and give them an index to non-default
  # border elements.
  #
  sub _prepare_borders {
  
      my $self = shift;
  
      my %borders;
      my $index = 0;
  
      for my $format ( @{ $self->{_xf_formats} } ) {
          my $key = $format->get_border_key();
  
          if ( exists $borders{$key} ) {
  
              # Border has already been used.
              $format->{_border_index} = $borders{$key};
              $format->{_has_border}   = 0;
          }
          else {
  
              # This is a new border.
              $borders{$key}           = $index;
              $format->{_border_index} = $index;
              $format->{_has_border}   = 1;
              $index++;
          }
      }
  
      $self->{_border_count} = $index;
  
      # For the DXF formats we only need to check if the properties have changed.
      for my $format ( @{ $self->{_dxf_formats} } ) {
          my $key = $format->get_border_key();
  
          if ( $key =~ m/[^0:]/ ) {
              $format->{_has_dxf_border} = 1;
          }
      }
  
  }
  
  
  ###############################################################################
  #
  # _prepare_fills()
  #
  # Iterate through the XF Format objects and give them an index to non-default
  # fill elements.
  #
  # The user defined fill properties start from 2 since there are 2 default
  # fills: patternType="none" and patternType="gray125".
  #
  sub _prepare_fills {
  
      my $self = shift;
  
      my %fills;
      my $index = 2;    # Start from 2. See above.
  
      # Add the default fills.
      $fills{'0:0:0'}  = 0;
      $fills{'17:0:0'} = 1;
  
  
      # Store the DXF colours separately since them may be reversed below.
      for my $format ( @{ $self->{_dxf_formats} } ) {
          if (   $format->{_pattern}
              || $format->{_bg_color}
              || $format->{_fg_color} )
          {
              $format->{_has_dxf_fill} = 1;
              $format->{_dxf_bg_color} = $format->{_bg_color};
              $format->{_dxf_fg_color} = $format->{_fg_color};
          }
      }
  
  
      for my $format ( @{ $self->{_xf_formats} } ) {
  
          # The following logical statements jointly take care of special cases
          # in relation to cell colours and patterns:
          # 1. For a solid fill (_pattern == 1) Excel reverses the role of
          #    foreground and background colours, and
          # 2. If the user specifies a foreground or background colour without
          #    a pattern they probably wanted a solid fill, so we fill in the
          #    defaults.
          #
          if (   $format->{_pattern} == 1
              && $format->{_bg_color} ne '0'
              && $format->{_fg_color} ne '0' )
          {
              my $tmp = $format->{_fg_color};
              $format->{_fg_color} = $format->{_bg_color};
              $format->{_bg_color} = $tmp;
          }
  
          if (   $format->{_pattern} <= 1
              && $format->{_bg_color} ne '0'
              && $format->{_fg_color} eq '0' )
          {
              $format->{_fg_color} = $format->{_bg_color};
              $format->{_bg_color} = 0;
              $format->{_pattern}  = 1;
          }
  
          if (   $format->{_pattern} <= 1
              && $format->{_bg_color} eq '0'
              && $format->{_fg_color} ne '0' )
          {
              $format->{_bg_color} = 0;
              $format->{_pattern}  = 1;
          }
  
  
          my $key = $format->get_fill_key();
  
          if ( exists $fills{$key} ) {
  
              # Fill has already been used.
              $format->{_fill_index} = $fills{$key};
              $format->{_has_fill}   = 0;
          }
          else {
  
              # This is a new fill.
              $fills{$key}           = $index;
              $format->{_fill_index} = $index;
              $format->{_has_fill}   = 1;
              $index++;
          }
      }
  
      $self->{_fill_count} = $index;
  
  
  }
  
  
  ###############################################################################
  #
  # _prepare_defined_names()
  #
  # Iterate through the worksheets and store any defined names in addition to
  # any user defined names. Stores the defined names for the Workbook.xml and
  # the named ranges for App.xml.
  #
  sub _prepare_defined_names {
  
      my $self = shift;
  
      my @defined_names = @{ $self->{_defined_names} };
  
      for my $sheet ( @{ $self->{_worksheets} } ) {
  
          # Check for Print Area settings.
          if ( $sheet->{_autofilter} ) {
  
              my $range  = $sheet->{_autofilter};
              my $hidden = 1;
  
              # Store the defined names.
              push @defined_names,
                [ '_xlnm._FilterDatabase', $sheet->{_index}, $range, $hidden ];
  
          }
  
          # Check for Print Area settings.
          if ( $sheet->{_print_area} ) {
  
              my $range = $sheet->{_print_area};
  
              # Store the defined names.
              push @defined_names,
                [ '_xlnm.Print_Area', $sheet->{_index}, $range ];
          }
  
          # Check for repeat rows/cols. aka, Print Titles.
          if ( $sheet->{_repeat_cols} || $sheet->{_repeat_rows} ) {
              my $range = '';
  
              if ( $sheet->{_repeat_cols} && $sheet->{_repeat_rows} ) {
                  $range = $sheet->{_repeat_cols} . ',' . $sheet->{_repeat_rows};
              }
              else {
                  $range = $sheet->{_repeat_cols} . $sheet->{_repeat_rows};
              }
  
              # Store the defined names.
              push @defined_names,
                [ '_xlnm.Print_Titles', $sheet->{_index}, $range ];
          }
  
      }
  
      @defined_names          = _sort_defined_names( @defined_names );
      $self->{_defined_names} = \@defined_names;
      $self->{_named_ranges}  = _extract_named_ranges( @defined_names );
  }
  
  
  ###############################################################################
  #
  # _sort_defined_names()
  #
  # Sort internal and user defined names in the same order as used by Excel.
  # This may not be strictly necessary but unsorted elements caused a lot of
  # issues in the Spreadsheet::WriteExcel binary version. Also makes
  # comparison testing easier.
  #
  sub _sort_defined_names {
  
      my @names = @_;
  
      #<<< Perltidy ignore this.
  
      @names = sort {
          # Primary sort based on the defined name.
          _normalise_defined_name( $a->[0] )
          cmp
          _normalise_defined_name( $b->[0] )
  
          ||
          # Secondary sort based on the sheet name.
          _normalise_sheet_name( $a->[2] )
          cmp
          _normalise_sheet_name( $b->[2] )
  
      } @names;
      #>>>
  
      return @names;
  }
  
  # Used in the above sort routine to normalise the defined names. Removes any
  # leading '_xmln.' from internal names and lowercases the strings.
  sub _normalise_defined_name {
      my $name = shift;
  
      $name =~ s/^_xlnm.//;
      $name = lc $name;
  
      return $name;
  }
  
  # Used in the above sort routine to normalise the worksheet names for the
  # secondary sort. Removes leading quote and lowercases the strings.
  sub _normalise_sheet_name {
      my $name = shift;
  
      $name =~ s/^'//;
      $name = lc $name;
  
      return $name;
  }
  
  
  ###############################################################################
  #
  # _extract_named_ranges()
  #
  # Extract the named ranges from the sorted list of defined names. These are
  # used in the App.xml file.
  #
  sub _extract_named_ranges {
  
      my @defined_names = @_;
      my @named_ranges;
  
      NAME:
      for my $defined_name ( @defined_names ) {
  
          my $name  = $defined_name->[0];
          my $index = $defined_name->[1];
          my $range = $defined_name->[2];
  
          # Skip autoFilter ranges.
          next NAME if $name eq '_xlnm._FilterDatabase';
  
          # We are only interested in defined names with ranges.
          if ( $range =~ /^([^!]+)!/ ) {
              my $sheet_name = $1;
  
              # Match Print_Area and Print_Titles xlnm types.
              if ( $name =~ /^_xlnm\.(.*)$/ ) {
                  my $xlnm_type = $1;
                  $name = $sheet_name . '!' . $xlnm_type;
              }
              elsif ( $index != -1 ) {
                  $name = $sheet_name . '!' . $name;
              }
  
              push @named_ranges, $name;
          }
      }
  
      return \@named_ranges;
  }
  
  
  ###############################################################################
  #
  # _prepare_drawings()
  #
  # Iterate through the worksheets and set up any chart or image drawings.
  #
  sub _prepare_drawings {
  
      my $self         = shift;
      my $chart_ref_id = 0;
      my $image_ref_id = 0;
      my $drawing_id   = 0;
  
      for my $sheet ( @{ $self->{_worksheets} } ) {
  
          my $chart_count = scalar @{ $sheet->{_charts} };
          my $image_count = scalar @{ $sheet->{_images} };
          my $shape_count = scalar @{ $sheet->{_shapes} };
  
          my $header_image_count = scalar @{ $sheet->{_header_images} };
          my $footer_image_count = scalar @{ $sheet->{_footer_images} };
          my $has_drawing        = 0;
  
  
          # Check that some image or drawing needs to be processed.
          if (   !$chart_count
              && !$image_count
              && !$shape_count
              && !$header_image_count
              && !$footer_image_count )
          {
              next;
          }
  
          # Don't increase the drawing_id header/footer images.
          if ( $chart_count || $image_count || $shape_count ) {
              $drawing_id++;
              $has_drawing = 1;
          }
  
          # Prepare the worksheet charts.
          for my $index ( 0 .. $chart_count - 1 ) {
              $chart_ref_id++;
              $sheet->_prepare_chart( $index, $chart_ref_id, $drawing_id );
          }
  
          # Prepare the worksheet images.
          for my $index ( 0 .. $image_count - 1 ) {
  
              my $filename = $sheet->{_images}->[$index]->[2];
  
              my ( $type, $width, $height, $name, $x_dpi, $y_dpi ) =
                $self->_get_image_properties( $filename );
  
              $image_ref_id++;
  
              $sheet->_prepare_image(
                  $index, $image_ref_id, $drawing_id,
                  $width, $height,       $name,
                  $type,  $x_dpi,        $y_dpi
              );
          }
  
          # Prepare the worksheet shapes.
          for my $index ( 0 .. $shape_count - 1 ) {
              $sheet->_prepare_shape( $index, $drawing_id );
          }
  
          # Prepare the header images.
          for my $index ( 0 .. $header_image_count - 1 ) {
  
              my $filename = $sheet->{_header_images}->[$index]->[0];
              my $position = $sheet->{_header_images}->[$index]->[1];
  
              my ( $type, $width, $height, $name, $x_dpi, $y_dpi ) =
                $self->_get_image_properties( $filename );
  
              $image_ref_id++;
  
              $sheet->_prepare_header_image( $image_ref_id, $width, $height,
                  $name, $type, $position, $x_dpi, $y_dpi );
          }
  
          # Prepare the footer images.
          for my $index ( 0 .. $footer_image_count - 1 ) {
  
              my $filename = $sheet->{_footer_images}->[$index]->[0];
              my $position = $sheet->{_footer_images}->[$index]->[1];
  
              my ( $type, $width, $height, $name, $x_dpi, $y_dpi ) =
                $self->_get_image_properties( $filename );
  
              $image_ref_id++;
  
              $sheet->_prepare_header_image( $image_ref_id, $width, $height,
                  $name, $type, $position, $x_dpi, $y_dpi );
          }
  
  
          if ( $has_drawing ) {
              my $drawing = $sheet->{_drawing};
              push @{ $self->{_drawings} }, $drawing;
          }
      }
  
  
      # Remove charts that were created but not inserted into worksheets.
      my @chart_data;
  
      for my $chart ( @{ $self->{_charts} } ) {
          if ( $chart->{_id} != -1 ) {
              push @chart_data, $chart;
          }
      }
  
      # Sort the workbook charts references into the order that the were
      # written from the worksheets above.
      @chart_data = sort { $a->{_id} <=> $b->{_id} } @chart_data;
  
      $self->{_charts} = \@chart_data;
      $self->{_drawing_count} = $drawing_id;
  }
  
  
  ###############################################################################
  #
  # _prepare_vml_objects()
  #
  # Iterate through the worksheets and set up the VML objects.
  #
  sub _prepare_vml_objects {
  
      my $self           = shift;
      my $comment_id     = 0;
      my $vml_drawing_id = 0;
      my $vml_data_id    = 1;
      my $vml_header_id  = 0;
      my $vml_shape_id   = 1024;
      my $vml_files      = 0;
      my $comment_files  = 0;
      my $has_button     = 0;
  
      for my $sheet ( @{ $self->{_worksheets} } ) {
  
          next if !$sheet->{_has_vml} and !$sheet->{_has_header_vml};
          $vml_files = 1;
  
  
          if ( $sheet->{_has_vml} ) {
  
              $comment_files++ if $sheet->{_has_comments};
              $comment_id++    if $sheet->{_has_comments};
              $vml_drawing_id++;
  
              my $count =
                $sheet->_prepare_vml_objects( $vml_data_id, $vml_shape_id,
                  $vml_drawing_id, $comment_id );
  
              # Each VML file should start with a shape id incremented by 1024.
              $vml_data_id  += 1 * int(    ( 1024 + $count ) / 1024 );
              $vml_shape_id += 1024 * int( ( 1024 + $count ) / 1024 );
  
          }
  
          if ( $sheet->{_has_header_vml} ) {
              $vml_header_id++;
              $vml_drawing_id++;
              $sheet->_prepare_header_vml_objects( $vml_header_id,
                  $vml_drawing_id );
          }
  
          # Set the sheet vba_codename if it has a button and the workbook
          # has a vbaProject binary.
          if ( $sheet->{_buttons_array} ) {
              $has_button = 1;
  
              if ( $self->{_vba_project} && !$sheet->{_vba_codename} ) {
                  $sheet->set_vba_name();
              }
          }
  
      }
  
      $self->{_num_vml_files}     = $vml_files;
      $self->{_num_comment_files} = $comment_files;
  
      # Add a font format for cell comments.
      if ( $comment_files > 0 ) {
          my $format = Excel::Writer::XLSX::Format->new(
              \$self->{_xf_format_indices},
              \$self->{_dxf_format_indices},
              font          => 'Tahoma',
              size          => 8,
              color_indexed => 81,
              font_only     => 1,
          );
  
          $format->get_xf_index();
  
          push @{ $self->{_formats} }, $format;
      }
  
      # Set the workbook vba_codename if one of the sheets has a button and
      # the workbook has a vbaProject binary.
      if ( $has_button && $self->{_vba_project} && !$self->{_vba_codename} ) {
          $self->set_vba_name();
      }
  }
  
  
  ###############################################################################
  #
  # _prepare_tables()
  #
  # Set the table ids for the worksheet tables.
  #
  sub _prepare_tables {
  
      my $self     = shift;
      my $table_id = 0;
      my $seen     = {};
  
      for my $sheet ( @{ $self->{_worksheets} } ) {
  
          my $table_count = scalar @{ $sheet->{_tables} };
  
          next unless $table_count;
  
          $sheet->_prepare_tables( $table_id + 1, $seen );
  
          $table_id += $table_count;
      }
  }
  
  
  ###############################################################################
  #
  # _add_chart_data()
  #
  # Add "cached" data to charts to provide the numCache and strCache data for
  # series and title/axis ranges.
  #
  sub _add_chart_data {
  
      my $self = shift;
      my %worksheets;
      my %seen_ranges;
      my @charts;
  
      # Map worksheet names to worksheet objects.
      for my $worksheet ( @{ $self->{_worksheets} } ) {
          $worksheets{ $worksheet->{_name} } = $worksheet;
      }
  
      # Build an array of the worksheet charts including any combined charts.
      for my $chart ( @{ $self->{_charts} } ) {
          push @charts, $chart;
  
          if ($chart->{_combined}) {
              push @charts, $chart->{_combined};
          }
      }
  
  
      CHART:
      for my $chart ( @charts ) {
  
          RANGE:
          while ( my ( $range, $id ) = each %{ $chart->{_formula_ids} } ) {
  
              # Skip if the series has user defined data.
              if ( defined $chart->{_formula_data}->[$id] ) {
                  if (   !exists $seen_ranges{$range}
                      || !defined $seen_ranges{$range} )
                  {
                      my $data = $chart->{_formula_data}->[$id];
                      $seen_ranges{$range} = $data;
                  }
                  next RANGE;
              }
  
              # Check to see if the data is already cached locally.
              if ( exists $seen_ranges{$range} ) {
                  $chart->{_formula_data}->[$id] = $seen_ranges{$range};
                  next RANGE;
              }
  
              # Convert the range formula to a sheet name and cell range.
              my ( $sheetname, @cells ) = $self->_get_chart_range( $range );
  
              # Skip if we couldn't parse the formula.
              next RANGE if !defined $sheetname;
  
              # Handle non-contiguous ranges: (Sheet1!$A$1:$A$2,Sheet1!$A$4:$A$5).
              # We don't try to parse the ranges. We just return an empty list.
              if ( $sheetname =~ m/^\([^,]+,/ ) {
                  $chart->{_formula_data}->[$id] = [];
                  $seen_ranges{$range} = [];
                  next RANGE;
              }
  
              # Die if the name is unknown since it indicates a user error in
              # a chart series formula.
              if ( !exists $worksheets{$sheetname} ) {
                  die "Unknown worksheet reference '$sheetname' in range "
                    . "'$range' passed to add_series().\n";
              }
  
              # Find the worksheet object based on the sheet name.
              my $worksheet = $worksheets{$sheetname};
  
              # Get the data from the worksheet table.
              my @data = $worksheet->_get_range_data( @cells );
  
              # Convert shared string indexes to strings.
              for my $token ( @data ) {
                  if ( ref $token ) {
                      $token = $self->{_str_array}->[ $token->{sst_id} ];
  
                      # Ignore rich strings for now. Deparse later if necessary.
                      if ( $token =~ m{^<r>} && $token =~ m{</r>$} ) {
                          $token = '';
                      }
                  }
              }
  
              # Add the data to the chart.
              $chart->{_formula_data}->[$id] = \@data;
  
              # Store range data locally to avoid lookup if seen again.
              $seen_ranges{$range} = \@data;
          }
      }
  }
  
  
  ###############################################################################
  #
  # _get_chart_range()
  #
  # Convert a range formula such as Sheet1!$B$1:$B$5 into a sheet name and cell
  # range such as ( 'Sheet1', 0, 1, 4, 1 ).
  #
  sub _get_chart_range {
  
      my $self  = shift;
      my $range = shift;
      my $cell_1;
      my $cell_2;
      my $sheetname;
      my $cells;
  
      # Split the range formula into sheetname and cells at the last '!'.
      my $pos = rindex $range, '!';
      if ( $pos > 0 ) {
          $sheetname = substr $range, 0, $pos;
          $cells = substr $range, $pos + 1;
      }
      else {
          return undef;
      }
  
      # Split the cell range into 2 cells or else use single cell for both.
      if ( $cells =~ ':' ) {
          ( $cell_1, $cell_2 ) = split /:/, $cells;
      }
      else {
          ( $cell_1, $cell_2 ) = ( $cells, $cells );
      }
  
      # Remove leading/trailing apostrophes and convert escaped quotes to single.
      $sheetname =~ s/^'//g;
      $sheetname =~ s/'$//g;
      $sheetname =~ s/''/'/g;
  
      my ( $row_start, $col_start ) = xl_cell_to_rowcol( $cell_1 );
      my ( $row_end,   $col_end )   = xl_cell_to_rowcol( $cell_2 );
  
      # Check that we have a 1D range only.
      if ( $row_start != $row_end && $col_start != $col_end ) {
          return undef;
      }
  
      return ( $sheetname, $row_start, $col_start, $row_end, $col_end );
  }
  
  
  ###############################################################################
  #
  # _store_externs()
  #
  # Write the EXTERNCOUNT and EXTERNSHEET records. These are used as indexes for
  # the NAME records.
  #
  sub _store_externs {
  
      my $self = shift;
  
  }
  
  
  ###############################################################################
  #
  # _store_names()
  #
  # Write the NAME record to define the print area and the repeat rows and cols.
  #
  sub _store_names {
  
      my $self = shift;
  
  }
  
  
  ###############################################################################
  #
  # _quote_sheetname()
  #
  # Sheetnames used in references should be quoted if they contain any spaces,
  # special characters or if the look like something that isn't a sheet name.
  # TODO. We need to handle more special cases.
  #
  sub _quote_sheetname {
  
      my $self      = shift;
      my $sheetname = $_[0];
  
      if ( $sheetname =~ /^Sheet\d+$/ ) {
          return $sheetname;
      }
      else {
          return qq('$sheetname');
      }
  }
  
  
  ###############################################################################
  #
  # _get_image_properties()
  #
  # Extract information from the image file such as dimension, type, filename,
  # and extension. Also keep track of previously seen images to optimise out
  # any duplicates.
  #
  sub _get_image_properties {
  
      my $self     = shift;
      my $filename = shift;
  
      my $type;
      my $width;
      my $height;
      my $x_dpi = 96;
      my $y_dpi = 96;
      my $image_name;
  
  
      ( $image_name ) = fileparse( $filename );
  
      # Open the image file and import the data.
      my $fh = FileHandle->new( $filename );
      croak "Couldn't import $filename: $!" unless defined $fh;
      binmode $fh;
  
      # Slurp the file into a string and do some size calcs.
      my $data = do { local $/; <$fh> };
      my $size = length $data;
  
  
      if ( unpack( 'x A3', $data ) eq 'PNG' ) {
  
          # Test for PNGs.
          ( $type, $width, $height, $x_dpi, $y_dpi ) =
            $self->_process_png( $data, $filename );
  
          $self->{_image_types}->{png} = 1;
      }
      elsif ( unpack( 'n', $data ) == 0xFFD8 ) {
  
          # Test for JPEG files.
          ( $type, $width, $height, $x_dpi, $y_dpi ) =
            $self->_process_jpg( $data, $filename );
  
          $self->{_image_types}->{jpeg} = 1;
      }
      elsif ( unpack( 'A2', $data ) eq 'BM' ) {
  
          # Test for BMPs.
          ( $type, $width, $height ) = $self->_process_bmp( $data, $filename );
  
          $self->{_image_types}->{bmp} = 1;
      }
      else {
          croak "Unsupported image format for file: $filename\n";
      }
  
      push @{ $self->{_images} }, [ $filename, $type ];
  
  
      $fh->close;
  
      return ( $type, $width, $height, $image_name, $x_dpi, $y_dpi );
  }
  
  
  ###############################################################################
  #
  # _process_png()
  #
  # Extract width and height information from a PNG file.
  #
  sub _process_png {
  
      my $self     = shift;
      my $data     = $_[0];
      my $filename = $_[1];
  
      my $type   = 'png';
      my $width  = 0;
      my $height = 0;
      my $x_dpi  = 96;
      my $y_dpi  = 96;
  
      my $offset      = 8;
      my $data_length = length $data;
  
      # Search through the image data to read the height and width in the
      # IHDR element. Also read the DPI in the pHYs element.
      while ( $offset < $data_length ) {
  
          my $length = unpack "N",  substr $data, $offset + 0, 4;
          my $type   = unpack "A4", substr $data, $offset + 4, 4;
  
          if ( $type eq "IHDR" ) {
              $width  = unpack "N", substr $data, $offset + 8,  4;
              $height = unpack "N", substr $data, $offset + 12, 4;
          }
  
          if ( $type eq "pHYs" ) {
              my $x_ppu = unpack "N", substr $data, $offset + 8,  4;
              my $y_ppu = unpack "N", substr $data, $offset + 12, 4;
              my $units = unpack "C", substr $data, $offset + 16, 1;
  
              if ( $units == 1 ) {
                  $x_dpi = $x_ppu * 0.0254;
                  $y_dpi = $y_ppu * 0.0254;
              }
          }
  
          $offset = $offset + $length + 12;
  
          last if $type eq "IEND";
      }
  
      if ( not defined $height ) {
          croak "$filename: no size data found in png image.\n";
      }
  
      return ( $type, $width, $height, $x_dpi, $y_dpi );
  }
  
  
  ###############################################################################
  #
  # _process_bmp()
  #
  # Extract width and height information from a BMP file.
  #
  # Most of the checks came from old Spredsheet::WriteExcel code.
  #
  sub _process_bmp {
  
      my $self     = shift;
      my $data     = $_[0];
      my $filename = $_[1];
      my $type     = 'bmp';
  
  
      # Check that the file is big enough to be a bitmap.
      if ( length $data <= 0x36 ) {
          croak "$filename doesn't contain enough data.";
      }
  
  
      # Read the bitmap width and height. Verify the sizes.
      my ( $width, $height ) = unpack "x18 V2", $data;
  
      if ( $width > 0xFFFF ) {
          croak "$filename: largest image width $width supported is 65k.";
      }
  
      if ( $height > 0xFFFF ) {
          croak "$filename: largest image height supported is 65k.";
      }
  
      # Read the bitmap planes and bpp data. Verify them.
      my ( $planes, $bitcount ) = unpack "x26 v2", $data;
  
      if ( $bitcount != 24 ) {
          croak "$filename isn't a 24bit true color bitmap.";
      }
  
      if ( $planes != 1 ) {
          croak "$filename: only 1 plane supported in bitmap image.";
      }
  
  
      # Read the bitmap compression. Verify compression.
      my $compression = unpack "x30 V", $data;
  
      if ( $compression != 0 ) {
          croak "$filename: compression not supported in bitmap image.";
      }
  
      return ( $type, $width, $height );
  }
  
  
  ###############################################################################
  #
  # _process_jpg()
  #
  # Extract width and height information from a JPEG file.
  #
  sub _process_jpg {
  
      my $self     = shift;
      my $data     = $_[0];
      my $filename = $_[1];
      my $type     = 'jpeg';
      my $x_dpi    = 96;
      my $y_dpi    = 96;
      my $width;
      my $height;
  
      my $offset      = 2;
      my $data_length = length $data;
  
      # Search through the image data to read the height and width in the
      # 0xFFC0/C2 element. Also read the DPI in the 0xFFE0 element.
      while ( $offset < $data_length ) {
  
          my $marker = unpack "n", substr $data, $offset + 0, 2;
          my $length = unpack "n", substr $data, $offset + 2, 2;
  
          if ( $marker == 0xFFC0 || $marker == 0xFFC2 ) {
              $height = unpack "n", substr $data, $offset + 5, 2;
              $width  = unpack "n", substr $data, $offset + 7, 2;
          }
  
          if ( $marker == 0xFFE0 ) {
              my $units     = unpack "C", substr $data, $offset + 11, 1;
              my $x_density = unpack "n", substr $data, $offset + 12, 2;
              my $y_density = unpack "n", substr $data, $offset + 14, 2;
  
              if ( $units == 1 ) {
                  $x_dpi = $x_density;
                  $y_dpi = $y_density;
              }
  
              if ( $units == 2 ) {
                  $x_dpi = $x_density * 2.54;
                  $y_dpi = $y_density * 2.54;
              }
          }
  
          $offset = $offset + $length + 2;
          last if $marker == 0xFFDA;
      }
  
      if ( not defined $height ) {
          croak "$filename: no size data found in jpeg image.\n";
      }
  
      return ( $type, $width, $height, $x_dpi, $y_dpi );
  }
  
  
  ###############################################################################
  #
  # _get_sheet_index()
  #
  # Convert a sheet name to its index. Return undef otherwise.
  #
  sub _get_sheet_index {
  
      my $self        = shift;
      my $sheetname   = shift;
      my $sheet_count = @{ $self->{_sheetnames} };
      my $sheet_index = undef;
  
      $sheetname =~ s/^'//;
      $sheetname =~ s/'$//;
  
      for my $i ( 0 .. $sheet_count - 1 ) {
          if ( $sheetname eq $self->{_sheetnames}->[$i] ) {
              $sheet_index = $i;
          }
      }
  
      return $sheet_index;
  }
  
  
  ###############################################################################
  #
  # set_optimization()
  #
  # Set the speed/memory optimisation level.
  #
  sub set_optimization {
  
      my $self = shift;
      my $level = defined $_[0] ? $_[0] : 1;
  
      croak "set_optimization() must be called before add_worksheet()"
        if $self->sheets();
  
      $self->{_optimization} = $level;
  }
  
  
  ###############################################################################
  #
  # Deprecated methods for backwards compatibility.
  #
  ###############################################################################
  
  # No longer required by Excel::Writer::XLSX.
  sub compatibility_mode { }
  sub set_codepage       { }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_workbook()
  #
  # Write <workbook> element.
  #
  sub _write_workbook {
  
      my $self    = shift;
      my $schema  = 'http://schemas.openxmlformats.org';
      my $xmlns   = $schema . '/spreadsheetml/2006/main';
      my $xmlns_r = $schema . '/officeDocument/2006/relationships';
  
      my @attributes = (
          'xmlns'   => $xmlns,
          'xmlns:r' => $xmlns_r,
      );
  
      $self->xml_start_tag( 'workbook', @attributes );
  }
  
  
  ###############################################################################
  #
  # write_file_version()
  #
  # Write the <fileVersion> element.
  #
  sub _write_file_version {
  
      my $self          = shift;
      my $app_name      = 'xl';
      my $last_edited   = 4;
      my $lowest_edited = 4;
      my $rup_build     = 4505;
  
      my @attributes = (
          'appName'      => $app_name,
          'lastEdited'   => $last_edited,
          'lowestEdited' => $lowest_edited,
          'rupBuild'     => $rup_build,
      );
  
      if ( $self->{_vba_project} ) {
          push @attributes, codeName => '{37E998C4-C9E5-D4B9-71C8-EB1FF731991C}';
      }
  
      $self->xml_empty_tag( 'fileVersion', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_workbook_pr()
  #
  # Write <workbookPr> element.
  #
  sub _write_workbook_pr {
  
      my $self                   = shift;
      my $date_1904              = $self->{_date_1904};
      my $show_ink_annotation    = 0;
      my $auto_compress_pictures = 0;
      my $default_theme_version  = 124226;
      my $codename               = $self->{_vba_codename};
      my @attributes;
  
      push @attributes, ( 'codeName' => $codename ) if $codename;
      push @attributes, ( 'date1904' => 1 )         if $date_1904;
      push @attributes, ( 'defaultThemeVersion' => $default_theme_version );
  
      $self->xml_empty_tag( 'workbookPr', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_book_views()
  #
  # Write <bookViews> element.
  #
  sub _write_book_views {
  
      my $self = shift;
  
      $self->xml_start_tag( 'bookViews' );
      $self->_write_workbook_view();
      $self->xml_end_tag( 'bookViews' );
  }
  
  ###############################################################################
  #
  # _write_workbook_view()
  #
  # Write <workbookView> element.
  #
  sub _write_workbook_view {
  
      my $self          = shift;
      my $x_window      = $self->{_x_window};
      my $y_window      = $self->{_y_window};
      my $window_width  = $self->{_window_width};
      my $window_height = $self->{_window_height};
      my $tab_ratio     = $self->{_tab_ratio};
      my $active_tab    = $self->{_activesheet};
      my $first_sheet   = $self->{_firstsheet};
  
      my @attributes = (
          'xWindow'      => $x_window,
          'yWindow'      => $y_window,
          'windowWidth'  => $window_width,
          'windowHeight' => $window_height,
      );
  
      # Store the tabRatio attribute when it isn't the default.
      push @attributes, ( tabRatio => $tab_ratio ) if $tab_ratio != 500;
  
      # Store the firstSheet attribute when it isn't the default.
      push @attributes, ( firstSheet => $first_sheet + 1 ) if $first_sheet > 0;
  
      # Store the activeTab attribute when it isn't the first sheet.
      push @attributes, ( activeTab => $active_tab ) if $active_tab > 0;
  
      $self->xml_empty_tag( 'workbookView', @attributes );
  }
  
  ###############################################################################
  #
  # _write_sheets()
  #
  # Write <sheets> element.
  #
  sub _write_sheets {
  
      my $self   = shift;
      my $id_num = 1;
  
      $self->xml_start_tag( 'sheets' );
  
      for my $worksheet ( @{ $self->{_worksheets} } ) {
          $self->_write_sheet( $worksheet->{_name}, $id_num++,
              $worksheet->{_hidden} );
      }
  
      $self->xml_end_tag( 'sheets' );
  }
  
  
  ###############################################################################
  #
  # _write_sheet()
  #
  # Write <sheet> element.
  #
  sub _write_sheet {
  
      my $self     = shift;
      my $name     = shift;
      my $sheet_id = shift;
      my $hidden   = shift;
      my $r_id     = 'rId' . $sheet_id;
  
      my @attributes = (
          'name'    => $name,
          'sheetId' => $sheet_id,
      );
  
      push @attributes, ( 'state' => 'hidden' ) if $hidden;
      push @attributes, ( 'r:id' => $r_id );
  
  
      $self->xml_empty_tag( 'sheet', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_calc_pr()
  #
  # Write <calcPr> element.
  #
  sub _write_calc_pr {
  
      my $self            = shift;
      my $calc_id         = $self->{_calc_id};
      my $concurrent_calc = 0;
  
      my @attributes = ( calcId => $calc_id );
  
      if ( $self->{_calc_mode} eq 'manual' ) {
          push @attributes, 'calcMode'   => 'manual';
          push @attributes, 'calcOnSave' => 0;
      }
      elsif ( $self->{_calc_mode} eq 'autoNoTable' ) {
          push @attributes, calcMode => 'autoNoTable';
      }
  
      if ( $self->{_calc_on_load} ) {
          push @attributes, 'fullCalcOnLoad' => 1;
      }
  
  
      $self->xml_empty_tag( 'calcPr', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_ext_lst()
  #
  # Write <extLst> element.
  #
  sub _write_ext_lst {
  
      my $self = shift;
  
      $self->xml_start_tag( 'extLst' );
      $self->_write_ext();
      $self->xml_end_tag( 'extLst' );
  }
  
  
  ###############################################################################
  #
  # _write_ext()
  #
  # Write <ext> element.
  #
  sub _write_ext {
  
      my $self     = shift;
      my $xmlns_mx = 'http://schemas.microsoft.com/office/mac/excel/2008/main';
      my $uri      = 'http://schemas.microsoft.com/office/mac/excel/2008/main';
  
      my @attributes = (
          'xmlns:mx' => $xmlns_mx,
          'uri'      => $uri,
      );
  
      $self->xml_start_tag( 'ext', @attributes );
      $self->_write_mx_arch_id();
      $self->xml_end_tag( 'ext' );
  }
  
  ###############################################################################
  #
  # _write_mx_arch_id()
  #
  # Write <mx:ArchID> element.
  #
  sub _write_mx_arch_id {
  
      my $self  = shift;
      my $Flags = 2;
  
      my @attributes = ( 'Flags' => $Flags, );
  
      $self->xml_empty_tag( 'mx:ArchID', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_defined_names()
  #
  # Write the <definedNames> element.
  #
  sub _write_defined_names {
  
      my $self = shift;
  
      return unless @{ $self->{_defined_names} };
  
      $self->xml_start_tag( 'definedNames' );
  
      for my $aref ( @{ $self->{_defined_names} } ) {
          $self->_write_defined_name( $aref );
      }
  
      $self->xml_end_tag( 'definedNames' );
  }
  
  
  ##############################################################################
  #
  # _write_defined_name()
  #
  # Write the <definedName> element.
  #
  sub _write_defined_name {
  
      my $self = shift;
      my $data = shift;
  
      my $name   = $data->[0];
      my $id     = $data->[1];
      my $range  = $data->[2];
      my $hidden = $data->[3];
  
      my @attributes = ( 'name' => $name );
  
      push @attributes, ( 'localSheetId' => $id ) if $id != -1;
      push @attributes, ( 'hidden'       => 1 )   if $hidden;
  
      $self->xml_data_element( 'definedName', $range, @attributes );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Workbook - A class for writing Excel Workbooks.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_WORKBOOK

$fatpacked{"Excel/Writer/XLSX/Worksheet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEL_WRITER_XLSX_WORKSHEET';
  package Excel::Writer::XLSX::Worksheet;
  
  ###############################################################################
  #
  # Worksheet - A class for writing Excel Worksheets.
  #
  #
  # Used in conjunction with Excel::Writer::XLSX
  #
  # Copyright 2000-2016, John McNamara, jmcnamara@cpan.org
  #
  # Documentation after __END__
  #
  
  # perltidy with the following options: -mbl=2 -pt=0 -nola
  
  use 5.008002;
  use strict;
  use warnings;
  use Carp;
  use File::Temp 'tempfile';
  use List::Util qw(max min);
  use Excel::Writer::XLSX::Format;
  use Excel::Writer::XLSX::Drawing;
  use Excel::Writer::XLSX::Package::XMLwriter;
  use Excel::Writer::XLSX::Utility qw(xl_cell_to_rowcol
                                      xl_rowcol_to_cell
                                      xl_col_to_name
                                      xl_range
                                      quote_sheetname);
  
  our @ISA     = qw(Excel::Writer::XLSX::Package::XMLwriter);
  our $VERSION = '0.89';
  
  
  ###############################################################################
  #
  # Public and private API methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
  
      my $class  = shift;
      my $fh     = shift;
      my $self   = Excel::Writer::XLSX::Package::XMLwriter->new( $fh );
      my $rowmax = 1_048_576;
      my $colmax = 16_384;
      my $strmax = 32767;
  
      $self->{_name}            = $_[0];
      $self->{_index}           = $_[1];
      $self->{_activesheet}     = $_[2];
      $self->{_firstsheet}      = $_[3];
      $self->{_str_total}       = $_[4];
      $self->{_str_unique}      = $_[5];
      $self->{_str_table}       = $_[6];
      $self->{_date_1904}       = $_[7];
      $self->{_palette}         = $_[8];
      $self->{_optimization}    = $_[9] || 0;
      $self->{_tempdir}         = $_[10];
      $self->{_excel2003_style} = $_[11];
  
      $self->{_ext_sheets}    = [];
      $self->{_fileclosed}    = 0;
      $self->{_excel_version} = 2007;
  
      $self->{_xls_rowmax} = $rowmax;
      $self->{_xls_colmax} = $colmax;
      $self->{_xls_strmax} = $strmax;
      $self->{_dim_rowmin} = undef;
      $self->{_dim_rowmax} = undef;
      $self->{_dim_colmin} = undef;
      $self->{_dim_colmax} = undef;
  
      $self->{_colinfo}    = {};
      $self->{_selections} = [];
      $self->{_hidden}     = 0;
      $self->{_active}     = 0;
      $self->{_tab_color}  = 0;
  
      $self->{_panes}       = [];
      $self->{_active_pane} = 3;
      $self->{_selected}    = 0;
  
      $self->{_page_setup_changed} = 0;
      $self->{_paper_size}         = 0;
      $self->{_orientation}        = 1;
  
      $self->{_print_options_changed} = 0;
      $self->{_hcenter}               = 0;
      $self->{_vcenter}               = 0;
      $self->{_print_gridlines}       = 0;
      $self->{_screen_gridlines}      = 1;
      $self->{_print_headers}         = 0;
  
      $self->{_header_footer_changed} = 0;
      $self->{_header}                = '';
      $self->{_footer}                = '';
      $self->{_header_footer_aligns}  = 1;
      $self->{_header_footer_scales}  = 1;
      $self->{_header_images}         = [];
      $self->{_footer_images}         = [];
  
      $self->{_margin_left}   = 0.7;
      $self->{_margin_right}  = 0.7;
      $self->{_margin_top}    = 0.75;
      $self->{_margin_bottom} = 0.75;
      $self->{_margin_header} = 0.3;
      $self->{_margin_footer} = 0.3;
  
      $self->{_repeat_rows} = '';
      $self->{_repeat_cols} = '';
      $self->{_print_area}  = '';
  
      $self->{_page_order}     = 0;
      $self->{_black_white}    = 0;
      $self->{_draft_quality}  = 0;
      $self->{_print_comments} = 0;
      $self->{_page_start}     = 0;
  
      $self->{_fit_page}   = 0;
      $self->{_fit_width}  = 0;
      $self->{_fit_height} = 0;
  
      $self->{_hbreaks} = [];
      $self->{_vbreaks} = [];
  
      $self->{_protect}  = 0;
      $self->{_password} = undef;
  
      $self->{_set_cols} = {};
      $self->{_set_rows} = {};
  
      $self->{_zoom}              = 100;
      $self->{_zoom_scale_normal} = 1;
      $self->{_print_scale}       = 100;
      $self->{_right_to_left}     = 0;
      $self->{_show_zeros}        = 1;
      $self->{_leading_zeros}     = 0;
  
      $self->{_outline_row_level} = 0;
      $self->{_outline_col_level} = 0;
      $self->{_outline_style}     = 0;
      $self->{_outline_below}     = 1;
      $self->{_outline_right}     = 1;
      $self->{_outline_on}        = 1;
      $self->{_outline_changed}   = 0;
  
      $self->{_original_row_height} = 15;
      $self->{_default_row_height}  = 15;
      $self->{_default_row_pixels}  = 20;
      $self->{_default_col_pixels}  = 64;
      $self->{_default_row_zeroed}  = 0;
  
      $self->{_names} = {};
  
      $self->{_write_match} = [];
  
  
      $self->{_table} = {};
      $self->{_merge} = [];
  
      $self->{_has_vml}             = 0;
      $self->{_has_header_vml}      = 0;
      $self->{_has_comments}        = 0;
      $self->{_comments}            = {};
      $self->{_comments_array}      = [];
      $self->{_comments_author}     = '';
      $self->{_comments_visible}    = 0;
      $self->{_vml_shape_id}        = 1024;
      $self->{_buttons_array}       = [];
      $self->{_header_images_array} = [];
  
      $self->{_autofilter}   = '';
      $self->{_filter_on}    = 0;
      $self->{_filter_range} = [];
      $self->{_filter_cols}  = {};
  
      $self->{_col_sizes}        = {};
      $self->{_row_sizes}        = {};
      $self->{_col_formats}      = {};
      $self->{_col_size_changed} = 0;
      $self->{_row_size_changed} = 0;
  
      $self->{_last_shape_id}          = 1;
      $self->{_rel_count}              = 0;
      $self->{_hlink_count}            = 0;
      $self->{_hlink_refs}             = [];
      $self->{_external_hyper_links}   = [];
      $self->{_external_drawing_links} = [];
      $self->{_external_comment_links} = [];
      $self->{_external_vml_links}     = [];
      $self->{_external_table_links}   = [];
      $self->{_drawing_links}          = [];
      $self->{_vml_drawing_links}      = [];
      $self->{_charts}                 = [];
      $self->{_images}                 = [];
      $self->{_tables}                 = [];
      $self->{_sparklines}             = [];
      $self->{_shapes}                 = [];
      $self->{_shape_hash}             = {};
      $self->{_has_shapes}             = 0;
      $self->{_drawing}                = 0;
  
      $self->{_horizontal_dpi} = 0;
      $self->{_vertical_dpi}   = 0;
  
      $self->{_rstring}      = '';
      $self->{_previous_row} = 0;
  
      if ( $self->{_optimization} == 1 ) {
          my $fh = tempfile( DIR => $self->{_tempdir} );
          binmode $fh, ':utf8';
  
          $self->{_cell_data_fh} = $fh;
          $self->{_fh}           = $fh;
      }
  
      $self->{_validations}  = [];
      $self->{_cond_formats} = {};
      $self->{_dxf_priority} = 1;
  
      if ( $self->{_excel2003_style} ) {
          $self->{_original_row_height}  = 12.75;
          $self->{_default_row_height}   = 12.75;
          $self->{_default_row_pixels}   = 17;
          $self->{_margin_left}          = 0.75;
          $self->{_margin_right}         = 0.75;
          $self->{_margin_top}           = 1;
          $self->{_margin_bottom}        = 1;
          $self->{_margin_header}        = 0.5;
          $self->{_margin_footer}        = 0.5;
          $self->{_header_footer_aligns} = 0;
      }
  
      bless $self, $class;
      return $self;
  }
  
  ###############################################################################
  #
  # _set_xml_writer()
  #
  # Over-ridden to ensure that write_single_row() is called for the final row
  # when optimisation mode is on.
  #
  sub _set_xml_writer {
  
      my $self     = shift;
      my $filename = shift;
  
      if ( $self->{_optimization} == 1 ) {
          $self->_write_single_row();
      }
  
      $self->SUPER::_set_xml_writer( $filename );
  }
  
  
  ###############################################################################
  #
  # _assemble_xml_file()
  #
  # Assemble and write the XML file.
  #
  sub _assemble_xml_file {
  
      my $self = shift;
  
      $self->xml_declaration();
  
      # Write the root worksheet element.
      $self->_write_worksheet();
  
      # Write the worksheet properties.
      $self->_write_sheet_pr();
  
      # Write the worksheet dimensions.
      $self->_write_dimension();
  
      # Write the sheet view properties.
      $self->_write_sheet_views();
  
      # Write the sheet format properties.
      $self->_write_sheet_format_pr();
  
      # Write the sheet column info.
      $self->_write_cols();
  
      # Write the worksheet data such as rows columns and cells.
      if ( $self->{_optimization} == 0 ) {
          $self->_write_sheet_data();
      }
      else {
          $self->_write_optimized_sheet_data();
      }
  
      # Write the sheetProtection element.
      $self->_write_sheet_protection();
  
      # Write the worksheet calculation properties.
      #$self->_write_sheet_calc_pr();
  
      # Write the worksheet phonetic properties.
      if ($self->{_excel2003_style}) {
          $self->_write_phonetic_pr();
      }
  
      # Write the autoFilter element.
      $self->_write_auto_filter();
  
      # Write the mergeCells element.
      $self->_write_merge_cells();
  
      # Write the conditional formats.
      $self->_write_conditional_formats();
  
      # Write the dataValidations element.
      $self->_write_data_validations();
  
      # Write the hyperlink element.
      $self->_write_hyperlinks();
  
      # Write the printOptions element.
      $self->_write_print_options();
  
      # Write the worksheet page_margins.
      $self->_write_page_margins();
  
      # Write the worksheet page setup.
      $self->_write_page_setup();
  
      # Write the headerFooter element.
      $self->_write_header_footer();
  
      # Write the rowBreaks element.
      $self->_write_row_breaks();
  
      # Write the colBreaks element.
      $self->_write_col_breaks();
  
      # Write the drawing element.
      $self->_write_drawings();
  
      # Write the legacyDrawing element.
      $self->_write_legacy_drawing();
  
      # Write the legacyDrawingHF element.
      $self->_write_legacy_drawing_hf();
  
      # Write the tableParts element.
      $self->_write_table_parts();
  
      # Write the extLst and sparklines.
      $self->_write_ext_sparklines();
  
      # Close the worksheet tag.
      $self->xml_end_tag( 'worksheet' );
  
      # Close the XML writer filehandle.
      $self->xml_get_fh()->close();
  }
  
  
  ###############################################################################
  #
  # _close()
  #
  # Write the worksheet elements.
  #
  sub _close {
  
      # TODO. Unused. Remove after refactoring.
      my $self       = shift;
      my $sheetnames = shift;
      my $num_sheets = scalar @$sheetnames;
  }
  
  
  ###############################################################################
  #
  # get_name().
  #
  # Retrieve the worksheet name.
  #
  sub get_name {
  
      my $self = shift;
  
      return $self->{_name};
  }
  
  
  ###############################################################################
  #
  # select()
  #
  # Set this worksheet as a selected worksheet, i.e. the worksheet has its tab
  # highlighted.
  #
  sub select {
  
      my $self = shift;
  
      $self->{_hidden}   = 0;    # Selected worksheet can't be hidden.
      $self->{_selected} = 1;
  }
  
  
  ###############################################################################
  #
  # activate()
  #
  # Set this worksheet as the active worksheet, i.e. the worksheet that is
  # displayed when the workbook is opened. Also set it as selected.
  #
  sub activate {
  
      my $self = shift;
  
      $self->{_hidden}   = 0;    # Active worksheet can't be hidden.
      $self->{_selected} = 1;
      ${ $self->{_activesheet} } = $self->{_index};
  }
  
  
  ###############################################################################
  #
  # hide()
  #
  # Hide this worksheet.
  #
  sub hide {
  
      my $self = shift;
  
      $self->{_hidden} = 1;
  
      # A hidden worksheet shouldn't be active or selected.
      $self->{_selected} = 0;
      ${ $self->{_activesheet} } = 0;
      ${ $self->{_firstsheet} }  = 0;
  }
  
  
  ###############################################################################
  #
  # set_first_sheet()
  #
  # Set this worksheet as the first visible sheet. This is necessary
  # when there are a large number of worksheets and the activated
  # worksheet is not visible on the screen.
  #
  sub set_first_sheet {
  
      my $self = shift;
  
      $self->{_hidden} = 0;    # Active worksheet can't be hidden.
      ${ $self->{_firstsheet} } = $self->{_index};
  }
  
  
  ###############################################################################
  #
  # protect( $password )
  #
  # Set the worksheet protection flags to prevent modification of worksheet
  # objects.
  #
  sub protect {
  
      my $self     = shift;
      my $password = shift || '';
      my $options  = shift || {};
  
      if ( $password ne '' ) {
          $password = $self->_encode_password( $password );
      }
  
      # Default values for objects that can be protected.
      my %defaults = (
          sheet                 => 1,
          content               => 0,
          objects               => 0,
          scenarios             => 0,
          format_cells          => 0,
          format_columns        => 0,
          format_rows           => 0,
          insert_columns        => 0,
          insert_rows           => 0,
          insert_hyperlinks     => 0,
          delete_columns        => 0,
          delete_rows           => 0,
          select_locked_cells   => 1,
          sort                  => 0,
          autofilter            => 0,
          pivot_tables          => 0,
          select_unlocked_cells => 1,
      );
  
  
      # Overwrite the defaults with user specified values.
      for my $key ( keys %{$options} ) {
  
          if ( exists $defaults{$key} ) {
              $defaults{$key} = $options->{$key};
          }
          else {
              carp "Unknown protection object: $key\n";
          }
      }
  
      # Set the password after the user defined values.
      $defaults{password} = $password;
  
      $self->{_protect} = \%defaults;
  }
  
  
  ###############################################################################
  #
  # _encode_password($password)
  #
  # Based on the algorithm provided by Daniel Rentz of OpenOffice.
  #
  sub _encode_password {
  
      use integer;
  
      my $self      = shift;
      my $plaintext = $_[0];
      my $password;
      my $count;
      my @chars;
      my $i = 0;
  
      $count = @chars = split //, $plaintext;
  
      foreach my $char ( @chars ) {
          my $low_15;
          my $high_15;
          $char    = ord( $char ) << ++$i;
          $low_15  = $char & 0x7fff;
          $high_15 = $char & 0x7fff << 15;
          $high_15 = $high_15 >> 15;
          $char    = $low_15 | $high_15;
      }
  
      $password = 0x0000;
      $password ^= $_ for @chars;
      $password ^= $count;
      $password ^= 0xCE4B;
  
      return sprintf "%X", $password;
  }
  
  
  ###############################################################################
  #
  # set_column($firstcol, $lastcol, $width, $format, $hidden, $level)
  #
  # Set the width of a single column or a range of columns.
  # See also: _write_col_info
  #
  sub set_column {
  
      my $self = shift;
      my @data = @_;
      my $cell = $data[0];
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $cell =~ /^\D/ ) {
          @data = $self->_substitute_cellref( @_ );
  
          # Returned values $row1 and $row2 aren't required here. Remove them.
          shift @data;    # $row1
          splice @data, 1, 1;    # $row2
      }
  
      return if @data < 3;       # Ensure at least $firstcol, $lastcol and $width
      return if not defined $data[0];    # Columns must be defined.
      return if not defined $data[1];
  
      # Assume second column is the same as first if 0. Avoids KB918419 bug.
      $data[1] = $data[0] if $data[1] == 0;
  
      # Ensure 2nd col is larger than first. Also for KB918419 bug.
      ( $data[0], $data[1] ) = ( $data[1], $data[0] ) if $data[0] > $data[1];
  
  
      # Check that cols are valid and store max and min values with default row.
      # NOTE: The check shouldn't modify the row dimensions and should only modify
      #       the column dimensions in certain cases.
      my $ignore_row = 1;
      my $ignore_col = 1;
      $ignore_col = 0 if ref $data[3];          # Column has a format.
      $ignore_col = 0 if $data[2] && $data[4];  # Column has a width but is hidden
  
      return -2
        if $self->_check_dimensions( 0, $data[0], $ignore_row, $ignore_col );
      return -2
        if $self->_check_dimensions( 0, $data[1], $ignore_row, $ignore_col );
  
      # Set the limits for the outline levels (0 <= x <= 7).
      $data[5] = 0 unless defined $data[5];
      $data[5] = 0 if $data[5] < 0;
      $data[5] = 7 if $data[5] > 7;
  
      if ( $data[5] > $self->{_outline_col_level} ) {
          $self->{_outline_col_level} = $data[5];
      }
  
      # Store the column data based on the first column. Padded for sorting.
      $self->{_colinfo}->{ sprintf "%05d", $data[0] } = [@data];
  
      # Store the column change to allow optimisations.
      $self->{_col_size_changed} = 1;
  
      # Store the col sizes for use when calculating image vertices taking
      # hidden columns into account. Also store the column formats.
      my $width = $data[4] ? 0 : $data[2];    # Set width to zero if hidden.
      my $format = $data[3];
  
      my ( $firstcol, $lastcol ) = @data;
  
      foreach my $col ( $firstcol .. $lastcol ) {
          $self->{_col_sizes}->{$col} = $width;
          $self->{_col_formats}->{$col} = $format if $format;
      }
  }
  
  
  ###############################################################################
  #
  # set_selection()
  #
  # Set which cell or cells are selected in a worksheet.
  #
  sub set_selection {
  
      my $self = shift;
      my $pane;
      my $active_cell;
      my $sqref;
  
      return unless @_;
  
      # Check for a cell reference in A1 notation and substitute row and column.
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
  
      # There should be either 2 or 4 arguments.
      if ( @_ == 2 ) {
  
          # Single cell selection.
          $active_cell = xl_rowcol_to_cell( $_[0], $_[1] );
          $sqref = $active_cell;
      }
      elsif ( @_ == 4 ) {
  
          # Range selection.
          $active_cell = xl_rowcol_to_cell( $_[0], $_[1] );
  
          my ( $row_first, $col_first, $row_last, $col_last ) = @_;
  
          # Swap last row/col for first row/col as necessary
          if ( $row_first > $row_last ) {
              ( $row_first, $row_last ) = ( $row_last, $row_first );
          }
  
          if ( $col_first > $col_last ) {
              ( $col_first, $col_last ) = ( $col_last, $col_first );
          }
  
          # If the first and last cell are the same write a single cell.
          if ( ( $row_first == $row_last ) && ( $col_first == $col_last ) ) {
              $sqref = $active_cell;
          }
          else {
              $sqref = xl_range( $row_first, $row_last, $col_first, $col_last );
          }
  
      }
      else {
  
          # User supplied wrong number or arguments.
          return;
      }
  
      # Selection isn't set for cell A1.
      return if $sqref eq 'A1';
  
      $self->{_selections} = [ [ $pane, $active_cell, $sqref ] ];
  }
  
  
  ###############################################################################
  #
  # freeze_panes( $row, $col, $top_row, $left_col )
  #
  # Set panes and mark them as frozen.
  #
  sub freeze_panes {
  
      my $self = shift;
  
      return unless @_;
  
      # Check for a cell reference in A1 notation and substitute row and column.
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      my $row      = shift;
      my $col      = shift || 0;
      my $top_row  = shift || $row;
      my $left_col = shift || $col;
      my $type     = shift || 0;
  
      $self->{_panes} = [ $row, $col, $top_row, $left_col, $type ];
  }
  
  
  ###############################################################################
  #
  # split_panes( $y, $x, $top_row, $left_col )
  #
  # Set panes and mark them as split.
  #
  # Implementers note. The API for this method doesn't map well from the XLS
  # file format and isn't sufficient to describe all cases of split panes.
  # It should probably be something like:
  #
  #     split_panes( $y, $x, $top_row, $left_col, $offset_row, $offset_col )
  #
  # I'll look at changing this if it becomes an issue.
  #
  sub split_panes {
  
      my $self = shift;
  
      # Call freeze panes but add the type flag for split panes.
      $self->freeze_panes( @_[ 0 .. 3 ], 2 );
  }
  
  # Older method name for backwards compatibility.
  *thaw_panes = *split_panes;
  
  
  ###############################################################################
  #
  # set_portrait()
  #
  # Set the page orientation as portrait.
  #
  sub set_portrait {
  
      my $self = shift;
  
      $self->{_orientation}        = 1;
      $self->{_page_setup_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # set_landscape()
  #
  # Set the page orientation as landscape.
  #
  sub set_landscape {
  
      my $self = shift;
  
      $self->{_orientation}        = 0;
      $self->{_page_setup_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # set_page_view()
  #
  # Set the page view mode for Mac Excel.
  #
  sub set_page_view {
  
      my $self = shift;
  
      $self->{_page_view} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # set_tab_color()
  #
  # Set the colour of the worksheet tab.
  #
  sub set_tab_color {
  
      my $self  = shift;
      my $color = &Excel::Writer::XLSX::Format::_get_color( $_[0] );
  
      $self->{_tab_color} = $color;
  }
  
  
  ###############################################################################
  #
  # set_paper()
  #
  # Set the paper type. Ex. 1 = US Letter, 9 = A4
  #
  sub set_paper {
  
      my $self       = shift;
      my $paper_size = shift;
  
      if ( $paper_size ) {
          $self->{_paper_size}         = $paper_size;
          $self->{_page_setup_changed} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # set_header()
  #
  # Set the page header caption and optional margin.
  #
  sub set_header {
  
      my $self    = shift;
      my $string  = $_[0] || '';
      my $margin  = $_[1] || 0.3;
      my $options = $_[2] || {};
  
  
      # Replace the Excel placeholder &[Picture] with the internal &G.
      $string =~ s/&\[Picture\]/&G/g;
  
      if ( length $string >= 255 ) {
          carp 'Header string must be less than 255 characters';
          return;
      }
  
      if ( defined $options->{align_with_margins} ) {
          $self->{_header_footer_aligns} = $options->{align_with_margins};
      }
  
      if ( defined $options->{scale_with_doc} ) {
          $self->{_header_footer_scales} = $options->{scale_with_doc};
      }
  
      # Reset the array in case the function is called more than once.
      $self->{_header_images} = [];
  
      if ( $options->{image_left} ) {
          push @{ $self->{_header_images} }, [ $options->{image_left}, 'LH' ];
      }
  
      if ( $options->{image_center} ) {
          push @{ $self->{_header_images} }, [ $options->{image_center}, 'CH' ];
      }
  
      if ( $options->{image_right} ) {
          push @{ $self->{_header_images} }, [ $options->{image_right}, 'RH' ];
      }
  
      my $placeholder_count = () = $string =~ /&G/g;
      my $image_count = @{ $self->{_header_images} };
  
      if ( $image_count != $placeholder_count ) {
          warn "Number of header images ($image_count) doesn't match placeholder "
            . "count ($placeholder_count) in string: $string\n";
          $self->{_header_images} = [];
          return;
      }
  
      if ( $image_count ) {
          $self->{_has_header_vml} = 1;
      }
  
      $self->{_header}                = $string;
      $self->{_margin_header}         = $margin;
      $self->{_header_footer_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # set_footer()
  #
  # Set the page footer caption and optional margin.
  #
  sub set_footer {
  
      my $self    = shift;
      my $string  = $_[0] || '';
      my $margin  = $_[1] || 0.3;
      my $options = $_[2] || {};
  
  
      # Replace the Excel placeholder &[Picture] with the internal &G.
      $string =~ s/&\[Picture\]/&G/g;
  
      if ( length $string >= 255 ) {
          carp 'Footer string must be less than 255 characters';
          return;
      }
  
      if ( defined $options->{align_with_margins} ) {
          $self->{_header_footer_aligns} = $options->{align_with_margins};
      }
  
      if ( defined $options->{scale_with_doc} ) {
          $self->{_header_footer_scales} = $options->{scale_with_doc};
      }
  
      # Reset the array in case the function is called more than once.
      $self->{_footer_images} = [];
  
      if ( $options->{image_left} ) {
          push @{ $self->{_footer_images} }, [ $options->{image_left}, 'LF' ];
      }
  
      if ( $options->{image_center} ) {
          push @{ $self->{_footer_images} }, [ $options->{image_center}, 'CF' ];
      }
  
      if ( $options->{image_right} ) {
          push @{ $self->{_footer_images} }, [ $options->{image_right}, 'RF' ];
      }
  
      my $placeholder_count = () = $string =~ /&G/g;
      my $image_count = @{ $self->{_footer_images} };
  
      if ( $image_count != $placeholder_count ) {
          warn "Number of footer images ($image_count) doesn't match placeholder "
            . "count ($placeholder_count) in string: $string\n";
          $self->{_footer_images} = [];
          return;
      }
  
      if ( $image_count ) {
          $self->{_has_header_vml} = 1;
      }
  
      $self->{_footer}                = $string;
      $self->{_margin_footer}         = $margin;
      $self->{_header_footer_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # center_horizontally()
  #
  # Center the page horizontally.
  #
  sub center_horizontally {
  
      my $self = shift;
  
      $self->{_print_options_changed} = 1;
      $self->{_hcenter}               = 1;
  }
  
  
  ###############################################################################
  #
  # center_vertically()
  #
  # Center the page horizontally.
  #
  sub center_vertically {
  
      my $self = shift;
  
      $self->{_print_options_changed} = 1;
      $self->{_vcenter}               = 1;
  }
  
  
  ###############################################################################
  #
  # set_margins()
  #
  # Set all the page margins to the same value in inches.
  #
  sub set_margins {
  
      my $self = shift;
  
      $self->set_margin_left( $_[0] );
      $self->set_margin_right( $_[0] );
      $self->set_margin_top( $_[0] );
      $self->set_margin_bottom( $_[0] );
  }
  
  
  ###############################################################################
  #
  # set_margins_LR()
  #
  # Set the left and right margins to the same value in inches.
  #
  sub set_margins_LR {
  
      my $self = shift;
  
      $self->set_margin_left( $_[0] );
      $self->set_margin_right( $_[0] );
  }
  
  
  ###############################################################################
  #
  # set_margins_TB()
  #
  # Set the top and bottom margins to the same value in inches.
  #
  sub set_margins_TB {
  
      my $self = shift;
  
      $self->set_margin_top( $_[0] );
      $self->set_margin_bottom( $_[0] );
  }
  
  
  ###############################################################################
  #
  # set_margin_left()
  #
  # Set the left margin in inches.
  #
  sub set_margin_left {
  
      my $self    = shift;
      my $margin  = shift;
      my $default = 0.7;
  
      # Add 0 to ensure the argument is numeric.
      if   ( defined $margin ) { $margin = 0 + $margin }
      else                     { $margin = $default }
  
      $self->{_margin_left} = $margin;
  }
  
  
  ###############################################################################
  #
  # set_margin_right()
  #
  # Set the right margin in inches.
  #
  sub set_margin_right {
  
      my $self    = shift;
      my $margin  = shift;
      my $default = 0.7;
  
      # Add 0 to ensure the argument is numeric.
      if   ( defined $margin ) { $margin = 0 + $margin }
      else                     { $margin = $default }
  
      $self->{_margin_right} = $margin;
  }
  
  
  ###############################################################################
  #
  # set_margin_top()
  #
  # Set the top margin in inches.
  #
  sub set_margin_top {
  
      my $self    = shift;
      my $margin  = shift;
      my $default = 0.75;
  
      # Add 0 to ensure the argument is numeric.
      if   ( defined $margin ) { $margin = 0 + $margin }
      else                     { $margin = $default }
  
      $self->{_margin_top} = $margin;
  }
  
  
  ###############################################################################
  #
  # set_margin_bottom()
  #
  # Set the bottom margin in inches.
  #
  sub set_margin_bottom {
  
  
      my $self    = shift;
      my $margin  = shift;
      my $default = 0.75;
  
      # Add 0 to ensure the argument is numeric.
      if   ( defined $margin ) { $margin = 0 + $margin }
      else                     { $margin = $default }
  
      $self->{_margin_bottom} = $margin;
  }
  
  
  ###############################################################################
  #
  # repeat_rows($first_row, $last_row)
  #
  # Set the rows to repeat at the top of each printed page.
  #
  sub repeat_rows {
  
      my $self = shift;
  
      my $row_min = $_[0];
      my $row_max = $_[1] || $_[0];    # Second row is optional
  
  
      # Convert to 1 based.
      $row_min++;
      $row_max++;
  
      my $area = '$' . $row_min . ':' . '$' . $row_max;
  
      # Build up the print titles "Sheet1!$1:$2"
      my $sheetname = quote_sheetname( $self->{_name} );
      $area = $sheetname . "!" . $area;
  
      $self->{_repeat_rows} = $area;
  }
  
  
  ###############################################################################
  #
  # repeat_columns($first_col, $last_col)
  #
  # Set the columns to repeat at the left hand side of each printed page. This is
  # stored as a <NamedRange> element.
  #
  sub repeat_columns {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
  
          # Returned values $row1 and $row2 aren't required here. Remove them.
          shift @_;    # $row1
          splice @_, 1, 1;    # $row2
      }
  
      my $col_min = $_[0];
      my $col_max = $_[1] || $_[0];    # Second col is optional
  
      # Convert to A notation.
      $col_min = xl_col_to_name( $_[0], 1 );
      $col_max = xl_col_to_name( $_[1], 1 );
  
      my $area = $col_min . ':' . $col_max;
  
      # Build up the print area range "=Sheet2!C1:C2"
      my $sheetname = quote_sheetname( $self->{_name} );
      $area = $sheetname . "!" . $area;
  
      $self->{_repeat_cols} = $area;
  }
  
  
  ###############################################################################
  #
  # print_area($first_row, $first_col, $last_row, $last_col)
  #
  # Set the print area in the current worksheet. This is stored as a <NamedRange>
  # element.
  #
  sub print_area {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      return if @_ != 4;    # Require 4 parameters
  
      my ( $row1, $col1, $row2, $col2 ) = @_;
  
      # Ignore max print area since this is the same as no print area for Excel.
      if (    $row1 == 0
          and $col1 == 0
          and $row2 == $self->{_xls_rowmax} - 1
          and $col2 == $self->{_xls_colmax} - 1 )
      {
          return;
      }
  
      # Build up the print area range "=Sheet2!R1C1:R2C1"
      my $area = $self->_convert_name_area( $row1, $col1, $row2, $col2 );
  
      $self->{_print_area} = $area;
  }
  
  
  ###############################################################################
  #
  # autofilter($first_row, $first_col, $last_row, $last_col)
  #
  # Set the autofilter area in the worksheet.
  #
  sub autofilter {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      return if @_ != 4;    # Require 4 parameters
  
      my ( $row1, $col1, $row2, $col2 ) = @_;
  
      # Reverse max and min values if necessary.
      ( $row1, $row2 ) = ( $row2, $row1 ) if $row2 < $row1;
      ( $col1, $col2 ) = ( $col2, $col1 ) if $col2 < $col1;
  
      # Build up the print area range "Sheet1!$A$1:$C$13".
      my $area = $self->_convert_name_area( $row1, $col1, $row2, $col2 );
      my $ref = xl_range( $row1, $row2, $col1, $col2 );
  
      $self->{_autofilter}     = $area;
      $self->{_autofilter_ref} = $ref;
      $self->{_filter_range}   = [ $col1, $col2 ];
  }
  
  
  ###############################################################################
  #
  # filter_column($column, $criteria, ...)
  #
  # Set the column filter criteria.
  #
  sub filter_column {
  
      my $self       = shift;
      my $col        = $_[0];
      my $expression = $_[1];
  
      croak "Must call autofilter() before filter_column()"
        unless $self->{_autofilter};
      croak "Incorrect number of arguments to filter_column()"
        unless @_ == 2;
  
  
      # Check for a column reference in A1 notation and substitute.
      if ( $col =~ /^\D/ ) {
          my $col_letter = $col;
  
          # Convert col ref to a cell ref and then to a col number.
          ( undef, $col ) = $self->_substitute_cellref( $col . '1' );
  
          croak "Invalid column '$col_letter'" if $col >= $self->{_xls_colmax};
      }
  
      my ( $col_first, $col_last ) = @{ $self->{_filter_range} };
  
      # Reject column if it is outside filter range.
      if ( $col < $col_first or $col > $col_last ) {
          croak "Column '$col' outside autofilter() column range "
            . "($col_first .. $col_last)";
      }
  
  
      my @tokens = $self->_extract_filter_tokens( $expression );
  
      croak "Incorrect number of tokens in expression '$expression'"
        unless ( @tokens == 3 or @tokens == 7 );
  
  
      @tokens = $self->_parse_filter_expression( $expression, @tokens );
  
      # Excel handles single or double custom filters as default filters. We need
      # to check for them and handle them accordingly.
      if ( @tokens == 2 && $tokens[0] == 2 ) {
  
          # Single equality.
          $self->filter_column_list( $col, $tokens[1] );
      }
      elsif (@tokens == 5
          && $tokens[0] == 2
          && $tokens[2] == 1
          && $tokens[3] == 2 )
      {
  
          # Double equality with "or" operator.
          $self->filter_column_list( $col, $tokens[1], $tokens[4] );
      }
      else {
  
          # Non default custom filter.
          $self->{_filter_cols}->{$col} = [@tokens];
          $self->{_filter_type}->{$col} = 0;
  
      }
  
      $self->{_filter_on} = 1;
  }
  
  
  ###############################################################################
  #
  # filter_column_list($column, @matches )
  #
  # Set the column filter criteria in Excel 2007 list style.
  #
  sub filter_column_list {
  
      my $self   = shift;
      my $col    = shift;
      my @tokens = @_;
  
      croak "Must call autofilter() before filter_column_list()"
        unless $self->{_autofilter};
      croak "Incorrect number of arguments to filter_column_list()"
        unless @tokens;
  
      # Check for a column reference in A1 notation and substitute.
      if ( $col =~ /^\D/ ) {
          my $col_letter = $col;
  
          # Convert col ref to a cell ref and then to a col number.
          ( undef, $col ) = $self->_substitute_cellref( $col . '1' );
  
          croak "Invalid column '$col_letter'" if $col >= $self->{_xls_colmax};
      }
  
      my ( $col_first, $col_last ) = @{ $self->{_filter_range} };
  
      # Reject column if it is outside filter range.
      if ( $col < $col_first or $col > $col_last ) {
          croak "Column '$col' outside autofilter() column range "
            . "($col_first .. $col_last)";
      }
  
      $self->{_filter_cols}->{$col} = [@tokens];
      $self->{_filter_type}->{$col} = 1;           # Default style.
      $self->{_filter_on}           = 1;
  }
  
  
  ###############################################################################
  #
  # _extract_filter_tokens($expression)
  #
  # Extract the tokens from the filter expression. The tokens are mainly non-
  # whitespace groups. The only tricky part is to extract string tokens that
  # contain whitespace and/or quoted double quotes (Excel's escaped quotes).
  #
  # Examples: 'x <  2000'
  #           'x >  2000 and x <  5000'
  #           'x = "foo"'
  #           'x = "foo bar"'
  #           'x = "foo "" bar"'
  #
  sub _extract_filter_tokens {
  
      my $self       = shift;
      my $expression = $_[0];
  
      return unless $expression;
  
      my @tokens = ( $expression =~ /"(?:[^"]|"")*"|\S+/g );    #"
  
      # Remove leading and trailing quotes and unescape other quotes
      for ( @tokens ) {
          s/^"//;                                               #"
          s/"$//;                                               #"
          s/""/"/g;                                             #"
      }
  
      return @tokens;
  }
  
  
  ###############################################################################
  #
  # _parse_filter_expression(@token)
  #
  # Converts the tokens of a possibly conditional expression into 1 or 2
  # sub expressions for further parsing.
  #
  # Examples:
  #          ('x', '==', 2000) -> exp1
  #          ('x', '>',  2000, 'and', 'x', '<', 5000) -> exp1 and exp2
  #
  sub _parse_filter_expression {
  
      my $self       = shift;
      my $expression = shift;
      my @tokens     = @_;
  
      # The number of tokens will be either 3 (for 1 expression)
      # or 7 (for 2  expressions).
      #
      if ( @tokens == 7 ) {
  
          my $conditional = $tokens[3];
  
          if ( $conditional =~ /^(and|&&)$/ ) {
              $conditional = 0;
          }
          elsif ( $conditional =~ /^(or|\|\|)$/ ) {
              $conditional = 1;
          }
          else {
              croak "Token '$conditional' is not a valid conditional "
                . "in filter expression '$expression'";
          }
  
          my @expression_1 =
            $self->_parse_filter_tokens( $expression, @tokens[ 0, 1, 2 ] );
          my @expression_2 =
            $self->_parse_filter_tokens( $expression, @tokens[ 4, 5, 6 ] );
  
          return ( @expression_1, $conditional, @expression_2 );
      }
      else {
          return $self->_parse_filter_tokens( $expression, @tokens );
      }
  }
  
  
  ###############################################################################
  #
  # _parse_filter_tokens(@token)
  #
  # Parse the 3 tokens of a filter expression and return the operator and token.
  #
  sub _parse_filter_tokens {
  
      my $self       = shift;
      my $expression = shift;
      my @tokens     = @_;
  
      my %operators = (
          '==' => 2,
          '='  => 2,
          '=~' => 2,
          'eq' => 2,
  
          '!=' => 5,
          '!~' => 5,
          'ne' => 5,
          '<>' => 5,
  
          '<'  => 1,
          '<=' => 3,
          '>'  => 4,
          '>=' => 6,
      );
  
      my $operator = $operators{ $tokens[1] };
      my $token    = $tokens[2];
  
  
      # Special handling of "Top" filter expressions.
      if ( $tokens[0] =~ /^top|bottom$/i ) {
  
          my $value = $tokens[1];
  
          if (   $value =~ /\D/
              or $value < 1
              or $value > 500 )
          {
              croak "The value '$value' in expression '$expression' "
                . "must be in the range 1 to 500";
          }
  
          $token = lc $token;
  
          if ( $token ne 'items' and $token ne '%' ) {
              croak "The type '$token' in expression '$expression' "
                . "must be either 'items' or '%'";
          }
  
          if ( $tokens[0] =~ /^top$/i ) {
              $operator = 30;
          }
          else {
              $operator = 32;
          }
  
          if ( $tokens[2] eq '%' ) {
              $operator++;
          }
  
          $token = $value;
      }
  
  
      if ( not $operator and $tokens[0] ) {
          croak "Token '$tokens[1]' is not a valid operator "
            . "in filter expression '$expression'";
      }
  
  
      # Special handling for Blanks/NonBlanks.
      if ( $token =~ /^blanks|nonblanks$/i ) {
  
          # Only allow Equals or NotEqual in this context.
          if ( $operator != 2 and $operator != 5 ) {
              croak "The operator '$tokens[1]' in expression '$expression' "
                . "is not valid in relation to Blanks/NonBlanks'";
          }
  
          $token = lc $token;
  
          # The operator should always be 2 (=) to flag a "simple" equality in
          # the binary record. Therefore we convert <> to =.
          if ( $token eq 'blanks' ) {
              if ( $operator == 5 ) {
                  $token = ' ';
              }
          }
          else {
              if ( $operator == 5 ) {
                  $operator = 2;
                  $token    = 'blanks';
              }
              else {
                  $operator = 5;
                  $token    = ' ';
              }
          }
      }
  
  
      # if the string token contains an Excel match character then change the
      # operator type to indicate a non "simple" equality.
      if ( $operator == 2 and $token =~ /[*?]/ ) {
          $operator = 22;
      }
  
  
      return ( $operator, $token );
  }
  
  
  ###############################################################################
  #
  # _convert_name_area($first_row, $first_col, $last_row, $last_col)
  #
  # Convert zero indexed rows and columns to the format required by worksheet
  # named ranges, eg, "Sheet1!$A$1:$C$13".
  #
  sub _convert_name_area {
  
      my $self = shift;
  
      my $row_num_1 = $_[0];
      my $col_num_1 = $_[1];
      my $row_num_2 = $_[2];
      my $col_num_2 = $_[3];
  
      my $range1       = '';
      my $range2       = '';
      my $row_col_only = 0;
      my $area;
  
      # Convert to A1 notation.
      my $col_char_1 = xl_col_to_name( $col_num_1, 1 );
      my $col_char_2 = xl_col_to_name( $col_num_2, 1 );
      my $row_char_1 = '$' . ( $row_num_1 + 1 );
      my $row_char_2 = '$' . ( $row_num_2 + 1 );
  
      # We need to handle some special cases that refer to rows or columns only.
      if ( $row_num_1 == 0 and $row_num_2 == $self->{_xls_rowmax} - 1 ) {
          $range1       = $col_char_1;
          $range2       = $col_char_2;
          $row_col_only = 1;
      }
      elsif ( $col_num_1 == 0 and $col_num_2 == $self->{_xls_colmax} - 1 ) {
          $range1       = $row_char_1;
          $range2       = $row_char_2;
          $row_col_only = 1;
      }
      else {
          $range1 = $col_char_1 . $row_char_1;
          $range2 = $col_char_2 . $row_char_2;
      }
  
      # A repeated range is only written once (if it isn't a special case).
      if ( $range1 eq $range2 && !$row_col_only ) {
          $area = $range1;
      }
      else {
          $area = $range1 . ':' . $range2;
      }
  
      # Build up the print area range "Sheet1!$A$1:$C$13".
      my $sheetname = quote_sheetname( $self->{_name} );
      $area = $sheetname . "!" . $area;
  
      return $area;
  }
  
  
  ###############################################################################
  #
  # hide_gridlines()
  #
  # Set the option to hide gridlines on the screen and the printed page.
  #
  # This was mainly useful for Excel 5 where printed gridlines were on by
  # default.
  #
  sub hide_gridlines {
  
      my $self = shift;
      my $option =
        defined $_[0] ? $_[0] : 1;    # Default to hiding printed gridlines
  
      if ( $option == 0 ) {
          $self->{_print_gridlines}       = 1;    # 1 = display, 0 = hide
          $self->{_screen_gridlines}      = 1;
          $self->{_print_options_changed} = 1;
      }
      elsif ( $option == 1 ) {
          $self->{_print_gridlines}  = 0;
          $self->{_screen_gridlines} = 1;
      }
      else {
          $self->{_print_gridlines}  = 0;
          $self->{_screen_gridlines} = 0;
      }
  }
  
  
  ###############################################################################
  #
  # print_row_col_headers()
  #
  # Set the option to print the row and column headers on the printed page.
  # See also the _store_print_headers() method below.
  #
  sub print_row_col_headers {
  
      my $self = shift;
      my $headers = defined $_[0] ? $_[0] : 1;
  
      if ( $headers ) {
          $self->{_print_headers}         = 1;
          $self->{_print_options_changed} = 1;
      }
      else {
          $self->{_print_headers} = 0;
      }
  }
  
  
  ###############################################################################
  #
  # fit_to_pages($width, $height)
  #
  # Store the vertical and horizontal number of pages that will define the
  # maximum area printed.
  #
  sub fit_to_pages {
  
      my $self = shift;
  
      $self->{_fit_page}           = 1;
      $self->{_fit_width}          = defined $_[0] ? $_[0] : 1;
      $self->{_fit_height}         = defined $_[1] ? $_[1] : 1;
      $self->{_page_setup_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # set_h_pagebreaks(@breaks)
  #
  # Store the horizontal page breaks on a worksheet.
  #
  sub set_h_pagebreaks {
  
      my $self = shift;
  
      push @{ $self->{_hbreaks} }, @_;
  }
  
  
  ###############################################################################
  #
  # set_v_pagebreaks(@breaks)
  #
  # Store the vertical page breaks on a worksheet.
  #
  sub set_v_pagebreaks {
  
      my $self = shift;
  
      push @{ $self->{_vbreaks} }, @_;
  }
  
  
  ###############################################################################
  #
  # set_zoom( $scale )
  #
  # Set the worksheet zoom factor.
  #
  sub set_zoom {
  
      my $self = shift;
      my $scale = $_[0] || 100;
  
      # Confine the scale to Excel's range
      if ( $scale < 10 or $scale > 400 ) {
          carp "Zoom factor $scale outside range: 10 <= zoom <= 400";
          $scale = 100;
      }
  
      $self->{_zoom} = int $scale;
  }
  
  
  ###############################################################################
  #
  # set_print_scale($scale)
  #
  # Set the scale factor for the printed page.
  #
  sub set_print_scale {
  
      my $self = shift;
      my $scale = $_[0] || 100;
  
      # Confine the scale to Excel's range
      if ( $scale < 10 or $scale > 400 ) {
          carp "Print scale $scale outside range: 10 <= zoom <= 400";
          $scale = 100;
      }
  
      # Turn off "fit to page" option.
      $self->{_fit_page} = 0;
  
      $self->{_print_scale}        = int $scale;
      $self->{_page_setup_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # print_black_and_white()
  #
  # Set the option to print the worksheet in black and white.
  #
  sub print_black_and_white {
  
      my $self = shift;
  
      $self->{_black_white} = 1;
  }
  
  
  ###############################################################################
  #
  # keep_leading_zeros()
  #
  # Causes the write() method to treat integers with a leading zero as a string.
  # This ensures that any leading zeros such, as in zip codes, are maintained.
  #
  sub keep_leading_zeros {
  
      my $self = shift;
  
      if ( defined $_[0] ) {
          $self->{_leading_zeros} = $_[0];
      }
      else {
          $self->{_leading_zeros} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # show_comments()
  #
  # Make any comments in the worksheet visible.
  #
  sub show_comments {
  
      my $self = shift;
  
      $self->{_comments_visible} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # set_comments_author()
  #
  # Set the default author of the cell comments.
  #
  sub set_comments_author {
  
      my $self = shift;
  
      $self->{_comments_author} = $_[0] if defined $_[0];
  }
  
  
  ###############################################################################
  #
  # right_to_left()
  #
  # Display the worksheet right to left for some eastern versions of Excel.
  #
  sub right_to_left {
  
      my $self = shift;
  
      $self->{_right_to_left} = defined $_[0] ? $_[0] : 1;
  }
  
  
  ###############################################################################
  #
  # hide_zero()
  #
  # Hide cell zero values.
  #
  sub hide_zero {
  
      my $self = shift;
  
      $self->{_show_zeros} = defined $_[0] ? not $_[0] : 0;
  }
  
  
  ###############################################################################
  #
  # print_across()
  #
  # Set the order in which pages are printed.
  #
  sub print_across {
  
      my $self = shift;
      my $page_order = defined $_[0] ? $_[0] : 1;
  
      if ( $page_order ) {
          $self->{_page_order}         = 1;
          $self->{_page_setup_changed} = 1;
      }
      else {
          $self->{_page_order} = 0;
      }
  }
  
  
  ###############################################################################
  #
  # set_start_page()
  #
  # Set the start page number.
  #
  sub set_start_page {
  
      my $self = shift;
      return unless defined $_[0];
  
      $self->{_page_start}   = $_[0];
  }
  
  
  ###############################################################################
  #
  # set_first_row_column()
  #
  # Set the topmost and leftmost visible row and column.
  # TODO: Document this when tested fully for interaction with panes.
  #
  sub set_first_row_column {
  
      my $self = shift;
  
      my $row = $_[0] || 0;
      my $col = $_[1] || 0;
  
      $row = $self->{_xls_rowmax} if $row > $self->{_xls_rowmax};
      $col = $self->{_xls_colmax} if $col > $self->{_xls_colmax};
  
      $self->{_first_row} = $row;
      $self->{_first_col} = $col;
  }
  
  
  ###############################################################################
  #
  # add_write_handler($re, $code_ref)
  #
  # Allow the user to add their own matches and handlers to the write() method.
  #
  sub add_write_handler {
  
      my $self = shift;
  
      return unless @_ == 2;
      return unless ref $_[1] eq 'CODE';
  
      push @{ $self->{_write_match} }, [@_];
  }
  
  
  ###############################################################################
  #
  # write($row, $col, $token, $format)
  #
  # Parse $token and call appropriate write method. $row and $column are zero
  # indexed. $format is optional.
  #
  # Returns: return value of called subroutine
  #
  sub write {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      my $token = $_[2];
  
      # Handle undefs as blanks
      $token = '' unless defined $token;
  
  
      # First try user defined matches.
      for my $aref ( @{ $self->{_write_match} } ) {
          my $re  = $aref->[0];
          my $sub = $aref->[1];
  
          if ( $token =~ /$re/ ) {
              my $match = &$sub( $self, @_ );
              return $match if defined $match;
          }
      }
  
  
      # Match an array ref.
      if ( ref $token eq "ARRAY" ) {
          return $self->write_row( @_ );
      }
  
      # Match integer with leading zero(s)
      elsif ( $self->{_leading_zeros} and $token =~ /^0\d+$/ ) {
          return $self->write_string( @_ );
      }
  
      # Match number
      elsif ( $token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/ ) {
          return $self->write_number( @_ );
      }
  
      # Match http, https or ftp URL
      elsif ( $token =~ m|^[fh]tt?ps?://| ) {
          return $self->write_url( @_ );
      }
  
      # Match mailto:
      elsif ( $token =~ m/^mailto:/ ) {
          return $self->write_url( @_ );
      }
  
      # Match internal or external sheet link
      elsif ( $token =~ m[^(?:in|ex)ternal:] ) {
          return $self->write_url( @_ );
      }
  
      # Match formula
      elsif ( $token =~ /^=/ ) {
          return $self->write_formula( @_ );
      }
  
      # Match array formula
      elsif ( $token =~ /^{=.*}$/ ) {
          return $self->write_formula( @_ );
      }
  
      # Match blank
      elsif ( $token eq '' ) {
          splice @_, 2, 1;    # remove the empty string from the parameter list
          return $self->write_blank( @_ );
      }
  
      # Default: match string
      else {
          return $self->write_string( @_ );
      }
  }
  
  
  ###############################################################################
  #
  # write_row($row, $col, $array_ref, $format)
  #
  # Write a row of data starting from ($row, $col). Call write_col() if any of
  # the elements of the array ref are in turn array refs. This allows the writing
  # of 1D or 2D arrays of data in one go.
  #
  # Returns: the first encountered error value or zero for no errors
  #
  sub write_row {
  
      my $self = shift;
  
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Catch non array refs passed by user.
      if ( ref $_[2] ne 'ARRAY' ) {
          croak "Not an array ref in call to write_row()$!";
      }
  
      my $row     = shift;
      my $col     = shift;
      my $tokens  = shift;
      my @options = @_;
      my $error   = 0;
      my $ret;
  
      for my $token ( @$tokens ) {
  
          # Check for nested arrays
          if ( ref $token eq "ARRAY" ) {
              $ret = $self->write_col( $row, $col, $token, @options );
          }
          else {
              $ret = $self->write( $row, $col, $token, @options );
          }
  
          # Return only the first error encountered, if any.
          $error ||= $ret;
          $col++;
      }
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # write_col($row, $col, $array_ref, $format)
  #
  # Write a column of data starting from ($row, $col). Call write_row() if any of
  # the elements of the array ref are in turn array refs. This allows the writing
  # of 1D or 2D arrays of data in one go.
  #
  # Returns: the first encountered error value or zero for no errors
  #
  sub write_col {
  
      my $self = shift;
  
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Catch non array refs passed by user.
      if ( ref $_[2] ne 'ARRAY' ) {
          croak "Not an array ref in call to write_col()$!";
      }
  
      my $row     = shift;
      my $col     = shift;
      my $tokens  = shift;
      my @options = @_;
      my $error   = 0;
      my $ret;
  
      for my $token ( @$tokens ) {
  
          # write() will deal with any nested arrays
          $ret = $self->write( $row, $col, $token, @options );
  
          # Return only the first error encountered, if any.
          $error ||= $ret;
          $row++;
      }
  
      return $error;
  }
  
  
  ###############################################################################
  #
  # write_comment($row, $col, $comment)
  #
  # Write a comment to the specified row and column (zero indexed).
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_comment {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
      my $row = $_[0];
      my $col = $_[1];
  
      # Check for pairs of optional arguments, i.e. an odd number of args.
      croak "Uneven number of additional arguments" unless @_ % 2;
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      $self->{_has_vml}      = 1;
      $self->{_has_comments} = 1;
  
      # Process the properties of the cell comment.
      $self->{_comments}->{$row}->{$col} = [ $self->_comment_params( @_ ) ];
  }
  
  
  ###############################################################################
  #
  # write_number($row, $col, $num, $format)
  #
  # Write a double to the specified row and column (zero indexed).
  # An integer can be written as a double. Excel will display an
  # integer. $format is optional.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_number {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
  
      my $row  = $_[0];              # Zero indexed row
      my $col  = $_[1];              # Zero indexed column
      my $num  = $_[2] + 0;
      my $xf   = $_[3];              # The cell format
      my $type = 'n';                # The data type
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, $num, $xf ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_string ($row, $col, $string, $format)
  #
  # Write a string to the specified row and column (zero indexed).
  # $format is optional.
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : long string truncated to 32767 chars
  #
  sub write_string {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
      my $row  = $_[0];              # Zero indexed row
      my $col  = $_[1];              # Zero indexed column
      my $str  = $_[2];
      my $xf   = $_[3];              # The cell format
      my $type = 's';                # The data type
      my $index;
      my $str_error = 0;
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      # Check that the string is < 32767 chars
      if ( length $str > $self->{_xls_strmax} ) {
          $str = substr( $str, 0, $self->{_xls_strmax} );
          $str_error = -3;
      }
  
      # Write a shared string or an in-line string based on optimisation level.
      if ( $self->{_optimization} == 0 ) {
          $index = $self->_get_shared_string_index( $str );
      }
      else {
          $index = $str;
      }
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, $index, $xf ];
  
      return $str_error;
  }
  
  
  ###############################################################################
  #
  # write_rich_string( $row, $column, $format, $string, ..., $cell_format )
  #
  # The write_rich_string() method is used to write strings with multiple formats.
  # The method receives string fragments prefixed by format objects. The final
  # format object is used as the cell format.
  #
  # Returns  0 : normal termination.
  #         -1 : insufficient number of arguments.
  #         -2 : row or column out of range.
  #         -3 : long string truncated to 32767 chars.
  #         -4 : 2 consecutive formats used.
  #
  sub write_rich_string {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
      my $row    = shift;            # Zero indexed row.
      my $col    = shift;            # Zero indexed column.
      my $str    = '';
      my $xf     = undef;
      my $type   = 's';              # The data type.
      my $length = 0;                # String length.
      my $index;
      my $str_error = 0;
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
  
      # If the last arg is a format we use it as the cell format.
      if ( ref $_[-1] ) {
          $xf = pop @_;
      }
  
  
      # Create a temp XML::Writer object and use it to write the rich string
      # XML to a string.
      open my $str_fh, '>', \$str or die "Failed to open filehandle: $!";
      binmode $str_fh, ':utf8';
  
      my $writer = Excel::Writer::XLSX::Package::XMLwriter->new( $str_fh );
  
      $self->{_rstring} = $writer;
  
      # Create a temp format with the default font for unformatted fragments.
      my $default = Excel::Writer::XLSX::Format->new();
  
      # Convert the list of $format, $string tokens to pairs of ($format, $string)
      # except for the first $string fragment which doesn't require a default
      # formatting run. Use the default for strings without a leading format.
      my @fragments;
      my $last = 'format';
      my $pos  = 0;
  
      for my $token ( @_ ) {
          if ( !ref $token ) {
  
              # Token is a string.
              if ( $last ne 'format' ) {
  
                  # If previous token wasn't a format add one before the string.
                  push @fragments, ( $default, $token );
              }
              else {
  
                  # If previous token was a format just add the string.
                  push @fragments, $token;
              }
  
              $length += length $token;    # Keep track of actual string length.
              $last = 'string';
          }
          else {
  
              # Can't allow 2 formats in a row.
              if ( $last eq 'format' && $pos > 0 ) {
                  return -4;
              }
  
              # Token is a format object. Add it to the fragment list.
              push @fragments, $token;
              $last = 'format';
          }
  
          $pos++;
      }
  
  
      # If the first token is a string start the <r> element.
      if ( !ref $fragments[0] ) {
          $self->{_rstring}->xml_start_tag( 'r' );
      }
  
      # Write the XML elements for the $format $string fragments.
      for my $token ( @fragments ) {
          if ( ref $token ) {
  
              # Write the font run.
              $self->{_rstring}->xml_start_tag( 'r' );
              $self->_write_font( $token );
          }
          else {
  
              # Write the string fragment part, with whitespace handling.
              my @attributes = ();
  
              if ( $token =~ /^\s/ || $token =~ /\s$/ ) {
                  push @attributes, ( 'xml:space' => 'preserve' );
              }
  
              $self->{_rstring}->xml_data_element( 't', $token, @attributes );
              $self->{_rstring}->xml_end_tag( 'r' );
          }
      }
  
      # Check that the string is < 32767 chars.
      if ( $length > $self->{_xls_strmax} ) {
          return -3;
      }
  
  
      # Write a shared string or an in-line string based on optimisation level.
      if ( $self->{_optimization} == 0 ) {
          $index = $self->_get_shared_string_index( $str );
      }
      else {
          $index = $str;
      }
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, $index, $xf ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_blank($row, $col, $format)
  #
  # Write a blank cell to the specified row and column (zero indexed).
  # A blank cell is used to specify formatting without adding a string
  # or a number.
  #
  # A blank cell without a format serves no purpose. Therefore, we don't write
  # a BLANK record unless a format is specified. This is mainly an optimisation
  # for the write_row() and write_col() methods.
  #
  # Returns  0 : normal termination (including no format)
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_blank {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Check the number of args
      return -1 if @_ < 2;
  
      # Don't write a blank cell unless it has a format
      return 0 if not defined $_[2];
  
      my $row  = $_[0];    # Zero indexed row
      my $col  = $_[1];    # Zero indexed column
      my $xf   = $_[2];    # The cell format
      my $type = 'b';      # The data type
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, undef, $xf ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_formula($row, $col, $formula, $format)
  #
  # Write a formula to the specified row and column (zero indexed).
  #
  # $format is optional.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_formula {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
      my $row     = $_[0];           # Zero indexed row
      my $col     = $_[1];           # Zero indexed column
      my $formula = $_[2];           # The formula text string
      my $xf      = $_[3];           # The format object.
      my $value   = $_[4];           # Optional formula value.
      my $type    = 'f';             # The data type
  
      # Hand off array formulas.
      if ( $formula =~ /^{=.*}$/ ) {
          return $self->write_array_formula( $row, $col, $row, $col, $formula,
              $xf, $value );
      }
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      # Remove the = sign if it exists.
      $formula =~ s/^=//;
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, $formula, $xf, $value ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_array_formula($row1, $col1, $row2, $col2, $formula, $format)
  #
  # Write an array formula to the specified row and column (zero indexed).
  #
  # $format is optional.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #
  sub write_array_formula {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 5 ) { return -1 }    # Check the number of args
  
      my $row1    = $_[0];           # First row
      my $col1    = $_[1];           # First column
      my $row2    = $_[2];           # Last row
      my $col2    = $_[3];           # Last column
      my $formula = $_[4];           # The formula text string
      my $xf      = $_[5];           # The format object.
      my $value   = $_[6];           # Optional formula value.
      my $type    = 'a';             # The data type
  
      # Swap last row/col with first row/col as necessary
      ( $row1, $row2 ) = ( $row2, $row1 ) if $row1 > $row2;
      ( $col1, $col2 ) = ( $col1, $col2 ) if $col1 > $col2;
  
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row2, $col2 );
  
  
      # Define array range
      my $range;
  
      if ( $row1 == $row2 and $col1 == $col2 ) {
          $range = xl_rowcol_to_cell( $row1, $col1 );
  
      }
      else {
          $range =
              xl_rowcol_to_cell( $row1, $col1 ) . ':'
            . xl_rowcol_to_cell( $row2, $col2 );
      }
  
      # Remove array formula braces and the leading =.
      $formula =~ s/^{(.*)}$/$1/;
      $formula =~ s/^=//;
  
      # Write previous row if in in-line string optimization mode.
      my $row = $row1;
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row1}->{$col1} =
        [ $type, $formula, $xf, $range, $value ];
  
  
      # Pad out the rest of the area with formatted zeroes.
      if ( !$self->{_optimization} ) {
          for my $row ( $row1 .. $row2 ) {
              for my $col ( $col1 .. $col2 ) {
                  next if $row == $row1 and $col == $col1;
                  $self->write_number( $row, $col, 0, $xf );
              }
          }
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # write_blank($row, $col, $format)
  #
  # Write a boolean value to the specified row and column (zero indexed).
  #
  # Returns  0 : normal termination (including no format)
  #         -2 : row or column out of range
  #
  sub write_boolean {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      my $row  = $_[0];            # Zero indexed row
      my $col  = $_[1];            # Zero indexed column
      my $val  = $_[2] ? 1 : 0;    # Boolean value.
      my $xf   = $_[3];            # The cell format
      my $type = 'l';              # The data type
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, $val, $xf ];
  
      return 0;
  }
  
  
  ###############################################################################
  #
  # outline_settings($visible, $symbols_below, $symbols_right, $auto_style)
  #
  # This method sets the properties for outlining and grouping. The defaults
  # correspond to Excel's defaults.
  #
  sub outline_settings {
  
      my $self = shift;
  
      $self->{_outline_on}    = defined $_[0] ? $_[0] : 1;
      $self->{_outline_below} = defined $_[1] ? $_[1] : 1;
      $self->{_outline_right} = defined $_[2] ? $_[2] : 1;
      $self->{_outline_style} = $_[3] || 0;
  
      $self->{_outline_changed} = 1;
  }
  
  
  ###############################################################################
  #
  # write_url($row, $col, $url, $string, $format)
  #
  # Write a hyperlink. This is comprised of two elements: the visible label and
  # the invisible link. The visible label is the same as the link unless an
  # alternative string is specified. The label is written using the
  # write_string() method. Therefore the max characters string limit applies.
  # $string and $format are optional and their order is interchangeable.
  #
  # The hyperlink can be to a http, ftp, mail, internal sheet, or external
  # directory url.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : long string truncated to 32767 chars
  #         -4 : URL longer than 255 characters
  #         -5 : Exceeds limit of 65_530 urls per worksheet
  #
  sub write_url {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
  
      # Reverse the order of $string and $format if necessary. We work on a copy
      # in order to protect the callers args. We don't use "local @_" in case of
      # perl50005 threads.
      my @args = @_;
      ( $args[3], $args[4] ) = ( $args[4], $args[3] ) if ref $args[3];
  
  
      my $row       = $args[0];    # Zero indexed row
      my $col       = $args[1];    # Zero indexed column
      my $url       = $args[2];    # URL string
      my $str       = $args[3];    # Alternative label
      my $xf        = $args[4];    # Cell format
      my $tip       = $args[5];    # Tool tip
      my $type      = 'l';         # XML data type
      my $link_type = 1;
  
      # The displayed string defaults to the url string.
      $str = $url unless defined $str;
  
      # Remove the URI scheme from internal links.
      if ( $url =~ s/^internal:// ) {
          $str =~ s/^internal://;
          $link_type = 2;
      }
  
      # Remove the URI scheme from external links and change the directory
      # separator from Unix to Dos.
      if ( $url =~ s/^external:// ) {
          $str =~ s/^external://;
          $url =~ s[/][\\]g;
          $str =~ s[/][\\]g;
      }
  
      # Strip the mailto header.
      $str =~ s/^mailto://;
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      # Check that the string is < 32767 chars
      my $str_error = 0;
      if ( length $str > $self->{_xls_strmax} ) {
          $str = substr( $str, 0, $self->{_xls_strmax} );
          $str_error = -3;
      }
  
      # Copy string for use in hyperlink elements.
      my $url_str = $str;
  
      # External links to URLs and to other Excel workbooks have slightly
      # different characteristics that we have to account for.
      if ( $link_type == 1 ) {
  
          # Escape URL unless it looks already escaped.
          if ( $url !~ /%[0-9a-fA-F]{2}/ ) {
  
              # Escape the URL escape symbol.
              $url =~ s/%/%25/g;
  
              # Escape whitespace in URL.
              $url =~ s/[\s\x00]/%20/g;
  
              # Escape other special characters in URL.
              $url =~ s/(["<>[\]`^{}])/sprintf '%%%x', ord $1/eg;
          }
  
          # Split url into the link and optional anchor/location.
          ( $url, $url_str ) = split /#/, $url, 2;
  
          # Add the file:/// URI to the url for Windows style "C:/" link and
          # Network shares.
          if ( $url =~ m{^\w:} || $url =~ m{^\\\\} ) {
              $url = 'file:///' . $url;
          }
  
          # Convert a ./dir/file.xlsx link to dir/file.xlsx.
          $url =~ s{^.\\}{};
      }
  
      # Excel limits the escaped URL and location/anchor to 255 characters.
      my $tmp_url_str = $url_str || '';
  
      if ( length $url > 255 || length $tmp_url_str > 255) {
          carp "Ignoring URL '$url' where link or anchor > 255 characters "
            . "since it exceeds Excel's limit for URLS. See LIMITATIONS "
            . "section of the Excel::Writer::XLSX documentation.";
          return -4;
      }
  
      # Check the limit of URLS per worksheet.
      $self->{_hlink_count}++;
  
      if ( $self->{_hlink_count} > 65_530 ) {
          carp "Ignoring URL '$url' since it exceeds Excel's limit of 65,530 "
            . "URLS per worksheet. See LIMITATIONS section of the "
            . "Excel::Writer::XLSX documentation.";
          return -5;
      }
  
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      # Write the hyperlink string.
      $self->write_string( $row, $col, $str, $xf );
  
      # Store the hyperlink data in a separate structure.
      $self->{_hyperlinks}->{$row}->{$col} = {
          _link_type => $link_type,
          _url       => $url,
          _str       => $url_str,
          _tip       => $tip
      };
  
      return $str_error;
  }
  
  
  ###############################################################################
  #
  # write_date_time ($row, $col, $string, $format)
  #
  # Write a datetime string in ISO8601 "yyyy-mm-ddThh:mm:ss.ss" format as a
  # number representing an Excel date. $format is optional.
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : Invalid date_time, written as string
  #
  sub write_date_time {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      if ( @_ < 3 ) { return -1 }    # Check the number of args
  
      my $row  = $_[0];              # Zero indexed row
      my $col  = $_[1];              # Zero indexed column
      my $str  = $_[2];
      my $xf   = $_[3];              # The cell format
      my $type = 'n';                # The data type
  
  
      # Check that row and col are valid and store max and min values
      return -2 if $self->_check_dimensions( $row, $col );
  
      my $str_error = 0;
      my $date_time = $self->convert_date_time( $str );
  
      # If the date isn't valid then write it as a string.
      if ( !defined $date_time ) {
          return $self->write_string( @_ );
      }
  
      # Write previous row if in in-line string optimization mode.
      if ( $self->{_optimization} == 1 && $row > $self->{_previous_row} ) {
          $self->_write_single_row( $row );
      }
  
      $self->{_table}->{$row}->{$col} = [ $type, $date_time, $xf ];
  
      return $str_error;
  }
  
  
  ###############################################################################
  #
  # convert_date_time($date_time_string)
  #
  # The function takes a date and time in ISO8601 "yyyy-mm-ddThh:mm:ss.ss" format
  # and converts it to a decimal number representing a valid Excel date.
  #
  # Dates and times in Excel are represented by real numbers. The integer part of
  # the number stores the number of days since the epoch and the fractional part
  # stores the percentage of the day in seconds. The epoch can be either 1900 or
  # 1904.
  #
  # Parameter: Date and time string in one of the following formats:
  #               yyyy-mm-ddThh:mm:ss.ss  # Standard
  #               yyyy-mm-ddT             # Date only
  #                         Thh:mm:ss.ss  # Time only
  #
  # Returns:
  #            A decimal number representing a valid Excel date, or
  #            undef if the date is invalid.
  #
  sub convert_date_time {
  
      my $self      = shift;
      my $date_time = $_[0];
  
      my $days    = 0;    # Number of days since epoch
      my $seconds = 0;    # Time expressed as fraction of 24h hours in seconds
  
      my ( $year, $month, $day );
      my ( $hour, $min,   $sec );
  
  
      # Strip leading and trailing whitespace.
      $date_time =~ s/^\s+//;
      $date_time =~ s/\s+$//;
  
      # Check for invalid date char.
      return if $date_time =~ /[^0-9T:\-\.Z]/;
  
      # Check for "T" after date or before time.
      return unless $date_time =~ /\dT|T\d/;
  
      # Strip trailing Z in ISO8601 date.
      $date_time =~ s/Z$//;
  
  
      # Split into date and time.
      my ( $date, $time ) = split /T/, $date_time;
  
  
      # We allow the time portion of the input DateTime to be optional.
      if ( $time ne '' ) {
  
          # Match hh:mm:ss.sss+ where the seconds are optional
          if ( $time =~ /^(\d\d):(\d\d)(:(\d\d(\.\d+)?))?/ ) {
              $hour = $1;
              $min  = $2;
              $sec  = $4 || 0;
          }
          else {
              return undef;    # Not a valid time format.
          }
  
          # Some boundary checks
          return if $hour >= 24;
          return if $min >= 60;
          return if $sec >= 60;
  
          # Excel expresses seconds as a fraction of the number in 24 hours.
          $seconds = ( $hour * 60 * 60 + $min * 60 + $sec ) / ( 24 * 60 * 60 );
      }
  
  
      # We allow the date portion of the input DateTime to be optional.
      return $seconds if $date eq '';
  
  
      # Match date as yyyy-mm-dd.
      if ( $date =~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/ ) {
          $year  = $1;
          $month = $2;
          $day   = $3;
      }
      else {
          return undef;    # Not a valid date format.
      }
  
      # Set the epoch as 1900 or 1904. Defaults to 1900.
      my $date_1904 = $self->{_date_1904};
  
  
      # Special cases for Excel.
      if ( not $date_1904 ) {
          return $seconds      if $date eq '1899-12-31';    # Excel 1900 epoch
          return $seconds      if $date eq '1900-01-00';    # Excel 1900 epoch
          return 60 + $seconds if $date eq '1900-02-29';    # Excel false leapday
      }
  
  
      # We calculate the date by calculating the number of days since the epoch
      # and adjust for the number of leap days. We calculate the number of leap
      # days by normalising the year in relation to the epoch. Thus the year 2000
      # becomes 100 for 4 and 100 year leapdays and 400 for 400 year leapdays.
      #
      my $epoch  = $date_1904 ? 1904 : 1900;
      my $offset = $date_1904 ? 4    : 0;
      my $norm   = 300;
      my $range  = $year - $epoch;
  
  
      # Set month days and check for leap year.
      my @mdays = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
      my $leap = 0;
      $leap = 1 if $year % 4 == 0 and $year % 100 or $year % 400 == 0;
      $mdays[1] = 29 if $leap;
  
  
      # Some boundary checks
      return if $year < $epoch or $year > 9999;
      return if $month < 1     or $month > 12;
      return if $day < 1       or $day > $mdays[ $month - 1 ];
  
      # Accumulate the number of days since the epoch.
      $days = $day;    # Add days for current month
      $days += $mdays[$_] for 0 .. $month - 2;    # Add days for past months
      $days += $range * 365;                      # Add days for past years
      $days += int( ( $range ) / 4 );             # Add leapdays
      $days -= int( ( $range + $offset ) / 100 ); # Subtract 100 year leapdays
      $days += int( ( $range + $offset + $norm ) / 400 );  # Add 400 year leapdays
      $days -= $leap;                                      # Already counted above
  
  
      # Adjust for Excel erroneously treating 1900 as a leap year.
      $days++ if $date_1904 == 0 and $days > 59;
  
      return $days + $seconds;
  }
  
  
  ###############################################################################
  #
  # set_row($row, $height, $XF, $hidden, $level, $collapsed)
  #
  # This method is used to set the height and XF format for a row.
  #
  sub set_row {
  
      my $self      = shift;
      my $row       = shift;         # Row Number.
      my $height    = shift;         # Row height.
      my $xf        = shift;         # Format object.
      my $hidden    = shift || 0;    # Hidden flag.
      my $level     = shift || 0;    # Outline level.
      my $collapsed = shift || 0;    # Collapsed row.
      my $min_col   = 0;
  
      return unless defined $row;    # Ensure at least $row is specified.
  
      # Get the default row height.
      my $default_height = $self->{_default_row_height};
  
      # Use min col in _check_dimensions(). Default to 0 if undefined.
      if ( defined $self->{_dim_colmin} ) {
          $min_col = $self->{_dim_colmin};
      }
  
      # Check that row is valid.
      return -2 if $self->_check_dimensions( $row, $min_col );
  
      $height = $default_height if !defined $height;
  
      # If the height is 0 the row is hidden and the height is the default.
      if ( $height == 0 ) {
          $hidden = 1;
          $height = $default_height;
      }
  
      # Set the limits for the outline levels (0 <= x <= 7).
      $level = 0 if $level < 0;
      $level = 7 if $level > 7;
  
      if ( $level > $self->{_outline_row_level} ) {
          $self->{_outline_row_level} = $level;
      }
  
      # Store the row properties.
      $self->{_set_rows}->{$row} = [ $height, $xf, $hidden, $level, $collapsed ];
  
      # Store the row change to allow optimisations.
      $self->{_row_size_changed} = 1;
  
      if ($hidden) {
          $height = 0;
      }
  
      # Store the row sizes for use when calculating image vertices.
      $self->{_row_sizes}->{$row} = $height;
  }
  
  
  ###############################################################################
  #
  # set_default_row()
  #
  # Set the default row properties
  #
  sub set_default_row {
  
      my $self        = shift;
      my $height      = shift || $self->{_original_row_height};
      my $zero_height = shift || 0;
  
      if ( $height != $self->{_original_row_height} ) {
          $self->{_default_row_height} = $height;
  
          # Store the row change to allow optimisations.
          $self->{_row_size_changed} = 1;
      }
  
      if ( $zero_height ) {
          $self->{_default_row_zeroed} = 1;
      }
  }
  
  
  ###############################################################################
  #
  # merge_range($first_row, $first_col, $last_row, $last_col, $string, $format)
  #
  # Merge a range of cells. The first cell should contain the data and the others
  # should be blank. All cells should contain the same format.
  #
  sub merge_range {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
      croak "Incorrect number of arguments" if @_ < 6;
      croak "Fifth parameter must be a format object" unless ref $_[5];
  
      my $row_first  = shift;
      my $col_first  = shift;
      my $row_last   = shift;
      my $col_last   = shift;
      my $string     = shift;
      my $format     = shift;
      my @extra_args = @_;      # For write_url().
  
      # Excel doesn't allow a single cell to be merged
      if ( $row_first == $row_last and $col_first == $col_last ) {
          croak "Can't merge single cell";
      }
  
      # Swap last row/col with first row/col as necessary
      ( $row_first, $row_last ) = ( $row_last, $row_first )
        if $row_first > $row_last;
      ( $col_first, $col_last ) = ( $col_last, $col_first )
        if $col_first > $col_last;
  
      # Check that column number is valid and store the max value
      return if $self->_check_dimensions( $row_last, $col_last );
  
      # Store the merge range.
      push @{ $self->{_merge} }, [ $row_first, $col_first, $row_last, $col_last ];
  
      # Write the first cell
      $self->write( $row_first, $col_first, $string, $format, @extra_args );
  
      # Pad out the rest of the area with formatted blank cells.
      for my $row ( $row_first .. $row_last ) {
          for my $col ( $col_first .. $col_last ) {
              next if $row == $row_first and $col == $col_first;
              $self->write_blank( $row, $col, $format );
          }
      }
  }
  
  
  ###############################################################################
  #
  # merge_range_type()
  #
  # Same as merge_range() above except the type of write() is specified.
  #
  sub merge_range_type {
  
      my $self = shift;
      my $type = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      my $row_first = shift;
      my $col_first = shift;
      my $row_last  = shift;
      my $col_last  = shift;
      my $format;
  
      # Get the format. It can be in different positions for the different types.
      if (   $type eq 'array_formula'
          || $type eq 'blank'
          || $type eq 'rich_string' )
      {
  
          # The format is the last element.
          $format = $_[-1];
      }
      else {
  
          # Or else it is after the token.
          $format = $_[1];
      }
  
      # Check that there is a format object.
      croak "Format object missing or in an incorrect position"
        unless ref $format;
  
      # Excel doesn't allow a single cell to be merged
      if ( $row_first == $row_last and $col_first == $col_last ) {
          croak "Can't merge single cell";
      }
  
      # Swap last row/col with first row/col as necessary
      ( $row_first, $row_last ) = ( $row_last, $row_first )
        if $row_first > $row_last;
      ( $col_first, $col_last ) = ( $col_last, $col_first )
        if $col_first > $col_last;
  
      # Check that column number is valid and store the max value
      return if $self->_check_dimensions( $row_last, $col_last );
  
      # Store the merge range.
      push @{ $self->{_merge} }, [ $row_first, $col_first, $row_last, $col_last ];
  
      # Write the first cell
      if ( $type eq 'string' ) {
          $self->write_string( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'number' ) {
          $self->write_number( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'blank' ) {
          $self->write_blank( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'date_time' ) {
          $self->write_date_time( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'rich_string' ) {
          $self->write_rich_string( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'url' ) {
          $self->write_url( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'formula' ) {
          $self->write_formula( $row_first, $col_first, @_ );
      }
      elsif ( $type eq 'array_formula' ) {
          $self->write_formula_array( $row_first, $col_first, @_ );
      }
      else {
          croak "Unknown type '$type'";
      }
  
      # Pad out the rest of the area with formatted blank cells.
      for my $row ( $row_first .. $row_last ) {
          for my $col ( $col_first .. $col_last ) {
              next if $row == $row_first and $col == $col_first;
              $self->write_blank( $row, $col, $format );
          }
      }
  }
  
  
  ###############################################################################
  #
  # data_validation($row, $col, {...})
  #
  # This method handles the interface to Excel data validation.
  # Somewhat ironically this requires a lot of validation code since the
  # interface is flexible and covers a several types of data validation.
  #
  # We allow data validation to be called on one cell or a range of cells. The
  # hashref contains the validation parameters and must be the last param:
  #    data_validation($row, $col, {...})
  #    data_validation($first_row, $first_col, $last_row, $last_col, {...})
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : incorrect parameter.
  #
  sub data_validation {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Check for a valid number of args.
      if ( @_ != 5 && @_ != 3 ) { return -1 }
  
      # The final hashref contains the validation parameters.
      my $param = pop;
  
      # Make the last row/col the same as the first if not defined.
      my ( $row1, $col1, $row2, $col2 ) = @_;
      if ( !defined $row2 ) {
          $row2 = $row1;
          $col2 = $col1;
      }
  
      # Check that row and col are valid without storing the values.
      return -2 if $self->_check_dimensions( $row1, $col1, 1, 1 );
      return -2 if $self->_check_dimensions( $row2, $col2, 1, 1 );
  
  
      # Check that the last parameter is a hash list.
      if ( ref $param ne 'HASH' ) {
          carp "Last parameter '$param' in data_validation() must be a hash ref";
          return -3;
      }
  
      # List of valid input parameters.
      my %valid_parameter = (
          validate      => 1,
          criteria      => 1,
          value         => 1,
          source        => 1,
          minimum       => 1,
          maximum       => 1,
          ignore_blank  => 1,
          dropdown      => 1,
          show_input    => 1,
          input_title   => 1,
          input_message => 1,
          show_error    => 1,
          error_title   => 1,
          error_message => 1,
          error_type    => 1,
          other_cells   => 1,
      );
  
      # Check for valid input parameters.
      for my $param_key ( keys %$param ) {
          if ( not exists $valid_parameter{$param_key} ) {
              carp "Unknown parameter '$param_key' in data_validation()";
              return -3;
          }
      }
  
      # Map alternative parameter names 'source' or 'minimum' to 'value'.
      $param->{value} = $param->{source}  if defined $param->{source};
      $param->{value} = $param->{minimum} if defined $param->{minimum};
  
      # 'validate' is a required parameter.
      if ( not exists $param->{validate} ) {
          carp "Parameter 'validate' is required in data_validation()";
          return -3;
      }
  
  
      # List of  valid validation types.
      my %valid_type = (
          'any'          => 'none',
          'any value'    => 'none',
          'whole number' => 'whole',
          'whole'        => 'whole',
          'integer'      => 'whole',
          'decimal'      => 'decimal',
          'list'         => 'list',
          'date'         => 'date',
          'time'         => 'time',
          'text length'  => 'textLength',
          'length'       => 'textLength',
          'custom'       => 'custom',
      );
  
  
      # Check for valid validation types.
      if ( not exists $valid_type{ lc( $param->{validate} ) } ) {
          carp "Unknown validation type '$param->{validate}' for parameter "
            . "'validate' in data_validation()";
          return -3;
      }
      else {
          $param->{validate} = $valid_type{ lc( $param->{validate} ) };
      }
  
      # No action is required for validation type 'any'
      # unless there are input messages.
      if (   $param->{validate} eq 'none'
          && !defined $param->{input_message}
          && !defined $param->{input_title} )
      {
          return 0;
      }
  
      # The any, list and custom validations don't have a criteria
      # so we use a default of 'between'.
      if (   $param->{validate} eq 'none'
          || $param->{validate} eq 'list'
          || $param->{validate} eq 'custom' )
      {
          $param->{criteria} = 'between';
          $param->{maximum}  = undef;
      }
  
      # 'criteria' is a required parameter.
      if ( not exists $param->{criteria} ) {
          carp "Parameter 'criteria' is required in data_validation()";
          return -3;
      }
  
  
      # List of valid criteria types.
      my %criteria_type = (
          'between'                  => 'between',
          'not between'              => 'notBetween',
          'equal to'                 => 'equal',
          '='                        => 'equal',
          '=='                       => 'equal',
          'not equal to'             => 'notEqual',
          '!='                       => 'notEqual',
          '<>'                       => 'notEqual',
          'greater than'             => 'greaterThan',
          '>'                        => 'greaterThan',
          'less than'                => 'lessThan',
          '<'                        => 'lessThan',
          'greater than or equal to' => 'greaterThanOrEqual',
          '>='                       => 'greaterThanOrEqual',
          'less than or equal to'    => 'lessThanOrEqual',
          '<='                       => 'lessThanOrEqual',
      );
  
      # Check for valid criteria types.
      if ( not exists $criteria_type{ lc( $param->{criteria} ) } ) {
          carp "Unknown criteria type '$param->{criteria}' for parameter "
            . "'criteria' in data_validation()";
          return -3;
      }
      else {
          $param->{criteria} = $criteria_type{ lc( $param->{criteria} ) };
      }
  
  
      # 'Between' and 'Not between' criteria require 2 values.
      if ( $param->{criteria} eq 'between' || $param->{criteria} eq 'notBetween' )
      {
          if ( not exists $param->{maximum} ) {
              carp "Parameter 'maximum' is required in data_validation() "
                . "when using 'between' or 'not between' criteria";
              return -3;
          }
      }
      else {
          $param->{maximum} = undef;
      }
  
  
      # List of valid error dialog types.
      my %error_type = (
          'stop'        => 0,
          'warning'     => 1,
          'information' => 2,
      );
  
      # Check for valid error dialog types.
      if ( not exists $param->{error_type} ) {
          $param->{error_type} = 0;
      }
      elsif ( not exists $error_type{ lc( $param->{error_type} ) } ) {
          carp "Unknown criteria type '$param->{error_type}' for parameter "
            . "'error_type' in data_validation()";
          return -3;
      }
      else {
          $param->{error_type} = $error_type{ lc( $param->{error_type} ) };
      }
  
  
      # Convert date/times value if required.
      if ( $param->{validate} eq 'date' || $param->{validate} eq 'time' ) {
          if ( $param->{value} =~ /T/ ) {
              my $date_time = $self->convert_date_time( $param->{value} );
  
              if ( !defined $date_time ) {
                  carp "Invalid date/time value '$param->{value}' "
                    . "in data_validation()";
                  return -3;
              }
              else {
                  $param->{value} = $date_time;
              }
          }
          if ( defined $param->{maximum} && $param->{maximum} =~ /T/ ) {
              my $date_time = $self->convert_date_time( $param->{maximum} );
  
              if ( !defined $date_time ) {
                  carp "Invalid date/time value '$param->{maximum}' "
                    . "in data_validation()";
                  return -3;
              }
              else {
                  $param->{maximum} = $date_time;
              }
          }
      }
  
      # Check that the input title doesn't exceed the maximum length.
      if ( $param->{input_title} and length $param->{input_title} > 32 ) {
          carp "Length of input title '$param->{input_title}'"
            . " exceeds Excel's limit of 32";
          return -3;
      }
  
      # Check that the error title don't exceed the maximum length.
      if ( $param->{error_title} and length $param->{error_title} > 32 ) {
          carp "Length of error title '$param->{error_title}'"
            . " exceeds Excel's limit of 32";
          return -3;
      }
  
      # Check that the input message don't exceed the maximum length.
      if ( $param->{input_message} and length $param->{input_message} > 255 ) {
          carp "Length of input message '$param->{input_message}'"
            . " exceeds Excel's limit of 255";
          return -3;
      }
  
      # Check that the error message don't exceed the maximum length.
      if ( $param->{error_message} and length $param->{error_message} > 255 ) {
          carp "Length of error message '$param->{error_message}'"
            . " exceeds Excel's limit of 255";
          return -3;
      }
  
      # Check that the input list don't exceed the maximum length.
      if ( $param->{validate} eq 'list' ) {
  
          if ( ref $param->{value} eq 'ARRAY' ) {
  
              my $formula = join ',', @{ $param->{value} };
              if ( length $formula > 255 ) {
                  carp "Length of list items '$formula' exceeds Excel's "
                    . "limit of 255, use a formula range instead";
                  return -3;
              }
          }
      }
  
      # Set some defaults if they haven't been defined by the user.
      $param->{ignore_blank} = 1 if !defined $param->{ignore_blank};
      $param->{dropdown}     = 1 if !defined $param->{dropdown};
      $param->{show_input}   = 1 if !defined $param->{show_input};
      $param->{show_error}   = 1 if !defined $param->{show_error};
  
  
      # These are the cells to which the validation is applied.
      $param->{cells} = [ [ $row1, $col1, $row2, $col2 ] ];
  
      # A (for now) undocumented parameter to pass additional cell ranges.
      if ( exists $param->{other_cells} ) {
  
          push @{ $param->{cells} }, @{ $param->{other_cells} };
      }
  
      # Store the validation information until we close the worksheet.
      push @{ $self->{_validations} }, $param;
  }
  
  
  ###############################################################################
  #
  # conditional_formatting($row, $col, {...})
  #
  # This method handles the interface to Excel conditional formatting.
  #
  # We allow the format to be called on one cell or a range of cells. The
  # hashref contains the formatting parameters and must be the last param:
  #    conditional_formatting($row, $col, {...})
  #    conditional_formatting($first_row, $first_col, $last_row, $last_col, {...})
  #
  # Returns  0 : normal termination
  #         -1 : insufficient number of arguments
  #         -2 : row or column out of range
  #         -3 : incorrect parameter.
  #
  sub conditional_formatting {
  
      my $self       = shift;
      my $user_range = '';
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
  
          # Check for a user defined multiple range like B3:K6,B8:K11.
          if ( $_[0] =~ /,/ ) {
              $user_range = $_[0];
              $user_range =~ s/^=//;
              $user_range =~ s/\s*,\s*/ /g;
              $user_range =~ s/\$//g;
          }
  
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Check for a valid number of args.
      if ( @_ != 5 && @_ != 3 ) { return -1 }
  
      # The final hashref contains the validation parameters.
      my $options = pop;
  
      # Make the last row/col the same as the first if not defined.
      my ( $row1, $col1, $row2, $col2 ) = @_;
      if ( !defined $row2 ) {
          $row2 = $row1;
          $col2 = $col1;
      }
  
      # Check that row and col are valid without storing the values.
      return -2 if $self->_check_dimensions( $row1, $col1, 1, 1 );
      return -2 if $self->_check_dimensions( $row2, $col2, 1, 1 );
  
  
      # Check that the last parameter is a hash list.
      if ( ref $options ne 'HASH' ) {
          carp "Last parameter in conditional_formatting() "
            . "must be a hash ref";
          return -3;
      }
  
      # Copy the user params.
      my $param = {%$options};
  
      # List of valid input parameters.
      my %valid_parameter = (
          type         => 1,
          format       => 1,
          criteria     => 1,
          value        => 1,
          minimum      => 1,
          maximum      => 1,
          stop_if_true => 1,
          min_type     => 1,
          mid_type     => 1,
          max_type     => 1,
          min_value    => 1,
          mid_value    => 1,
          max_value    => 1,
          min_color    => 1,
          mid_color    => 1,
          max_color    => 1,
          bar_color    => 1,
      );
  
      # Check for valid input parameters.
      for my $param_key ( keys %$param ) {
          if ( not exists $valid_parameter{$param_key} ) {
              carp "Unknown parameter '$param_key' in conditional_formatting()";
              return -3;
          }
      }
  
      # 'type' is a required parameter.
      if ( not exists $param->{type} ) {
          carp "Parameter 'type' is required in conditional_formatting()";
          return -3;
      }
  
  
      # List of  valid validation types.
      my %valid_type = (
          'cell'          => 'cellIs',
          'date'          => 'date',
          'time'          => 'time',
          'average'       => 'aboveAverage',
          'duplicate'     => 'duplicateValues',
          'unique'        => 'uniqueValues',
          'top'           => 'top10',
          'bottom'        => 'top10',
          'text'          => 'text',
          'time_period'   => 'timePeriod',
          'blanks'        => 'containsBlanks',
          'no_blanks'     => 'notContainsBlanks',
          'errors'        => 'containsErrors',
          'no_errors'     => 'notContainsErrors',
          '2_color_scale' => '2_color_scale',
          '3_color_scale' => '3_color_scale',
          'data_bar'      => 'dataBar',
          'formula'       => 'expression',
      );
  
  
      # Check for valid validation types.
      if ( not exists $valid_type{ lc( $param->{type} ) } ) {
          carp "Unknown validation type '$param->{type}' for parameter "
            . "'type' in conditional_formatting()";
          return -3;
      }
      else {
          $param->{direction} = 'bottom' if $param->{type} eq 'bottom';
          $param->{type} = $valid_type{ lc( $param->{type} ) };
      }
  
  
      # List of valid criteria types.
      my %criteria_type = (
          'between'                  => 'between',
          'not between'              => 'notBetween',
          'equal to'                 => 'equal',
          '='                        => 'equal',
          '=='                       => 'equal',
          'not equal to'             => 'notEqual',
          '!='                       => 'notEqual',
          '<>'                       => 'notEqual',
          'greater than'             => 'greaterThan',
          '>'                        => 'greaterThan',
          'less than'                => 'lessThan',
          '<'                        => 'lessThan',
          'greater than or equal to' => 'greaterThanOrEqual',
          '>='                       => 'greaterThanOrEqual',
          'less than or equal to'    => 'lessThanOrEqual',
          '<='                       => 'lessThanOrEqual',
          'containing'               => 'containsText',
          'not containing'           => 'notContains',
          'begins with'              => 'beginsWith',
          'ends with'                => 'endsWith',
          'yesterday'                => 'yesterday',
          'today'                    => 'today',
          'last 7 days'              => 'last7Days',
          'last week'                => 'lastWeek',
          'this week'                => 'thisWeek',
          'next week'                => 'nextWeek',
          'last month'               => 'lastMonth',
          'this month'               => 'thisMonth',
          'next month'               => 'nextMonth',
      );
  
      # Check for valid criteria types.
      if ( defined $param->{criteria}
          && exists $criteria_type{ lc( $param->{criteria} ) } )
      {
          $param->{criteria} = $criteria_type{ lc( $param->{criteria} ) };
      }
  
      # Convert date/times value if required.
      if ( $param->{type} eq 'date' || $param->{type} eq 'time' ) {
          $param->{type} = 'cellIs';
  
          if ( defined $param->{value} && $param->{value} =~ /T/ ) {
              my $date_time = $self->convert_date_time( $param->{value} );
  
              if ( !defined $date_time ) {
                  carp "Invalid date/time value '$param->{value}' "
                    . "in conditional_formatting()";
                  return -3;
              }
              else {
                  $param->{value} = $date_time;
              }
          }
  
          if ( defined $param->{minimum} && $param->{minimum} =~ /T/ ) {
              my $date_time = $self->convert_date_time( $param->{minimum} );
  
              if ( !defined $date_time ) {
                  carp "Invalid date/time value '$param->{minimum}' "
                    . "in conditional_formatting()";
                  return -3;
              }
              else {
                  $param->{minimum} = $date_time;
              }
          }
  
          if ( defined $param->{maximum} && $param->{maximum} =~ /T/ ) {
              my $date_time = $self->convert_date_time( $param->{maximum} );
  
              if ( !defined $date_time ) {
                  carp "Invalid date/time value '$param->{maximum}' "
                    . "in conditional_formatting()";
                  return -3;
              }
              else {
                  $param->{maximum} = $date_time;
              }
          }
      }
  
      # Set the formatting range.
      my $range      = '';
      my $start_cell = '';    # Use for formulas.
  
      # Swap last row/col for first row/col as necessary
      if ( $row1 > $row2 ) {
          ( $row1, $row2 ) = ( $row2, $row1 );
      }
  
      if ( $col1 > $col2 ) {
          ( $col1, $col2 ) = ( $col2, $col1 );
      }
  
      # If the first and last cell are the same write a single cell.
      if ( ( $row1 == $row2 ) && ( $col1 == $col2 ) ) {
          $range = xl_rowcol_to_cell( $row1, $col1 );
          $start_cell = $range;
      }
      else {
          $range = xl_range( $row1, $row2, $col1, $col2 );
          $start_cell = xl_rowcol_to_cell( $row1, $col1 );
      }
  
      # Override with user defined multiple range if provided.
      if ( $user_range ) {
          $range = $user_range;
      }
  
      # Get the dxf format index.
      if ( defined $param->{format} && ref $param->{format} ) {
          $param->{format} = $param->{format}->get_dxf_index();
      }
  
      # Set the priority based on the order of adding.
      $param->{priority} = $self->{_dxf_priority}++;
  
      # Special handling of text criteria.
      if ( $param->{type} eq 'text' ) {
  
          if ( $param->{criteria} eq 'containsText' ) {
              $param->{type}    = 'containsText';
              $param->{formula} = sprintf 'NOT(ISERROR(SEARCH("%s",%s)))',
                $param->{value}, $start_cell;
          }
          elsif ( $param->{criteria} eq 'notContains' ) {
              $param->{type}    = 'notContainsText';
              $param->{formula} = sprintf 'ISERROR(SEARCH("%s",%s))',
                $param->{value}, $start_cell;
          }
          elsif ( $param->{criteria} eq 'beginsWith' ) {
              $param->{type}    = 'beginsWith';
              $param->{formula} = sprintf 'LEFT(%s,%d)="%s"',
                $start_cell, length( $param->{value} ), $param->{value};
          }
          elsif ( $param->{criteria} eq 'endsWith' ) {
              $param->{type}    = 'endsWith';
              $param->{formula} = sprintf 'RIGHT(%s,%d)="%s"',
                $start_cell, length( $param->{value} ), $param->{value};
          }
          else {
              carp "Invalid text criteria '$param->{criteria}' "
                . "in conditional_formatting()";
          }
      }
  
      # Special handling of time time_period criteria.
      if ( $param->{type} eq 'timePeriod' ) {
  
          if ( $param->{criteria} eq 'yesterday' ) {
              $param->{formula} = sprintf 'FLOOR(%s,1)=TODAY()-1', $start_cell;
          }
          elsif ( $param->{criteria} eq 'today' ) {
              $param->{formula} = sprintf 'FLOOR(%s,1)=TODAY()', $start_cell;
          }
          elsif ( $param->{criteria} eq 'tomorrow' ) {
              $param->{formula} = sprintf 'FLOOR(%s,1)=TODAY()+1', $start_cell;
          }
          elsif ( $param->{criteria} eq 'last7Days' ) {
              $param->{formula} =
                sprintf 'AND(TODAY()-FLOOR(%s,1)<=6,FLOOR(%s,1)<=TODAY())',
                $start_cell, $start_cell;
          }
          elsif ( $param->{criteria} eq 'lastWeek' ) {
              $param->{formula} =
                sprintf 'AND(TODAY()-ROUNDDOWN(%s,0)>=(WEEKDAY(TODAY())),'
                . 'TODAY()-ROUNDDOWN(%s,0)<(WEEKDAY(TODAY())+7))',
                $start_cell, $start_cell;
          }
          elsif ( $param->{criteria} eq 'thisWeek' ) {
              $param->{formula} =
                sprintf 'AND(TODAY()-ROUNDDOWN(%s,0)<=WEEKDAY(TODAY())-1,'
                . 'ROUNDDOWN(%s,0)-TODAY()<=7-WEEKDAY(TODAY()))',
                $start_cell, $start_cell;
          }
          elsif ( $param->{criteria} eq 'nextWeek' ) {
              $param->{formula} =
                sprintf 'AND(ROUNDDOWN(%s,0)-TODAY()>(7-WEEKDAY(TODAY())),'
                . 'ROUNDDOWN(%s,0)-TODAY()<(15-WEEKDAY(TODAY())))',
                $start_cell, $start_cell;
          }
          elsif ( $param->{criteria} eq 'lastMonth' ) {
              $param->{formula} =
                sprintf
                'AND(MONTH(%s)=MONTH(TODAY())-1,OR(YEAR(%s)=YEAR(TODAY()),'
                . 'AND(MONTH(%s)=1,YEAR(A1)=YEAR(TODAY())-1)))',
                $start_cell, $start_cell, $start_cell;
          }
          elsif ( $param->{criteria} eq 'thisMonth' ) {
              $param->{formula} =
                sprintf 'AND(MONTH(%s)=MONTH(TODAY()),YEAR(%s)=YEAR(TODAY()))',
                $start_cell, $start_cell;
          }
          elsif ( $param->{criteria} eq 'nextMonth' ) {
              $param->{formula} =
                sprintf
                'AND(MONTH(%s)=MONTH(TODAY())+1,OR(YEAR(%s)=YEAR(TODAY()),'
                . 'AND(MONTH(%s)=12,YEAR(%s)=YEAR(TODAY())+1)))',
                $start_cell, $start_cell, $start_cell, $start_cell;
          }
          else {
              carp "Invalid time_period criteria '$param->{criteria}' "
                . "in conditional_formatting()";
          }
      }
  
  
      # Special handling of blanks/error types.
      if ( $param->{type} eq 'containsBlanks' ) {
          $param->{formula} = sprintf 'LEN(TRIM(%s))=0', $start_cell;
      }
  
      if ( $param->{type} eq 'notContainsBlanks' ) {
          $param->{formula} = sprintf 'LEN(TRIM(%s))>0', $start_cell;
      }
  
      if ( $param->{type} eq 'containsErrors' ) {
          $param->{formula} = sprintf 'ISERROR(%s)', $start_cell;
      }
  
      if ( $param->{type} eq 'notContainsErrors' ) {
          $param->{formula} = sprintf 'NOT(ISERROR(%s))', $start_cell;
      }
  
  
      # Special handling for 2 color scale.
      if ( $param->{type} eq '2_color_scale' ) {
          $param->{type} = 'colorScale';
  
          # Color scales don't use any additional formatting.
          $param->{format} = undef;
  
          # Turn off 3 color parameters.
          $param->{mid_type}  = undef;
          $param->{mid_color} = undef;
  
          $param->{min_type}  ||= 'min';
          $param->{max_type}  ||= 'max';
          $param->{min_value} ||= 0;
          $param->{max_value} ||= 0;
          $param->{min_color} ||= '#FF7128';
          $param->{max_color} ||= '#FFEF9C';
  
          $param->{max_color} = $self->_get_palette_color( $param->{max_color} );
          $param->{min_color} = $self->_get_palette_color( $param->{min_color} );
      }
  
  
      # Special handling for 3 color scale.
      if ( $param->{type} eq '3_color_scale' ) {
          $param->{type} = 'colorScale';
  
          # Color scales don't use any additional formatting.
          $param->{format} = undef;
  
          $param->{min_type}  ||= 'min';
          $param->{mid_type}  ||= 'percentile';
          $param->{max_type}  ||= 'max';
          $param->{min_value} ||= 0;
          $param->{mid_value} = 50 unless defined $param->{mid_value};
          $param->{max_value} ||= 0;
          $param->{min_color} ||= '#F8696B';
          $param->{mid_color} ||= '#FFEB84';
          $param->{max_color} ||= '#63BE7B';
  
          $param->{max_color} = $self->_get_palette_color( $param->{max_color} );
          $param->{mid_color} = $self->_get_palette_color( $param->{mid_color} );
          $param->{min_color} = $self->_get_palette_color( $param->{min_color} );
      }
  
  
      # Special handling for data bar.
      if ( $param->{type} eq 'dataBar' ) {
  
          # Color scales don't use any additional formatting.
          $param->{format} = undef;
  
          $param->{min_type}  ||= 'min';
          $param->{max_type}  ||= 'max';
          $param->{min_value} ||= 0;
          $param->{max_value} ||= 0;
          $param->{bar_color} ||= '#638EC6';
  
          $param->{bar_color} = $self->_get_palette_color( $param->{bar_color} );
      }
  
  
      # Store the validation information until we close the worksheet.
      push @{ $self->{_cond_formats}->{$range} }, $param;
  }
  
  
  ###############################################################################
  #
  # add_table()
  #
  # Add an Excel table to a worksheet.
  #
  sub add_table {
  
      my $self       = shift;
      my $user_range = '';
      my %table;
      my @col_formats;
  
      # We would need to order the write statements very carefully within this
      # function to support optimisation mode. Disable add_table() when it is
      # on for now.
      if ( $self->{_optimization} == 1 ) {
          carp "add_table() isn't supported when set_optimization() is on";
          return -1;
      }
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( @_ && $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Check for a valid number of args.
      if ( @_ < 4 ) {
          carp "Not enough parameters to add_table()";
          return -1;
      }
  
      my ( $row1, $col1, $row2, $col2 ) = @_;
  
      # Check that row and col are valid without storing the values.
      return -2 if $self->_check_dimensions( $row1, $col1, 1, 1 );
      return -2 if $self->_check_dimensions( $row2, $col2, 1, 1 );
  
  
      # The final hashref contains the validation parameters.
      my $param = $_[4] || {};
  
      # Check that the last parameter is a hash list.
      if ( ref $param ne 'HASH' ) {
          carp "Last parameter '$param' in add_table() must be a hash ref";
          return -3;
      }
  
  
      # List of valid input parameters.
      my %valid_parameter = (
          autofilter     => 1,
          banded_columns => 1,
          banded_rows    => 1,
          columns        => 1,
          data           => 1,
          first_column   => 1,
          header_row     => 1,
          last_column    => 1,
          name           => 1,
          style          => 1,
          total_row      => 1,
      );
  
      # Check for valid input parameters.
      for my $param_key ( keys %$param ) {
          if ( not exists $valid_parameter{$param_key} ) {
              carp "Unknown parameter '$param_key' in add_table()";
              return -3;
          }
      }
  
      # Turn on Excel's defaults.
      $param->{banded_rows} = 1 if !defined $param->{banded_rows};
      $param->{header_row}  = 1 if !defined $param->{header_row};
      $param->{autofilter}  = 1 if !defined $param->{autofilter};
  
      # Set the table options.
      $table{_show_first_col}   = $param->{first_column}   ? 1 : 0;
      $table{_show_last_col}    = $param->{last_column}    ? 1 : 0;
      $table{_show_row_stripes} = $param->{banded_rows}    ? 1 : 0;
      $table{_show_col_stripes} = $param->{banded_columns} ? 1 : 0;
      $table{_header_row_count} = $param->{header_row}     ? 1 : 0;
      $table{_totals_row_shown} = $param->{total_row}      ? 1 : 0;
  
  
      # Set the table name.
      if ( defined $param->{name} ) {
          my $name = $param->{name};
  
          # Warn if the name contains invalid chars as defined by Excel help.
          if ( $name !~ m/^[\w\\][\w\\.]*$/ || $name =~ m/^\d/ ) {
              carp "Invalid character in name '$name' used in add_table()";
              return -3;
          }
  
          # Warn if the name looks like a cell name.
          if ( $name =~ m/^[a-zA-Z][a-zA-Z]?[a-dA-D]?[0-9]+$/ ) {
              carp "Invalid name '$name' looks like a cell name in add_table()";
              return -3;
          }
  
          # Warn if the name looks like a R1C1.
          if ( $name =~ m/^[rcRC]$/ || $name =~ m/^[rcRC]\d+[rcRC]\d+$/ ) {
              carp "Invalid name '$name' like a RC cell ref in add_table()";
              return -3;
          }
  
          $table{_name} = $param->{name};
      }
  
      # Set the table style.
      if ( defined $param->{style} ) {
          $table{_style} = $param->{style};
  
          # Remove whitespace from style name.
          $table{_style} =~ s/\s//g;
      }
      else {
          $table{_style} = "TableStyleMedium9";
      }
  
  
      # Swap last row/col for first row/col as necessary.
      if ( $row1 > $row2 ) {
          ( $row1, $row2 ) = ( $row2, $row1 );
      }
  
      if ( $col1 > $col2 ) {
          ( $col1, $col2 ) = ( $col2, $col1 );
      }
  
  
      # Set the data range rows (without the header and footer).
      my $first_data_row = $row1;
      my $last_data_row  = $row2;
      $first_data_row++ if $param->{header_row};
      $last_data_row--  if $param->{total_row};
  
  
      # Set the table and autofilter ranges.
      $table{_range}   = xl_range( $row1, $row2,          $col1, $col2 );
      $table{_a_range} = xl_range( $row1, $last_data_row, $col1, $col2 );
  
  
      # If the header row if off the default is to turn autofilter off.
      if ( !$param->{header_row} ) {
          $param->{autofilter} = 0;
      }
  
      # Set the autofilter range.
      if ( $param->{autofilter} ) {
          $table{_autofilter} = $table{_a_range};
      }
  
      # Add the table columns.
      my $col_id = 1;
      for my $col_num ( $col1 .. $col2 ) {
  
          # Set up the default column data.
          my $col_data = {
              _id             => $col_id,
              _name           => 'Column' . $col_id,
              _total_string   => '',
              _total_function => '',
              _formula        => '',
              _format         => undef,
              _name_format    => undef,
          };
  
          # Overwrite the defaults with any use defined values.
          if ( $param->{columns} ) {
  
              # Check if there are user defined values for this column.
              if ( my $user_data = $param->{columns}->[ $col_id - 1 ] ) {
  
                  # Map user defined values to internal values.
                  $col_data->{_name} = $user_data->{header}
                    if $user_data->{header};
  
                  # Get the header format if defined.
                  $col_data->{_name_format} = $user_data->{header_format};
  
                  # Handle the column formula.
                  if ( $user_data->{formula} ) {
                      my $formula = $user_data->{formula};
  
                      # Remove the leading = from formula.
                      $formula =~ s/^=//;
  
                      # Covert Excel 2010 "@" ref to 2007 "#This Row".
                      $formula =~ s/@/[#This Row],/g;
  
                      $col_data->{_formula} = $formula;
  
                      for my $row ( $first_data_row .. $last_data_row ) {
                          $self->write_formula( $row, $col_num, $formula,
                              $user_data->{format} );
                      }
                  }
  
                  # Handle the function for the total row.
                  if ( $user_data->{total_function} ) {
                      my $function = $user_data->{total_function};
  
                      # Massage the function name.
                      $function = lc $function;
                      $function =~ s/_//g;
                      $function =~ s/\s//g;
  
                      $function = 'countNums' if $function eq 'countnums';
                      $function = 'stdDev'    if $function eq 'stddev';
  
                      $col_data->{_total_function} = $function;
  
                      my $formula = _table_function_to_formula(
                          $function,
                          $col_data->{_name}
  
                      );
  
                      my $value = $user_data->{total_value} || 0;
  
                      $self->write_formula( $row2, $col_num, $formula,
                          $user_data->{format}, $value );
  
                  }
                  elsif ( $user_data->{total_string} ) {
  
                      # Total label only (not a function).
                      my $total_string = $user_data->{total_string};
                      $col_data->{_total_string} = $total_string;
  
                      $self->write_string( $row2, $col_num, $total_string,
                          $user_data->{format} );
                  }
  
                  # Get the dxf format index.
                  if ( defined $user_data->{format} && ref $user_data->{format} )
                  {
                      $col_data->{_format} =
                        $user_data->{format}->get_dxf_index();
                  }
  
                  # Store the column format for writing the cell data.
                  # It doesn't matter if it is undefined.
                  $col_formats[ $col_id - 1 ] = $user_data->{format};
              }
          }
  
          # Store the column data.
          push @{ $table{_columns} }, $col_data;
  
          # Write the column headers to the worksheet.
          if ( $param->{header_row} ) {
              $self->write_string( $row1, $col_num, $col_data->{_name},
                  $col_data->{_name_format} );
          }
  
          $col_id++;
      }    # Table columns.
  
  
      # Write the cell data if supplied.
      if ( my $data = $param->{data} ) {
  
          my $i = 0;    # For indexing the row data.
          for my $row ( $first_data_row .. $last_data_row ) {
              my $j = 0;    # For indexing the col data.
  
              for my $col ( $col1 .. $col2 ) {
  
                  my $token = $data->[$i]->[$j];
  
                  if ( defined $token ) {
                      $self->write( $row, $col, $token, $col_formats[$j] );
                  }
  
                  $j++;
              }
              $i++;
          }
      }
  
  
      # Store the table data.
      push @{ $self->{_tables} }, \%table;
  
      return \%table;
  }
  
  
  ###############################################################################
  #
  # add_sparkline()
  #
  # Add sparklines to the worksheet.
  #
  sub add_sparkline {
  
      my $self      = shift;
      my $param     = shift;
      my $sparkline = {};
  
      # Check that the last parameter is a hash list.
      if ( ref $param ne 'HASH' ) {
          carp "Parameter list in add_sparkline() must be a hash ref";
          return -1;
      }
  
      # List of valid input parameters.
      my %valid_parameter = (
          location        => 1,
          range           => 1,
          type            => 1,
          high_point      => 1,
          low_point       => 1,
          negative_points => 1,
          first_point     => 1,
          last_point      => 1,
          markers         => 1,
          style           => 1,
          series_color    => 1,
          negative_color  => 1,
          markers_color   => 1,
          first_color     => 1,
          last_color      => 1,
          high_color      => 1,
          low_color       => 1,
          max             => 1,
          min             => 1,
          axis            => 1,
          reverse         => 1,
          empty_cells     => 1,
          show_hidden     => 1,
          plot_hidden     => 1,
          date_axis       => 1,
          weight          => 1,
      );
  
      # Check for valid input parameters.
      for my $param_key ( keys %$param ) {
          if ( not exists $valid_parameter{$param_key} ) {
              carp "Unknown parameter '$param_key' in add_sparkline()";
              return -2;
          }
      }
  
      # 'location' is a required parameter.
      if ( not exists $param->{location} ) {
          carp "Parameter 'location' is required in add_sparkline()";
          return -3;
      }
  
      # 'range' is a required parameter.
      if ( not exists $param->{range} ) {
          carp "Parameter 'range' is required in add_sparkline()";
          return -3;
      }
  
  
      # Handle the sparkline type.
      my $type = $param->{type} || 'line';
  
      if ( $type ne 'line' && $type ne 'column' && $type ne 'win_loss' ) {
          carp "Parameter 'type' must be 'line', 'column' "
            . "or 'win_loss' in add_sparkline()";
          return -4;
      }
  
      $type = 'stacked' if $type eq 'win_loss';
      $sparkline->{_type} = $type;
  
  
      # We handle single location/range values or array refs of values.
      if ( ref $param->{location} ) {
          $sparkline->{_locations} = $param->{location};
          $sparkline->{_ranges}    = $param->{range};
      }
      else {
          $sparkline->{_locations} = [ $param->{location} ];
          $sparkline->{_ranges}    = [ $param->{range} ];
      }
  
      my $range_count    = @{ $sparkline->{_ranges} };
      my $location_count = @{ $sparkline->{_locations} };
  
      # The ranges and locations must match.
      if ( $range_count != $location_count ) {
          carp "Must have the same number of location and range "
            . "parameters in add_sparkline()";
          return -5;
      }
  
      # Store the count.
      $sparkline->{_count} = @{ $sparkline->{_locations} };
  
  
      # Get the worksheet name for the range conversion below.
      my $sheetname = quote_sheetname( $self->{_name} );
  
      # Cleanup the input ranges.
      for my $range ( @{ $sparkline->{_ranges} } ) {
  
          # Remove the absolute reference $ symbols.
          $range =~ s{\$}{}g;
  
          # Remove the = from xl_range_formula(.
          $range =~ s{^=}{};
  
          # Convert a simple range into a full Sheet1!A1:D1 range.
          if ( $range !~ /!/ ) {
              $range = $sheetname . "!" . $range;
          }
      }
  
      # Cleanup the input locations.
      for my $location ( @{ $sparkline->{_locations} } ) {
          $location =~ s{\$}{}g;
      }
  
      # Map options.
      $sparkline->{_high}     = $param->{high_point};
      $sparkline->{_low}      = $param->{low_point};
      $sparkline->{_negative} = $param->{negative_points};
      $sparkline->{_first}    = $param->{first_point};
      $sparkline->{_last}     = $param->{last_point};
      $sparkline->{_markers}  = $param->{markers};
      $sparkline->{_min}      = $param->{min};
      $sparkline->{_max}      = $param->{max};
      $sparkline->{_axis}     = $param->{axis};
      $sparkline->{_reverse}  = $param->{reverse};
      $sparkline->{_hidden}   = $param->{show_hidden};
      $sparkline->{_weight}   = $param->{weight};
  
      # Map empty cells options.
      my $empty = $param->{empty_cells} || '';
  
      if ( $empty eq 'zero' ) {
          $sparkline->{_empty} = 0;
      }
      elsif ( $empty eq 'connect' ) {
          $sparkline->{_empty} = 'span';
      }
      else {
          $sparkline->{_empty} = 'gap';
      }
  
  
      # Map the date axis range.
      my $date_range = $param->{date_axis};
  
      if ( $date_range && $date_range !~ /!/ ) {
          $date_range = $sheetname . "!" . $date_range;
      }
      $sparkline->{_date_axis} = $date_range;
  
  
      # Set the sparkline styles.
      my $style_id = $param->{style} || 0;
      my $style = $Excel::Writer::XLSX::Package::Theme::spark_styles[$style_id];
  
      $sparkline->{_series_color}   = $style->{series};
      $sparkline->{_negative_color} = $style->{negative};
      $sparkline->{_markers_color}  = $style->{markers};
      $sparkline->{_first_color}    = $style->{first};
      $sparkline->{_last_color}     = $style->{last};
      $sparkline->{_high_color}     = $style->{high};
      $sparkline->{_low_color}      = $style->{low};
  
      # Override the style colours with user defined colors.
      $self->_set_spark_color( $sparkline, $param, 'series_color' );
      $self->_set_spark_color( $sparkline, $param, 'negative_color' );
      $self->_set_spark_color( $sparkline, $param, 'markers_color' );
      $self->_set_spark_color( $sparkline, $param, 'first_color' );
      $self->_set_spark_color( $sparkline, $param, 'last_color' );
      $self->_set_spark_color( $sparkline, $param, 'high_color' );
      $self->_set_spark_color( $sparkline, $param, 'low_color' );
  
      push @{ $self->{_sparklines} }, $sparkline;
  }
  
  
  ###############################################################################
  #
  # insert_button()
  #
  # Insert a button form object into the worksheet.
  #
  sub insert_button {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Check the number of args.
      if ( @_ < 3 ) { return -1 }
  
      my $button = $self->_button_params( @_ );
  
      push @{ $self->{_buttons_array} }, $button;
  
      $self->{_has_vml} = 1;
  }
  
  
  ###############################################################################
  #
  # set_vba_name()
  #
  # Set the VBA name for the worksheet.
  #
  sub set_vba_name {
  
      my $self         = shift;
      my $vba_codemame = shift;
  
      if ( $vba_codemame ) {
          $self->{_vba_codename} = $vba_codemame;
      }
      else {
          $self->{_vba_codename} = $self->{_name};
      }
  }
  
  
  ###############################################################################
  #
  # Internal methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _table_function_to_formula
  #
  # Convert a table total function to a worksheet formula.
  #
  sub _table_function_to_formula {
  
      my $function = shift;
      my $col_name = shift;
      my $formula  = '';
  
      my %subtotals = (
          average   => 101,
          countNums => 102,
          count     => 103,
          max       => 104,
          min       => 105,
          stdDev    => 107,
          sum       => 109,
          var       => 110,
      );
  
      if ( exists $subtotals{$function} ) {
          my $func_num = $subtotals{$function};
          $formula = qq{SUBTOTAL($func_num,[$col_name])};
      }
      else {
          carp "Unsupported function '$function' in add_table()";
      }
  
      return $formula;
  }
  
  
  ###############################################################################
  #
  # _set_spark_color()
  #
  # Set the sparkline colour.
  #
  sub _set_spark_color {
  
      my $self        = shift;
      my $sparkline   = shift;
      my $param       = shift;
      my $user_color  = shift;
      my $spark_color = '_' . $user_color;
  
      return unless $param->{$user_color};
  
      $sparkline->{$spark_color} =
        { _rgb => $self->_get_palette_color( $param->{$user_color} ) };
  }
  
  
  ###############################################################################
  #
  # _get_palette_color()
  #
  # Convert from an Excel internal colour index to a XML style #RRGGBB index
  # based on the default or user defined values in the Workbook palette.
  #
  sub _get_palette_color {
  
      my $self    = shift;
      my $index   = shift;
      my $palette = $self->{_palette};
  
      # Handle colours in #XXXXXX RGB format.
      if ( $index =~ m/^#([0-9A-F]{6})$/i ) {
          return "FF" . uc( $1 );
      }
  
      # Adjust the colour index.
      $index -= 8;
  
      # Palette is passed in from the Workbook class.
      my @rgb = @{ $palette->[$index] };
  
      return sprintf "FF%02X%02X%02X", @rgb[0, 1, 2];
  }
  
  
  ###############################################################################
  #
  # _substitute_cellref()
  #
  # Substitute an Excel cell reference in A1 notation for  zero based row and
  # column values in an argument list.
  #
  # Ex: ("A4", "Hello") is converted to (3, 0, "Hello").
  #
  sub _substitute_cellref {
  
      my $self = shift;
      my $cell = uc( shift );
  
      # Convert a column range: 'A:A' or 'B:G'.
      # A range such as A:A is equivalent to A1:Rowmax, so add rows as required
      if ( $cell =~ /\$?([A-Z]{1,3}):\$?([A-Z]{1,3})/ ) {
          my ( $row1, $col1 ) = $self->_cell_to_rowcol( $1 . '1' );
          my ( $row2, $col2 ) =
            $self->_cell_to_rowcol( $2 . $self->{_xls_rowmax} );
          return $row1, $col1, $row2, $col2, @_;
      }
  
      # Convert a cell range: 'A1:B7'
      if ( $cell =~ /\$?([A-Z]{1,3}\$?\d+):\$?([A-Z]{1,3}\$?\d+)/ ) {
          my ( $row1, $col1 ) = $self->_cell_to_rowcol( $1 );
          my ( $row2, $col2 ) = $self->_cell_to_rowcol( $2 );
          return $row1, $col1, $row2, $col2, @_;
      }
  
      # Convert a cell reference: 'A1' or 'AD2000'
      if ( $cell =~ /\$?([A-Z]{1,3}\$?\d+)/ ) {
          my ( $row1, $col1 ) = $self->_cell_to_rowcol( $1 );
          return $row1, $col1, @_;
  
      }
  
      croak( "Unknown cell reference $cell" );
  }
  
  
  ###############################################################################
  #
  # _cell_to_rowcol($cell_ref)
  #
  # Convert an Excel cell reference in A1 notation to a zero based row and column
  # reference; converts C1 to (0, 2).
  #
  # See also: http://www.perlmonks.org/index.pl?node_id=270352
  #
  # Returns: ($row, $col, $row_absolute, $col_absolute)
  #
  #
  sub _cell_to_rowcol {
  
      my $self = shift;
  
      my $cell = $_[0];
      $cell =~ /(\$?)([A-Z]{1,3})(\$?)(\d+)/;
  
      my $col_abs = $1 eq "" ? 0 : 1;
      my $col     = $2;
      my $row_abs = $3 eq "" ? 0 : 1;
      my $row     = $4;
  
      # Convert base26 column string to number
      # All your Base are belong to us.
      my @chars = split //, $col;
      my $expn = 0;
      $col = 0;
  
      while ( @chars ) {
          my $char = pop( @chars );    # LS char first
          $col += ( ord( $char ) - ord( 'A' ) + 1 ) * ( 26**$expn );
          $expn++;
      }
  
      # Convert 1-index to zero-index
      $row--;
      $col--;
  
      # TODO Check row and column range
      return $row, $col, $row_abs, $col_abs;
  }
  
  
  ###############################################################################
  #
  # _xl_rowcol_to_cell($row, $col)
  #
  # Optimised version of xl_rowcol_to_cell from Utility.pm for the inner loop
  # of _write_cell().
  #
  
  our @col_names = ( 'A' .. 'XFD' );
  
  sub _xl_rowcol_to_cell {
      return $col_names[ $_[1] ] . ( $_[0] + 1 );
  }
  
  
  ###############################################################################
  #
  # _sort_pagebreaks()
  #
  # This is an internal method that is used to filter elements of the array of
  # pagebreaks used in the _store_hbreak() and _store_vbreak() methods. It:
  #   1. Removes duplicate entries from the list.
  #   2. Sorts the list.
  #   3. Removes 0 from the list if present.
  #
  sub _sort_pagebreaks {
  
      my $self = shift;
  
      return () unless @_;
  
      my %hash;
      my @array;
  
      @hash{@_} = undef;    # Hash slice to remove duplicates
      @array = sort { $a <=> $b } keys %hash;    # Numerical sort
      shift @array if $array[0] == 0;            # Remove zero
  
      # The Excel 2007 specification says that the maximum number of page breaks
      # is 1026. However, in practice it is actually 1023.
      my $max_num_breaks = 1023;
      splice( @array, $max_num_breaks ) if @array > $max_num_breaks;
  
      return @array;
  }
  
  
  ###############################################################################
  #
  # _check_dimensions($row, $col, $ignore_row, $ignore_col)
  #
  # Check that $row and $col are valid and store max and min values for use in
  # other methods/elements.
  #
  # The $ignore_row/$ignore_col flags is used to indicate that we wish to
  # perform the dimension check without storing the value.
  #
  # The ignore flags are use by set_row() and data_validate.
  #
  sub _check_dimensions {
  
      my $self       = shift;
      my $row        = $_[0];
      my $col        = $_[1];
      my $ignore_row = $_[2];
      my $ignore_col = $_[3];
  
  
      return -2 if not defined $row;
      return -2 if $row >= $self->{_xls_rowmax};
  
      return -2 if not defined $col;
      return -2 if $col >= $self->{_xls_colmax};
  
      # In optimization mode we don't change dimensions for rows that are
      # already written.
      if ( !$ignore_row && !$ignore_col && $self->{_optimization} == 1 ) {
          return -2 if $row < $self->{_previous_row};
      }
  
      if ( !$ignore_row ) {
  
          if ( not defined $self->{_dim_rowmin} or $row < $self->{_dim_rowmin} ) {
              $self->{_dim_rowmin} = $row;
          }
  
          if ( not defined $self->{_dim_rowmax} or $row > $self->{_dim_rowmax} ) {
              $self->{_dim_rowmax} = $row;
          }
      }
  
      if ( !$ignore_col ) {
  
          if ( not defined $self->{_dim_colmin} or $col < $self->{_dim_colmin} ) {
              $self->{_dim_colmin} = $col;
          }
  
          if ( not defined $self->{_dim_colmax} or $col > $self->{_dim_colmax} ) {
              $self->{_dim_colmax} = $col;
          }
      }
  
      return 0;
  }
  
  
  ###############################################################################
  #
  #  _position_object_pixels()
  #
  # Calculate the vertices that define the position of a graphical object within
  # the worksheet in pixels.
  #
  #         +------------+------------+
  #         |     A      |      B     |
  #   +-----+------------+------------+
  #   |     |(x1,y1)     |            |
  #   |  1  |(A1)._______|______      |
  #   |     |    |              |     |
  #   |     |    |              |     |
  #   +-----+----|    Object    |-----+
  #   |     |    |              |     |
  #   |  2  |    |______________.     |
  #   |     |            |        (B2)|
  #   |     |            |     (x2,y2)|
  #   +---- +------------+------------+
  #
  # Example of an object that covers some of the area from cell A1 to cell B2.
  #
  # Based on the width and height of the object we need to calculate 8 vars:
  #
  #     $col_start, $row_start, $col_end, $row_end, $x1, $y1, $x2, $y2.
  #
  # We also calculate the absolute x and y position of the top left vertex of
  # the object. This is required for images.
  #
  #    $x_abs, $y_abs
  #
  # The width and height of the cells that the object occupies can be variable
  # and have to be taken into account.
  #
  # The values of $col_start and $row_start are passed in from the calling
  # function. The values of $col_end and $row_end are calculated by subtracting
  # the width and height of the object from the width and height of the
  # underlying cells.
  #
  sub _position_object_pixels {
  
      my $self = shift;
  
      my $col_start;    # Col containing upper left corner of object.
      my $x1;           # Distance to left side of object.
  
      my $row_start;    # Row containing top left corner of object.
      my $y1;           # Distance to top of object.
  
      my $col_end;      # Col containing lower right corner of object.
      my $x2;           # Distance to right side of object.
  
      my $row_end;      # Row containing bottom right corner of object.
      my $y2;           # Distance to bottom of object.
  
      my $width;        # Width of object frame.
      my $height;       # Height of object frame.
  
      my $x_abs = 0;    # Absolute distance to left side of object.
      my $y_abs = 0;    # Absolute distance to top  side of object.
  
      ( $col_start, $row_start, $x1, $y1, $width, $height ) = @_;
  
      # Adjust start column for negative offsets.
      while ( $x1 < 0 && $col_start > 0) {
          $x1 += $self->_size_col( $col_start  - 1);
          $col_start--;
      }
  
      # Adjust start row for negative offsets.
      while ( $y1 < 0 && $row_start > 0) {
          $y1 += $self->_size_row( $row_start - 1);
          $row_start--;
      }
  
      # Ensure that the image isn't shifted off the page at top left.
      $x1 = 0 if $x1 < 0;
      $y1 = 0 if $y1 < 0;
  
      # Calculate the absolute x offset of the top-left vertex.
      if ( $self->{_col_size_changed} ) {
          for my $col_id ( 0 .. $col_start -1 ) {
              $x_abs += $self->_size_col( $col_id );
          }
      }
      else {
          # Optimisation for when the column widths haven't changed.
          $x_abs += $self->{_default_col_pixels} * $col_start;
      }
  
      $x_abs += $x1;
  
      # Calculate the absolute y offset of the top-left vertex.
      # Store the column change to allow optimisations.
      if ( $self->{_row_size_changed} ) {
          for my $row_id ( 0 .. $row_start -1 ) {
              $y_abs += $self->_size_row( $row_id );
          }
      }
      else {
          # Optimisation for when the row heights haven't changed.
          $y_abs += $self->{_default_row_pixels} * $row_start;
      }
  
      $y_abs += $y1;
  
  
      # Adjust start column for offsets that are greater than the col width.
      while ( $x1 >= $self->_size_col( $col_start ) ) {
          $x1 -= $self->_size_col( $col_start );
          $col_start++;
      }
  
      # Adjust start row for offsets that are greater than the row height.
      while ( $y1 >= $self->_size_row( $row_start ) ) {
          $y1 -= $self->_size_row( $row_start );
          $row_start++;
      }
  
      # Initialise end cell to the same as the start cell.
      $col_end = $col_start;
      $row_end = $row_start;
  
      $width  = $width + $x1;
      $height = $height + $y1;
  
  
      # Subtract the underlying cell widths to find the end cell of the object.
      while ( $width >= $self->_size_col( $col_end ) ) {
          $width -= $self->_size_col( $col_end );
          $col_end++;
      }
  
  
      # Subtract the underlying cell heights to find the end cell of the object.
      while ( $height >= $self->_size_row( $row_end ) ) {
          $height -= $self->_size_row( $row_end );
          $row_end++;
      }
  
      # The end vertices are whatever is left from the width and height.
      $x2 = $width;
      $y2 = $height;
  
      return (
          $col_start, $row_start, $x1, $y1,
          $col_end,   $row_end,   $x2, $y2,
          $x_abs,     $y_abs
  
      );
  }
  
  
  ###############################################################################
  #
  #  _position_object_emus()
  #
  # Calculate the vertices that define the position of a graphical object within
  # the worksheet in EMUs.
  #
  # The vertices are expressed as English Metric Units (EMUs). There are 12,700
  # EMUs per point. Therefore, 12,700 * 3 /4 = 9,525 EMUs per pixel.
  #
  sub _position_object_emus {
  
      my $self       = shift;
  
      my (
          $col_start, $row_start, $x1, $y1,
          $col_end,   $row_end,   $x2, $y2,
          $x_abs,     $y_abs
  
      ) = $self->_position_object_pixels( @_ );
  
      # Convert the pixel values to EMUs. See above.
      $x1    = int( 0.5 + 9_525 * $x1 );
      $y1    = int( 0.5 + 9_525 * $y1 );
      $x2    = int( 0.5 + 9_525 * $x2 );
      $y2    = int( 0.5 + 9_525 * $y2 );
      $x_abs = int( 0.5 + 9_525 * $x_abs );
      $y_abs = int( 0.5 + 9_525 * $y_abs );
  
      return (
          $col_start, $row_start, $x1, $y1,
          $col_end,   $row_end,   $x2, $y2,
          $x_abs,     $y_abs
  
      );
  }
  
  
  ###############################################################################
  #
  #  _position_shape_emus()
  #
  # Calculate the vertices that define the position of a shape object within
  # the worksheet in EMUs.  Save the vertices with the object.
  #
  # The vertices are expressed as English Metric Units (EMUs). There are 12,700
  # EMUs per point. Therefore, 12,700 * 3 /4 = 9,525 EMUs per pixel.
  #
  sub _position_shape_emus {
  
      my $self  = shift;
      my $shape = shift;
  
      my (
          $col_start, $row_start, $x1, $y1,    $col_end,
          $row_end,   $x2,        $y2, $x_abs, $y_abs
        )
        = $self->_position_object_pixels(
          $shape->{_column_start},
          $shape->{_row_start},
          $shape->{_x_offset},
          $shape->{_y_offset},
          $shape->{_width} * $shape->{_scale_x},
          $shape->{_height} * $shape->{_scale_y},
          $shape->{_drawing}
        );
  
      # Now that x2/y2 have been calculated with a potentially negative
      # width/height we use the absolute value and convert to EMUs.
      $shape->{_width_emu}  = int( abs( $shape->{_width} * 9_525 ) );
      $shape->{_height_emu} = int( abs( $shape->{_height} * 9_525 ) );
  
      $shape->{_column_start} = int( $col_start );
      $shape->{_row_start}    = int( $row_start );
      $shape->{_column_end}   = int( $col_end );
      $shape->{_row_end}      = int( $row_end );
  
      # Convert the pixel values to EMUs. See above.
      $shape->{_x1}    = int( $x1 * 9_525 );
      $shape->{_y1}    = int( $y1 * 9_525 );
      $shape->{_x2}    = int( $x2 * 9_525 );
      $shape->{_y2}    = int( $y2 * 9_525 );
      $shape->{_x_abs} = int( $x_abs * 9_525 );
      $shape->{_y_abs} = int( $y_abs * 9_525 );
  }
  
  ###############################################################################
  #
  # _size_col($col)
  #
  # Convert the width of a cell from user's units to pixels. Excel rounds the
  # column width to the nearest pixel. If the width hasn't been set by the user
  # we use the default value. If the column is hidden it has a value of zero.
  #
  sub _size_col {
  
      my $self = shift;
      my $col  = shift;
  
      my $max_digit_width = 7;    # For Calabri 11.
      my $padding         = 5;
      my $pixels;
  
      # Look up the cell value to see if it has been changed.
      if ( exists $self->{_col_sizes}->{$col}
          and defined $self->{_col_sizes}->{$col} )
      {
          my $width = $self->{_col_sizes}->{$col};
  
          # Convert to pixels.
          if ( $width == 0 ) {
              $pixels = 0;
          }
          elsif ( $width < 1 ) {
              $pixels = int( $width * ( $max_digit_width + $padding ) + 0.5 );
          }
          else {
              $pixels = int( $width * $max_digit_width + 0.5 ) + $padding;
          }
      }
      else {
          $pixels = $self->{_default_col_pixels};
      }
  
      return $pixels;
  }
  
  
  ###############################################################################
  #
  # _size_row($row)
  #
  # Convert the height of a cell from user's units to pixels. If the height
  # hasn't been set by the user we use the default value. If the row is hidden
  # it has a value of zero.
  #
  sub _size_row {
  
      my $self = shift;
      my $row  = shift;
      my $pixels;
  
      # Look up the cell value to see if it has been changed
      if ( exists $self->{_row_sizes}->{$row} ) {
          my $height = $self->{_row_sizes}->{$row};
  
          if ( $height == 0 ) {
              $pixels = 0;
          }
          else {
              $pixels = int( 4 / 3 * $height );
          }
      }
      else {
          $pixels = int( 4 / 3 * $self->{_default_row_height} );
      }
  
      return $pixels;
  }
  
  
  ###############################################################################
  #
  # _get_shared_string_index()
  #
  # Add a string to the shared string table, if it isn't already there, and
  # return the string index.
  #
  sub _get_shared_string_index {
  
      my $self = shift;
      my $str  = shift;
  
      # Add the string to the shared string table.
      if ( not exists ${ $self->{_str_table} }->{$str} ) {
          ${ $self->{_str_table} }->{$str} = ${ $self->{_str_unique} }++;
      }
  
      ${ $self->{_str_total} }++;
      my $index = ${ $self->{_str_table} }->{$str};
  
      return $index;
  }
  
  
  ###############################################################################
  #
  # insert_chart( $row, $col, $chart, $x, $y, $x_scale, $y_scale )
  #
  # Insert a chart into a worksheet. The $chart argument should be a Chart
  # object or else it is assumed to be a filename of an external binary file.
  # The latter is for backwards compatibility.
  #
  sub insert_chart {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column.
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      my $row      = $_[0];
      my $col      = $_[1];
      my $chart    = $_[2];
      my $x_offset = $_[3] || 0;
      my $y_offset = $_[4] || 0;
      my $x_scale  = $_[5] || 1;
      my $y_scale  = $_[6] || 1;
  
      croak "Insufficient arguments in insert_chart()" unless @_ >= 3;
  
      if ( ref $chart ) {
  
          # Check for a Chart object.
          croak "Not a Chart object in insert_chart()"
            unless $chart->isa( 'Excel::Writer::XLSX::Chart' );
  
          # Check that the chart is an embedded style chart.
          croak "Not a embedded style Chart object in insert_chart()"
            unless $chart->{_embedded};
  
      }
  
      # Ensure a chart isn't inserted more than once.
      if (   $chart->{_already_inserted}
          || $chart->{_combined} && $chart->{_combined}->{_already_inserted} )
      {
          carp "Chart cannot be inserted in a worksheet more than once";
          return;
      }
      else {
          $chart->{_already_inserted} = 1;
  
          if ( $chart->{_combined} ) {
              $chart->{_combined}->{_already_inserted} = 1;
          }
      }
  
      # Use the values set with $chart->set_size(), if any.
      $x_scale  = $chart->{_x_scale}  if $chart->{_x_scale} != 1;
      $y_scale  = $chart->{_y_scale}  if $chart->{_y_scale} != 1;
      $x_offset = $chart->{_x_offset} if $chart->{_x_offset};
      $y_offset = $chart->{_y_offset} if $chart->{_y_offset};
  
      push @{ $self->{_charts} },
        [ $row, $col, $chart, $x_offset, $y_offset, $x_scale, $y_scale ];
  }
  
  
  ###############################################################################
  #
  # _prepare_chart()
  #
  # Set up chart/drawings.
  #
  sub _prepare_chart {
  
      my $self         = shift;
      my $index        = shift;
      my $chart_id     = shift;
      my $drawing_id   = shift;
      my $drawing_type = 1;
  
      my ( $row, $col, $chart, $x_offset, $y_offset, $x_scale, $y_scale ) =
        @{ $self->{_charts}->[$index] };
  
      $chart->{_id} = $chart_id - 1;
  
      # Use user specified dimensions, if any.
      my $width  = $chart->{_width}  if $chart->{_width};
      my $height = $chart->{_height} if $chart->{_height};
  
      $width  = int( 0.5 + ( $width  * $x_scale ) );
      $height = int( 0.5 + ( $height * $y_scale ) );
  
      my @dimensions =
        $self->_position_object_emus( $col, $row, $x_offset, $y_offset, $width,
          $height);
  
      # Set the chart name for the embedded object if it has been specified.
      my $name = $chart->{_chart_name};
  
      # Create a Drawing object to use with worksheet unless one already exists.
      if ( !$self->{_drawing} ) {
  
          my $drawing = Excel::Writer::XLSX::Drawing->new();
          $drawing->_add_drawing_object( $drawing_type, @dimensions, 0, 0,
              $name );
          $drawing->{_embedded} = 1;
  
          $self->{_drawing} = $drawing;
  
          push @{ $self->{_external_drawing_links} },
            [ '/drawing', '../drawings/drawing' . $drawing_id . '.xml' ];
      }
      else {
          my $drawing = $self->{_drawing};
          $drawing->_add_drawing_object( $drawing_type, @dimensions, 0, 0,
              $name );
  
      }
  
      push @{ $self->{_drawing_links} },
        [ '/chart', '../charts/chart' . $chart_id . '.xml' ];
  }
  
  
  ###############################################################################
  #
  # _get_range_data
  #
  # Returns a range of data from the worksheet _table to be used in chart
  # cached data. Strings are returned as SST ids and decoded in the workbook.
  # Return undefs for data that doesn't exist since Excel can chart series
  # with data missing.
  #
  sub _get_range_data {
  
      my $self = shift;
  
      return () if $self->{_optimization};
  
      my @data;
      my ( $row_start, $col_start, $row_end, $col_end ) = @_;
  
      # TODO. Check for worksheet limits.
  
      # Iterate through the table data.
      for my $row_num ( $row_start .. $row_end ) {
  
          # Store undef if row doesn't exist.
          if ( !exists $self->{_table}->{$row_num} ) {
              push @data, undef;
              next;
          }
  
          for my $col_num ( $col_start .. $col_end ) {
  
              if ( my $cell = $self->{_table}->{$row_num}->{$col_num} ) {
  
                  my $type  = $cell->[0];
                  my $token = $cell->[1];
  
  
                  if ( $type eq 'n' ) {
  
                      # Store a number.
                      push @data, $token;
                  }
                  elsif ( $type eq 's' ) {
  
                      # Store a string.
                      if ( $self->{_optimization} == 0 ) {
                          push @data, { 'sst_id' => $token };
                      }
                      else {
                          push @data, $token;
                      }
                  }
                  elsif ( $type eq 'f' ) {
  
                      # Store a formula.
                      push @data, $cell->[3] || 0;
                  }
                  elsif ( $type eq 'a' ) {
  
                      # Store an array formula.
                      push @data, $cell->[4] || 0;
                  }
                  elsif ( $type eq 'b' ) {
  
                      # Store a empty cell.
                      push @data, '';
                  }
              }
              else {
  
                  # Store undef if col doesn't exist.
                  push @data, undef;
              }
          }
      }
  
      return @data;
  }
  
  
  ###############################################################################
  #
  # insert_image( $row, $col, $filename, $x, $y, $x_scale, $y_scale )
  #
  # Insert an image into the worksheet.
  #
  sub insert_image {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column.
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      my $row      = $_[0];
      my $col      = $_[1];
      my $image    = $_[2];
      my $x_offset = $_[3] || 0;
      my $y_offset = $_[4] || 0;
      my $x_scale  = $_[5] || 1;
      my $y_scale  = $_[6] || 1;
  
      croak "Insufficient arguments in insert_image()" unless @_ >= 3;
      croak "Couldn't locate $image: $!" unless -e $image;
  
      push @{ $self->{_images} },
        [ $row, $col, $image, $x_offset, $y_offset, $x_scale, $y_scale ];
  }
  
  
  ###############################################################################
  #
  # _prepare_image()
  #
  # Set up image/drawings.
  #
  sub _prepare_image {
  
      my $self         = shift;
      my $index        = shift;
      my $image_id     = shift;
      my $drawing_id   = shift;
      my $width        = shift;
      my $height       = shift;
      my $name         = shift;
      my $image_type   = shift;
      my $x_dpi        = shift;
      my $y_dpi        = shift;
      my $drawing_type = 2;
      my $drawing;
  
      my ( $row, $col, $image, $x_offset, $y_offset, $x_scale, $y_scale ) =
        @{ $self->{_images}->[$index] };
  
      $width  *= $x_scale;
      $height *= $y_scale;
  
      $width  *= 96 / $x_dpi;
      $height *= 96 / $y_dpi;
  
      my @dimensions =
        $self->_position_object_emus( $col, $row, $x_offset, $y_offset, $width,
          $height);
  
      # Convert from pixels to emus.
      $width  = int( 0.5 + ( $width * 9_525 ) );
      $height = int( 0.5 + ( $height * 9_525 ) );
  
      # Create a Drawing object to use with worksheet unless one already exists.
      if ( !$self->{_drawing} ) {
  
          $drawing = Excel::Writer::XLSX::Drawing->new();
          $drawing->{_embedded} = 1;
  
          $self->{_drawing} = $drawing;
  
          push @{ $self->{_external_drawing_links} },
            [ '/drawing', '../drawings/drawing' . $drawing_id . '.xml' ];
      }
      else {
          $drawing = $self->{_drawing};
      }
  
      $drawing->_add_drawing_object( $drawing_type, @dimensions, $width, $height,
          $name );
  
  
      push @{ $self->{_drawing_links} },
        [ '/image', '../media/image' . $image_id . '.' . $image_type ];
  }
  
  
  ###############################################################################
  #
  # _prepare_header_image()
  #
  # Set up an image without a drawing object for header/footer images.
  #
  sub _prepare_header_image {
  
      my $self       = shift;
      my $image_id   = shift;
      my $width      = shift;
      my $height     = shift;
      my $name       = shift;
      my $image_type = shift;
      my $position   = shift;
      my $x_dpi      = shift;
      my $y_dpi      = shift;
  
      # Strip the extension from the filename.
      $name =~ s/\.[^\.]+$//;
  
      push @{ $self->{_header_images_array} },
        [ $width, $height, $name, $position, $x_dpi, $y_dpi ];
  
      push @{ $self->{_vml_drawing_links} },
        [ '/image', '../media/image' . $image_id . '.' . $image_type ];
  }
  
  
  ###############################################################################
  #
  # insert_shape( $row, $col, $shape, $x, $y, $x_scale, $y_scale )
  #
  # Insert a shape into the worksheet.
  #
  sub insert_shape {
  
      my $self = shift;
  
      # Check for a cell reference in A1 notation and substitute row and column.
      if ( $_[0] =~ /^\D/ ) {
          @_ = $self->_substitute_cellref( @_ );
      }
  
      # Check the number of arguments.
      croak "Insufficient arguments in insert_shape()" unless @_ >= 3;
  
      my $shape = $_[2];
  
      # Verify we are being asked to insert a "shape" object.
      croak "Not a Shape object in insert_shape()"
        unless $shape->isa( 'Excel::Writer::XLSX::Shape' );
  
      # Set the shape properties.
      $shape->{_row_start}    = $_[0];
      $shape->{_column_start} = $_[1];
      $shape->{_x_offset}     = $_[3] || 0;
      $shape->{_y_offset}     = $_[4] || 0;
  
      # Override shape scale if supplied as an argument.  Otherwise, use the
      # existing shape scale factors.
      $shape->{_scale_x} = $_[5] if defined $_[5];
      $shape->{_scale_y} = $_[6] if defined $_[6];
  
      # Assign a shape ID.
      my $needs_id = 1;
      while ( $needs_id ) {
          my $id = $shape->{_id} || 0;
          my $used = exists $self->{_shape_hash}->{$id} ? 1 : 0;
  
          # Test if shape ID is already used. Otherwise assign a new one.
          if ( !$used && $id != 0 ) {
              $needs_id = 0;
          }
          else {
              $shape->{_id} = ++$self->{_last_shape_id};
          }
      }
  
      $shape->{_element} = $#{ $self->{_shapes} } + 1;
  
      # Allow lookup of entry into shape array by shape ID.
      $self->{_shape_hash}->{ $shape->{_id} } = $shape->{_element};
  
      # Create link to Worksheet color palette.
      $shape->{_palette} = $self->{_palette};
  
      if ( $shape->{_stencil} ) {
  
          # Insert a copy of the shape, not a reference so that the shape is
          # used as a stencil. Previously stamped copies don't get modified
          # if the stencil is modified.
          my $insert = { %{$shape} };
  
         # For connectors change x/y coords based on location of connected shapes.
          $self->_auto_locate_connectors( $insert );
  
          # Bless the copy into this class, so AUTOLOADED _get, _set methods
          #still work on the child.
          bless $insert, ref $shape;
  
          push @{ $self->{_shapes} }, $insert;
          return $insert;
      }
      else {
  
         # For connectors change x/y coords based on location of connected shapes.
          $self->_auto_locate_connectors( $shape );
  
          # Insert a link to the shape on the list of shapes. Connection to
          # the parent shape is maintained
          push @{ $self->{_shapes} }, $shape;
          return $shape;
      }
  }
  
  
  ###############################################################################
  #
  # _prepare_shape()
  #
  # Set up drawing shapes
  #
  sub _prepare_shape {
  
      my $self       = shift;
      my $index      = shift;
      my $drawing_id = shift;
      my $shape      = $self->{_shapes}->[$index];
      my $drawing;
      my $drawing_type = 3;
  
      # Create a Drawing object to use with worksheet unless one already exists.
      if ( !$self->{_drawing} ) {
  
          $drawing              = Excel::Writer::XLSX::Drawing->new();
          $drawing->{_embedded} = 1;
          $self->{_drawing}     = $drawing;
  
          push @{ $self->{_external_drawing_links} },
            [ '/drawing', '../drawings/drawing' . $drawing_id . '.xml' ];
  
          $self->{_has_shapes} = 1;
      }
      else {
          $drawing = $self->{_drawing};
      }
  
      # Validate the he shape against various rules.
      $self->_validate_shape( $shape, $index );
  
      $self->_position_shape_emus( $shape );
  
      my @dimensions = (
          $shape->{_column_start}, $shape->{_row_start},
          $shape->{_x1},           $shape->{_y1},
          $shape->{_column_end},   $shape->{_row_end},
          $shape->{_x2},           $shape->{_y2},
          $shape->{_x_abs},        $shape->{_y_abs},
          $shape->{_width_emu},    $shape->{_height_emu},
      );
  
      $drawing->_add_drawing_object( $drawing_type, @dimensions, $shape->{_name},
          $shape );
  }
  
  
  ###############################################################################
  #
  # _auto_locate_connectors()
  #
  # Re-size connector shapes if they are connected to other shapes.
  #
  sub _auto_locate_connectors {
  
      my $self  = shift;
      my $shape = shift;
  
      # Valid connector shapes.
      my $connector_shapes = {
          straightConnector => 1,
          Connector         => 1,
          bentConnector     => 1,
          curvedConnector   => 1,
          line              => 1,
      };
  
      my $shape_base = $shape->{_type};
  
      # Remove the number of segments from end of type.
      chop $shape_base;
  
      $shape->{_connect} = $connector_shapes->{$shape_base} ? 1 : 0;
  
      return unless $shape->{_connect};
  
      # Both ends have to be connected to size it.
      return unless ( $shape->{_start} and $shape->{_end} );
  
      # Both ends need to provide info about where to connect.
      return unless ( $shape->{_start_side} and $shape->{_end_side} );
  
      my $sid = $shape->{_start};
      my $eid = $shape->{_end};
  
      my $slink_id = $self->{_shape_hash}->{$sid};
      my ( $sls, $els );
      if ( defined $slink_id ) {
          $sls = $self->{_shapes}->[$slink_id];    # Start linked shape.
      }
      else {
          warn "missing start connection for '$shape->{_name}', id=$sid\n";
          return;
      }
  
      my $elink_id = $self->{_shape_hash}->{$eid};
      if ( defined $elink_id ) {
          $els = $self->{_shapes}->[$elink_id];    # Start linked shape.
      }
      else {
          warn "missing end connection for '$shape->{_name}', id=$eid\n";
          return;
      }
  
      # Assume shape connections are to the middle of an object, and
      # not a corner (for now).
      my $connect_type = $shape->{_start_side} . $shape->{_end_side};
      my $smidx        = $sls->{_x_offset} + $sls->{_width} / 2;
      my $emidx        = $els->{_x_offset} + $els->{_width} / 2;
      my $smidy        = $sls->{_y_offset} + $sls->{_height} / 2;
      my $emidy        = $els->{_y_offset} + $els->{_height} / 2;
      my $netx         = abs( $smidx - $emidx );
      my $nety         = abs( $smidy - $emidy );
  
      if ( $connect_type eq 'bt' ) {
          my $sy = $sls->{_y_offset} + $sls->{_height};
          my $ey = $els->{_y_offset};
  
          $shape->{_width} = abs( int( $emidx - $smidx ) );
          $shape->{_x_offset} = int( min( $smidx, $emidx ) );
          $shape->{_height} =
            abs(
              int( $els->{_y_offset} - ( $sls->{_y_offset} + $sls->{_height} ) )
            );
          $shape->{_y_offset} = int(
              min( ( $sls->{_y_offset} + $sls->{_height} ), $els->{_y_offset} ) );
          $shape->{_flip_h} = ( $smidx < $emidx ) ? 1 : 0;
          $shape->{_rotation} = 90;
  
          if ( $sy > $ey ) {
              $shape->{_flip_v} = 1;
  
              # Create 3 adjustments for an end shape vertically above a
              # start shape. Adjustments count from the upper left object.
              if ( $#{ $shape->{_adjustments} } < 0 ) {
                  $shape->{_adjustments} = [ -10, 50, 110 ];
              }
  
              $shape->{_type} = 'bentConnector5';
          }
      }
      elsif ( $connect_type eq 'rl' ) {
          $shape->{_width} =
            abs(
              int( $els->{_x_offset} - ( $sls->{_x_offset} + $sls->{_width} ) ) );
          $shape->{_height} = abs( int( $emidy - $smidy ) );
          $shape->{_x_offset} =
            min( $sls->{_x_offset} + $sls->{_width}, $els->{_x_offset} );
          $shape->{_y_offset} = min( $smidy, $emidy );
  
          $shape->{_flip_h} = 1 if ( $smidx < $emidx ) and ( $smidy > $emidy );
          $shape->{_flip_h} = 1 if ( $smidx > $emidx ) and ( $smidy < $emidy );
          if ( $smidx > $emidx ) {
  
              # Create 3 adjustments if end shape is left of start
              if ( $#{ $shape->{_adjustments} } < 0 ) {
                  $shape->{_adjustments} = [ -10, 50, 110 ];
              }
  
              $shape->{_type} = 'bentConnector5';
          }
      }
      else {
          warn "Connection $connect_type not implemented yet\n";
      }
  }
  
  
  ###############################################################################
  #
  # _validate_shape()
  #
  # Check shape attributes to ensure they are valid.
  #
  sub _validate_shape {
  
      my $self  = shift;
      my $shape = shift;
      my $index = shift;
  
      if ( !grep ( /^$shape->{_align}$/, qw[l ctr r just] ) ) {
          croak "Shape $index ($shape->{_type}) alignment ($shape->{align}), "
            . "not in ('l', 'ctr', 'r', 'just')\n";
      }
  
      if ( !grep ( /^$shape->{_valign}$/, qw[t ctr b] ) ) {
          croak "Shape $index ($shape->{_type}) vertical alignment "
            . "($shape->{valign}), not ('t', 'ctr', 'b')\n";
      }
  }
  
  
  ###############################################################################
  #
  # _prepare_vml_objects()
  #
  # Turn the HoH that stores the comments into an array for easier handling
  # and set the external links for comments and buttons.
  #
  sub _prepare_vml_objects {
  
      my $self           = shift;
      my $vml_data_id    = shift;
      my $vml_shape_id   = shift;
      my $vml_drawing_id = shift;
      my $comment_id     = shift;
      my @comments;
  
  
      # We sort the comments by row and column but that isn't strictly required.
      my @rows = sort { $a <=> $b } keys %{ $self->{_comments} };
  
      for my $row ( @rows ) {
          my @cols = sort { $a <=> $b } keys %{ $self->{_comments}->{$row} };
  
          for my $col ( @cols ) {
  
              # Set comment visibility if required and not already user defined.
              if ( $self->{_comments_visible} ) {
                  if ( !defined $self->{_comments}->{$row}->{$col}->[4] ) {
                      $self->{_comments}->{$row}->{$col}->[4] = 1;
                  }
              }
  
              # Set comment author if not already user defined.
              if ( !defined $self->{_comments}->{$row}->{$col}->[3] ) {
                  $self->{_comments}->{$row}->{$col}->[3] =
                    $self->{_comments_author};
              }
  
              push @comments, $self->{_comments}->{$row}->{$col};
          }
      }
  
      push @{ $self->{_external_vml_links} },
        [ '/vmlDrawing', '../drawings/vmlDrawing' . $vml_drawing_id . '.vml' ];
  
      if ( $self->{_has_comments} ) {
  
          $self->{_comments_array} = \@comments;
  
          push @{ $self->{_external_comment_links} },
            [ '/comments', '../comments' . $comment_id . '.xml' ];
      }
  
      my $count         = scalar @comments;
      my $start_data_id = $vml_data_id;
  
      # The VML o:idmap data id contains a comma separated range when there is
      # more than one 1024 block of comments, like this: data="1,2".
      for my $i ( 1 .. int( $count / 1024 ) ) {
          $vml_data_id = "$vml_data_id," . ( $start_data_id + $i );
      }
  
      $self->{_vml_data_id}  = $vml_data_id;
      $self->{_vml_shape_id} = $vml_shape_id;
  
      return $count;
  }
  
  
  ###############################################################################
  #
  # _prepare_header_vml_objects()
  #
  # Set up external linkage for VML header/footer images.
  #
  sub _prepare_header_vml_objects {
  
      my $self           = shift;
      my $vml_header_id  = shift;
      my $vml_drawing_id = shift;
  
      $self->{_vml_header_id} = $vml_header_id;
  
      push @{ $self->{_external_vml_links} },
        [ '/vmlDrawing', '../drawings/vmlDrawing' . $vml_drawing_id . '.vml' ];
  }
  
  
  ###############################################################################
  #
  # _prepare_tables()
  #
  # Set the table ids for the worksheet tables.
  #
  sub _prepare_tables {
  
      my $self     = shift;
      my $table_id = shift;
      my $seen     = shift;
  
  
      for my $table ( @{ $self->{_tables} } ) {
  
          $table-> {_id} = $table_id;
  
          # Set the table name unless defined by the user.
          if ( !defined $table->{_name} ) {
  
              # Set a default name.
              $table->{_name} = 'Table' . $table_id;
          }
  
          # Check for duplicate table names.
          my $name = lc $table->{_name};
  
          if ( exists $seen->{$name} ) {
              die "error: invalid duplicate table name '$table->{_name}' found";
          }
          else {
              $seen->{$name} = 1;
          }
  
          # Store the link used for the rels file.
          my $link = [ '/table', '../tables/table' . $table_id . '.xml' ];
  
          push @{ $self->{_external_table_links} }, $link;
          $table_id++;
      }
  }
  
  
  ###############################################################################
  #
  # _comment_params()
  #
  # This method handles the additional optional parameters to write_comment() as
  # well as calculating the comment object position and vertices.
  #
  sub _comment_params {
  
      my $self = shift;
  
      my $row    = shift;
      my $col    = shift;
      my $string = shift;
  
      my $default_width  = 128;
      my $default_height = 74;
  
      my %params = (
          author     => undef,
          color      => 81,
          start_cell => undef,
          start_col  => undef,
          start_row  => undef,
          visible    => undef,
          width      => $default_width,
          height     => $default_height,
          x_offset   => undef,
          x_scale    => 1,
          y_offset   => undef,
          y_scale    => 1,
      );
  
  
      # Overwrite the defaults with any user supplied values. Incorrect or
      # misspelled parameters are silently ignored.
      %params = ( %params, @_ );
  
  
      # Ensure that a width and height have been set.
      $params{width}  = $default_width  if not $params{width};
      $params{height} = $default_height if not $params{height};
  
  
      # Limit the string to the max number of chars.
      my $max_len = 32767;
  
      if ( length( $string ) > $max_len ) {
          $string = substr( $string, 0, $max_len );
      }
  
  
      # Set the comment background colour.
      my $color    = $params{color};
      my $color_id = &Excel::Writer::XLSX::Format::_get_color( $color );
  
      if ( $color_id =~ m/^#[0-9A-F]{6}$/i ) {
          $params{color} = $color_id;
      }
      elsif ( $color_id == 0 ) {
          $params{color} = '#ffffe1';
      }
      else {
          my $palette = $self->{_palette};
  
          # Get the RGB color from the palette.
          my @rgb = @{ $palette->[ $color_id - 8 ] };
          my $rgb_color = sprintf "%02x%02x%02x", @rgb[0, 1, 2];
  
          # Minor modification to allow comparison testing. Change RGB colors
          # from long format, ffcc00 to short format fc0 used by VML.
          $rgb_color =~ s/^([0-9a-f])\1([0-9a-f])\2([0-9a-f])\3$/$1$2$3/;
  
          $params{color} = sprintf "#%s [%d]", $rgb_color, $color_id;
      }
  
  
      # Convert a cell reference to a row and column.
      if ( defined $params{start_cell} ) {
          my ( $row, $col ) = $self->_substitute_cellref( $params{start_cell} );
          $params{start_row} = $row;
          $params{start_col} = $col;
      }
  
  
      # Set the default start cell and offsets for the comment. These are
      # generally fixed in relation to the parent cell. However there are
      # some edge cases for cells at the, er, edges.
      #
      my $row_max = $self->{_xls_rowmax};
      my $col_max = $self->{_xls_colmax};
  
      if ( not defined $params{start_row} ) {
  
          if    ( $row == 0 )            { $params{start_row} = 0 }
          elsif ( $row == $row_max - 3 ) { $params{start_row} = $row_max - 7 }
          elsif ( $row == $row_max - 2 ) { $params{start_row} = $row_max - 6 }
          elsif ( $row == $row_max - 1 ) { $params{start_row} = $row_max - 5 }
          else                           { $params{start_row} = $row - 1 }
      }
  
      if ( not defined $params{y_offset} ) {
  
          if    ( $row == 0 )            { $params{y_offset} = 2 }
          elsif ( $row == $row_max - 3 ) { $params{y_offset} = 16 }
          elsif ( $row == $row_max - 2 ) { $params{y_offset} = 16 }
          elsif ( $row == $row_max - 1 ) { $params{y_offset} = 14 }
          else                           { $params{y_offset} = 10 }
      }
  
      if ( not defined $params{start_col} ) {
  
          if    ( $col == $col_max - 3 ) { $params{start_col} = $col_max - 6 }
          elsif ( $col == $col_max - 2 ) { $params{start_col} = $col_max - 5 }
          elsif ( $col == $col_max - 1 ) { $params{start_col} = $col_max - 4 }
          else                           { $params{start_col} = $col + 1 }
      }
  
      if ( not defined $params{x_offset} ) {
  
          if    ( $col == $col_max - 3 ) { $params{x_offset} = 49 }
          elsif ( $col == $col_max - 2 ) { $params{x_offset} = 49 }
          elsif ( $col == $col_max - 1 ) { $params{x_offset} = 49 }
          else                           { $params{x_offset} = 15 }
      }
  
  
      # Scale the size of the comment box if required.
      if ( $params{x_scale} ) {
          $params{width} = $params{width} * $params{x_scale};
      }
  
      if ( $params{y_scale} ) {
          $params{height} = $params{height} * $params{y_scale};
      }
  
      # Round the dimensions to the nearest pixel.
      $params{width}  = int( 0.5 + $params{width} );
      $params{height} = int( 0.5 + $params{height} );
  
      # Calculate the positions of comment object.
      my @vertices = $self->_position_object_pixels(
          $params{start_col}, $params{start_row}, $params{x_offset},
          $params{y_offset},  $params{width},     $params{height}
      );
  
      # Add the width and height for VML.
      push @vertices, ( $params{width}, $params{height} );
  
      return (
          $row,
          $col,
          $string,
  
          $params{author},
          $params{visible},
          $params{color},
  
          [@vertices]
      );
  }
  
  
  ###############################################################################
  #
  # _button_params()
  #
  # This method handles the parameters passed to insert_button() as well as
  # calculating the comment object position and vertices.
  #
  sub _button_params {
  
      my $self   = shift;
      my $row    = shift;
      my $col    = shift;
      my $params = shift;
      my $button = { _row => $row, _col => $col };
  
      my $button_number = 1 + @{ $self->{_buttons_array} };
  
      # Set the button caption.
      my $caption = $params->{caption};
  
      # Set a default caption if none was specified by user.
      if ( !defined $caption ) {
          $caption = 'Button ' . $button_number;
      }
  
      $button->{_font}->{_caption} = $caption;
  
  
      # Set the macro name.
      if ( $params->{macro} ) {
          $button->{_macro} = '[0]!' . $params->{macro};
      }
      else {
          $button->{_macro} = '[0]!Button' . $button_number . '_Click';
      }
  
  
      # Ensure that a width and height have been set.
      my $default_width  = $self->{_default_col_pixels};
      my $default_height = $self->{_default_row_pixels};
      $params->{width}  = $default_width  if !$params->{width};
      $params->{height} = $default_height if !$params->{height};
  
      # Set the x/y offsets.
      $params->{x_offset}  = 0  if !$params->{x_offset};
      $params->{y_offset}  = 0  if !$params->{y_offset};
  
      # Scale the size of the comment box if required.
      if ( $params->{x_scale} ) {
          $params->{width} = $params->{width} * $params->{x_scale};
      }
  
      if ( $params->{y_scale} ) {
          $params->{height} = $params->{height} * $params->{y_scale};
      }
  
      # Round the dimensions to the nearest pixel.
      $params->{width}  = int( 0.5 + $params->{width} );
      $params->{height} = int( 0.5 + $params->{height} );
  
      $params->{start_row} = $row;
      $params->{start_col} = $col;
  
      # Calculate the positions of comment object.
      my @vertices = $self->_position_object_pixels(
          $params->{start_col}, $params->{start_row}, $params->{x_offset},
          $params->{y_offset},  $params->{width},     $params->{height}
      );
  
      # Add the width and height for VML.
      push @vertices, ( $params->{width}, $params->{height} );
  
      $button->{_vertices} = \@vertices;
  
      return $button;
  }
  
  
  ###############################################################################
  #
  # Deprecated methods for backwards compatibility.
  #
  ###############################################################################
  
  
  # This method was mainly only required for Excel 5.
  sub write_url_range { }
  
  # Deprecated UTF-16 method required for the Excel 5 format.
  sub write_utf16be_string {
  
      my $self = shift;
  
      # Convert A1 notation if present.
      @_ = $self->_substitute_cellref( @_ ) if $_[0] =~ /^\D/;
  
      # Check the number of args.
      return -1 if @_ < 3;
  
      # Convert UTF16 string to UTF8.
      require Encode;
      my $utf8_string = Encode::decode( 'UTF-16BE', $_[2] );
  
      return $self->write_string( $_[0], $_[1], $utf8_string, $_[3] );
  }
  
  # Deprecated UTF-16 method required for the Excel 5 format.
  sub write_utf16le_string {
  
      my $self = shift;
  
      # Convert A1 notation if present.
      @_ = $self->_substitute_cellref( @_ ) if $_[0] =~ /^\D/;
  
      # Check the number of args.
      return -1 if @_ < 3;
  
      # Convert UTF16 string to UTF8.
      require Encode;
      my $utf8_string = Encode::decode( 'UTF-16LE', $_[2] );
  
      return $self->write_string( $_[0], $_[1], $utf8_string, $_[3] );
  }
  
  # No longer required. Was used to avoid slow formula parsing.
  sub store_formula {
  
      my $self   = shift;
      my $string = shift;
  
      my @tokens = split /(\$?[A-I]?[A-Z]\$?\d+)/, $string;
  
      return \@tokens;
  }
  
  # No longer required. Was used to avoid slow formula parsing.
  sub repeat_formula {
  
      my $self = shift;
  
      # Convert A1 notation if present.
      @_ = $self->_substitute_cellref( @_ ) if $_[0] =~ /^\D/;
  
      if ( @_ < 2 ) { return -1 }    # Check the number of args
  
      my $row         = shift;       # Zero indexed row
      my $col         = shift;       # Zero indexed column
      my $formula_ref = shift;       # Array ref with formula tokens
      my $format      = shift;       # XF format
      my @pairs       = @_;          # Pattern/replacement pairs
  
  
      # Enforce an even number of arguments in the pattern/replacement list.
      croak "Odd number of elements in pattern/replacement list" if @pairs % 2;
  
      # Check that $formula is an array ref.
      croak "Not a valid formula" if ref $formula_ref ne 'ARRAY';
  
      my @tokens = @$formula_ref;
  
      # Allow the user to specify the result of the formula by appending a
      # result => $value pair to the end of the arguments.
      my $value = undef;
      if ( @pairs && $pairs[-2] eq 'result' ) {
          $value = pop @pairs;
          pop @pairs;
      }
  
      # Make the substitutions.
      while ( @pairs ) {
          my $pattern = shift @pairs;
          my $replace = shift @pairs;
  
          foreach my $token ( @tokens ) {
              last if $token =~ s/$pattern/$replace/;
          }
      }
  
      my $formula = join '', @tokens;
  
      return $self->write_formula( $row, $col, $formula, $format, $value );
  }
  
  
  ###############################################################################
  #
  # XML writing methods.
  #
  ###############################################################################
  
  
  ###############################################################################
  #
  # _write_worksheet()
  #
  # Write the <worksheet> element. This is the root element of Worksheet.
  #
  sub _write_worksheet {
  
      my $self                   = shift;
      my $schema                 = 'http://schemas.openxmlformats.org/';
      my $xmlns                  = $schema . 'spreadsheetml/2006/main';
      my $xmlns_r                = $schema . 'officeDocument/2006/relationships';
      my $xmlns_mc               = $schema . 'markup-compatibility/2006';
  
      my @attributes = (
          'xmlns'   => $xmlns,
          'xmlns:r' => $xmlns_r,
      );
  
      if ( $self->{_excel_version} == 2010 ) {
          push @attributes, ( 'xmlns:mc' => $xmlns_mc );
  
          push @attributes,
            (     'xmlns:x14ac' => 'http://schemas.microsoft.com/'
                . 'office/spreadsheetml/2009/9/ac' );
  
          push @attributes, ( 'mc:Ignorable' => 'x14ac' );
  
      }
  
      $self->xml_start_tag( 'worksheet', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_sheet_pr()
  #
  # Write the <sheetPr> element for Sheet level properties.
  #
  sub _write_sheet_pr {
  
      my $self       = shift;
      my @attributes = ();
  
      if (   !$self->{_fit_page}
          && !$self->{_filter_on}
          && !$self->{_tab_color}
          && !$self->{_outline_changed}
          && !$self->{_vba_codename} )
      {
          return;
      }
  
  
      my $codename = $self->{_vba_codename};
      push @attributes, ( 'codeName'   => $codename ) if $codename;
      push @attributes, ( 'filterMode' => 1 )         if $self->{_filter_on};
  
      if (   $self->{_fit_page}
          || $self->{_tab_color}
          || $self->{_outline_changed} )
      {
          $self->xml_start_tag( 'sheetPr', @attributes );
          $self->_write_tab_color();
          $self->_write_outline_pr();
          $self->_write_page_set_up_pr();
          $self->xml_end_tag( 'sheetPr' );
      }
      else {
          $self->xml_empty_tag( 'sheetPr', @attributes );
      }
  }
  
  
  ##############################################################################
  #
  # _write_page_set_up_pr()
  #
  # Write the <pageSetUpPr> element.
  #
  sub _write_page_set_up_pr {
  
      my $self = shift;
  
      return unless $self->{_fit_page};
  
      my @attributes = ( 'fitToPage' => 1 );
  
      $self->xml_empty_tag( 'pageSetUpPr', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_dimension()
  #
  # Write the <dimension> element. This specifies the range of cells in the
  # worksheet. As a special case, empty spreadsheets use 'A1' as a range.
  #
  sub _write_dimension {
  
      my $self = shift;
      my $ref;
  
      if ( !defined $self->{_dim_rowmin} && !defined $self->{_dim_colmin} ) {
  
          # If the min dims are undefined then no dimensions have been set
          # and we use the default 'A1'.
          $ref = 'A1';
      }
      elsif ( !defined $self->{_dim_rowmin} && defined $self->{_dim_colmin} ) {
  
          # If the row dims aren't set but the column dims are then they
          # have been changed via set_column().
  
          if ( $self->{_dim_colmin} == $self->{_dim_colmax} ) {
  
              # The dimensions are a single cell and not a range.
              $ref = xl_rowcol_to_cell( 0, $self->{_dim_colmin} );
          }
          else {
  
              # The dimensions are a cell range.
              my $cell_1 = xl_rowcol_to_cell( 0, $self->{_dim_colmin} );
              my $cell_2 = xl_rowcol_to_cell( 0, $self->{_dim_colmax} );
  
              $ref = $cell_1 . ':' . $cell_2;
          }
  
      }
      elsif ($self->{_dim_rowmin} == $self->{_dim_rowmax}
          && $self->{_dim_colmin} == $self->{_dim_colmax} )
      {
  
          # The dimensions are a single cell and not a range.
          $ref = xl_rowcol_to_cell( $self->{_dim_rowmin}, $self->{_dim_colmin} );
      }
      else {
  
          # The dimensions are a cell range.
          my $cell_1 =
            xl_rowcol_to_cell( $self->{_dim_rowmin}, $self->{_dim_colmin} );
          my $cell_2 =
            xl_rowcol_to_cell( $self->{_dim_rowmax}, $self->{_dim_colmax} );
  
          $ref = $cell_1 . ':' . $cell_2;
      }
  
  
      my @attributes = ( 'ref' => $ref );
  
      $self->xml_empty_tag( 'dimension', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_sheet_views()
  #
  # Write the <sheetViews> element.
  #
  sub _write_sheet_views {
  
      my $self = shift;
  
      my @attributes = ();
  
      $self->xml_start_tag( 'sheetViews', @attributes );
      $self->_write_sheet_view();
      $self->xml_end_tag( 'sheetViews' );
  }
  
  
  ###############################################################################
  #
  # _write_sheet_view()
  #
  # Write the <sheetView> element.
  #
  # Sample structure:
  #     <sheetView
  #         showGridLines="0"
  #         showRowColHeaders="0"
  #         showZeros="0"
  #         rightToLeft="1"
  #         tabSelected="1"
  #         showRuler="0"
  #         showOutlineSymbols="0"
  #         view="pageLayout"
  #         zoomScale="121"
  #         zoomScaleNormal="121"
  #         workbookViewId="0"
  #      />
  #
  sub _write_sheet_view {
  
      my $self             = shift;
      my $gridlines        = $self->{_screen_gridlines};
      my $show_zeros       = $self->{_show_zeros};
      my $right_to_left    = $self->{_right_to_left};
      my $tab_selected     = $self->{_selected};
      my $view             = $self->{_page_view};
      my $zoom             = $self->{_zoom};
      my $workbook_view_id = 0;
      my @attributes       = ();
  
      # Hide screen gridlines if required
      if ( !$gridlines ) {
          push @attributes, ( 'showGridLines' => 0 );
      }
  
      # Hide zeroes in cells.
      if ( !$show_zeros ) {
          push @attributes, ( 'showZeros' => 0 );
      }
  
      # Display worksheet right to left for Hebrew, Arabic and others.
      if ( $right_to_left ) {
          push @attributes, ( 'rightToLeft' => 1 );
      }
  
      # Show that the sheet tab is selected.
      if ( $tab_selected ) {
          push @attributes, ( 'tabSelected' => 1 );
      }
  
  
      # Turn outlines off. Also required in the outlinePr element.
      if ( !$self->{_outline_on} ) {
          push @attributes, ( "showOutlineSymbols" => 0 );
      }
  
      # Set the page view/layout mode if required.
      # TODO. Add pageBreakPreview mode when requested.
      if ( $view ) {
          push @attributes, ( 'view' => 'pageLayout' );
      }
  
      # Set the zoom level.
      if ( $zoom != 100 ) {
          push @attributes, ( 'zoomScale' => $zoom ) unless $view;
          push @attributes, ( 'zoomScaleNormal' => $zoom )
            if $self->{_zoom_scale_normal};
      }
  
      push @attributes, ( 'workbookViewId' => $workbook_view_id );
  
      if ( @{ $self->{_panes} } || @{ $self->{_selections} } ) {
          $self->xml_start_tag( 'sheetView', @attributes );
          $self->_write_panes();
          $self->_write_selections();
          $self->xml_end_tag( 'sheetView' );
      }
      else {
          $self->xml_empty_tag( 'sheetView', @attributes );
      }
  }
  
  
  ###############################################################################
  #
  # _write_selections()
  #
  # Write the <selection> elements.
  #
  sub _write_selections {
  
      my $self = shift;
  
      for my $selection ( @{ $self->{_selections} } ) {
          $self->_write_selection( @$selection );
      }
  }
  
  
  ###############################################################################
  #
  # _write_selection()
  #
  # Write the <selection> element.
  #
  sub _write_selection {
  
      my $self        = shift;
      my $pane        = shift;
      my $active_cell = shift;
      my $sqref       = shift;
      my @attributes  = ();
  
      push @attributes, ( 'pane'       => $pane )        if $pane;
      push @attributes, ( 'activeCell' => $active_cell ) if $active_cell;
      push @attributes, ( 'sqref'      => $sqref )       if $sqref;
  
      $self->xml_empty_tag( 'selection', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_sheet_format_pr()
  #
  # Write the <sheetFormatPr> element.
  #
  sub _write_sheet_format_pr {
  
      my $self               = shift;
      my $base_col_width     = 10;
      my $default_row_height = $self->{_default_row_height};
      my $row_level          = $self->{_outline_row_level};
      my $col_level          = $self->{_outline_col_level};
      my $zero_height        = $self->{_default_row_zeroed};
  
      my @attributes = ( 'defaultRowHeight' => $default_row_height );
  
      if ( $self->{_default_row_height} != $self->{_original_row_height} ) {
          push @attributes, ( 'customHeight' => 1 );
      }
  
      if ( $self->{_default_row_zeroed} ) {
          push @attributes, ( 'zeroHeight' => 1 );
      }
  
      push @attributes, ( 'outlineLevelRow' => $row_level ) if $row_level;
      push @attributes, ( 'outlineLevelCol' => $col_level ) if $col_level;
  
      if ( $self->{_excel_version} == 2010 ) {
          push @attributes, ( 'x14ac:dyDescent' => '0.25' );
      }
  
      $self->xml_empty_tag( 'sheetFormatPr', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_cols()
  #
  # Write the <cols> element and <col> sub elements.
  #
  sub _write_cols {
  
      my $self = shift;
  
      # Exit unless some column have been formatted.
      return unless %{ $self->{_colinfo} };
  
      $self->xml_start_tag( 'cols' );
  
      for my $col ( sort keys %{ $self->{_colinfo} } ) {
          $self->_write_col_info( @{ $self->{_colinfo}->{$col} } );
      }
  
      $self->xml_end_tag( 'cols' );
  }
  
  
  ##############################################################################
  #
  # _write_col_info()
  #
  # Write the <col> element.
  #
  sub _write_col_info {
  
      my $self         = shift;
      my $min          = $_[0] || 0;    # First formatted column.
      my $max          = $_[1] || 0;    # Last formatted column.
      my $width        = $_[2];         # Col width in user units.
      my $format       = $_[3];         # Format index.
      my $hidden       = $_[4] || 0;    # Hidden flag.
      my $level        = $_[5] || 0;    # Outline level.
      my $collapsed    = $_[6] || 0;    # Outline level.
      my $custom_width = 1;
      my $xf_index     = 0;
  
      # Get the format index.
      if ( ref( $format ) ) {
          $xf_index = $format->get_xf_index();
      }
  
      # Set the Excel default col width.
      if ( !defined $width ) {
          if ( !$hidden ) {
              $width        = 8.43;
              $custom_width = 0;
          }
          else {
              $width = 0;
          }
      }
      else {
  
          # Width is defined but same as default.
          if ( $width == 8.43 ) {
              $custom_width = 0;
          }
      }
  
  
      # Convert column width from user units to character width.
      my $max_digit_width = 7;    # For Calabri 11.
      my $padding         = 5;
  
      if ( $width > 0 ) {
          if ( $width < 1 ) {
              $width =
                int( ( int( $width * ($max_digit_width + $padding) + 0.5 ) ) /
                    $max_digit_width *
                    256 ) / 256;
          }
          else {
              $width =
                int( ( int( $width * $max_digit_width + 0.5 ) + $padding ) /
                    $max_digit_width *
                    256 ) / 256;
          }
      }
  
      my @attributes = (
          'min'   => $min + 1,
          'max'   => $max + 1,
          'width' => $width,
      );
  
      push @attributes, ( 'style'        => $xf_index ) if $xf_index;
      push @attributes, ( 'hidden'       => 1 )         if $hidden;
      push @attributes, ( 'customWidth'  => 1 )         if $custom_width;
      push @attributes, ( 'outlineLevel' => $level )    if $level;
      push @attributes, ( 'collapsed'    => 1 )         if $collapsed;
  
  
      $self->xml_empty_tag( 'col', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_sheet_data()
  #
  # Write the <sheetData> element.
  #
  sub _write_sheet_data {
  
      my $self = shift;
  
      if ( not defined $self->{_dim_rowmin} ) {
  
          # If the dimensions aren't defined then there is no data to write.
          $self->xml_empty_tag( 'sheetData' );
      }
      else {
          $self->xml_start_tag( 'sheetData' );
          $self->_write_rows();
          $self->xml_end_tag( 'sheetData' );
  
      }
  
  }
  
  
  ###############################################################################
  #
  # _write_optimized_sheet_data()
  #
  # Write the <sheetData> element when the memory optimisation is on. In which
  # case we read the data stored in the temp file and rewrite it to the XML
  # sheet file.
  #
  sub _write_optimized_sheet_data {
  
      my $self = shift;
  
      if ( not defined $self->{_dim_rowmin} ) {
  
          # If the dimensions aren't defined then there is no data to write.
          $self->xml_empty_tag( 'sheetData' );
      }
      else {
  
          $self->xml_start_tag( 'sheetData' );
  
          my $xlsx_fh = $self->xml_get_fh();
          my $cell_fh = $self->{_cell_data_fh};
  
          my $buffer;
  
          # Rewind the temp file.
          seek $cell_fh, 0, 0;
  
          while ( read( $cell_fh, $buffer, 4_096 ) ) {
              local $\ = undef;    # Protect print from -l on commandline.
              print $xlsx_fh $buffer;
          }
  
          $self->xml_end_tag( 'sheetData' );
      }
  }
  
  
  ###############################################################################
  #
  # _write_rows()
  #
  # Write out the worksheet data as a series of rows and cells.
  #
  sub _write_rows {
  
      my $self = shift;
  
      $self->_calculate_spans();
  
      for my $row_num ( $self->{_dim_rowmin} .. $self->{_dim_rowmax} ) {
  
          # Skip row if it doesn't contain row formatting, cell data or a comment.
          if (   !$self->{_set_rows}->{$row_num}
              && !$self->{_table}->{$row_num}
              && !$self->{_comments}->{$row_num} )
          {
              next;
          }
  
          my $span_index = int( $row_num / 16 );
          my $span       = $self->{_row_spans}->[$span_index];
  
          # Write the cells if the row contains data.
          if ( my $row_ref = $self->{_table}->{$row_num} ) {
  
              if ( !$self->{_set_rows}->{$row_num} ) {
                  $self->_write_row( $row_num, $span );
              }
              else {
                  $self->_write_row( $row_num, $span,
                      @{ $self->{_set_rows}->{$row_num} } );
              }
  
  
              for my $col_num ( $self->{_dim_colmin} .. $self->{_dim_colmax} ) {
                  if ( my $col_ref = $self->{_table}->{$row_num}->{$col_num} ) {
                      $self->_write_cell( $row_num, $col_num, $col_ref );
                  }
              }
  
              $self->xml_end_tag( 'row' );
          }
          elsif ( $self->{_comments}->{$row_num} ) {
  
              $self->_write_empty_row( $row_num, $span,
                  @{ $self->{_set_rows}->{$row_num} } );
          }
          else {
  
              # Row attributes only.
              $self->_write_empty_row( $row_num, $span,
                  @{ $self->{_set_rows}->{$row_num} } );
          }
      }
  }
  
  
  ###############################################################################
  #
  # _write_single_row()
  #
  # Write out the worksheet data as a single row with cells. This method is
  # used when memory optimisation is on. A single row is written and the data
  # table is reset. That way only one row of data is kept in memory at any one
  # time. We don't write span data in the optimised case since it is optional.
  #
  sub _write_single_row {
  
      my $self        = shift;
      my $current_row = shift || 0;
      my $row_num     = $self->{_previous_row};
  
      # Set the new previous row as the current row.
      $self->{_previous_row} = $current_row;
  
      # Skip row if it doesn't contain row formatting, cell data or a comment.
      if (   !$self->{_set_rows}->{$row_num}
          && !$self->{_table}->{$row_num}
          && !$self->{_comments}->{$row_num} )
      {
          return;
      }
  
      # Write the cells if the row contains data.
      if ( my $row_ref = $self->{_table}->{$row_num} ) {
  
          if ( !$self->{_set_rows}->{$row_num} ) {
              $self->_write_row( $row_num );
          }
          else {
              $self->_write_row( $row_num, undef,
                  @{ $self->{_set_rows}->{$row_num} } );
          }
  
          for my $col_num ( $self->{_dim_colmin} .. $self->{_dim_colmax} ) {
              if ( my $col_ref = $self->{_table}->{$row_num}->{$col_num} ) {
                  $self->_write_cell( $row_num, $col_num, $col_ref );
              }
          }
  
          $self->xml_end_tag( 'row' );
      }
      else {
  
          # Row attributes or comments only.
          $self->_write_empty_row( $row_num, undef,
              @{ $self->{_set_rows}->{$row_num} } );
      }
  
      # Reset table.
      $self->{_table} = {};
  
  }
  
  
  ###############################################################################
  #
  # _calculate_spans()
  #
  # Calculate the "spans" attribute of the <row> tag. This is an XLSX
  # optimisation and isn't strictly required. However, it makes comparing
  # files easier.
  #
  # The span is the same for each block of 16 rows.
  #
  sub _calculate_spans {
  
      my $self = shift;
  
      my @spans;
      my $span_min;
      my $span_max;
  
      for my $row_num ( $self->{_dim_rowmin} .. $self->{_dim_rowmax} ) {
  
          # Calculate spans for cell data.
          if ( my $row_ref = $self->{_table}->{$row_num} ) {
  
              for my $col_num ( $self->{_dim_colmin} .. $self->{_dim_colmax} ) {
                  if ( my $col_ref = $self->{_table}->{$row_num}->{$col_num} ) {
  
                      if ( !defined $span_min ) {
                          $span_min = $col_num;
                          $span_max = $col_num;
                      }
                      else {
                          $span_min = $col_num if $col_num < $span_min;
                          $span_max = $col_num if $col_num > $span_max;
                      }
                  }
              }
          }
  
          # Calculate spans for comments.
          if ( defined $self->{_comments}->{$row_num} ) {
  
              for my $col_num ( $self->{_dim_colmin} .. $self->{_dim_colmax} ) {
                  if ( defined $self->{_comments}->{$row_num}->{$col_num} ) {
  
                      if ( !defined $span_min ) {
                          $span_min = $col_num;
                          $span_max = $col_num;
                      }
                      else {
                          $span_min = $col_num if $col_num < $span_min;
                          $span_max = $col_num if $col_num > $span_max;
                      }
                  }
              }
          }
  
          if ( ( ( $row_num + 1 ) % 16 == 0 )
              || $row_num == $self->{_dim_rowmax} )
          {
              my $span_index = int( $row_num / 16 );
  
              if ( defined $span_min ) {
                  $span_min++;
                  $span_max++;
                  $spans[$span_index] = "$span_min:$span_max";
                  $span_min = undef;
              }
          }
      }
  
      $self->{_row_spans} = \@spans;
  }
  
  
  ###############################################################################
  #
  # _write_row()
  #
  # Write the <row> element.
  #
  sub _write_row {
  
      my $self      = shift;
      my $r         = shift;
      my $spans     = shift;
      my $height    = shift;
      my $format    = shift;
      my $hidden    = shift || 0;
      my $level     = shift || 0;
      my $collapsed = shift || 0;
      my $empty_row = shift || 0;
      my $xf_index  = 0;
  
      $height = $self->{_default_row_height} if !defined $height;
  
      my @attributes = ( 'r' => $r + 1 );
  
      # Get the format index.
      if ( ref( $format ) ) {
          $xf_index = $format->get_xf_index();
      }
  
      push @attributes, ( 'spans'        => $spans )    if defined $spans;
      push @attributes, ( 's'            => $xf_index ) if $xf_index;
      push @attributes, ( 'customFormat' => 1 )         if $format;
  
      if ( $height != $self->{_original_row_height} ) {
          push @attributes, ( 'ht' => $height );
      }
  
      push @attributes, ( 'hidden'       => 1 )         if $hidden;
  
      if ( $height != $self->{_original_row_height} ) {
          push @attributes, ( 'customHeight' => 1 );
      }
  
      push @attributes, ( 'outlineLevel' => $level )    if $level;
      push @attributes, ( 'collapsed'    => 1 )         if $collapsed;
  
      if ( $self->{_excel_version} == 2010 ) {
          push @attributes, ( 'x14ac:dyDescent' => '0.25' );
      }
  
      if ( $empty_row ) {
          $self->xml_empty_tag_unencoded( 'row', @attributes );
      }
      else {
          $self->xml_start_tag_unencoded( 'row', @attributes );
      }
  }
  
  
  ###############################################################################
  #
  # _write_empty_row()
  #
  # Write and empty <row> element, i.e., attributes only, no cell data.
  #
  sub _write_empty_row {
  
      my $self = shift;
  
      # Set the $empty_row parameter.
      $_[7] = 1;
  
      $self->_write_row( @_ );
  }
  
  
  ###############################################################################
  #
  # _write_cell()
  #
  # Write the <cell> element. This is the innermost loop so efficiency is
  # important where possible. The basic methodology is that the data of every
  # cell type is passed in as follows:
  #
  #      [ $row, $col, $aref]
  #
  # The aref, called $cell below, contains the following structure in all types:
  #
  #     [ $type, $token, $xf, @args ]
  #
  # Where $type:  represents the cell type, such as string, number, formula, etc.
  #       $token: is the actual data for the string, number, formula, etc.
  #       $xf:    is the XF format object.
  #       @args:  additional args relevant to the specific data type.
  #
  sub _write_cell {
  
      my $self     = shift;
      my $row      = shift;
      my $col      = shift;
      my $cell     = shift;
      my $type     = $cell->[0];
      my $token    = $cell->[1];
      my $xf       = $cell->[2];
      my $xf_index = 0;
  
      my %error_codes = (
          '#DIV/0!' => 1,
          '#N/A'    => 1,
          '#NAME?'  => 1,
          '#NULL!'  => 1,
          '#NUM!'   => 1,
          '#REF!'   => 1,
          '#VALUE!' => 1,
      );
  
      my %boolean = ( 'TRUE' => 1, 'FALSE' => 0 );
  
      # Get the format index.
      if ( ref( $xf ) ) {
          $xf_index = $xf->get_xf_index();
      }
  
      my $range = _xl_rowcol_to_cell( $row, $col );
      my @attributes = ( 'r' => $range );
  
      # Add the cell format index.
      if ( $xf_index ) {
          push @attributes, ( 's' => $xf_index );
      }
      elsif ( $self->{_set_rows}->{$row} && $self->{_set_rows}->{$row}->[1] ) {
          my $row_xf = $self->{_set_rows}->{$row}->[1];
          push @attributes, ( 's' => $row_xf->get_xf_index() );
      }
      elsif ( $self->{_col_formats}->{$col} ) {
          my $col_xf = $self->{_col_formats}->{$col};
          push @attributes, ( 's' => $col_xf->get_xf_index() );
      }
  
  
      # Write the various cell types.
      if ( $type eq 'n' ) {
  
          # Write a number.
          $self->xml_number_element( $token, @attributes );
      }
      elsif ( $type eq 's' ) {
  
          # Write a string.
          if ( $self->{_optimization} == 0 ) {
              $self->xml_string_element( $token, @attributes );
          }
          else {
  
              my $string = $token;
  
              # Escape control characters. See SharedString.pm for details.
              $string =~ s/(_x[0-9a-fA-F]{4}_)/_x005F$1/g;
              $string =~ s/([\x00-\x08\x0B-\x1F])/sprintf "_x%04X_", ord($1)/eg;
  
              # Write any rich strings without further tags.
              if ( $string =~ m{^<r>} && $string =~ m{</r>$} ) {
  
                  $self->xml_rich_inline_string( $string, @attributes );
              }
              else {
  
                  # Add attribute to preserve leading or trailing whitespace.
                  my $preserve = 0;
                  if ( $string =~ /^\s/ || $string =~ /\s$/ ) {
                      $preserve = 1;
                  }
  
                  $self->xml_inline_string( $string, $preserve, @attributes );
              }
          }
      }
      elsif ( $type eq 'f' ) {
  
          # Write a formula.
          my $value = $cell->[3] || 0;
  
          # Check if the formula value is a string.
          if (   $value
              && $value !~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/ )
          {
              if ( exists $boolean{$value} ) {
                  push @attributes, ( 't' => 'b' );
                  $value = $boolean{$value};
              }
              elsif ( exists $error_codes{$value} ) {
                  push @attributes, ( 't' => 'e' );
              }
              else {
                  push @attributes, ( 't' => 'str' );
                  $value = Excel::Writer::XLSX::Package::XMLwriter::_escape_data(
                      $value );
              }
          }
  
          $self->xml_formula_element( $token, $value, @attributes );
  
      }
      elsif ( $type eq 'a' ) {
  
          # Write an array formula.
          $self->xml_start_tag( 'c', @attributes );
          $self->_write_cell_array_formula( $token, $cell->[3] );
          $self->_write_cell_value( $cell->[4] );
          $self->xml_end_tag( 'c' );
      }
      elsif ( $type eq 'l' ) {
  
          # Write a boolean value.
          push @attributes, ( 't' => 'b' );
  
          $self->xml_start_tag( 'c', @attributes );
          $self->_write_cell_value( $cell->[1] );
          $self->xml_end_tag( 'c' );
      }
      elsif ( $type eq 'b' ) {
  
          # Write a empty cell.
          $self->xml_empty_tag( 'c', @attributes );
      }
  }
  
  
  ###############################################################################
  #
  # _write_cell_value()
  #
  # Write the cell value <v> element.
  #
  sub _write_cell_value {
  
      my $self = shift;
      my $value = defined $_[0] ? $_[0] : '';
  
      $self->xml_data_element( 'v', $value );
  }
  
  
  ###############################################################################
  #
  # _write_cell_formula()
  #
  # Write the cell formula <f> element.
  #
  sub _write_cell_formula {
  
      my $self = shift;
      my $formula = defined $_[0] ? $_[0] : '';
  
      $self->xml_data_element( 'f', $formula );
  }
  
  
  ###############################################################################
  #
  # _write_cell_array_formula()
  #
  # Write the cell array formula <f> element.
  #
  sub _write_cell_array_formula {
  
      my $self    = shift;
      my $formula = shift;
      my $range   = shift;
  
      my @attributes = ( 't' => 'array', 'ref' => $range );
  
      $self->xml_data_element( 'f', $formula, @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_sheet_calc_pr()
  #
  # Write the <sheetCalcPr> element for the worksheet calculation properties.
  #
  sub _write_sheet_calc_pr {
  
      my $self              = shift;
      my $full_calc_on_load = 1;
  
      my @attributes = ( 'fullCalcOnLoad' => $full_calc_on_load );
  
      $self->xml_empty_tag( 'sheetCalcPr', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_phonetic_pr()
  #
  # Write the <phoneticPr> element.
  #
  sub _write_phonetic_pr {
  
      my $self    = shift;
      my $font_id = 0;
      my $type    = 'noConversion';
  
      my @attributes = (
          'fontId' => $font_id,
          'type'   => $type,
      );
  
      $self->xml_empty_tag( 'phoneticPr', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_page_margins()
  #
  # Write the <pageMargins> element.
  #
  sub _write_page_margins {
  
      my $self = shift;
  
      my @attributes = (
          'left'   => $self->{_margin_left},
          'right'  => $self->{_margin_right},
          'top'    => $self->{_margin_top},
          'bottom' => $self->{_margin_bottom},
          'header' => $self->{_margin_header},
          'footer' => $self->{_margin_footer},
      );
  
      $self->xml_empty_tag( 'pageMargins', @attributes );
  }
  
  
  ###############################################################################
  #
  # _write_page_setup()
  #
  # Write the <pageSetup> element.
  #
  # The following is an example taken from Excel.
  #
  # <pageSetup
  #     paperSize="9"
  #     scale="110"
  #     fitToWidth="2"
  #     fitToHeight="2"
  #     pageOrder="overThenDown"
  #     orientation="portrait"
  #     blackAndWhite="1"
  #     draft="1"
  #     horizontalDpi="200"
  #     verticalDpi="200"
  #     r:id="rId1"
  # />
  #
  sub _write_page_setup {
  
      my $self       = shift;
      my @attributes = ();
  
      return unless $self->{_page_setup_changed};
  
      # Set paper size.
      if ( $self->{_paper_size} ) {
          push @attributes, ( 'paperSize' => $self->{_paper_size} );
      }
  
      # Set the print_scale
      if ( $self->{_print_scale} != 100 ) {
          push @attributes, ( 'scale' => $self->{_print_scale} );
      }
  
      # Set the "Fit to page" properties.
      if ( $self->{_fit_page} && $self->{_fit_width} != 1 ) {
          push @attributes, ( 'fitToWidth' => $self->{_fit_width} );
      }
  
      if ( $self->{_fit_page} && $self->{_fit_height} != 1 ) {
          push @attributes, ( 'fitToHeight' => $self->{_fit_height} );
      }
  
      # Set the page print direction.
      if ( $self->{_page_order} ) {
          push @attributes, ( 'pageOrder' => "overThenDown" );
      }
  
      # Set start page.
      if ( $self->{_page_start} > 1 ) {
          push @attributes, ( 'firstPageNumber' => $self->{_page_start} );
      }
  
      # Set page orientation.
      if ( $self->{_orientation} == 0 ) {
          push @attributes, ( 'orientation' => 'landscape' );
      }
      else {
          push @attributes, ( 'orientation' => 'portrait' );
      }
  
      # Set print in black and white option.
      if ( $self->{_black_white} ) {
          push @attributes, ( 'blackAndWhite' => 1 );
      }
  
      # Set start page.
      if ( $self->{_page_start} != 0 ) {
          push @attributes, ( 'useFirstPageNumber' => 1 );
      }
  
      # Set the DPI. Mainly only for testing.
      if ( $self->{_horizontal_dpi} ) {
          push @attributes, ( 'horizontalDpi' => $self->{_horizontal_dpi} );
      }
  
      if ( $self->{_vertical_dpi} ) {
          push @attributes, ( 'verticalDpi' => $self->{_vertical_dpi} );
      }
  
  
      $self->xml_empty_tag( 'pageSetup', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_merge_cells()
  #
  # Write the <mergeCells> element.
  #
  sub _write_merge_cells {
  
      my $self         = shift;
      my $merged_cells = $self->{_merge};
      my $count        = @$merged_cells;
  
      return unless $count;
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'mergeCells', @attributes );
  
      for my $merged_range ( @$merged_cells ) {
  
          # Write the mergeCell element.
          $self->_write_merge_cell( $merged_range );
      }
  
      $self->xml_end_tag( 'mergeCells' );
  }
  
  
  ##############################################################################
  #
  # _write_merge_cell()
  #
  # Write the <mergeCell> element.
  #
  sub _write_merge_cell {
  
      my $self         = shift;
      my $merged_range = shift;
      my ( $row_min, $col_min, $row_max, $col_max ) = @$merged_range;
  
  
      # Convert the merge dimensions to a cell range.
      my $cell_1 = xl_rowcol_to_cell( $row_min, $col_min );
      my $cell_2 = xl_rowcol_to_cell( $row_max, $col_max );
      my $ref    = $cell_1 . ':' . $cell_2;
  
      my @attributes = ( 'ref' => $ref );
  
      $self->xml_empty_tag( 'mergeCell', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_print_options()
  #
  # Write the <printOptions> element.
  #
  sub _write_print_options {
  
      my $self       = shift;
      my @attributes = ();
  
      return unless $self->{_print_options_changed};
  
      # Set horizontal centering.
      if ( $self->{_hcenter} ) {
          push @attributes, ( 'horizontalCentered' => 1 );
      }
  
      # Set vertical centering.
      if ( $self->{_vcenter} ) {
          push @attributes, ( 'verticalCentered' => 1 );
      }
  
      # Enable row and column headers.
      if ( $self->{_print_headers} ) {
          push @attributes, ( 'headings' => 1 );
      }
  
      # Set printed gridlines.
      if ( $self->{_print_gridlines} ) {
          push @attributes, ( 'gridLines' => 1 );
      }
  
  
      $self->xml_empty_tag( 'printOptions', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_header_footer()
  #
  # Write the <headerFooter> element.
  #
  sub _write_header_footer {
  
      my $self       = shift;
      my @attributes = ();
  
      if ( !$self->{_header_footer_scales} ) {
          push @attributes, ( 'scaleWithDoc' => 0 );
      }
  
      if ( !$self->{_header_footer_aligns} ) {
          push @attributes, ( 'alignWithMargins' => 0 );
      }
  
      if ( $self->{_header_footer_changed} ) {
          $self->xml_start_tag( 'headerFooter', @attributes );
          $self->_write_odd_header() if $self->{_header};
          $self->_write_odd_footer() if $self->{_footer};
          $self->xml_end_tag( 'headerFooter' );
      }
      elsif ( $self->{_excel2003_style} ) {
          $self->xml_empty_tag( 'headerFooter', @attributes );
      }
  }
  
  
  ##############################################################################
  #
  # _write_odd_header()
  #
  # Write the <oddHeader> element.
  #
  sub _write_odd_header {
  
      my $self = shift;
      my $data = $self->{_header};
  
      $self->xml_data_element( 'oddHeader', $data );
  }
  
  
  ##############################################################################
  #
  # _write_odd_footer()
  #
  # Write the <oddFooter> element.
  #
  sub _write_odd_footer {
  
      my $self = shift;
      my $data = $self->{_footer};
  
      $self->xml_data_element( 'oddFooter', $data );
  }
  
  
  ##############################################################################
  #
  # _write_row_breaks()
  #
  # Write the <rowBreaks> element.
  #
  sub _write_row_breaks {
  
      my $self = shift;
  
      my @page_breaks = $self->_sort_pagebreaks( @{ $self->{_hbreaks} } );
      my $count       = scalar @page_breaks;
  
      return unless @page_breaks;
  
      my @attributes = (
          'count'            => $count,
          'manualBreakCount' => $count,
      );
  
      $self->xml_start_tag( 'rowBreaks', @attributes );
  
      for my $row_num ( @page_breaks ) {
          $self->_write_brk( $row_num, 16383 );
      }
  
      $self->xml_end_tag( 'rowBreaks' );
  }
  
  
  ##############################################################################
  #
  # _write_col_breaks()
  #
  # Write the <colBreaks> element.
  #
  sub _write_col_breaks {
  
      my $self = shift;
  
      my @page_breaks = $self->_sort_pagebreaks( @{ $self->{_vbreaks} } );
      my $count       = scalar @page_breaks;
  
      return unless @page_breaks;
  
      my @attributes = (
          'count'            => $count,
          'manualBreakCount' => $count,
      );
  
      $self->xml_start_tag( 'colBreaks', @attributes );
  
      for my $col_num ( @page_breaks ) {
          $self->_write_brk( $col_num, 1048575 );
      }
  
      $self->xml_end_tag( 'colBreaks' );
  }
  
  
  ##############################################################################
  #
  # _write_brk()
  #
  # Write the <brk> element.
  #
  sub _write_brk {
  
      my $self = shift;
      my $id   = shift;
      my $max  = shift;
      my $man  = 1;
  
      my @attributes = (
          'id'  => $id,
          'max' => $max,
          'man' => $man,
      );
  
      $self->xml_empty_tag( 'brk', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_auto_filter()
  #
  # Write the <autoFilter> element.
  #
  sub _write_auto_filter {
  
      my $self = shift;
      my $ref  = $self->{_autofilter_ref};
  
      return unless $ref;
  
      my @attributes = ( 'ref' => $ref );
  
      if ( $self->{_filter_on} ) {
  
          # Autofilter defined active filters.
          $self->xml_start_tag( 'autoFilter', @attributes );
  
          $self->_write_autofilters();
  
          $self->xml_end_tag( 'autoFilter' );
  
      }
      else {
  
          # Autofilter defined without active filters.
          $self->xml_empty_tag( 'autoFilter', @attributes );
      }
  
  }
  
  
  ###############################################################################
  #
  # _write_autofilters()
  #
  # Function to iterate through the columns that form part of an autofilter
  # range and write the appropriate filters.
  #
  sub _write_autofilters {
  
      my $self = shift;
  
      my ( $col1, $col2 ) = @{ $self->{_filter_range} };
  
      for my $col ( $col1 .. $col2 ) {
  
          # Skip if column doesn't have an active filter.
          next unless $self->{_filter_cols}->{$col};
  
          # Retrieve the filter tokens and write the autofilter records.
          my @tokens = @{ $self->{_filter_cols}->{$col} };
          my $type   = $self->{_filter_type}->{$col};
  
          # Filters are relative to first column in the autofilter.
          $self->_write_filter_column( $col - $col1, $type, \@tokens );
      }
  }
  
  
  ##############################################################################
  #
  # _write_filter_column()
  #
  # Write the <filterColumn> element.
  #
  sub _write_filter_column {
  
      my $self    = shift;
      my $col_id  = shift;
      my $type    = shift;
      my $filters = shift;
  
      my @attributes = ( 'colId' => $col_id );
  
      $self->xml_start_tag( 'filterColumn', @attributes );
  
  
      if ( $type == 1 ) {
  
          # Type == 1 is the new XLSX style filter.
          $self->_write_filters( @$filters );
  
      }
      else {
  
          # Type == 0 is the classic "custom" filter.
          $self->_write_custom_filters( @$filters );
      }
  
      $self->xml_end_tag( 'filterColumn' );
  }
  
  
  ##############################################################################
  #
  # _write_filters()
  #
  # Write the <filters> element.
  #
  sub _write_filters {
  
      my $self    = shift;
      my @filters = @_;
  
      if ( @filters == 1 && $filters[0] eq 'blanks' ) {
  
          # Special case for blank cells only.
          $self->xml_empty_tag( 'filters', 'blank' => 1 );
      }
      else {
  
          # General case.
          $self->xml_start_tag( 'filters' );
  
          for my $filter ( @filters ) {
              $self->_write_filter( $filter );
          }
  
          $self->xml_end_tag( 'filters' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_filter()
  #
  # Write the <filter> element.
  #
  sub _write_filter {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->xml_empty_tag( 'filter', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_custom_filters()
  #
  # Write the <customFilters> element.
  #
  sub _write_custom_filters {
  
      my $self   = shift;
      my @tokens = @_;
  
      if ( @tokens == 2 ) {
  
          # One filter expression only.
          $self->xml_start_tag( 'customFilters' );
          $self->_write_custom_filter( @tokens );
          $self->xml_end_tag( 'customFilters' );
  
      }
      else {
  
          # Two filter expressions.
  
          my @attributes;
  
          # Check if the "join" operand is "and" or "or".
          if ( $tokens[2] == 0 ) {
              @attributes = ( 'and' => 1 );
          }
          else {
              @attributes = ( 'and' => 0 );
          }
  
          # Write the two custom filters.
          $self->xml_start_tag( 'customFilters', @attributes );
          $self->_write_custom_filter( $tokens[0], $tokens[1] );
          $self->_write_custom_filter( $tokens[3], $tokens[4] );
          $self->xml_end_tag( 'customFilters' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_custom_filter()
  #
  # Write the <customFilter> element.
  #
  sub _write_custom_filter {
  
      my $self       = shift;
      my $operator   = shift;
      my $val        = shift;
      my @attributes = ();
  
      my %operators = (
          1  => 'lessThan',
          2  => 'equal',
          3  => 'lessThanOrEqual',
          4  => 'greaterThan',
          5  => 'notEqual',
          6  => 'greaterThanOrEqual',
          22 => 'equal',
      );
  
  
      # Convert the operator from a number to a descriptive string.
      if ( defined $operators{$operator} ) {
          $operator = $operators{$operator};
      }
      else {
          croak "Unknown operator = $operator\n";
      }
  
      # The 'equal' operator is the default attribute and isn't stored.
      push @attributes, ( 'operator' => $operator ) unless $operator eq 'equal';
      push @attributes, ( 'val' => $val );
  
      $self->xml_empty_tag( 'customFilter', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_hyperlinks()
  #
  # Process any stored hyperlinks in row/col order and write the <hyperlinks>
  # element. The attributes are different for internal and external links.
  #
  sub _write_hyperlinks {
  
      my $self = shift;
      my @hlink_refs;
  
      # Sort the hyperlinks into row order.
      my @row_nums = sort { $a <=> $b } keys %{ $self->{_hyperlinks} };
  
      # Exit if there are no hyperlinks to process.
      return if !@row_nums;
  
      # Iterate over the rows.
      for my $row_num ( @row_nums ) {
  
          # Sort the hyperlinks into column order.
          my @col_nums = sort { $a <=> $b }
            keys %{ $self->{_hyperlinks}->{$row_num} };
  
          # Iterate over the columns.
          for my $col_num ( @col_nums ) {
  
              # Get the link data for this cell.
              my $link      = $self->{_hyperlinks}->{$row_num}->{$col_num};
              my $link_type = $link->{_link_type};
  
  
              # If the cell isn't a string then we have to add the url as
              # the string to display.
              my $display;
              if (   $self->{_table}
                  && $self->{_table}->{$row_num}
                  && $self->{_table}->{$row_num}->{$col_num} )
              {
                  my $cell = $self->{_table}->{$row_num}->{$col_num};
                  $display = $link->{_url} if $cell->[0] ne 's';
              }
  
  
              if ( $link_type == 1 ) {
  
                  # External link with rel file relationship.
                  push @hlink_refs,
                    [
                      $link_type,    $row_num,
                      $col_num,      ++$self->{_rel_count},
                      $link->{_str}, $display,
                      $link->{_tip}
                    ];
  
                  # Links for use by the packager.
                  push @{ $self->{_external_hyper_links} },
                    [ '/hyperlink', $link->{_url}, 'External' ];
              }
              else {
  
                  # Internal link with rel file relationship.
                  push @hlink_refs,
                    [
                      $link_type,    $row_num,      $col_num,
                      $link->{_url}, $link->{_str}, $link->{_tip}
                    ];
              }
          }
      }
  
      # Write the hyperlink elements.
      $self->xml_start_tag( 'hyperlinks' );
  
      for my $aref ( @hlink_refs ) {
          my ( $type, @args ) = @$aref;
  
          if ( $type == 1 ) {
              $self->_write_hyperlink_external( @args );
          }
          elsif ( $type == 2 ) {
              $self->_write_hyperlink_internal( @args );
          }
      }
  
      $self->xml_end_tag( 'hyperlinks' );
  }
  
  
  ##############################################################################
  #
  # _write_hyperlink_external()
  #
  # Write the <hyperlink> element for external links.
  #
  sub _write_hyperlink_external {
  
      my $self     = shift;
      my $row      = shift;
      my $col      = shift;
      my $id       = shift;
      my $location = shift;
      my $display  = shift;
      my $tooltip  = shift;
  
      my $ref = xl_rowcol_to_cell( $row, $col );
      my $r_id = 'rId' . $id;
  
      my @attributes = (
          'ref'  => $ref,
          'r:id' => $r_id,
      );
  
      push @attributes, ( 'location' => $location ) if defined $location;
      push @attributes, ( 'display' => $display )   if defined $display;
      push @attributes, ( 'tooltip'  => $tooltip )  if defined $tooltip;
  
      $self->xml_empty_tag( 'hyperlink', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_hyperlink_internal()
  #
  # Write the <hyperlink> element for internal links.
  #
  sub _write_hyperlink_internal {
  
      my $self     = shift;
      my $row      = shift;
      my $col      = shift;
      my $location = shift;
      my $display  = shift;
      my $tooltip  = shift;
  
      my $ref = xl_rowcol_to_cell( $row, $col );
  
      my @attributes = ( 'ref' => $ref, 'location' => $location );
  
      push @attributes, ( 'tooltip' => $tooltip ) if defined $tooltip;
      push @attributes, ( 'display' => $display );
  
      $self->xml_empty_tag( 'hyperlink', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_panes()
  #
  # Write the frozen or split <pane> elements.
  #
  sub _write_panes {
  
      my $self  = shift;
      my @panes = @{ $self->{_panes} };
  
      return unless @panes;
  
      if ( $panes[4] == 2 ) {
          $self->_write_split_panes( @panes );
      }
      else {
          $self->_write_freeze_panes( @panes );
      }
  }
  
  
  ##############################################################################
  #
  # _write_freeze_panes()
  #
  # Write the <pane> element for freeze panes.
  #
  sub _write_freeze_panes {
  
      my $self = shift;
      my @attributes;
  
      my ( $row, $col, $top_row, $left_col, $type ) = @_;
  
      my $y_split       = $row;
      my $x_split       = $col;
      my $top_left_cell = xl_rowcol_to_cell( $top_row, $left_col );
      my $active_pane;
      my $state;
      my $active_cell;
      my $sqref;
  
      # Move user cell selection to the panes.
      if ( @{ $self->{_selections} } ) {
          ( undef, $active_cell, $sqref ) = @{ $self->{_selections}->[0] };
          $self->{_selections} = [];
      }
  
      # Set the active pane.
      if ( $row && $col ) {
          $active_pane = 'bottomRight';
  
          my $row_cell = xl_rowcol_to_cell( $row, 0 );
          my $col_cell = xl_rowcol_to_cell( 0,    $col );
  
          push @{ $self->{_selections} },
            (
              [ 'topRight',    $col_cell,    $col_cell ],
              [ 'bottomLeft',  $row_cell,    $row_cell ],
              [ 'bottomRight', $active_cell, $sqref ]
            );
      }
      elsif ( $col ) {
          $active_pane = 'topRight';
          push @{ $self->{_selections} }, [ 'topRight', $active_cell, $sqref ];
      }
      else {
          $active_pane = 'bottomLeft';
          push @{ $self->{_selections} }, [ 'bottomLeft', $active_cell, $sqref ];
      }
  
      # Set the pane type.
      if ( $type == 0 ) {
          $state = 'frozen';
      }
      elsif ( $type == 1 ) {
          $state = 'frozenSplit';
      }
      else {
          $state = 'split';
      }
  
  
      push @attributes, ( 'xSplit' => $x_split ) if $x_split;
      push @attributes, ( 'ySplit' => $y_split ) if $y_split;
  
      push @attributes, ( 'topLeftCell' => $top_left_cell );
      push @attributes, ( 'activePane'  => $active_pane );
      push @attributes, ( 'state'       => $state );
  
  
      $self->xml_empty_tag( 'pane', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_split_panes()
  #
  # Write the <pane> element for split panes.
  #
  # See also, implementers note for split_panes().
  #
  sub _write_split_panes {
  
      my $self = shift;
      my @attributes;
      my $y_split;
      my $x_split;
      my $has_selection = 0;
      my $active_pane;
      my $active_cell;
      my $sqref;
  
      my ( $row, $col, $top_row, $left_col, $type ) = @_;
      $y_split = $row;
      $x_split = $col;
  
      # Move user cell selection to the panes.
      if ( @{ $self->{_selections} } ) {
          ( undef, $active_cell, $sqref ) = @{ $self->{_selections}->[0] };
          $self->{_selections} = [];
          $has_selection = 1;
      }
  
      # Convert the row and col to 1/20 twip units with padding.
      $y_split = int( 20 * $y_split + 300 ) if $y_split;
      $x_split = $self->_calculate_x_split_width( $x_split ) if $x_split;
  
      # For non-explicit topLeft definitions, estimate the cell offset based
      # on the pixels dimensions. This is only a workaround and doesn't take
      # adjusted cell dimensions into account.
      if ( $top_row == $row && $left_col == $col ) {
          $top_row  = int( 0.5 + ( $y_split - 300 ) / 20 / 15 );
          $left_col = int( 0.5 + ( $x_split - 390 ) / 20 / 3 * 4 / 64 );
      }
  
      my $top_left_cell = xl_rowcol_to_cell( $top_row, $left_col );
  
      # If there is no selection set the active cell to the top left cell.
      if ( !$has_selection ) {
          $active_cell = $top_left_cell;
          $sqref       = $top_left_cell;
      }
  
      # Set the Cell selections.
      if ( $row && $col ) {
          $active_pane = 'bottomRight';
  
          my $row_cell = xl_rowcol_to_cell( $top_row, 0 );
          my $col_cell = xl_rowcol_to_cell( 0,        $left_col );
  
          push @{ $self->{_selections} },
            (
              [ 'topRight',    $col_cell,    $col_cell ],
              [ 'bottomLeft',  $row_cell,    $row_cell ],
              [ 'bottomRight', $active_cell, $sqref ]
            );
      }
      elsif ( $col ) {
          $active_pane = 'topRight';
          push @{ $self->{_selections} }, [ 'topRight', $active_cell, $sqref ];
      }
      else {
          $active_pane = 'bottomLeft';
          push @{ $self->{_selections} }, [ 'bottomLeft', $active_cell, $sqref ];
      }
  
      push @attributes, ( 'xSplit' => $x_split ) if $x_split;
      push @attributes, ( 'ySplit' => $y_split ) if $y_split;
      push @attributes, ( 'topLeftCell' => $top_left_cell );
      push @attributes, ( 'activePane' => $active_pane ) if $has_selection;
  
      $self->xml_empty_tag( 'pane', @attributes );
  }
  
  
  ##############################################################################
  #
  # _calculate_x_split_width()
  #
  # Convert column width from user units to pane split width.
  #
  sub _calculate_x_split_width {
  
      my $self  = shift;
      my $width = shift;
  
      my $max_digit_width = 7;    # For Calabri 11.
      my $padding         = 5;
      my $pixels;
  
      # Convert to pixels.
      if ( $width < 1 ) {
          $pixels = int( $width * ( $max_digit_width + $padding ) + 0.5 );
      }
      else {
            $pixels = int( $width * $max_digit_width + 0.5 ) + $padding;
      }
  
      # Convert to points.
      my $points = $pixels * 3 / 4;
  
      # Convert to twips (twentieths of a point).
      my $twips = $points * 20;
  
      # Add offset/padding.
      $width = $twips + 390;
  
      return $width;
  }
  
  
  ##############################################################################
  #
  # _write_tab_color()
  #
  # Write the <tabColor> element.
  #
  sub _write_tab_color {
  
      my $self        = shift;
      my $color_index = $self->{_tab_color};
  
      return unless $color_index;
  
      my $rgb = $self->_get_palette_color( $color_index );
  
      my @attributes = ( 'rgb' => $rgb );
  
      $self->xml_empty_tag( 'tabColor', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_outline_pr()
  #
  # Write the <outlinePr> element.
  #
  sub _write_outline_pr {
  
      my $self       = shift;
      my @attributes = ();
  
      return unless $self->{_outline_changed};
  
      push @attributes, ( "applyStyles"        => 1 ) if $self->{_outline_style};
      push @attributes, ( "summaryBelow"       => 0 ) if !$self->{_outline_below};
      push @attributes, ( "summaryRight"       => 0 ) if !$self->{_outline_right};
      push @attributes, ( "showOutlineSymbols" => 0 ) if !$self->{_outline_on};
  
      $self->xml_empty_tag( 'outlinePr', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_sheet_protection()
  #
  # Write the <sheetProtection> element.
  #
  sub _write_sheet_protection {
  
      my $self = shift;
      my @attributes;
  
      return unless $self->{_protect};
  
      my %arg = %{ $self->{_protect} };
  
      push @attributes, ( "password"    => $arg{password} ) if $arg{password};
      push @attributes, ( "sheet"       => 1 )              if $arg{sheet};
      push @attributes, ( "content"     => 1 )              if $arg{content};
      push @attributes, ( "objects"     => 1 )              if !$arg{objects};
      push @attributes, ( "scenarios"   => 1 )              if !$arg{scenarios};
      push @attributes, ( "formatCells" => 0 )              if $arg{format_cells};
      push @attributes, ( "formatColumns"    => 0 ) if $arg{format_columns};
      push @attributes, ( "formatRows"       => 0 ) if $arg{format_rows};
      push @attributes, ( "insertColumns"    => 0 ) if $arg{insert_columns};
      push @attributes, ( "insertRows"       => 0 ) if $arg{insert_rows};
      push @attributes, ( "insertHyperlinks" => 0 ) if $arg{insert_hyperlinks};
      push @attributes, ( "deleteColumns"    => 0 ) if $arg{delete_columns};
      push @attributes, ( "deleteRows"       => 0 ) if $arg{delete_rows};
  
      push @attributes, ( "selectLockedCells" => 1 )
        if !$arg{select_locked_cells};
  
      push @attributes, ( "sort"        => 0 ) if $arg{sort};
      push @attributes, ( "autoFilter"  => 0 ) if $arg{autofilter};
      push @attributes, ( "pivotTables" => 0 ) if $arg{pivot_tables};
  
      push @attributes, ( "selectUnlockedCells" => 1 )
        if !$arg{select_unlocked_cells};
  
  
      $self->xml_empty_tag( 'sheetProtection', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_drawings()
  #
  # Write the <drawing> elements.
  #
  sub _write_drawings {
  
      my $self = shift;
  
      return unless $self->{_drawing};
  
      $self->_write_drawing( ++$self->{_rel_count} );
  }
  
  
  ##############################################################################
  #
  # _write_drawing()
  #
  # Write the <drawing> element.
  #
  sub _write_drawing {
  
      my $self = shift;
      my $id   = shift;
      my $r_id = 'rId' . $id;
  
      my @attributes = ( 'r:id' => $r_id );
  
      $self->xml_empty_tag( 'drawing', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_legacy_drawing()
  #
  # Write the <legacyDrawing> element.
  #
  sub _write_legacy_drawing {
  
      my $self = shift;
      my $id;
  
      return unless $self->{_has_vml};
  
      # Increment the relationship id for any drawings or comments.
      $id = ++$self->{_rel_count};
  
      my @attributes = ( 'r:id' => 'rId' . $id );
  
      $self->xml_empty_tag( 'legacyDrawing', @attributes );
  }
  
  
  
  ##############################################################################
  #
  # _write_legacy_drawing_hf()
  #
  # Write the <legacyDrawingHF> element.
  #
  sub _write_legacy_drawing_hf {
  
      my $self = shift;
      my $id;
  
      return unless $self->{_has_header_vml};
  
      # Increment the relationship id for any drawings or comments.
      $id = ++$self->{_rel_count};
  
      my @attributes = ( 'r:id' => 'rId' . $id );
  
      $self->xml_empty_tag( 'legacyDrawingHF', @attributes );
  }
  
  
  #
  # Note, the following font methods are, more or less, duplicated from the
  # Excel::Writer::XLSX::Package::Styles class. I will look at implementing
  # this is a cleaner encapsulated mode at a later stage.
  #
  
  
  ##############################################################################
  #
  # _write_font()
  #
  # Write the <font> element.
  #
  sub _write_font {
  
      my $self   = shift;
      my $format = shift;
  
      $self->{_rstring}->xml_start_tag( 'rPr' );
  
      $self->{_rstring}->xml_empty_tag( 'b' )       if $format->{_bold};
      $self->{_rstring}->xml_empty_tag( 'i' )       if $format->{_italic};
      $self->{_rstring}->xml_empty_tag( 'strike' )  if $format->{_font_strikeout};
      $self->{_rstring}->xml_empty_tag( 'outline' ) if $format->{_font_outline};
      $self->{_rstring}->xml_empty_tag( 'shadow' )  if $format->{_font_shadow};
  
      # Handle the underline variants.
      $self->_write_underline( $format->{_underline} ) if $format->{_underline};
  
      $self->_write_vert_align( 'superscript' ) if $format->{_font_script} == 1;
      $self->_write_vert_align( 'subscript' )   if $format->{_font_script} == 2;
  
      $self->{_rstring}->xml_empty_tag( 'sz', 'val', $format->{_size} );
  
      if ( my $theme = $format->{_theme} ) {
          $self->_write_rstring_color( 'theme' => $theme );
      }
      elsif ( my $color = $format->{_color} ) {
          $color = $self->_get_palette_color( $color );
  
          $self->_write_rstring_color( 'rgb' => $color );
      }
      else {
          $self->_write_rstring_color( 'theme' => 1 );
      }
  
      $self->{_rstring}->xml_empty_tag( 'rFont', 'val', $format->{_font} );
      $self->{_rstring}
        ->xml_empty_tag( 'family', 'val', $format->{_font_family} );
  
      if ( $format->{_font} eq 'Calibri' && !$format->{_hyperlink} ) {
          $self->{_rstring}
            ->xml_empty_tag( 'scheme', 'val', $format->{_font_scheme} );
      }
  
      $self->{_rstring}->xml_end_tag( 'rPr' );
  }
  
  
  ###############################################################################
  #
  # _write_underline()
  #
  # Write the underline font element.
  #
  sub _write_underline {
  
      my $self      = shift;
      my $underline = shift;
      my @attributes;
  
      # Handle the underline variants.
      if ( $underline == 2 ) {
          @attributes = ( val => 'double' );
      }
      elsif ( $underline == 33 ) {
          @attributes = ( val => 'singleAccounting' );
      }
      elsif ( $underline == 34 ) {
          @attributes = ( val => 'doubleAccounting' );
      }
      else {
          @attributes = ();    # Default to single underline.
      }
  
      $self->{_rstring}->xml_empty_tag( 'u', @attributes );
  
  }
  
  
  ##############################################################################
  #
  # _write_vert_align()
  #
  # Write the <vertAlign> font sub-element.
  #
  sub _write_vert_align {
  
      my $self = shift;
      my $val  = shift;
  
      my @attributes = ( 'val' => $val );
  
      $self->{_rstring}->xml_empty_tag( 'vertAlign', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_rstring_color()
  #
  # Write the <color> element.
  #
  sub _write_rstring_color {
  
      my $self  = shift;
      my $name  = shift;
      my $value = shift;
  
      my @attributes = ( $name => $value );
  
      $self->{_rstring}->xml_empty_tag( 'color', @attributes );
  }
  
  
  #
  # End font duplication code.
  #
  
  
  ##############################################################################
  #
  # _write_data_validations()
  #
  # Write the <dataValidations> element.
  #
  sub _write_data_validations {
  
      my $self        = shift;
      my @validations = @{ $self->{_validations} };
      my $count       = @validations;
  
      return unless $count;
  
      my @attributes = ( 'count' => $count );
  
      $self->xml_start_tag( 'dataValidations', @attributes );
  
      for my $validation ( @validations ) {
  
          # Write the dataValidation element.
          $self->_write_data_validation( $validation );
      }
  
      $self->xml_end_tag( 'dataValidations' );
  }
  
  
  ##############################################################################
  #
  # _write_data_validation()
  #
  # Write the <dataValidation> element.
  #
  sub _write_data_validation {
  
      my $self       = shift;
      my $param      = shift;
      my $sqref      = '';
      my @attributes = ();
  
  
      # Set the cell range(s) for the data validation.
      for my $cells ( @{ $param->{cells} } ) {
  
          # Add a space between multiple cell ranges.
          $sqref .= ' ' if $sqref ne '';
  
          my ( $row_first, $col_first, $row_last, $col_last ) = @$cells;
  
          # Swap last row/col for first row/col as necessary
          if ( $row_first > $row_last ) {
              ( $row_first, $row_last ) = ( $row_last, $row_first );
          }
  
          if ( $col_first > $col_last ) {
              ( $col_first, $col_last ) = ( $col_last, $col_first );
          }
  
          # If the first and last cell are the same write a single cell.
          if ( ( $row_first == $row_last ) && ( $col_first == $col_last ) ) {
              $sqref .= xl_rowcol_to_cell( $row_first, $col_first );
          }
          else {
              $sqref .= xl_range( $row_first, $row_last, $col_first, $col_last );
          }
      }
  
  
      if ( $param->{validate} ne 'none' ) {
  
          push @attributes, ( 'type' => $param->{validate} );
  
          if ( $param->{criteria} ne 'between' ) {
              push @attributes, ( 'operator' => $param->{criteria} );
          }
  
      }
  
      if ( $param->{error_type} ) {
          push @attributes, ( 'errorStyle' => 'warning' )
            if $param->{error_type} == 1;
          push @attributes, ( 'errorStyle' => 'information' )
            if $param->{error_type} == 2;
      }
  
      push @attributes, ( 'allowBlank'       => 1 ) if $param->{ignore_blank};
      push @attributes, ( 'showDropDown'     => 1 ) if !$param->{dropdown};
      push @attributes, ( 'showInputMessage' => 1 ) if $param->{show_input};
      push @attributes, ( 'showErrorMessage' => 1 ) if $param->{show_error};
  
      push @attributes, ( 'errorTitle' => $param->{error_title} )
        if $param->{error_title};
  
      push @attributes, ( 'error' => $param->{error_message} )
        if $param->{error_message};
  
      push @attributes, ( 'promptTitle' => $param->{input_title} )
        if $param->{input_title};
  
      push @attributes, ( 'prompt' => $param->{input_message} )
        if $param->{input_message};
  
      push @attributes, ( 'sqref' => $sqref );
  
      if ( $param->{validate} eq 'none' ) {
          $self->xml_empty_tag( 'dataValidation', @attributes );
      }
      else {
          $self->xml_start_tag( 'dataValidation', @attributes );
  
          # Write the formula1 element.
          $self->_write_formula_1( $param->{value} );
  
          # Write the formula2 element.
          $self->_write_formula_2( $param->{maximum} )
            if defined $param->{maximum};
  
          $self->xml_end_tag( 'dataValidation' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_formula_1()
  #
  # Write the <formula1> element.
  #
  sub _write_formula_1 {
  
      my $self    = shift;
      my $formula = shift;
  
      # Convert a list array ref into a comma separated string.
      if ( ref $formula eq 'ARRAY' ) {
          $formula = join ',', @$formula;
          $formula = qq("$formula");
      }
  
      $formula =~ s/^=//;    # Remove formula symbol.
  
      $self->xml_data_element( 'formula1', $formula );
  }
  
  
  ##############################################################################
  #
  # _write_formula_2()
  #
  # Write the <formula2> element.
  #
  sub _write_formula_2 {
  
      my $self    = shift;
      my $formula = shift;
  
      $formula =~ s/^=//;    # Remove formula symbol.
  
      $self->xml_data_element( 'formula2', $formula );
  }
  
  
  ##############################################################################
  #
  # _write_conditional_formats()
  #
  # Write the Worksheet conditional formats.
  #
  sub _write_conditional_formats {
  
      my $self   = shift;
      my @ranges = sort keys %{ $self->{_cond_formats} };
  
      return unless scalar @ranges;
  
      for my $range ( @ranges ) {
          $self->_write_conditional_formatting( $range,
              $self->{_cond_formats}->{$range} );
      }
  }
  
  
  ##############################################################################
  #
  # _write_conditional_formatting()
  #
  # Write the <conditionalFormatting> element.
  #
  sub _write_conditional_formatting {
  
      my $self   = shift;
      my $range  = shift;
      my $params = shift;
  
      my @attributes = ( 'sqref' => $range );
  
      $self->xml_start_tag( 'conditionalFormatting', @attributes );
  
      for my $param ( @$params ) {
  
          # Write the cfRule element.
          $self->_write_cf_rule( $param );
      }
  
      $self->xml_end_tag( 'conditionalFormatting' );
  }
  
  ##############################################################################
  #
  # _write_cf_rule()
  #
  # Write the <cfRule> element.
  #
  sub _write_cf_rule {
  
      my $self  = shift;
      my $param = shift;
  
      my @attributes = ( 'type' => $param->{type} );
  
      push @attributes, ( 'dxfId' => $param->{format} )
        if defined $param->{format};
  
      push @attributes, ( 'priority' => $param->{priority} );
  
      push @attributes, ( 'stopIfTrue' => 1 )
        if defined $param->{stop_if_true};
  
      if ( $param->{type} eq 'cellIs' ) {
          push @attributes, ( 'operator' => $param->{criteria} );
  
          $self->xml_start_tag( 'cfRule', @attributes );
  
          if ( defined $param->{minimum} && defined $param->{maximum} ) {
              $self->_write_formula( $param->{minimum} );
              $self->_write_formula( $param->{maximum} );
          }
          else {
              $self->_write_formula( $param->{value} );
          }
  
          $self->xml_end_tag( 'cfRule' );
      }
      elsif ( $param->{type} eq 'aboveAverage' ) {
          if ( $param->{criteria} =~ /below/ ) {
              push @attributes, ( 'aboveAverage' => 0 );
          }
  
          if ( $param->{criteria} =~ /equal/ ) {
              push @attributes, ( 'equalAverage' => 1 );
          }
  
          if ( $param->{criteria} =~ /([123]) std dev/ ) {
              push @attributes, ( 'stdDev' => $1 );
          }
  
          $self->xml_empty_tag( 'cfRule', @attributes );
      }
      elsif ( $param->{type} eq 'top10' ) {
          if ( defined $param->{criteria} && $param->{criteria} eq '%' ) {
              push @attributes, ( 'percent' => 1 );
          }
  
          if ( $param->{direction} ) {
              push @attributes, ( 'bottom' => 1 );
          }
  
          my $rank = $param->{value} || 10;
          push @attributes, ( 'rank' => $rank );
  
          $self->xml_empty_tag( 'cfRule', @attributes );
      }
      elsif ( $param->{type} eq 'duplicateValues' ) {
          $self->xml_empty_tag( 'cfRule', @attributes );
      }
      elsif ( $param->{type} eq 'uniqueValues' ) {
          $self->xml_empty_tag( 'cfRule', @attributes );
      }
      elsif ($param->{type} eq 'containsText'
          || $param->{type} eq 'notContainsText'
          || $param->{type} eq 'beginsWith'
          || $param->{type} eq 'endsWith' )
      {
          push @attributes, ( 'operator' => $param->{criteria} );
          push @attributes, ( 'text'     => $param->{value} );
  
          $self->xml_start_tag( 'cfRule', @attributes );
          $self->_write_formula( $param->{formula} );
          $self->xml_end_tag( 'cfRule' );
      }
      elsif ( $param->{type} eq 'timePeriod' ) {
          push @attributes, ( 'timePeriod' => $param->{criteria} );
  
          $self->xml_start_tag( 'cfRule', @attributes );
          $self->_write_formula( $param->{formula} );
          $self->xml_end_tag( 'cfRule' );
      }
      elsif ($param->{type} eq 'containsBlanks'
          || $param->{type} eq 'notContainsBlanks'
          || $param->{type} eq 'containsErrors'
          || $param->{type} eq 'notContainsErrors' )
      {
          $self->xml_start_tag( 'cfRule', @attributes );
          $self->_write_formula( $param->{formula} );
          $self->xml_end_tag( 'cfRule' );
      }
      elsif ( $param->{type} eq 'colorScale' ) {
  
          $self->xml_start_tag( 'cfRule', @attributes );
          $self->_write_color_scale( $param );
          $self->xml_end_tag( 'cfRule' );
      }
      elsif ( $param->{type} eq 'dataBar' ) {
  
          $self->xml_start_tag( 'cfRule', @attributes );
          $self->_write_data_bar( $param );
          $self->xml_end_tag( 'cfRule' );
      }
      elsif ( $param->{type} eq 'expression' ) {
  
          $self->xml_start_tag( 'cfRule', @attributes );
          $self->_write_formula( $param->{criteria} );
          $self->xml_end_tag( 'cfRule' );
      }
  }
  
  
  ##############################################################################
  #
  # _write_formula()
  #
  # Write the <formula> element.
  #
  sub _write_formula {
  
      my $self = shift;
      my $data = shift;
  
      # Remove equality from formula.
      $data =~ s/^=//;
  
      $self->xml_data_element( 'formula', $data );
  }
  
  
  ##############################################################################
  #
  # _write_color_scale()
  #
  # Write the <colorScale> element.
  #
  sub _write_color_scale {
  
      my $self  = shift;
      my $param = shift;
  
      $self->xml_start_tag( 'colorScale' );
  
      $self->_write_cfvo( $param->{min_type}, $param->{min_value} );
  
      if ( defined $param->{mid_type} ) {
          $self->_write_cfvo( $param->{mid_type}, $param->{mid_value} );
      }
  
      $self->_write_cfvo( $param->{max_type}, $param->{max_value} );
  
      $self->_write_color( 'rgb' => $param->{min_color} );
  
      if ( defined $param->{mid_color} ) {
          $self->_write_color( 'rgb' => $param->{mid_color} );
      }
  
      $self->_write_color( 'rgb' => $param->{max_color} );
  
      $self->xml_end_tag( 'colorScale' );
  }
  
  
  ##############################################################################
  #
  # _write_data_bar()
  #
  # Write the <dataBar> element.
  #
  sub _write_data_bar {
  
      my $self  = shift;
      my $param = shift;
  
      $self->xml_start_tag( 'dataBar' );
  
      $self->_write_cfvo( $param->{min_type}, $param->{min_value} );
      $self->_write_cfvo( $param->{max_type}, $param->{max_value} );
  
      $self->_write_color( 'rgb' => $param->{bar_color} );
  
      $self->xml_end_tag( 'dataBar' );
  }
  
  
  ##############################################################################
  #
  # _write_cfvo()
  #
  # Write the <cfvo> element.
  #
  sub _write_cfvo {
  
      my $self = shift;
      my $type = shift;
      my $val  = shift;
  
      my @attributes = (
          'type' => $type,
          'val'  => $val
      );
  
      $self->xml_empty_tag( 'cfvo', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_color()
  #
  # Write the <color> element.
  #
  sub _write_color {
  
      my $self  = shift;
      my $name  = shift;
      my $value = shift;
  
      my @attributes = ( $name => $value );
  
      $self->xml_empty_tag( 'color', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_table_parts()
  #
  # Write the <tableParts> element.
  #
  sub _write_table_parts {
  
      my $self   = shift;
      my @tables = @{ $self->{_tables} };
      my $count  = scalar @tables;
  
      # Return if worksheet doesn't contain any tables.
      return unless $count;
  
      my @attributes = ( 'count' => $count, );
  
      $self->xml_start_tag( 'tableParts', @attributes );
  
      for my $table ( @tables ) {
  
          # Write the tablePart element.
          $self->_write_table_part( ++$self->{_rel_count} );
  
      }
  
      $self->xml_end_tag( 'tableParts' );
  }
  
  
  ##############################################################################
  #
  # _write_table_part()
  #
  # Write the <tablePart> element.
  #
  sub _write_table_part {
  
      my $self = shift;
      my $id   = shift;
      my $r_id = 'rId' . $id;
  
      my @attributes = ( 'r:id' => $r_id, );
  
      $self->xml_empty_tag( 'tablePart', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_ext_sparklines()
  #
  # Write the <extLst> element and sparkline subelements.
  #
  sub _write_ext_sparklines {
  
      my $self       = shift;
      my @sparklines = @{ $self->{_sparklines} };
      my $count      = scalar @sparklines;
  
      # Return if worksheet doesn't contain any sparklines.
      return unless $count;
  
  
      # Write the extLst element.
      $self->xml_start_tag( 'extLst' );
  
      # Write the ext element.
      $self->_write_ext();
  
      # Write the x14:sparklineGroups element.
      $self->_write_sparkline_groups();
  
      # Write the sparkline elements.
      for my $sparkline ( reverse @sparklines ) {
  
          # Write the x14:sparklineGroup element.
          $self->_write_sparkline_group( $sparkline );
  
          # Write the x14:colorSeries element.
          $self->_write_color_series( $sparkline->{_series_color} );
  
          # Write the x14:colorNegative element.
          $self->_write_color_negative( $sparkline->{_negative_color} );
  
          # Write the x14:colorAxis element.
          $self->_write_color_axis();
  
          # Write the x14:colorMarkers element.
          $self->_write_color_markers( $sparkline->{_markers_color} );
  
          # Write the x14:colorFirst element.
          $self->_write_color_first( $sparkline->{_first_color} );
  
          # Write the x14:colorLast element.
          $self->_write_color_last( $sparkline->{_last_color} );
  
          # Write the x14:colorHigh element.
          $self->_write_color_high( $sparkline->{_high_color} );
  
          # Write the x14:colorLow element.
          $self->_write_color_low( $sparkline->{_low_color} );
  
          if ( $sparkline->{_date_axis} ) {
              $self->xml_data_element( 'xm:f', $sparkline->{_date_axis} );
          }
  
          $self->_write_sparklines( $sparkline );
  
          $self->xml_end_tag( 'x14:sparklineGroup' );
      }
  
  
      $self->xml_end_tag( 'x14:sparklineGroups' );
      $self->xml_end_tag( 'ext' );
      $self->xml_end_tag( 'extLst' );
  }
  
  
  ##############################################################################
  #
  # _write_sparklines()
  #
  # Write the <x14:sparklines> element and <x14:sparkline> subelements.
  #
  sub _write_sparklines {
  
      my $self      = shift;
      my $sparkline = shift;
  
      # Write the sparkline elements.
      $self->xml_start_tag( 'x14:sparklines' );
  
      for my $i ( 0 .. $sparkline->{_count} - 1 ) {
          my $range    = $sparkline->{_ranges}->[$i];
          my $location = $sparkline->{_locations}->[$i];
  
          $self->xml_start_tag( 'x14:sparkline' );
          $self->xml_data_element( 'xm:f',     $range );
          $self->xml_data_element( 'xm:sqref', $location );
          $self->xml_end_tag( 'x14:sparkline' );
      }
  
  
      $self->xml_end_tag( 'x14:sparklines' );
  }
  
  
  ##############################################################################
  #
  # _write_ext()
  #
  # Write the <ext> element.
  #
  sub _write_ext {
  
      my $self       = shift;
      my $schema     = 'http://schemas.microsoft.com/office/';
      my $xmlns_x_14 = $schema . 'spreadsheetml/2009/9/main';
      my $uri        = '{05C60535-1F16-4fd2-B633-F4F36F0B64E0}';
  
      my @attributes = (
          'xmlns:x14' => $xmlns_x_14,
          'uri'       => $uri,
      );
  
      $self->xml_start_tag( 'ext', @attributes );
  }
  
  
  ##############################################################################
  #
  # _write_sparkline_groups()
  #
  # Write the <x14:sparklineGroups> element.
  #
  sub _write_sparkline_groups {
  
      my $self     = shift;
      my $xmlns_xm = 'http://schemas.microsoft.com/office/excel/2006/main';
  
      my @attributes = ( 'xmlns:xm' => $xmlns_xm );
  
      $self->xml_start_tag( 'x14:sparklineGroups', @attributes );
  
  }
  
  
  ##############################################################################
  #
  # _write_sparkline_group()
  #
  # Write the <x14:sparklineGroup> element.
  #
  # Example for order.
  #
  # <x14:sparklineGroup
  #     manualMax="0"
  #     manualMin="0"
  #     lineWeight="2.25"
  #     type="column"
  #     dateAxis="1"
  #     displayEmptyCellsAs="span"
  #     markers="1"
  #     high="1"
  #     low="1"
  #     first="1"
  #     last="1"
  #     negative="1"
  #     displayXAxis="1"
  #     displayHidden="1"
  #     minAxisType="custom"
  #     maxAxisType="custom"
  #     rightToLeft="1">
  #
  sub _write_sparkline_group {
  
      my $self     = shift;
      my $opts     = shift;
      my $empty    = $opts->{_empty};
      my $user_max = 0;
      my $user_min = 0;
      my @a;
  
      if ( defined $opts->{_max} ) {
  
          if ( $opts->{_max} eq 'group' ) {
              $opts->{_cust_max} = 'group';
          }
          else {
              push @a, ( 'manualMax' => $opts->{_max} );
              $opts->{_cust_max} = 'custom';
          }
      }
  
      if ( defined $opts->{_min} ) {
  
          if ( $opts->{_min} eq 'group' ) {
              $opts->{_cust_min} = 'group';
          }
          else {
              push @a, ( 'manualMin' => $opts->{_min} );
              $opts->{_cust_min} = 'custom';
          }
      }
  
  
      # Ignore the default type attribute (line).
      if ( $opts->{_type} ne 'line' ) {
          push @a, ( 'type' => $opts->{_type} );
      }
  
      push @a, ( 'lineWeight' => $opts->{_weight} ) if $opts->{_weight};
      push @a, ( 'dateAxis' => 1 ) if $opts->{_date_axis};
      push @a, ( 'displayEmptyCellsAs' => $empty ) if $empty;
  
      push @a, ( 'markers'       => 1 )                  if $opts->{_markers};
      push @a, ( 'high'          => 1 )                  if $opts->{_high};
      push @a, ( 'low'           => 1 )                  if $opts->{_low};
      push @a, ( 'first'         => 1 )                  if $opts->{_first};
      push @a, ( 'last'          => 1 )                  if $opts->{_last};
      push @a, ( 'negative'      => 1 )                  if $opts->{_negative};
      push @a, ( 'displayXAxis'  => 1 )                  if $opts->{_axis};
      push @a, ( 'displayHidden' => 1 )                  if $opts->{_hidden};
      push @a, ( 'minAxisType'   => $opts->{_cust_min} ) if $opts->{_cust_min};
      push @a, ( 'maxAxisType'   => $opts->{_cust_max} ) if $opts->{_cust_max};
      push @a, ( 'rightToLeft'   => 1 )                  if $opts->{_reverse};
  
      $self->xml_start_tag( 'x14:sparklineGroup', @a );
  }
  
  
  ##############################################################################
  #
  # _write_spark_color()
  #
  # Helper function for the sparkline color functions below.
  #
  sub _write_spark_color {
  
      my $self    = shift;
      my $element = shift;
      my $color   = shift;
      my @attr;
  
      push @attr, ( 'rgb'   => $color->{_rgb} )   if defined $color->{_rgb};
      push @attr, ( 'theme' => $color->{_theme} ) if defined $color->{_theme};
      push @attr, ( 'tint'  => $color->{_tint} )  if defined $color->{_tint};
  
      $self->xml_empty_tag( $element, @attr );
  }
  
  
  ##############################################################################
  #
  # _write_color_series()
  #
  # Write the <x14:colorSeries> element.
  #
  sub _write_color_series {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorSeries', @_ );
  }
  
  
  ##############################################################################
  #
  # _write_color_negative()
  #
  # Write the <x14:colorNegative> element.
  #
  sub _write_color_negative {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorNegative', @_ );
  }
  
  
  ##############################################################################
  #
  # _write_color_axis()
  #
  # Write the <x14:colorAxis> element.
  #
  sub _write_color_axis {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorAxis', { _rgb => 'FF000000' } );
  }
  
  
  ##############################################################################
  #
  # _write_color_markers()
  #
  # Write the <x14:colorMarkers> element.
  #
  sub _write_color_markers {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorMarkers', @_ );
  }
  
  
  ##############################################################################
  #
  # _write_color_first()
  #
  # Write the <x14:colorFirst> element.
  #
  sub _write_color_first {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorFirst', @_ );
  }
  
  
  ##############################################################################
  #
  # _write_color_last()
  #
  # Write the <x14:colorLast> element.
  #
  sub _write_color_last {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorLast', @_ );
  }
  
  
  ##############################################################################
  #
  # _write_color_high()
  #
  # Write the <x14:colorHigh> element.
  #
  sub _write_color_high {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorHigh', @_ );
  }
  
  
  ##############################################################################
  #
  # _write_color_low()
  #
  # Write the <x14:colorLow> element.
  #
  sub _write_color_low {
  
      my $self = shift;
  
      $self->_write_spark_color( 'x14:colorLow', @_ );
  }
  
  
  1;
  
  
  __END__
  
  
  =head1 NAME
  
  Worksheet - A class for writing Excel Worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Excel::Writer::XLSX>
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with L<Excel::Writer::XLSX>.
  
  =head1 AUTHOR
  
  John McNamara jmcnamara@cpan.org
  
  =head1 COPYRIGHT
  
  (c) MM-MMXVI, John McNamara.
  
  All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
EXCEL_WRITER_XLSX_WORKSHEET

$fatpacked{"OLE/Storage_Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OLE_STORAGE_LITE';
  # OLE::Storage_Lite
  #  by Kawai, Takanori (Hippo2000) 2000.11.4, 8, 14
  # This Program is Still ALPHA version.
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS Object
  #//////////////////////////////////////////////////////////////////////////////
  #==============================================================================
  # OLE::Storage_Lite::PPS
  #==============================================================================
  package OLE::Storage_Lite::PPS;
  require Exporter;
  use strict;
  use vars qw($VERSION @ISA);
  @ISA = qw(Exporter);
  $VERSION = '0.19';
  
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub new ($$$$$$$$$$;$$) {
  #1. Constructor for General Usage
    my($sClass, $iNo, $sNm, $iType, $iPrev, $iNext, $iDir,
       $raTime1st, $raTime2nd, $iStart, $iSize, $sData, $raChild) = @_;
  
    if($iType == OLE::Storage_Lite::PpsType_File()) { #FILE
      return OLE::Storage_Lite::PPS::File->_new
          ($iNo, $sNm, $iType, $iPrev, $iNext, $iDir, $raTime1st, $raTime2nd,
           $iStart, $iSize, $sData, $raChild);
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Dir()) { #DIRECTRY
      return OLE::Storage_Lite::PPS::Dir->_new
          ($iNo, $sNm, $iType, $iPrev, $iNext, $iDir, $raTime1st, $raTime2nd,
           $iStart, $iSize, $sData, $raChild);
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Root()) { #ROOT
      return OLE::Storage_Lite::PPS::Root->_new
          ($iNo, $sNm, $iType, $iPrev, $iNext, $iDir, $raTime1st, $raTime2nd,
           $iStart, $iSize, $sData, $raChild);
    }
    else {
      die "Error PPS:$iType $sNm\n";
    }
  }
  #------------------------------------------------------------------------------
  # _new (OLE::Storage_Lite::PPS)
  #   for OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _new ($$$$$$$$$$$;$$) {
    my($sClass, $iNo, $sNm, $iType, $iPrev, $iNext, $iDir,
          $raTime1st, $raTime2nd, $iStart, $iSize, $sData, $raChild) = @_;
  #1. Constructor for OLE::Storage_Lite
    my $oThis = {
      No   => $iNo,
      Name => $sNm,
      Type => $iType,
      PrevPps => $iPrev,
      NextPps => $iNext,
      DirPps => $iDir,
      Time1st => $raTime1st,
      Time2nd => $raTime2nd,
      StartBlock => $iStart,
      Size       => $iSize,
      Data       => $sData,
      Child      => $raChild,
    };
    bless $oThis, $sClass;
    return $oThis;
  }
  #------------------------------------------------------------------------------
  # _DataLen (OLE::Storage_Lite::PPS)
  # Check for update
  #------------------------------------------------------------------------------
  sub _DataLen($) {
      my($oSelf) =@_;
      return 0 unless(defined($oSelf->{Data}));
      return ($oSelf->{_PPS_FILE})?
          ($oSelf->{_PPS_FILE}->stat())[7] : length($oSelf->{Data});
  }
  #------------------------------------------------------------------------------
  # _makeSmallData (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _makeSmallData($$$) {
    my($oThis, $aList, $rhInfo) = @_;
    my ($sRes);
    my $FILE = $rhInfo->{_FILEH_};
    my $iSmBlk = 0;
  
    foreach my $oPps (@$aList) {
  #1. Make SBD, small data string
    if($oPps->{Type}==OLE::Storage_Lite::PpsType_File()) {
      next if($oPps->{Size}<=0);
      if($oPps->{Size} < $rhInfo->{_SMALL_SIZE}) {
        my $iSmbCnt = int($oPps->{Size} / $rhInfo->{_SMALL_BLOCK_SIZE})
                      + (($oPps->{Size} % $rhInfo->{_SMALL_BLOCK_SIZE})? 1: 0);
        #1.1 Add to SBD
        for (my $i = 0; $i<($iSmbCnt-1); $i++) {
              print {$FILE} (pack("V", $i+$iSmBlk+1));
        }
        print {$FILE} (pack("V", -2));
  
        #1.2 Add to Data String(this will be written for RootEntry)
        #Check for update
        if($oPps->{_PPS_FILE}) {
          my $sBuff;
          $oPps->{_PPS_FILE}->seek(0, 0); #To The Top
          while($oPps->{_PPS_FILE}->read($sBuff, 4096)) {
              $sRes .= $sBuff;
          }
        }
        else {
          $sRes .= $oPps->{Data};
        }
        $sRes .= ("\x00" x
          ($rhInfo->{_SMALL_BLOCK_SIZE} - ($oPps->{Size}% $rhInfo->{_SMALL_BLOCK_SIZE})))
          if($oPps->{Size}% $rhInfo->{_SMALL_BLOCK_SIZE});
        #1.3 Set for PPS
        $oPps->{StartBlock} = $iSmBlk;
        $iSmBlk += $iSmbCnt;
      }
    }
    }
    my $iSbCnt = int($rhInfo->{_BIG_BLOCK_SIZE}/ OLE::Storage_Lite::LongIntSize());
    print {$FILE} (pack("V", -1) x ($iSbCnt - ($iSmBlk % $iSbCnt)))
      if($iSmBlk  % $iSbCnt);
  #2. Write SBD with adjusting length for block
    return $sRes;
  }
  #------------------------------------------------------------------------------
  # _savePpsWk (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _savePpsWk($$)
  {
    my($oThis, $rhInfo) = @_;
  #1. Write PPS
    my $FILE = $rhInfo->{_FILEH_};
    print {$FILE} (
              $oThis->{Name}
              . ("\x00" x (64 - length($oThis->{Name})))  #64
              , pack("v", length($oThis->{Name}) + 2)     #66
              , pack("c", $oThis->{Type})         #67
              , pack("c", 0x00) #UK               #68
              , pack("V", $oThis->{PrevPps}) #Prev        #72
              , pack("V", $oThis->{NextPps}) #Next        #76
              , pack("V", $oThis->{DirPps})  #Dir     #80
              , "\x00\x09\x02\x00"                #84
              , "\x00\x00\x00\x00"                #88
              , "\xc0\x00\x00\x00"                #92
              , "\x00\x00\x00\x46"                #96
              , "\x00\x00\x00\x00"                #100
              , OLE::Storage_Lite::LocalDate2OLE($oThis->{Time1st})       #108
              , OLE::Storage_Lite::LocalDate2OLE($oThis->{Time2nd})       #116
              , pack("V", defined($oThis->{StartBlock})?
                        $oThis->{StartBlock}:0)       #116
              , pack("V", defined($oThis->{Size})?
                   $oThis->{Size} : 0)            #124
              , pack("V", 0),                  #128
          );
  }
  
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS::Root Object
  #//////////////////////////////////////////////////////////////////////////////
  #==============================================================================
  # OLE::Storage_Lite::PPS::Root
  #==============================================================================
  package OLE::Storage_Lite::PPS::Root;
  require Exporter;
  use strict;
  use IO::File;
  use IO::Handle;
  use Fcntl;
  use vars qw($VERSION @ISA);
  @ISA = qw(OLE::Storage_Lite::PPS Exporter);
  $VERSION = '0.19';
  sub _savePpsSetPnt($$$);
  sub _savePpsSetPnt2($$$);
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub new ($;$$$) {
      my($sClass, $raTime1st, $raTime2nd, $raChild) = @_;
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          OLE::Storage_Lite::Asc2Ucs('Root Entry'),
          5,
          undef,
          undef,
          undef,
          $raTime1st,
          $raTime2nd,
          undef,
          undef,
          undef,
          $raChild);
  }
  #------------------------------------------------------------------------------
  # save (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub save($$;$$) {
    my($oThis, $sFile, $bNoAs, $rhInfo) = @_;
    #0.Initial Setting for saving
    $rhInfo = {} unless($rhInfo);
    $rhInfo->{_BIG_BLOCK_SIZE}  = 2**
                  (($rhInfo->{_BIG_BLOCK_SIZE})?
                      _adjust2($rhInfo->{_BIG_BLOCK_SIZE})  : 9);
    $rhInfo->{_SMALL_BLOCK_SIZE}= 2 **
                  (($rhInfo->{_SMALL_BLOCK_SIZE})?
                      _adjust2($rhInfo->{_SMALL_BLOCK_SIZE}): 6);
    $rhInfo->{_SMALL_SIZE} = 0x1000;
    $rhInfo->{_PPS_SIZE} = 0x80;
  
    my $closeFile = 1;
  
    #1.Open File
    #1.1 $sFile is Ref of scalar
    if(ref($sFile) eq 'SCALAR') {
      require IO::Scalar;
      my $oIo = new IO::Scalar $sFile, O_WRONLY;
      $rhInfo->{_FILEH_} = $oIo;
    }
    #1.1.1 $sFile is a IO::Scalar object
    # Now handled as a filehandle ref below.
  
    #1.2 $sFile is a IO::Handle object
    elsif(UNIVERSAL::isa($sFile, 'IO::Handle')) {
      # Not all filehandles support binmode() so try it in an eval.
      eval{ binmode $sFile };
      $rhInfo->{_FILEH_} = $sFile;
    }
    #1.3 $sFile is a simple filename string
    elsif(!ref($sFile)) {
      if($sFile ne '-') {
          my $oIo = new IO::File;
          $oIo->open(">$sFile") || return undef;
          binmode($oIo);
          $rhInfo->{_FILEH_} = $oIo;
      }
      else {
          my $oIo = new IO::Handle;
          $oIo->fdopen(fileno(STDOUT),"w") || return undef;
          binmode($oIo);
          $rhInfo->{_FILEH_} = $oIo;
      }
    }
    #1.4 Assume that if $sFile is a ref then it is a valid filehandle
    else {
      # Not all filehandles support binmode() so try it in an eval.
      eval{ binmode $sFile };
      $rhInfo->{_FILEH_} = $sFile;
      # Caller controls filehandle closing
      $closeFile = 0;
    }
  
    my $iBlk = 0;
    #1. Make an array of PPS (for Save)
    my @aList=();
    if($bNoAs) {
      _savePpsSetPnt2([$oThis], \@aList, $rhInfo);
    }
    else {
      _savePpsSetPnt([$oThis], \@aList, $rhInfo);
    }
    my ($iSBDcnt, $iBBcnt, $iPPScnt) = $oThis->_calcSize(\@aList, $rhInfo);
  
    #2.Save Header
    $oThis->_saveHeader($rhInfo, $iSBDcnt, $iBBcnt, $iPPScnt);
  
    #3.Make Small Data string (write SBD)
    my $sSmWk = $oThis->_makeSmallData(\@aList, $rhInfo);
    $oThis->{Data} = $sSmWk;  #Small Datas become RootEntry Data
  
    #4. Write BB
    my $iBBlk = $iSBDcnt;
    $oThis->_saveBigData(\$iBBlk, \@aList, $rhInfo);
  
    #5. Write PPS
    $oThis->_savePps(\@aList, $rhInfo);
  
    #6. Write BD and BDList and Adding Header informations
    $oThis->_saveBbd($iSBDcnt, $iBBcnt, $iPPScnt,  $rhInfo);
  
    #7.Close File
    return $rhInfo->{_FILEH_}->close if $closeFile;
  }
  #------------------------------------------------------------------------------
  # _calcSize (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _calcSize($$)
  {
    my($oThis, $raList, $rhInfo) = @_;
  
  #0. Calculate Basic Setting
    my ($iSBDcnt, $iBBcnt, $iPPScnt) = (0,0,0);
    my $iSmallLen = 0;
    my $iSBcnt = 0;
    foreach my $oPps (@$raList) {
        if($oPps->{Type}==OLE::Storage_Lite::PpsType_File()) {
          $oPps->{Size} = $oPps->_DataLen();  #Mod
          if($oPps->{Size} < $rhInfo->{_SMALL_SIZE}) {
            $iSBcnt += int($oPps->{Size} / $rhInfo->{_SMALL_BLOCK_SIZE})
                            + (($oPps->{Size} % $rhInfo->{_SMALL_BLOCK_SIZE})? 1: 0);
          }
          else {
            $iBBcnt +=
              (int($oPps->{Size}/ $rhInfo->{_BIG_BLOCK_SIZE}) +
                  (($oPps->{Size}% $rhInfo->{_BIG_BLOCK_SIZE})? 1: 0));
          }
        }
    }
    $iSmallLen = $iSBcnt * $rhInfo->{_SMALL_BLOCK_SIZE};
    my $iSlCnt = int($rhInfo->{_BIG_BLOCK_SIZE}/ OLE::Storage_Lite::LongIntSize());
    $iSBDcnt = int($iSBcnt / $iSlCnt)+ (($iSBcnt % $iSlCnt)? 1:0);
    $iBBcnt +=  (int($iSmallLen/ $rhInfo->{_BIG_BLOCK_SIZE}) +
                  (( $iSmallLen% $rhInfo->{_BIG_BLOCK_SIZE})? 1: 0));
    my $iCnt = scalar(@$raList);
    my $iBdCnt = $rhInfo->{_BIG_BLOCK_SIZE}/OLE::Storage_Lite::PpsSize();
    $iPPScnt = (int($iCnt/$iBdCnt) + (($iCnt % $iBdCnt)? 1: 0));
    return ($iSBDcnt, $iBBcnt, $iPPScnt);
  }
  #------------------------------------------------------------------------------
  # _adjust2 (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _adjust2($) {
    my($i2) = @_;
    my $iWk;
    $iWk = log($i2)/log(2);
    return ($iWk > int($iWk))? int($iWk)+1:$iWk;
  }
  #------------------------------------------------------------------------------
  # _saveHeader (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _saveHeader($$$$$) {
    my($oThis, $rhInfo, $iSBDcnt, $iBBcnt, $iPPScnt) = @_;
    my $FILE = $rhInfo->{_FILEH_};
  
  #0. Calculate Basic Setting
    my $iBlCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize();
    my $i1stBdL = int(($rhInfo->{_BIG_BLOCK_SIZE} - 0x4C) / OLE::Storage_Lite::LongIntSize());
    my $i1stBdMax = $i1stBdL * $iBlCnt  - $i1stBdL;
    my $iBdExL = 0;
    my $iAll = $iBBcnt + $iPPScnt + $iSBDcnt;
    my $iAllW = $iAll;
    my $iBdCntW = int($iAllW / $iBlCnt) + (($iAllW % $iBlCnt)? 1: 0);
    my $iBdCnt = int(($iAll + $iBdCntW) / $iBlCnt) + ((($iAllW+$iBdCntW) % $iBlCnt)? 1: 0);
    my $i;
  
    if ($iBdCnt > $i1stBdL) {
      #0.1 Calculate BD count
      $iBlCnt--; #the BlCnt is reduced in the count of the last sect is used for a pointer the next Bl
      my $iBBleftover = $iAll - $i1stBdMax;
  
      if ($iAll >$i1stBdMax) {
        while(1) {
          $iBdCnt = int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0);
          $iBdExL = int(($iBdCnt) / $iBlCnt) + ((($iBdCnt) % $iBlCnt)? 1: 0);
          $iBBleftover = $iBBleftover + $iBdExL;
          last if($iBdCnt == (int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0)));
        }
      }
      $iBdCnt += $i1stBdL;
      #print "iBdCnt = $iBdCnt \n";
    }
  #1.Save Header
    print {$FILE} (
              "\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1"
              , "\x00\x00\x00\x00" x 4
              , pack("v", 0x3b)
              , pack("v", 0x03)
              , pack("v", -2)
              , pack("v", 9)
              , pack("v", 6)
              , pack("v", 0)
              , "\x00\x00\x00\x00" x 2
              , pack("V", $iBdCnt),
              , pack("V", $iBBcnt+$iSBDcnt), #ROOT START
              , pack("V", 0)
              , pack("V", 0x1000)
              , pack("V", $iSBDcnt ? 0 : -2)                  #Small Block Depot
              , pack("V", $iSBDcnt)
      );
  #2. Extra BDList Start, Count
    if($iAll <= $i1stBdMax) {
      print {$FILE} (
                  pack("V", -2),      #Extra BDList Start
                  pack("V", 0),       #Extra BDList Count
          );
    }
    else {
      print {$FILE} (
              pack("V", $iAll+$iBdCnt),
              pack("V", $iBdExL),
          );
    }
  
  #3. BDList
      for($i=0; $i<$i1stBdL and $i < $iBdCnt; $i++) {
          print {$FILE} (pack("V", $iAll+$i));
      }
      print {$FILE} ((pack("V", -1)) x($i1stBdL-$i)) if($i<$i1stBdL);
  }
  #------------------------------------------------------------------------------
  # _saveBigData (OLE::Storage_Lite::PPS)
  #------------------------------------------------------------------------------
  sub _saveBigData($$$$) {
    my($oThis, $iStBlk, $raList, $rhInfo) = @_;
    my $iRes = 0;
    my $FILE = $rhInfo->{_FILEH_};
  
  #1.Write Big (ge 0x1000) Data into Block
    foreach my $oPps (@$raList) {
      if($oPps->{Type}!=OLE::Storage_Lite::PpsType_Dir()) {
  #print "PPS: $oPps DEF:", defined($oPps->{Data}), "\n";
          $oPps->{Size} = $oPps->_DataLen();  #Mod
          if(($oPps->{Size} >= $rhInfo->{_SMALL_SIZE}) ||
              (($oPps->{Type} == OLE::Storage_Lite::PpsType_Root()) && defined($oPps->{Data}))) {
              #1.1 Write Data
              #Check for update
              if($oPps->{_PPS_FILE}) {
                  my $sBuff;
                  my $iLen = 0;
                  $oPps->{_PPS_FILE}->seek(0, 0); #To The Top
                  while($oPps->{_PPS_FILE}->read($sBuff, 4096)) {
                      $iLen += length($sBuff);
                      print {$FILE} ($sBuff);           #Check for update
                  }
              }
              else {
                  print {$FILE} ($oPps->{Data});
              }
              print {$FILE} (
                          "\x00" x
                          ($rhInfo->{_BIG_BLOCK_SIZE} -
                              ($oPps->{Size} % $rhInfo->{_BIG_BLOCK_SIZE}))
                      ) if ($oPps->{Size} % $rhInfo->{_BIG_BLOCK_SIZE});
              #1.2 Set For PPS
              $oPps->{StartBlock} = $$iStBlk;
              $$iStBlk +=
                      (int($oPps->{Size}/ $rhInfo->{_BIG_BLOCK_SIZE}) +
                          (($oPps->{Size}% $rhInfo->{_BIG_BLOCK_SIZE})? 1: 0));
          }
      }
    }
  }
  #------------------------------------------------------------------------------
  # _savePps (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _savePps($$$)
  {
    my($oThis, $raList, $rhInfo) = @_;
  #0. Initial
    my $FILE = $rhInfo->{_FILEH_};
  #2. Save PPS
    foreach my $oItem (@$raList) {
        $oItem->_savePpsWk($rhInfo);
    }
  #3. Adjust for Block
    my $iCnt = scalar(@$raList);
    my $iBCnt = $rhInfo->{_BIG_BLOCK_SIZE} / $rhInfo->{_PPS_SIZE};
    print {$FILE} ("\x00" x (($iBCnt - ($iCnt % $iBCnt)) * $rhInfo->{_PPS_SIZE}))
          if($iCnt % $iBCnt);
    return int($iCnt / $iBCnt) + (($iCnt % $iBCnt)? 1: 0);
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt2 (OLE::Storage_Lite::PPS::Root)
  #  For Test
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt2($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt2($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = 0; #int($iCnt/ 2);     #$iCnt
  
        my @aWk = @$aThis;
        my @aPrev = ($#$aThis > 1)? splice(@aWk, 1, 1) : (); #$iPos);
        my @aNext = splice(@aWk, 1); #, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt2(
              \@aPrev, $raList, $rhInfo);
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
  
  #1.3.2 Devide a array into Previous,Next
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt2(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt2($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt2 (OLE::Storage_Lite::PPS::Root)
  #  For Test
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt2s($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt2($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = 0; #int($iCnt/ 2);     #$iCnt
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
        my @aWk = @$aThis;
  #1.3.2 Devide a array into Previous,Next
        my @aPrev = splice(@aWk, 0, $iPos);
        my @aNext = splice(@aWk, 1, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt2(
              \@aPrev, $raList, $rhInfo);
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt2(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt2($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = int($iCnt/ 2);     #$iCnt
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
        my @aWk = @$aThis;
  #1.3.2 Devide a array into Previous,Next
        my @aPrev = splice(@aWk, 0, $iPos);
        my @aNext = splice(@aWk, 1, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt(
              \@aPrev, $raList, $rhInfo);
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _savePpsSetPnt (OLE::Storage_Lite::PPS::Root)
  #------------------------------------------------------------------------------
  sub _savePpsSetPnt1($$$)
  {
    my($aThis, $raList, $rhInfo) = @_;
  #1. make Array as Children-Relations
  #1.1 if No Children
    if($#$aThis < 0) {
        return 0xFFFFFFFF;
    }
    elsif($#$aThis == 0) {
  #1.2 Just Only one
        push @$raList, $aThis->[0];
        $aThis->[0]->{No} = $#$raList;
        $aThis->[0]->{PrevPps} = 0xFFFFFFFF;
        $aThis->[0]->{NextPps} = 0xFFFFFFFF;
        $aThis->[0]->{DirPps} = _savePpsSetPnt($aThis->[0]->{Child}, $raList, $rhInfo);
        return $aThis->[0]->{No};
    }
    else {
  #1.3 Array
        my $iCnt = $#$aThis + 1;
  #1.3.1 Define Center
        my $iPos = int($iCnt/ 2);     #$iCnt
        push @$raList, $aThis->[$iPos];
        $aThis->[$iPos]->{No} = $#$raList;
        my @aWk = @$aThis;
  #1.3.2 Devide a array into Previous,Next
        my @aPrev = splice(@aWk, 0, $iPos);
        my @aNext = splice(@aWk, 1, $iCnt - $iPos -1);
        $aThis->[$iPos]->{PrevPps} = _savePpsSetPnt(
              \@aPrev, $raList, $rhInfo);
        $aThis->[$iPos]->{NextPps} = _savePpsSetPnt(
              \@aNext, $raList, $rhInfo);
        $aThis->[$iPos]->{DirPps} = _savePpsSetPnt($aThis->[$iPos]->{Child}, $raList, $rhInfo);
        return $aThis->[$iPos]->{No};
    }
  }
  #------------------------------------------------------------------------------
  # _saveBbd (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _saveBbd($$$$)
  {
    my($oThis, $iSbdSize, $iBsize, $iPpsCnt, $rhInfo) = @_;
    my $FILE = $rhInfo->{_FILEH_};
  #0. Calculate Basic Setting
    my $iBbCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize();
    my $iBlCnt = $iBbCnt - 1;
    my $i1stBdL = int(($rhInfo->{_BIG_BLOCK_SIZE} - 0x4C) / OLE::Storage_Lite::LongIntSize());
    my $i1stBdMax = $i1stBdL * $iBbCnt  - $i1stBdL;
    my $iBdExL = 0;
    my $iAll = $iBsize + $iPpsCnt + $iSbdSize;
    my $iAllW = $iAll;
    my $iBdCntW = int($iAllW / $iBbCnt) + (($iAllW % $iBbCnt)? 1: 0);
    my $iBdCnt = 0;
    my $i;
  #0.1 Calculate BD count
    my $iBBleftover = $iAll - $i1stBdMax;
    if ($iAll >$i1stBdMax) {
  
      while(1) {
        $iBdCnt = int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0);
        $iBdExL = int(($iBdCnt) / $iBlCnt) + ((($iBdCnt) % $iBlCnt)? 1: 0);
        $iBBleftover = $iBBleftover + $iBdExL;
        last if($iBdCnt == (int(($iBBleftover) / $iBlCnt) + ((($iBBleftover) % $iBlCnt)? 1: 0)));
      }
    }
    $iAllW += $iBdExL;
    $iBdCnt += $i1stBdL;
    #print "iBdCnt = $iBdCnt \n";
  
  #1. Making BD
  #1.1 Set for SBD
    if($iSbdSize > 0) {
      for ($i = 0; $i<($iSbdSize-1); $i++) {
        print {$FILE} (pack("V", $i+1));
      }
      print {$FILE} (pack("V", -2));
    }
  #1.2 Set for B
    for ($i = 0; $i<($iBsize-1); $i++) {
        print {$FILE} (pack("V", $i+$iSbdSize+1));
    }
    print {$FILE} (pack("V", -2));
  
  #1.3 Set for PPS
    for ($i = 0; $i<($iPpsCnt-1); $i++) {
        print {$FILE} (pack("V", $i+$iSbdSize+$iBsize+1));
    }
    print {$FILE} (pack("V", -2));
  #1.4 Set for BBD itself ( 0xFFFFFFFD : BBD)
    for($i=0; $i<$iBdCnt;$i++) {
      print {$FILE} (pack("V", 0xFFFFFFFD));
    }
  #1.5 Set for ExtraBDList
    for($i=0; $i<$iBdExL;$i++) {
      print {$FILE} (pack("V", 0xFFFFFFFC));
    }
  #1.6 Adjust for Block
    print {$FILE} (pack("V", -1) x ($iBbCnt - (($iAllW + $iBdCnt) % $iBbCnt)))
                  if(($iAllW + $iBdCnt) % $iBbCnt);
  #2.Extra BDList
    if($iBdCnt > $i1stBdL)  {
      my $iN=0;
      my $iNb=0;
      for($i=$i1stBdL;$i<$iBdCnt; $i++, $iN++) {
        if($iN>=($iBbCnt-1)) {
            $iN = 0;
            $iNb++;
            print {$FILE} (pack("V", $iAll+$iBdCnt+$iNb));
        }
        print {$FILE} (pack("V", $iBsize+$iSbdSize+$iPpsCnt+$i));
      }
      print {$FILE} (pack("V", -1) x (($iBbCnt-1) - (($iBdCnt-$i1stBdL) % ($iBbCnt-1))))
          if(($iBdCnt-$i1stBdL) % ($iBbCnt-1));
      print {$FILE} (pack("V", -2));
    }
  }
  
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS::File Object
  #//////////////////////////////////////////////////////////////////////////////
  #==============================================================================
  # OLE::Storage_Lite::PPS::File
  #==============================================================================
  package OLE::Storage_Lite::PPS::File;
  require Exporter;
  use strict;
  use vars qw($VERSION @ISA);
  @ISA = qw(OLE::Storage_Lite::PPS Exporter);
  $VERSION = '0.19';
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS::File)
  #------------------------------------------------------------------------------
  sub new ($$$) {
    my($sClass, $sNm, $sData) = @_;
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          $sNm,
          2,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          $sData,
          undef);
  }
  #------------------------------------------------------------------------------
  # newFile (OLE::Storage_Lite::PPS::File)
  #------------------------------------------------------------------------------
  sub newFile ($$;$) {
      my($sClass, $sNm, $sFile) = @_;
      my $oSelf =
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          $sNm,
          2,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          undef,
          '',
          undef);
  #
      if((!defined($sFile)) or ($sFile eq '')) {
          $oSelf->{_PPS_FILE} = IO::File->new_tmpfile();
      }
      elsif(UNIVERSAL::isa($sFile, 'IO::Handle')) {
          $oSelf->{_PPS_FILE} = $sFile;
      }
      elsif(!ref($sFile)) {
          #File Name
          $oSelf->{_PPS_FILE} = new IO::File;
          return undef unless($oSelf->{_PPS_FILE});
          $oSelf->{_PPS_FILE}->open("$sFile", "r+") || return undef;
      }
      else {
          return undef;
      }
      if($oSelf->{_PPS_FILE}) {
          $oSelf->{_PPS_FILE}->seek(0, 2);
          binmode($oSelf->{_PPS_FILE});
          $oSelf->{_PPS_FILE}->autoflush(1);
      }
      return $oSelf;
  }
  #------------------------------------------------------------------------------
  # append (OLE::Storage_Lite::PPS::File)
  #------------------------------------------------------------------------------
  sub append ($$) {
      my($oSelf, $sData) = @_;
      if($oSelf->{_PPS_FILE}) {
          print {$oSelf->{_PPS_FILE}} $sData;
      }
      else {
          $oSelf->{Data} .= $sData;
      }
  }
  
  #//////////////////////////////////////////////////////////////////////////////
  # OLE::Storage_Lite::PPS::Dir Object
  #//////////////////////////////////////////////////////////////////////////////
  #------------------------------------------------------------------------------
  # new (OLE::Storage_Lite::PPS::Dir)
  #------------------------------------------------------------------------------
  package OLE::Storage_Lite::PPS::Dir;
  require Exporter;
  use strict;
  use vars qw($VERSION @ISA);
  @ISA = qw(OLE::Storage_Lite::PPS Exporter);
  $VERSION = '0.19';
  sub new ($$;$$$) {
      my($sClass, $sName, $raTime1st, $raTime2nd, $raChild) = @_;
      OLE::Storage_Lite::PPS::_new(
          $sClass,
          undef,
          $sName,
          1,
          undef,
          undef,
          undef,
          $raTime1st,
          $raTime2nd,
          undef,
          undef,
          undef,
          $raChild);
  }
  #==============================================================================
  # OLE::Storage_Lite
  #==============================================================================
  package OLE::Storage_Lite;
  require Exporter;
  
  use strict;
  use IO::File;
  use Time::Local 'timegm';
  
  use vars qw($VERSION @ISA @EXPORT);
  @ISA = qw(Exporter);
  $VERSION = '0.19';
  sub _getPpsSearch($$$$$;$);
  sub _getPpsTree($$$;$);
  #------------------------------------------------------------------------------
  # Const for OLE::Storage_Lite
  #------------------------------------------------------------------------------
  #0. Constants
  sub PpsType_Root {5};
  sub PpsType_Dir  {1};
  sub PpsType_File {2};
  sub DataSizeSmall{0x1000};
  sub LongIntSize  {4};
  sub PpsSize      {0x80};
  #------------------------------------------------------------------------------
  # new OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub new($$) {
    my($sClass, $sFile) = @_;
    my $oThis = {
      _FILE => $sFile,
    };
    bless $oThis;
    return $oThis;
  }
  #------------------------------------------------------------------------------
  # getPpsTree: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub getPpsTree($;$)
  {
    my($oThis, $bData) = @_;
  #0.Init
    my $rhInfo = _initParse($oThis->{_FILE});
    return undef unless($rhInfo);
  #1. Get Data
    my ($oPps) = _getPpsTree(0, $rhInfo, $bData);
    close(IN);
    return $oPps;
  }
  #------------------------------------------------------------------------------
  # getSearch: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub getPpsSearch($$;$$)
  {
    my($oThis, $raName, $bData, $iCase) = @_;
  #0.Init
    my $rhInfo = _initParse($oThis->{_FILE});
    return undef unless($rhInfo);
  #1. Get Data
    my @aList = _getPpsSearch(0, $rhInfo, $raName, $bData, $iCase);
    close(IN);
    return @aList;
  }
  #------------------------------------------------------------------------------
  # getNthPps: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub getNthPps($$;$)
  {
    my($oThis, $iNo, $bData) = @_;
  #0.Init
    my $rhInfo = _initParse($oThis->{_FILE});
    return undef unless($rhInfo);
  #1. Get Data
    my $oPps = _getNthPps($iNo, $rhInfo, $bData);
    close IN;
    return $oPps;
  }
  #------------------------------------------------------------------------------
  # _initParse: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _initParse($) {
    my($sFile)=@_;
    my $oIo;
    #1. $sFile is Ref of scalar
    if(ref($sFile) eq 'SCALAR') {
      require IO::Scalar;
      $oIo = new IO::Scalar;
      $oIo->open($sFile);
    }
    #2. $sFile is a IO::Handle object
    elsif(UNIVERSAL::isa($sFile, 'IO::Handle')) {
      $oIo = $sFile;
      binmode($oIo);
    }
    #3. $sFile is a simple filename string
    elsif(!ref($sFile)) {
      $oIo = new IO::File;
      $oIo->open("<$sFile") || return undef;
      binmode($oIo);
    }
    #4 Assume that if $sFile is a ref then it is a valid filehandle
    else {
      $oIo = $sFile;
      # Not all filehandles support binmode() so try it in an eval.
      eval{ binmode $oIo };
    }
    return _getHeaderInfo($oIo);
  }
  #------------------------------------------------------------------------------
  # _getPpsTree: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _getPpsTree($$$;$) {
    my($iNo, $rhInfo, $bData, $raDone) = @_;
    if(defined($raDone)) {
      return () if(grep {$_ ==$iNo} @$raDone);
    }
    else {
      $raDone=[];
    }
    push @$raDone, $iNo;
  
    my $iRootBlock = $rhInfo->{_ROOT_START} ;
  #1. Get Information about itself
    my $oPps = _getNthPps($iNo, $rhInfo, $bData);
  #2. Child
    if($oPps->{DirPps} !=  0xFFFFFFFF) {
      my @aChildL = _getPpsTree($oPps->{DirPps}, $rhInfo, $bData, $raDone);
      $oPps->{Child} =  \@aChildL;
    }
    else {
      $oPps->{Child} =  undef;
    }
  #3. Previous,Next PPSs
    my @aList = ();
    push @aList, _getPpsTree($oPps->{PrevPps}, $rhInfo, $bData, $raDone)
                          if($oPps->{PrevPps} != 0xFFFFFFFF);
    push @aList, $oPps;
    push @aList, _getPpsTree($oPps->{NextPps}, $rhInfo, $bData, $raDone)
                  if($oPps->{NextPps} != 0xFFFFFFFF);
    return @aList;
  }
  #------------------------------------------------------------------------------
  # _getPpsSearch: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub _getPpsSearch($$$$$;$) {
    my($iNo, $rhInfo, $raName, $bData, $iCase, $raDone) = @_;
    my $iRootBlock = $rhInfo->{_ROOT_START} ;
    my @aRes;
  #1. Check it self
    if(defined($raDone)) {
      return () if(grep {$_==$iNo} @$raDone);
    }
    else {
      $raDone=[];
    }
    push @$raDone, $iNo;
    my $oPps = _getNthPps($iNo, $rhInfo, undef);
  #  if(grep($_ eq $oPps->{Name}, @$raName)) {
    if(($iCase && (grep(/^\Q$oPps->{Name}\E$/i, @$raName))) ||
       (grep($_ eq $oPps->{Name}, @$raName))) {
      $oPps = _getNthPps($iNo, $rhInfo, $bData) if ($bData);
      @aRes = ($oPps);
    }
    else {
      @aRes = ();
    }
  #2. Check Child, Previous, Next PPSs
    push @aRes, _getPpsSearch($oPps->{DirPps},  $rhInfo, $raName, $bData, $iCase, $raDone)
          if($oPps->{DirPps} !=  0xFFFFFFFF) ;
    push @aRes, _getPpsSearch($oPps->{PrevPps}, $rhInfo, $raName, $bData, $iCase, $raDone)
          if($oPps->{PrevPps} != 0xFFFFFFFF );
    push @aRes, _getPpsSearch($oPps->{NextPps}, $rhInfo, $raName, $bData, $iCase, $raDone)
          if($oPps->{NextPps} != 0xFFFFFFFF);
    return @aRes;
  }
  #===================================================================
  # Get Header Info (BASE Informain about that file)
  #===================================================================
  sub _getHeaderInfo($){
    my($FILE) = @_;
    my($iWk);
    my $rhInfo = {};
    $rhInfo->{_FILEH_} = $FILE;
    my $sWk;
  #0. Check ID
    $rhInfo->{_FILEH_}->seek(0, 0);
    $rhInfo->{_FILEH_}->read($sWk, 8);
    return undef unless($sWk eq "\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1");
  #BIG BLOCK SIZE
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x1E, 2, "v");
    return undef unless(defined($iWk));
    $rhInfo->{_BIG_BLOCK_SIZE} = 2 ** $iWk;
  #SMALL BLOCK SIZE
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x20, 2, "v");
    return undef unless(defined($iWk));
    $rhInfo->{_SMALL_BLOCK_SIZE} = 2 ** $iWk;
  #BDB Count
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x2C, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_BDB_COUNT} = $iWk;
  #START BLOCK
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x30, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_ROOT_START} = $iWk;
  #MIN SIZE OF BB
  #  $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x38, 4, "V");
  #  return undef unless(defined($iWk));
  #  $rhInfo->{_MIN_SIZE_BB} = $iWk;
  #SMALL BD START
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x3C, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_SBD_START} = $iWk;
  #SMALL BD COUNT
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x40, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_SBD_COUNT} = $iWk;
  #EXTRA BBD START
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x44, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_EXTRA_BBD_START} = $iWk;
  #EXTRA BD COUNT
    $iWk = _getInfoFromFile($rhInfo->{_FILEH_}, 0x48, 4, "V");
    return undef unless(defined($iWk));
    $rhInfo->{_EXTRA_BBD_COUNT} = $iWk;
  #GET BBD INFO
    $rhInfo->{_BBD_INFO}= _getBbdInfo($rhInfo);
  #GET ROOT PPS
    my $oRoot = _getNthPps(0, $rhInfo, undef);
    $rhInfo->{_SB_START} = $oRoot->{StartBlock};
    $rhInfo->{_SB_SIZE}  = $oRoot->{Size};
    return $rhInfo;
  }
  #------------------------------------------------------------------------------
  # _getInfoFromFile
  #------------------------------------------------------------------------------
  sub _getInfoFromFile($$$$) {
    my($FILE, $iPos, $iLen, $sFmt) =@_;
    my($sWk);
    return undef unless($FILE);
    return undef if($FILE->seek($iPos, 0)==0);
    return undef if($FILE->read($sWk,  $iLen)!=$iLen);
    return unpack($sFmt, $sWk);
  }
  #------------------------------------------------------------------------------
  # _getBbdInfo
  #------------------------------------------------------------------------------
  sub _getBbdInfo($) {
    my($rhInfo) =@_;
    my @aBdList = ();
    my $iBdbCnt = $rhInfo->{_BDB_COUNT};
    my $iGetCnt;
    my $sWk;
    my $i1stCnt = int(($rhInfo->{_BIG_BLOCK_SIZE} - 0x4C) / OLE::Storage_Lite::LongIntSize());
    my $iBdlCnt = int($rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize()) - 1;
  
  #1. 1st BDlist
    $rhInfo->{_FILEH_}->seek(0x4C, 0);
    $iGetCnt = ($iBdbCnt < $i1stCnt)? $iBdbCnt: $i1stCnt;
    $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize()*$iGetCnt);
    push @aBdList, unpack("V$iGetCnt", $sWk);
    $iBdbCnt -= $iGetCnt;
  #2. Extra BDList
    my $iBlock = $rhInfo->{_EXTRA_BBD_START};
    while(($iBdbCnt> 0) && _isNormalBlock($iBlock)){
      _setFilePos($iBlock, 0, $rhInfo);
      $iGetCnt= ($iBdbCnt < $iBdlCnt)? $iBdbCnt: $iBdlCnt;
      $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize()*$iGetCnt);
      push @aBdList, unpack("V$iGetCnt", $sWk);
      $iBdbCnt -= $iGetCnt;
      $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize());
      $iBlock = unpack("V", $sWk);
    }
  #3.Get BDs
    my @aWk;
    my %hBd;
    my $iBlkNo = 0;
    my $iBdL;
    my $i;
    my $iBdCnt = int($rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize());
    foreach $iBdL (@aBdList) {
      _setFilePos($iBdL, 0, $rhInfo);
      $rhInfo->{_FILEH_}->read($sWk, $rhInfo->{_BIG_BLOCK_SIZE});
      @aWk = unpack("V$iBdCnt", $sWk);
      for($i=0;$i<$iBdCnt;$i++, $iBlkNo++) {
         if($aWk[$i] != ($iBlkNo+1)){
              $hBd{$iBlkNo} = $aWk[$i];
          }
      }
    }
    return \%hBd;
  }
  #------------------------------------------------------------------------------
  # getNthPps (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNthPps($$$){
    my($iPos, $rhInfo, $bData) = @_;
    my($iPpsStart) = ($rhInfo->{_ROOT_START});
    my($iPpsBlock, $iPpsPos);
    my $sWk;
    my $iBlock;
  
    my $iBaseCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::PpsSize();
    $iPpsBlock = int($iPos / $iBaseCnt);
    $iPpsPos   = $iPos % $iBaseCnt;
  
    $iBlock = _getNthBlockNo($iPpsStart, $iPpsBlock, $rhInfo);
    return undef unless(defined($iBlock));
  
    _setFilePos($iBlock, OLE::Storage_Lite::PpsSize()*$iPpsPos, $rhInfo);
    $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::PpsSize());
    return undef unless($sWk);
    my $iNmSize = unpack("v", substr($sWk, 0x40, 2));
    $iNmSize = ($iNmSize > 2)? $iNmSize - 2 : $iNmSize;
    my $sNm= substr($sWk, 0, $iNmSize);
    my $iType = unpack("C", substr($sWk, 0x42, 2));
    my $lPpsPrev = unpack("V", substr($sWk, 0x44, OLE::Storage_Lite::LongIntSize()));
    my $lPpsNext = unpack("V", substr($sWk, 0x48, OLE::Storage_Lite::LongIntSize()));
    my $lDirPps  = unpack("V", substr($sWk, 0x4C, OLE::Storage_Lite::LongIntSize()));
    my @raTime1st =
          (($iType == OLE::Storage_Lite::PpsType_Root()) or ($iType == OLE::Storage_Lite::PpsType_Dir()))?
              OLEDate2Local(substr($sWk, 0x64, 8)) : undef ,
    my @raTime2nd =
          (($iType == OLE::Storage_Lite::PpsType_Root()) or ($iType == OLE::Storage_Lite::PpsType_Dir()))?
              OLEDate2Local(substr($sWk, 0x6C, 8)) : undef,
    my($iStart, $iSize) = unpack("VV", substr($sWk, 0x74, 8));
    if($bData) {
        my $sData = _getData($iType, $iStart, $iSize, $rhInfo);
        return OLE::Storage_Lite::PPS->new(
          $iPos, $sNm, $iType, $lPpsPrev, $lPpsNext, $lDirPps,
          \@raTime1st, \@raTime2nd, $iStart, $iSize, $sData, undef);
    }
    else {
        return OLE::Storage_Lite::PPS->new(
          $iPos, $sNm, $iType, $lPpsPrev, $lPpsNext, $lDirPps,
          \@raTime1st, \@raTime2nd, $iStart, $iSize, undef, undef);
    }
  }
  #------------------------------------------------------------------------------
  # _setFilePos (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _setFilePos($$$){
    my($iBlock, $iPos, $rhInfo) = @_;
    $rhInfo->{_FILEH_}->seek(($iBlock+1)*$rhInfo->{_BIG_BLOCK_SIZE}+$iPos, 0);
  }
  #------------------------------------------------------------------------------
  # _getNthBlockNo (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNthBlockNo($$$){
    my($iStBlock, $iNth, $rhInfo) = @_;
    my $iSv;
    my $iNext = $iStBlock;
    for(my $i =0; $i<$iNth; $i++) {
      $iSv = $iNext;
      $iNext = _getNextBlockNo($iSv, $rhInfo);
      return undef unless _isNormalBlock($iNext);
    }
    return $iNext;
  }
  #------------------------------------------------------------------------------
  # _getData (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getData($$$$)
  {
    my($iType, $iBlock, $iSize, $rhInfo) = @_;
    if ($iType == OLE::Storage_Lite::PpsType_File()) {
      if($iSize < OLE::Storage_Lite::DataSizeSmall()) {
          return _getSmallData($iBlock, $iSize, $rhInfo);
      }
      else {
          return _getBigData($iBlock, $iSize, $rhInfo);
      }
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Root()) {  #Root
      return _getBigData($iBlock, $iSize, $rhInfo);
    }
    elsif($iType == OLE::Storage_Lite::PpsType_Dir()) {  # Directory
      return undef;
    }
  }
  #------------------------------------------------------------------------------
  # _getBigData (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getBigData($$$)
  {
    my($iBlock, $iSize, $rhInfo) = @_;
    my($iRest, $sWk, $sRes);
  
    return '' unless(_isNormalBlock($iBlock));
    $iRest = $iSize;
    my($i, $iGetSize, $iNext);
    $sRes = '';
    my @aKeys= sort({$a<=>$b} keys(%{$rhInfo->{_BBD_INFO}}));
  
    while ($iRest > 0) {
      my @aRes = grep($_ >= $iBlock, @aKeys);
      my $iNKey = $aRes[0];
      $i = $iNKey - $iBlock;
      $iNext = $rhInfo->{_BBD_INFO}{$iNKey};
      _setFilePos($iBlock, 0, $rhInfo);
      my $iGetSize = ($rhInfo->{_BIG_BLOCK_SIZE} * ($i+1));
      $iGetSize = $iRest if($iRest < $iGetSize);
      $rhInfo->{_FILEH_}->read( $sWk, $iGetSize);
      $sRes .= $sWk;
      $iRest -= $iGetSize;
      $iBlock= $iNext;
    }
    return $sRes;
  }
  #------------------------------------------------------------------------------
  # _getNextBlockNo (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNextBlockNo($$){
    my($iBlockNo, $rhInfo) = @_;
    my $iRes = $rhInfo->{_BBD_INFO}->{$iBlockNo};
    return defined($iRes)? $iRes: $iBlockNo+1;
  }
  #------------------------------------------------------------------------------
  # _isNormalBlock (OLE::Storage_Lite)
  # 0xFFFFFFFC : BDList, 0xFFFFFFFD : BBD,
  # 0xFFFFFFFE: End of Chain 0xFFFFFFFF : unused
  #------------------------------------------------------------------------------
  sub _isNormalBlock($){
    my($iBlock) = @_;
    return ($iBlock < 0xFFFFFFFC)? 1: undef;
  }
  #------------------------------------------------------------------------------
  # _getSmallData (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getSmallData($$$)
  {
    my($iSmBlock, $iSize, $rhInfo) = @_;
    my($sRes, $sWk);
    my $iRest = $iSize;
    $sRes = '';
    while ($iRest > 0) {
      _setFilePosSmall($iSmBlock, $rhInfo);
      $rhInfo->{_FILEH_}->read($sWk,
          ($iRest >= $rhInfo->{_SMALL_BLOCK_SIZE})?
              $rhInfo->{_SMALL_BLOCK_SIZE}: $iRest);
      $sRes .= $sWk;
      $iRest -= $rhInfo->{_SMALL_BLOCK_SIZE};
      $iSmBlock= _getNextSmallBlockNo($iSmBlock, $rhInfo);
    }
    return $sRes;
  }
  #------------------------------------------------------------------------------
  # _setFilePosSmall(OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _setFilePosSmall($$)
  {
    my($iSmBlock, $rhInfo) = @_;
    my $iSmStart = $rhInfo->{_SB_START};
    my $iBaseCnt = $rhInfo->{_BIG_BLOCK_SIZE} / $rhInfo->{_SMALL_BLOCK_SIZE};
    my $iNth = int($iSmBlock/$iBaseCnt);
    my $iPos = $iSmBlock % $iBaseCnt;
  
    my $iBlk = _getNthBlockNo($iSmStart, $iNth, $rhInfo);
    _setFilePos($iBlk, $iPos * $rhInfo->{_SMALL_BLOCK_SIZE}, $rhInfo);
  }
  #------------------------------------------------------------------------------
  # _getNextSmallBlockNo (OLE::Storage_Lite)
  #------------------------------------------------------------------------------
  sub _getNextSmallBlockNo($$)
  {
    my($iSmBlock, $rhInfo) = @_;
    my($sWk);
  
    my $iBaseCnt = $rhInfo->{_BIG_BLOCK_SIZE} / OLE::Storage_Lite::LongIntSize();
    my $iNth = int($iSmBlock/$iBaseCnt);
    my $iPos = $iSmBlock % $iBaseCnt;
    my $iBlk = _getNthBlockNo($rhInfo->{_SBD_START}, $iNth, $rhInfo);
    _setFilePos($iBlk, $iPos * OLE::Storage_Lite::LongIntSize(), $rhInfo);
    $rhInfo->{_FILEH_}->read($sWk, OLE::Storage_Lite::LongIntSize());
    return unpack("V", $sWk);
  
  }
  #------------------------------------------------------------------------------
  # Asc2Ucs: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub Asc2Ucs($)
  {
    my($sAsc) = @_;
    return join("\x00", split //, $sAsc) . "\x00";
  }
  #------------------------------------------------------------------------------
  # Ucs2Asc: OLE::Storage_Lite
  #------------------------------------------------------------------------------
  sub Ucs2Asc($)
  {
    my($sUcs) = @_;
    return join('', map(pack('c', $_), unpack('v*', $sUcs)));
  }
  
  #------------------------------------------------------------------------------
  # OLEDate2Local()
  #
  # Convert from a Window FILETIME structure to a localtime array. FILETIME is
  # a 64-bit value representing the number of 100-nanosecond intervals since
  # January 1 1601.
  #
  # We first convert the FILETIME to seconds and then subtract the difference
  # between the 1601 epoch and the 1970 Unix epoch.
  #
  sub OLEDate2Local {
  
      my $oletime = shift;
  
      # Unpack the FILETIME into high and low longs.
      my ( $lo, $hi ) = unpack 'V2', $oletime;
  
      # Convert the longs to a double.
      my $nanoseconds = $hi * 2**32 + $lo;
  
      # Convert the 100 nanosecond units into seconds.
      my $time = $nanoseconds / 1e7;
  
      # Subtract the number of seconds between the 1601 and 1970 epochs.
      $time -= 11644473600;
  
      # Convert to a localtime (actually gmtime) structure.
      my @localtime = gmtime($time);
  
      return @localtime;
  }
  
  #------------------------------------------------------------------------------
  # LocalDate2OLE()
  #
  # Convert from a a localtime array to a Window FILETIME structure. FILETIME is
  # a 64-bit value representing the number of 100-nanosecond intervals since
  # January 1 1601.
  #
  # We first convert the localtime (actually gmtime) to seconds and then add the
  # difference between the 1601 epoch and the 1970 Unix epoch. We convert that to
  # 100 nanosecond units, divide it into high and low longs and return it as a
  # packed 64bit structure.
  #
  sub LocalDate2OLE {
  
      my $localtime = shift;
  
      return "\x00" x 8 unless $localtime;
  
      # Convert from localtime (actually gmtime) to seconds.
      my $time = timegm( @{$localtime} );
  
      # Add the number of seconds between the 1601 and 1970 epochs.
      $time += 11644473600;
  
      # The FILETIME seconds are in units of 100 nanoseconds.
      my $nanoseconds = $time * 1E7;
  
  use POSIX 'fmod';
  
      # Pack the total nanoseconds into 64 bits...
      my $hi = int( $nanoseconds / 2**32 );
      my $lo = fmod($nanoseconds, 2**32);
  
      my $oletime = pack "VV", $lo, $hi;
  
      return $oletime;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  OLE::Storage_Lite - Simple Class for OLE document interface.
  
  =head1 SYNOPSIS
  
      use OLE::Storage_Lite;
  
      # Initialize.
  
      # From a file
      my $oOl = OLE::Storage_Lite->new("some.xls");
  
      # From a filehandle object
      use IO::File;
      my $oIo = new IO::File;
      $oIo->open("<iofile.xls");
      binmode($oIo);
      my $oOl = OLE::Storage_Lite->new($oFile);
  
      # Read data
      my $oPps = $oOl->getPpsTree(1);
  
      # Save Data
      # To a File
      $oPps->save("kaba.xls"); #kaba.xls
      $oPps->save('-');        #STDOUT
  
      # To a filehandle object
      my $oIo = new IO::File;
      $oIo->open(">iofile.xls");
      bimode($oIo);
      $oPps->save($oIo);
  
  
  =head1 DESCRIPTION
  
  OLE::Storage_Lite allows you to read and write an OLE structured file.
  
  OLE::Storage_Lite::PPS is a class representing PPS. OLE::Storage_Lite::PPS::Root, OLE::Storage_Lite::PPS::File and OLE::Storage_Lite::PPS::Dir
  are subclasses of OLE::Storage_Lite::PPS.
  
  
  =head2 new()
  
  Constructor.
  
      $oOle = OLE::Storage_Lite->new($sFile);
  
  Creates a OLE::Storage_Lite object for C<$sFile>. C<$sFile> must be a correct file name.
  
  The C<new()> constructor also accepts a valid filehandle. Remember to C<binmode()> the filehandle first.
  
  
  =head2 getPpsTree()
  
      $oPpsRoot = $oOle->getPpsTree([$bData]);
  
  Returns PPS as an OLE::Storage_Lite::PPS::Root object.
  Other PPS objects will be included as its children.
  
  If C<$bData> is true, the objects will have data in the file.
  
  
  =head2 getPpsSearch()
  
      $oPpsRoot = $oOle->getPpsTree($raName [, $bData][, $iCase] );
  
  Returns PPSs as OLE::Storage_Lite::PPS objects that has the name specified in C<$raName> array.
  
  If C<$bData> is true, the objects will have data in the file.
  If C<$iCase> is true, search is case insensitive.
  
  
  =head2 getNthPps()
  
      $oPpsRoot = $oOle->getNthPps($iNth [, $bData]);
  
  Returns PPS as C<OLE::Storage_Lite::PPS> object specified number C<$iNth>.
  
  If C<$bData> is true, the objects will have data in the file.
  
  
  =head2 Asc2Ucs()
  
      $sUcs2 = OLE::Storage_Lite::Asc2Ucs($sAsc>);
  
  Utility function. Just adds 0x00 after every characters in C<$sAsc>.
  
  
  =head2 Ucs2Asc()
  
      $sAsc = OLE::Storage_Lite::Ucs2Asc($sUcs2);
  
  Utility function. Just deletes 0x00 after words in C<$sUcs>.
  
  
  =head1 OLE::Storage_Lite::PPS
  
  OLE::Storage_Lite::PPS has these properties:
  
  =over 4
  
  =item No
  
  Order number in saving.
  
  =item Name
  
  Its name in UCS2 (a.k.a Unicode).
  
  =item Type
  
  Its type (1:Dir, 2:File (Data), 5: Root)
  
  =item PrevPps
  
  Previous pps (as No)
  
  =item NextPps
  
  Next pps (as No)
  
  =item DirPps
  
  Dir pps (as No).
  
  =item Time1st
  
  Timestamp 1st in array ref as similar fomat of localtime.
  
  =item Time2nd
  
  Timestamp 2nd in array ref as similar fomat of localtime.
  
  =item StartBlock
  
  Start block number
  
  =item Size
  
  Size of the pps
  
  =item Data
  
  Its data
  
  =item Child
  
  Its child PPSs in array ref
  
  =back
  
  
  =head1 OLE::Storage_Lite::PPS::Root
  
  OLE::Storage_Lite::PPS::Root has 2 methods.
  
  =head2 new()
  
      $oRoot = OLE::Storage_Lite::PPS::Root->new(
                      $raTime1st,
                      $raTime2nd,
                      $raChild);
  
  
  Constructor.
  
  C<$raTime1st>, C<$raTime2nd> are array refs with ($iSec, $iMin, $iHour, $iDay, $iMon, $iYear).
  $iSec means seconds, $iMin means minutes. $iHour means hours.
  $iDay means day. $iMon is month -1. $iYear is year - 1900.
  
  C<$raChild> is a array ref of children PPSs.
  
  
  =head2 save()
  
      $oRoot = $oRoot>->save(
                      $sFile,
                      $bNoAs);
  
  
  Saves information into C<$sFile>. If C<$sFile> is '-', this will use STDOUT.
  
  The C<new()> constructor also accepts a valid filehandle. Remember to C<binmode()> the filehandle first.
  
  If C<$bNoAs> is defined, this function will use the No of PPSs for saving order.
  If C<$bNoAs> is undefined, this will calculate PPS saving order.
  
  
  =head1 OLE::Storage_Lite::PPS::Dir
  
  OLE::Storage_Lite::PPS::Dir has 1 method.
  
  =head2 new()
  
      $oRoot = OLE::Storage_Lite::PPS::Dir->new(
                      $sName,
                    [, $raTime1st]
                    [, $raTime2nd]
                    [, $raChild>]);
  
  
  Constructor.
  
  C<$sName> is a name of the PPS.
  
  C<$raTime1st>, C<$raTime2nd> is a array ref as
  ($iSec, $iMin, $iHour, $iDay, $iMon, $iYear).
  $iSec means seconds, $iMin means minutes. $iHour means hours.
  $iDay means day. $iMon is month -1. $iYear is year - 1900.
  
  C<$raChild> is a array ref of children PPSs.
  
  
  =head1 OLE::Storage_Lite::PPS::File
  
  OLE::Storage_Lite::PPS::File has 3 method.
  
  =head2 new
  
      $oRoot = OLE::Storage_Lite::PPS::File->new($sName, $sData);
  
  C<$sName> is name of the PPS.
  
  C<$sData> is data of the PPS.
  
  
  =head2 newFile()
  
      $oRoot = OLE::Storage_Lite::PPS::File->newFile($sName, $sFile);
  
  This function makes to use file handle for geting and storing data.
  
  C<$sName> is name of the PPS.
  
  If C<$sFile> is scalar, it assumes that is a filename.
  If C<$sFile> is an IO::Handle object, it uses that specified handle.
  If C<$sFile> is undef or '', it uses temporary file.
  
  CAUTION: Take care C<$sFile> will be updated by C<append> method.
  So if you want to use IO::Handle and append a data to it,
  you should open the handle with "r+".
  
  
  =head2 append()
  
      $oRoot = $oPps->append($sData);
  
  appends specified data to that PPS.
  
  C<$sData> is appending data for that PPS.
  
  
  =head1 CAUTION
  
  A saved file with VBA (a.k.a Macros) by this module will not work correctly.
  However modules can get the same information from the file,
  the file occurs a error in application(Word, Excel ...).
  
  
  =head1 DEPRECATED FEATURES
  
  Older version of C<OLE::Storage_Lite> autovivified a scalar ref in the C<new()> constructors into a scalar filehandle. This functionality is still there for backwards compatibility but it is highly recommended that you do not use it. Instead create a filehandle (scalar or otherwise) and pass that in.
  
  
  =head1 COPYRIGHT
  
  The OLE::Storage_Lite module is Copyright (c) 2000,2001 Kawai Takanori. Japan.
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the Perl README file.
  
  
  =head1 ACKNOWLEDGEMENTS
  
  First of all, I would like to acknowledge to Martin Schwartz and his module OLE::Storage.
  
  
  =head1 AUTHOR
  
  Kawai Takanori kwitknr@cpan.org
  
  This module is currently maintained by John McNamara jmcnamara@cpan.org
  
  
  =head1 SEE ALSO
  
  OLE::Storage
  
  Documentation for the OLE Compound document has been released by Microsoft under the I<Open Specification Promise>. See http://www.microsoft.com/interop/docs/supportingtechnologies.mspx
  
  The Digital Imaging Group have also detailed the OLE format in the JPEG2000 specification: see Appendix A of http://www.i3a.org/pdf/wg1n1017.pdf
  
  
  =cut
OLE_STORAGE_LITE

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  
  require 5;
  package Pod::Simple;
  use strict;
  use Carp ();
  BEGIN           { *DEBUG = sub () {0} unless defined &DEBUG }
  use integer;
  use Pod::Escapes 1.04 ();
  use Pod::Simple::LinkSection ();
  use Pod::Simple::BlackBox ();
  #use utf8;
  
  use vars qw(
    $VERSION @ISA
    @Known_formatting_codes  @Known_directives
    %Known_formatting_codes  %Known_directives
    $NL
  );
  
  @ISA = ('Pod::Simple::BlackBox');
  $VERSION = '3.32';
  
  @Known_formatting_codes = qw(I B C L E F S X Z); 
  %Known_formatting_codes = map(($_=>1), @Known_formatting_codes);
  @Known_directives       = qw(head1 head2 head3 head4 item over back); 
  %Known_directives       = map(($_=>'Plain'), @Known_directives);
  $NL = $/ unless defined $NL;
  
  #-----------------------------------------------------------------------------
  # Set up some constants:
  
  BEGIN {
    if(defined &ASCII)    { }
    elsif(chr(65) eq 'A') { *ASCII = sub () {1}  }
    else                  { *ASCII = sub () {''} }
  
    unless(defined &MANY_LINES) { *MANY_LINES = sub () {20} }
    DEBUG > 4 and print STDERR "MANY_LINES is ", MANY_LINES(), "\n";
    unless(MANY_LINES() >= 1) {
      die "MANY_LINES is too small (", MANY_LINES(), ")!\nAborting";
    }
    if(defined &UNICODE) { }
    elsif($] >= 5.008)   { *UNICODE = sub() {1}  }
    else                 { *UNICODE = sub() {''} }
  }
  if(DEBUG > 2) {
    print STDERR "# We are ", ASCII ? '' : 'not ', "in ASCII-land\n";
    print STDERR "# We are under a Unicode-safe Perl.\n";
  }
  
  # The NO BREAK SPACE and SOFT HYHPEN are used in several submodules.
  if ($] ge 5.007_003) {  # On sufficiently modern Perls we can handle any
                          # character set
    $Pod::Simple::nbsp = chr utf8::unicode_to_native(0xA0);
    $Pod::Simple::shy  = chr utf8::unicode_to_native(0xAD);
  }
  elsif (Pod::Simple::ASCII) {  # Hard code ASCII early Perl
    $Pod::Simple::nbsp = "\xA0";
    $Pod::Simple::shy  = "\xAD";
  }
  else { # EBCDIC on early Perl.  We know what the values are for the code
          # pages supported then.
    $Pod::Simple::nbsp = "\x41";
    $Pod::Simple::shy  = "\xCA";
  }
  
  # Design note:
  # This is a parser for Pod.  It is not a parser for the set of Pod-like
  #  languages which happens to contain Pod -- it is just for Pod, plus possibly
  #  some extensions.
  
  # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  __PACKAGE__->_accessorize(
    'nbsp_for_S',        # Whether to map S<...>'s to \xA0 characters
    'source_filename',   # Filename of the source, for use in warnings
    'source_dead',       # Whether to consider this parser's source dead
  
    'output_fh',         # The filehandle we're writing to, if applicable.
                         # Used only in some derived classes.
  
    'hide_line_numbers', # For some dumping subclasses: whether to pointedly
                         # suppress the start_line attribute
  
    'line_count',        # the current line number
    'pod_para_count',    # count of pod paragraphs seen so far
  
    'no_whining',        # whether to suppress whining
    'no_errata_section', # whether to suppress the errata section
    'complain_stderr',   # whether to complain to stderr
  
    'doc_has_started',   # whether we've fired the open-Document event yet
  
    'bare_output',       # For some subclasses: whether to prepend
                         #  header-code and postpend footer-code
  
    'keep_encoding_directive',  # whether to emit =encoding
    'nix_X_codes',       # whether to ignore X<...> codes
    'merge_text',        # whether to avoid breaking a single piece of
                         #  text up into several events
  
    'preserve_whitespace', # whether to try to keep whitespace as-is
    'strip_verbatim_indent', # What indent to strip from verbatim
  
    'parse_characters',  # Whether parser should expect chars rather than octets
  
   'content_seen',      # whether we've seen any real Pod content
   'errors_seen',       # TODO: document.  whether we've seen any errors (fatal or not)
  
   'codes_in_verbatim', # for PseudoPod extensions
  
   'code_handler',      # coderef to call when a code (non-pod) line is seen
   'cut_handler',       # ... when a =cut line is seen
   'pod_handler',       # ... when a =pod line is seen
   'whiteline_handler', # ... when a line with only whitespace is seen
   #Called like:
   # $code_handler->($line, $self->{'line_count'}, $self) if $code_handler;
   #  $cut_handler->($line, $self->{'line_count'}, $self) if $cut_handler;
   #  $pod_handler->($line, $self->{'line_count'}, $self) if $pod_handler;
   #   $wl_handler->($line, $self->{'line_count'}, $self) if $wl_handler;
   'parse_empty_lists', # whether to acknowledge empty =over/=back blocks
   'raw_mode',          # to report entire raw lines instead of Pod elements
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub any_errata_seen {  # good for using as an exit() value...
    return shift->{'errors_seen'} || 0;
  }
  
  sub errata_seen {
    return shift->{'all_errata'} || {};
  }
  
  # Returns the encoding only if it was recognized as being handled and set
  sub detected_encoding {
    return shift->{'detected_encoding'};
  }
  
  sub encoding {
    my $this = shift;
    return $this->{'encoding'} unless @_;  # GET.
  
    $this->_handle_encoding_line("=encoding $_[0]");
    if ($this->{'_processed_encoding'}) {
      delete $this->{'_processed_encoding'};
      if(! $this->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n";
      } elsif( $this->{'encoding_command_statuses'}[-1] ) {
        $this->scream( "=encoding $_[0]",
           sprintf "Couldn't do %s: %s",
           $this->{'encoding_command_reqs'  }[-1],
           $this->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (encoding successfully handled.)\n";
      }
      return $this->{'encoding'};
    } else {
      return undef;
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  # Pull in some functions that, for some reason, I expect to see here too:
  BEGIN {
    *pretty        = \&Pod::Simple::BlackBox::pretty;
    *stringify_lol = \&Pod::Simple::BlackBox::stringify_lol;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub version_report {
    my $class = ref($_[0]) || $_[0];
    if($class eq __PACKAGE__) {
      return "$class $VERSION";
    } else {
      my $v = $class->VERSION;
      return "$class $v (" . __PACKAGE__ . " $VERSION)";
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  #sub curr_open { # read-only list accessor
  #  return @{ $_[0]{'curr_open'} || return() };
  #}
  #sub _curr_open_listref { $_[0]{'curr_open'} ||= [] }
  
  
  sub output_string {
    # Works by faking out output_fh.  Simplifies our code.
    #
    my $this = shift;
    return $this->{'output_string'} unless @_;  # GET.
    
    require Pod::Simple::TiedOutFH;
    my $x = (defined($_[0]) and ref($_[0])) ? $_[0] : \( $_[0] );
    $$x = '' unless defined $$x;
    DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";
    $this->{'output_fh'} = Pod::Simple::TiedOutFH->handle_on($_[0]);
    return
      $this->{'output_string'} = $_[0];
      #${ ${ $this->{'output_fh'} } };
  }
  
  sub abandon_output_string { $_[0]->abandon_output_fh; delete $_[0]{'output_string'} }
  sub abandon_output_fh     { $_[0]->output_fh(undef) }
  # These don't delete the string or close the FH -- they just delete our
  #  references to it/them.
  # TODO: document these
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub new {
    # takes no parameters
    my $class = ref($_[0]) || $_[0];
    #Carp::croak(__PACKAGE__ . " is a virtual base class -- see perldoc "
    #  . __PACKAGE__ );
    return bless {
      'accept_codes'      => { map( ($_=>$_), @Known_formatting_codes ) },
      'accept_directives' => { %Known_directives },
      'accept_targets'    => {},
    }, $class;
  }
  
  
  
  # TODO: an option for whether to interpolate E<...>'s, or just resolve to codes.
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {     # OVERRIDE IN DERIVED CLASS
    my($self, $element_name, $attr_hash_r) = @_;
    return;
  }
  
  sub _handle_element_end {       # OVERRIDE IN DERIVED CLASS
    my($self, $element_name) = @_;
    return;
  }
  
  sub _handle_text          {     # OVERRIDE IN DERIVED CLASS
    my($self, $text) = @_;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now directives (not targets)
  
  sub accept_directive_as_verbatim  { shift->_accept_directives('Verbatim', @_) }
  sub accept_directive_as_data      { shift->_accept_directives('Data',     @_) }
  sub accept_directive_as_processed { shift->_accept_directives('Plain',    @_) }
  
  sub _accept_directives {
    my($this, $type) = splice @_,0,2;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "\"$d\" is already a reserved Pod directive name"
       if exists $Known_directives{$d};
      $this->{'accept_directives'}{$d} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n";
    }
    DEBUG > 6 and print STDERR "$this\'s accept_directives : ",
     pretty($this->{'accept_directives'}), "\n";
    
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  # TODO: document these:
  
  sub unaccept_directive { shift->unaccept_directives(@_) };
  
  sub unaccept_directives {
    my $this = shift;
    foreach my $d (@_) {
      next unless defined $d and length $d;
      Carp::croak "\"$d\" isn't a valid directive name"
       unless $d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;
      Carp::croak "But you must accept \"$d\" directives -- it's a builtin!"
       if exists $Known_directives{$d};
      delete $this->{'accept_directives'}{$d};
      DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n";
    }
    return sort keys %{ $this->{'accept_directives'} } if wantarray;
    return
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now targets (not directives)
  
  sub accept_target         { shift->accept_targets(@_)         } # alias
  sub accept_target_as_text { shift->accept_targets_as_text(@_) } # alias
  
  
  sub accept_targets         { shift->_accept_targets('1', @_) }
  
  sub accept_targets_as_text { shift->_accept_targets('force_resolve', @_) }
   # forces them to be processed, even when there's no ":".
  
  sub _accept_targets {
    my($this, $type) = splice @_,0,2;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      $this->{'accept_targets'}{$t} = $type;
      DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n";
    }    
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_target         { shift->unaccept_targets(@_) }
  
  sub unaccept_targets {
    my $this = shift;
    foreach my $t (@_) {
      next unless defined $t and length $t;
      # TODO: enforce some limitations on what a target name can be?
      delete $this->{'accept_targets'}{$t};
      DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n";
    }    
    return sort keys %{ $this->{'accept_targets'} } if wantarray;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  # And now codes (not targets or directives)
  
  # XXX Probably it is an error that the digit '9' is excluded from these re's.
  # Broken for early Perls on EBCDIC
  my $xml_name_re = eval "qr/[^-.0-8:A-Z_a-z[:^ascii:]]/";
  if (! defined $xml_name_re) {
      $xml_name_re = qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/;
  }
  
  sub accept_code { shift->accept_codes(@_) } # alias
  
  sub accept_codes {  # Add some codes
    my $this = shift;
    
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      $this->{'accept_codes'}{$new_code} = $new_code;
  
      # Yes, map to itself -- just so that when we
      #  see "=extend W [whatever] thatelementname", we say that W maps
      #  to whatever $this->{accept_codes}{thatelementname} is,
      #  i.e., "thatelementname".  Then when we go re-mapping,
      #  a "W" in the treelet turns into "thatelementname".  We only
      #  remap once.
      # If we say we accept "W", then a "W" in the treelet simply turns
      #  into "W".
    }
    
    return;
  }
  
  #--------------------------------------------------------------------------
  sub unaccept_code { shift->unaccept_codes(@_) }
  
  sub unaccept_codes { # remove some codes
    my $this = shift;
    
    foreach my $new_code (@_) {
      next unless defined $new_code and length $new_code;
      # A good-enough check that it's good as an XML Name symbol:
      Carp::croak "\"$new_code\" isn't a valid element name"
        if $new_code =~ $xml_name_re
            # Characters under 0x80 that aren't legal in an XML Name.
        or $new_code =~ m/^[-\.0-9]/s
        or $new_code =~ m/:[-\.0-9]/s;
            # The legal under-0x80 Name characters that
            #  an XML Name still can't start with.
  
      Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!"
       if grep $new_code eq $_, @Known_formatting_codes;
  
      delete $this->{'accept_codes'}{$new_code};
  
      DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n";
    }
    
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_string_document {
    my $self = shift;
    my @lines;
    foreach my $line_group (@_) {
      next unless defined $line_group and length $line_group;
      pos($line_group) = 0;
      while($line_group =~
        m/([^\n\r]*)(\r?\n?)/g # supports \r, \n ,\r\n
        #m/([^\n\r]*)((?:\r?\n)?)/g
      ) {
        #print(">> $1\n"),
        $self->parse_lines($1)
         if length($1) or length($2)
          or pos($line_group) != length($line_group);
         # I.e., unless it's a zero-length "empty line" at the very
         #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
      }
    }
    $self->parse_lines(undef); # to signal EOF
    return $self;
  }
  
  sub _init_fh_source {
    my($self, $source) = @_;
  
    #DEBUG > 1 and print STDERR "Declaring $source as :raw for starters\n";
    #$self->_apply_binmode($source, ':raw');
    #binmode($source, ":raw");
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  #
  
  sub parse_file {
    my($self, $source) = (@_);
  
    if(!defined $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } elsif(ref(\$source) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($source);
    } elsif(ref $source) {
      $self->{'source_filename'} = '' . ($source);
    } elsif(!length $source) {
      Carp::croak("Can't use empty-string as a source for parse_file");
    } else {
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$source") || Carp::croak("Can't open $source: $!");
        $self->{'source_filename'} = $source;
        $source = *PODSOURCE{IO};
      }
      $self->_init_fh_source($source);
    }
    # By here, $source is a FH.
  
    $self->{'source_fh'} = $source;
  
    my($i, @lines);
    until( $self->{'source_dead'} ) {
      splice @lines;
  
      for($i = MANY_LINES; $i--;) {  # read those many lines at a time
        local $/ = $NL;
        push @lines, scalar(<$source>);  # readline
        last unless defined $lines[-1];
         # but pass thru the undef, which will set source_dead to true
      }
  
      my $at_eof = ! $lines[-1]; # keep track of the undef
      pop @lines if $at_eof; # silence warnings
  
      # be eol agnostic
      s/\r\n?/\n/g for @lines;
   
      # make sure there are only one line elements for parse_lines
      @lines = split(/(?<=\n)/, join('', @lines));
  
      # push the undef back after popping it to set source_dead to true
      push @lines, undef if $at_eof;
  
      $self->parse_lines(@lines);
    }
    delete($self->{'source_fh'}); # so it can be GC'd
    return $self;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub parse_from_file {
    # An emulation of Pod::Parser's interface, for the sake of Perldoc.
    # Basically just a wrapper around parse_file.
  
    my($self, $source, $to) = @_;
    $self = $self->new unless ref($self); # so we tolerate being a class method
    
    if(!defined $source)             { $source = *STDIN{IO}
    } elsif(ref(\$source) eq 'GLOB') { # stet
    } elsif(ref($source)           ) { # stet
    } elsif(!length $source
       or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i
    ) { 
      $source = *STDIN{IO};
    }
  
    if(!defined $to) {             $self->output_fh( *STDOUT{IO}   );
    } elsif(ref(\$to) eq 'GLOB') { $self->output_fh( $to );
    } elsif(ref($to)) {            $self->output_fh( $to );
    } elsif(!length $to
       or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i
    ) {
      $self->output_fh( *STDOUT{IO} );
    } elsif($to =~ m/^>&(?:STDERR|2)$/i) {
      $self->output_fh( *STDERR{IO} );
    } else {
      require Symbol;
      my $out_fh = Symbol::gensym();
      DEBUG and print STDERR "Write-opening to $to\n";
      open($out_fh, ">$to")  or  Carp::croak "Can't write-open $to: $!";
      binmode($out_fh)
       if $self->can('write_with_binmode') and $self->write_with_binmode;
      $self->output_fh($out_fh);
    }
  
    return $self->parse_file($source);
  }
  
  #-----------------------------------------------------------------------------
  
  sub whine {
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    if($self->{'no_whining'}) {
      DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";
      return;
    }
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub scream {    # like whine, but not suppressible
    #my($self,$line,$complaint) = @_;
    my $self = shift(@_);
    ++$self->{'errors_seen'};
    push @{$self->{'all_errata'}{$_[0]}}, $_[1];
    return $self->_complain_warn(@_) if $self->{'complain_stderr'};
    return $self->_complain_errata(@_);
  }
  
  sub _complain_warn {
    my($self,$line,$complaint) = @_;
    return printf STDERR "%s around line %s: %s\n",
      $self->{'source_filename'} || 'Pod input', $line, $complaint;
  }
  
  sub _complain_errata {
    my($self,$line,$complaint) = @_;
    if( $self->{'no_errata_section'} ) {
      DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n";
    } else {
      DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";
      push @{$self->{'errata'}{$line}}, $complaint
        # for a report to be generated later!
    }
    return 1;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _get_initial_item_type {
    # A hack-wrapper here for when you have like "=over\n\n=item 456\n\n"
    my($self, $para) = @_;
    return $para->[1]{'~type'}  if $para->[1]{'~type'};
  
    return $para->[1]{'~type'} = 'text'
     if join("\n", @{$para}[2 .. $#$para]) =~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';
    # Else fall thru to the general case:
    return $self->_get_item_type($para);
  }
  
  
  
  sub _get_item_type {       # mutates the item!!
    my($self, $para) = @_;
    return $para->[1]{'~type'} if $para->[1]{'~type'};
  
  
    # Otherwise we haven't yet been to this node.  Maybe alter it...
    
    my $content = join "\n", @{$para}[2 .. $#$para];
  
    if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s) {
      # Like: "=item *", "=item   *   ", "=item"
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      $para->[1]{'~orig_content'} = $content;
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*\*\s+(.+)/s) {  # tolerance
    
      # Like: "=item * Foo bar baz";
      $para->[1]{'~orig_content'}      = $content;
      $para->[1]{'~_freaky_para_hack'} = $1;
      DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'bullet';
  
    } elsif($content =~ m/^\s*(\d+)\.?\s*$/s) {
      # Like: "=item 1.", "=item    123412"
      
      $para->[1]{'~orig_content'} = $content;
      $para->[1]{'number'} = $1;  # Yes, stores the number there!
  
      splice @$para, 2; # so it ends up just being ['=item', { attrhash } ]
      return $para->[1]{'~type'} = 'number';
      
    } else {
      # It's anything else.
      return $para->[1]{'~type'} = 'text';
  
    }
  }
  
  #-----------------------------------------------------------------------------
  
  sub _make_treelet {
    my $self = shift;  # and ($para, $start_line)
    my $treelet;
    if(!@_) {
      return [''];
    } if(ref $_[0] and ref $_[0][0] and $_[0][0][0] eq '~Top') {
      # Hack so we can pass in fake-o pre-cooked paragraphs:
      #  just have the first line be a reference to a ['~Top', {}, ...]
      # We use this feechure in gen_errata and stuff.
  
      DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";
      $treelet = $_[0][0];
      splice @$treelet, 0, 2;  # lop the top off
      return $treelet;
    } else {
      $treelet = $self->_treelet_from_formatting_codes(@_);
    }
    
    if( $self->_remap_sequences($treelet) ) {
      $self->_treat_Zs($treelet);  # Might as well nix these first
      $self->_treat_Ls($treelet);  # L has to precede E and S
      $self->_treat_Es($treelet);
      $self->_treat_Ss($treelet);  # S has to come after E
  
      $self->_wrap_up($treelet); # Nix X's and merge texties
      
    } else {
      DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n";
       # Very common case!
    }
    
    splice @$treelet, 0, 2;  # lop the top off
  
    return $treelet;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _wrap_up {
    my($self, @stack) = @_;
    my $nixx  = $self->{'nix_X_codes'};
    my $merge = $self->{'merge_text' };
    return unless $nixx or $merge;
  
    DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",
     $merge ? (" Merge mode on\n") : (),
     $nixx  ? (" Nix-X mode on\n") : (),
    ;    
    
  
    my($i, $treelet);
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        DEBUG > 3 and print STDERR " Considering child at $i ", pretty($treelet->[$i]), "\n";
        if($nixx and ref $treelet->[$i] and $treelet->[$i][0] eq 'X') {
          DEBUG > 3 and print STDERR "   Nixing X node at $i\n";
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          # no need to back-update the counter just yet
          redo;
  
        } elsif($merge and $i != 2 and  # non-initial
           !ref $treelet->[$i] and !ref $treelet->[$i - 1]
        ) {
          DEBUG > 3 and print STDERR "   Merging ", $i-1,
           ":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";
          $treelet->[$i-1] .= ( splice(@$treelet, $i, 1) )[0];
          DEBUG > 4 and print STDERR "    Now: ", $i-1, ":[$treelet->[$i-1]]\n";
          --$i;
          next; 
          # since we just pulled the possibly last node out from under
          #  ourselves, we can't just redo()
  
        } elsif( ref $treelet->[$i] ) {
          DEBUG > 4 and print STDERR "  Enqueuing ", pretty($treelet->[$i]), " for traversal.\n";
          push @stack, $treelet->[$i];
  
          if($treelet->[$i][0] eq 'L') {
            my $thing;
            foreach my $attrname ('section', 'to') {        
              if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
                unshift @stack, $thing;
                DEBUG > 4 and print STDERR "  +Enqueuing ",
                 pretty( $treelet->[$i][1]{$attrname} ),
                 " as an attribute value to tweak.\n";
              }
            }
          }
        }
      }
    }
    DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";
  
    return;
  }
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _remap_sequences {
    my($self,@stack) = @_;
    
    if(@stack == 1 and @{ $stack[0] } == 3 and !ref $stack[0][2]) {
      # VERY common case: abort it.
      DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";
      return 0;
    }
    
    my $map = ($self->{'accept_codes'} || die "NO accept_codes in $self?!?");
  
    my $start_line = $stack[0][1]{'start_line'};
    DEBUG > 2 and printf
     "\nAbout to start _remap_sequences on treelet from line %s.\n",
     $start_line || '[?]'
    ;
    DEBUG > 3 and print STDERR " Map: ",
      join('; ', map "$_=" . (
          ref($map->{$_}) ? join(",", @{$map->{$_}}) : $map->{$_}
        ),
        sort keys %$map ),
      ("B~C~E~F~I~L~S~X~Z" eq join '~', sort keys %$map)
       ? "  (all normal)\n" : "\n"
    ;
  
    # A recursive algorithm implemented iteratively!  Whee!
    
    my($is, $was, $i, $treelet); # scratch
    while($treelet = shift @stack) {
      DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        
        DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";
        
        $is = $treelet->[$i][0] = $map->{ $was = $treelet->[$i][0] };
        if( DEBUG > 3 ) {
          if(!defined $is) {
            print STDERR "   Code $was<> is UNKNOWN!\n";
          } elsif($is eq $was) {
            DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n";
          } else  {
            print STDERR "   Code $was<> maps to ",
             ref($is)
              ? ( "tags ", map("$_<", @$is), '...', map('>', @$is), "\n" )
              : "tag $is<...>.\n";
          }
        }
        
        if(!defined $is) {
          $self->whine($start_line, "Deleting unknown formatting code $was<>");
          $is = $treelet->[$i][0] = '1';  # But saving the children!
          # I could also insert a leading "$was<" and tailing ">" as
          # children of this node, but something about that seems icky.
        }
        if(ref $is) {
          my @dynasty = @$is;
          DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";
          $treelet->[$i][0] = pop @dynasty;
          my $nugget;
          while(@dynasty) {
            DEBUG > 4 and printf
             "    Grafting a new %s node between %s and %s\n",
             $dynasty[-1], $treelet->[0], $treelet->[$i][0], 
            ;
            
            #$nugget = ;
            splice @$treelet, $i, 1, [pop(@dynasty), {}, $treelet->[$i]];
              # relace node with a new parent
          }
        } elsif($is eq '0') {
          splice(@$treelet, $i, 1); # just nix this node (and its descendants)
          --$i;  # back-update the counter
        } elsif($is eq '1') {
          splice(@$treelet, $i, 1 # replace this node with its children!
            => splice @{ $treelet->[$i] },2
                # (not catching its first two (non-child) items)
          );
          --$i;  # back up for new stuff
        } else {
          # otherwise it's unremarkable
          unshift @stack, $treelet->[$i];  # just recurse
        }
      }
    }
    
    DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";
  
    if(@_ == 2 and @{ $_[1] } == 3 and !ref $_[1][2]) {
      DEBUG and print STDERR "Noting that the treelet is now formatless.\n";
      return 0;
    }
    return 1;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _ponder_extend {
  
    # "Go to an extreme, move back to a more comfortable place"
    #  -- /Oblique Strategies/,  Brian Eno and Peter Schmidt
    
    my($self, $para) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";
  
    if($content =~
      m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs
    ) {
      my $new_letter = $1;
      my $fallbacks_one = $2;
      my $elements_one;
      $elements_one = defined($3) ? $3 : $1;
  
      DEBUG > 2 and print STDERR "Extensor has good syntax.\n";
  
      unless($new_letter =~ m/^[A-Z]$/s or $new_letter) {
        DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can extend only formatting codes A-Z, not like \"$new_letter\""
        );
        return;
      }
      
      if(grep $new_letter eq $_, @Known_formatting_codes) {
        DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You can't extend an established code like \"$new_letter\""
        );
        
        #TODO: or allow if last bit is same?
        
        return;
      }
  
      unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s  # like "B", "M,I", etc.
        or $fallbacks_one eq '0' or $fallbacks_one eq '1'
      ) {
        $self->whine(
          $para->[1]{'start_line'},
          "Format for second =extend parameter must be like"
          . " M or 1 or 0 or M,N or M,N,O but you have it like "
          . $fallbacks_one
        );
        return;
      }
      
      unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s) { # like "B", "M,I", etc.
        $self->whine(
          $para->[1]{'start_line'},
          "Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like "
          . $elements_one
        );
        return;
      }
  
      my @fallbacks  = split ',', $fallbacks_one,  -1;
      my @elements   = split ',', $elements_one, -1;
  
      foreach my $f (@fallbacks) {
        next if exists $Known_formatting_codes{$f} or $f eq '0' or $f eq '1';
        DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";
        $self->whine(
          $para->[1]{'start_line'},
          "Can't use unknown formatting code '$f' as a fallback for '$new_letter'"
        );
        return;
      }
  
      DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",
       @fallbacks, @elements;
  
      my $canonical_form;
      foreach my $e (@elements) {
        if(exists $self->{'accept_codes'}{$e}) {
          DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";
          $canonical_form = $e;
          last; # first acceptable elementname wins!
        } else {
          DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n";
        }
      }
  
  
      if( defined $canonical_form ) {
        # We found a good N => elementname mapping
        $self->{'accept_codes'}{$new_letter} = $canonical_form;
        DEBUG > 2 and print
         "Extensor maps $new_letter => known element $canonical_form.\n";
      } else {
        # We have to use the fallback(s), which might be '0', or '1'.
        $self->{'accept_codes'}{$new_letter}
          = (@fallbacks == 1) ? $fallbacks[0] : \@fallbacks;
        DEBUG > 2 and print
         "Extensor maps $new_letter => fallbacks @fallbacks.\n";
      }
  
    } else {
      DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";
      $self->whine(
        $para->[1]{'start_line'},
        "Unknown =extend syntax: $content"
      )
    }
    return;
  }
  
  
  #:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.:.
  
  sub _treat_Zs {  # Nix Z<...>'s
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for($i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'Z') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
          
        DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";
          
        # bitch UNLESS it's empty
        unless(  @{$treelet->[$i]} == 2
             or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "A non-empty Z<>" );
        }      # but kill it anyway
          
        splice(@$treelet, $i, 1); # thereby just nix this node.
        --$i;
          
      }
    }
    
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  # Quoting perlpodspec:
  
  # In parsing an L<...> code, Pod parsers must distinguish at least four
  # attributes:
  
  ############# Not used.  Expressed via the element children plus
  #############  the value of the "content-implicit" flag.
  # First:
  # The link-text. If there is none, this must be undef. (E.g., in "L<Perl
  # Functions|perlfunc>", the link-text is "Perl Functions". In
  # "L<Time::HiRes>" and even "L<|Time::HiRes>", there is no link text. Note
  # that link text may contain formatting.)
  # 
  
  ############# The element children
  # Second:
  # The possibly inferred link-text -- i.e., if there was no real link text,
  # then this is the text that we'll infer in its place. (E.g., for
  # "L<Getopt::Std>", the inferred link text is "Getopt::Std".)
  #
  
  ############# The "to" attribute (which might be text, or a treelet)
  # Third:
  # The name or URL, or undef if none. (E.g., in "L<Perl
  # Functions|perlfunc>", the name -- also sometimes called the page -- is
  # "perlfunc". In "L</CAVEATS>", the name is undef.)
  # 
  
  ############# The "section" attribute (which might be next, or a treelet)
  # Fourth:
  # The section (AKA "item" in older perlpods), or undef if none. E.g., in
  # Getopt::Std/DESCRIPTION, "DESCRIPTION" is the section. (Note that this
  # is not the same as a manpage section like the "5" in "man 5 crontab".
  # "Section Foo" in the Pod sense means the part of the text that's
  # introduced by the heading or item whose text is "Foo".)
  # 
  # Pod parsers may also note additional attributes including:
  #
  
  ############# The "type" attribute.
  # Fifth:
  # A flag for whether item 3 (if present) is a URL (like
  # "http://lists.perl.org" is), in which case there should be no section
  # attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
  # possibly a man page name (like "crontab(5)" is).
  #
  
  ############# The "raw" attribute that is already there.
  # Sixth:
  # The raw original L<...> content, before text is split on "|", "/", etc,
  # and before E<...> codes are expanded.
  
  
  # For L<...> codes without a "name|" part, only E<...> and Z<> codes may
  # occur -- no other formatting codes. That is, authors should not use
  # "L<B<Foo::Bar>>".
  #
  # Note, however, that formatting codes and Z<>'s can occur in any and all
  # parts of an L<...> (i.e., in name, section, text, and url).
  
  sub _treat_Ls {  # Process our dear dear friends, the L<...> sequences
  
    # L<name>
    # L<name/"sec"> or L<name/sec>
    # L</"sec"> or L</sec> or L<"sec">
    # L<text|name>
    # L<text|name/"sec"> or L<text|name/sec>
    # L<text|/"sec"> or L<text|/sec> or L<text|"sec">
    # L<scheme:...>
    # L<text|scheme:...>
  
    my($self,@stack) = @_;
  
    my($i, $treelet);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) {
        # iterate over children of current tree node
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        unless($treelet->[$i][0] eq 'L') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
        
        
        # By here, $treelet->[$i] is definitely an L node
        my $ell = $treelet->[$i];
        DEBUG > 1 and print STDERR "Ogling L node $ell\n";
          
        # bitch if it's empty
        if(  @{$ell} == 2
         or (@{$ell} == 3 and $ell->[2] eq '')
        ) {
          $self->whine( $start_line, "An empty L<>" );
          $treelet->[$i] = 'L<>';  # just make it a text node
          next;  # and move on
        }
  
        if( (! ref $ell->[2]  && $ell->[2] =~ /\A\s/)
          ||(! ref $ell->[-1] && $ell->[-1] =~ /\s\z/)
        ) {
          $self->whine( $start_line, "L<> starts or ends with whitespace" );
        }
       
        # Catch URLs:
  
        # there are a number of possible cases:
        # 1) text node containing url: http://foo.com
        #   -> [ 'http://foo.com' ]
        # 2) text node containing url and text: foo|http://foo.com
        #   -> [ 'foo|http://foo.com' ]
        # 3) text node containing url start: mailto:xE<at>foo.com
        #   -> [ 'mailto:x', [ E ... ], 'foo.com' ]
        # 4) text node containing url start and text: foo|mailto:xE<at>foo.com
        #   -> [ 'foo|mailto:x', [ E ... ], 'foo.com' ]
        # 5) other nodes containing text and url start: OE<39>Malley|http://foo.com
        #   -> [ 'O', [ E ... ], 'Malley', '|http://foo.com' ]
        # ... etc.
  
        # anything before the url is part of the text.
        # anything after it is part of the url.
        # the url text node itself may contain parts of both.
  
        if (my ($url_index, $text_part, $url_part) =
          # grep is no good here; we want to bail out immediately so that we can
          # use $1, $2, etc. without having to do the match twice.
          sub {
            for (2..$#$ell) {
              next if ref $ell->[$_];
              next unless $ell->[$_] =~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;
              return ($_, $1, $2);
            }
            return;
          }->()
        ) {
          $ell->[1]{'type'} = 'url';
  
          my @text = @{$ell}[2..$url_index-1];
          push @text, $text_part if defined $text_part;
  
          my @url  = @{$ell}[$url_index+1..$#$ell];
          unshift @url, $url_part;
  
          unless (@text) {
            $ell->[1]{'content-implicit'} = 'yes';
            @text = @url;
          }
  
          $ell->[1]{to} = Pod::Simple::LinkSection->new(
            @url == 1
            ? $url[0]
            : [ '', {}, @url ],
          );
  
          splice @$ell, 2, $#$ell, @text;
  
          next;
        }
        
        # Catch some very simple and/or common cases
        if(@{$ell} == 3 and ! ref $ell->[2]) {
          my $it = $ell->[2];
          if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s) { # man sections
            # Hopefully neither too broad nor too restrictive a RE
            DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";
            $ell->[1]{'type'} = 'man';
            # This's the only place where man links can get made.
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
  
            next;
          }
          if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s) {
            # Extremely forgiving idea of what constitutes a bare
            #  modulename link like L<Foo::Bar> or even L<Thing::1.0::Docs::Tralala>
            DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";
            $ell->[1]{'type'} = 'pod';
            $ell->[1]{'content-implicit'} = 'yes';
            $ell->[1]{'to'  } =
              Pod::Simple::LinkSection->new( $it ); # treelet!
            next;
          }
          # else fall thru...
        }
        
        
  
        # ...Uhoh, here's the real L<...> parsing stuff...
        # "With the ill behavior, with the ill behavior, with the ill behavior..."
  
        DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";
        
        
        my $link_text; # set to an arrayref if found
        my @ell_content = @$ell;
        splice @ell_content,0,2; # Knock off the 'L' and {} bits
  
        DEBUG > 3 and print STDERR " Ell content to start: ",
         pretty(@ell_content), "\n";
  
  
        # Look for the "|" -- only in CHILDREN (not all underlings!)
        # Like L<I like the strictness|strict>
        DEBUG > 3 and
           print STDERR "  Peering at L content for a '|' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";
  
          if($ell_content[$j] =~ m/^([^\|]*)\|(.*)$/s) {
            my @link_text = ($1);   # might be 0-length
            $ell_content[$j] = $2;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";
  
            if ($link_text[0] =~ m{[|/]}) {
              $self->whine(
                $start_line,
                "alternative text '$link_text[0]' contains non-escaped | or /"
              );
            }
  
            unshift @link_text, splice @ell_content, 0, $j;
              # leaving only things at J and after
            @ell_content =  grep ref($_)||length($_), @ell_content ;
            $link_text   = [grep ref($_)||length($_), @link_text  ];
            DEBUG > 3 and printf
             "  So link text is %s\n  and remaining ell content is %s\n",
              pretty($link_text), pretty(@ell_content);
            last;
          }
        }
        
        
        # Now look for the "/" -- only in CHILDREN (not all underlings!)
        # And afterward, anything left in @ell_content will be the raw name
        # Like L<Foo::Bar/Object Methods>
        my $section_name;  # set to arrayref if found
        DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";
        for(my $j = 0; $j < @ell_content; ++$j) {
          next if ref $ell_content[$j];
          DEBUG > 3 and
           print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";
  
          if($ell_content[$j] =~ m/^([^\/]*)\/(.*)$/s) {
            my @section_name = ($2); # might be 0-length
            $ell_content[$j] =  $1;  # might be 0-length
  
            DEBUG > 3 and
             print STDERR "     FOUND a '/' in it.",
               "  Splitting to page [...$1] + section [$2...]\n";
  
            push @section_name, splice @ell_content, 1+$j;
              # leaving only things before and including J
            
            @ell_content  = grep ref($_)||length($_), @ell_content  ;
            @section_name = grep ref($_)||length($_), @section_name ;
  
            # Turn L<.../"foo"> into L<.../foo>
            if(@section_name
              and !ref($section_name[0]) and !ref($section_name[-1])
              and $section_name[ 0] =~ m/^\"/s
              and $section_name[-1] =~ m/\"$/s
              and !( # catch weird degenerate case of L<"> !
                @section_name == 1 and $section_name[0] eq '"'
              )
            ) {
              $section_name[ 0] =~ s/^\"//s;
              $section_name[-1] =~ s/\"$//s;
              DEBUG > 3 and
               print STDERR "     Quotes removed: ", pretty(@section_name), "\n";
            } else {
              DEBUG > 3 and
               print STDERR "     No need to remove quotes in ", pretty(@section_name), "\n";
            }
  
            $section_name = \@section_name;
            last;
          }
        }
  
        # Turn L<"Foo Bar"> into L</Foo Bar>
        if(!$section_name and @ell_content
           and !ref($ell_content[0]) and !ref($ell_content[-1])
           and $ell_content[ 0] =~ m/^\"/s
           and $ell_content[-1] =~ m/\"$/s
           and !( # catch weird degenerate case of L<"> !
             @ell_content == 1 and $ell_content[0] eq '"'
           )
        ) {
          $section_name = [splice @ell_content];
          $section_name->[ 0] =~ s/^\"//s;
          $section_name->[-1] =~ s/\"$//s;
        }
  
        # Turn L<Foo Bar> into L</Foo Bar>.
        if(!$section_name and !$link_text and @ell_content
           and grep !ref($_) && m/ /s, @ell_content
        ) {
          $section_name = [splice @ell_content];
          # That's support for the now-deprecated syntax.
          # (Maybe generate a warning eventually?)
          # Note that it deliberately won't work on L<...|Foo Bar>
        }
  
  
        # Now make up the link_text
        # L<Foo>     -> L<Foo|Foo>
        # L</Bar>    -> L<"Bar"|Bar>
        # L<Foo/Bar> -> L<"Bar" in Foo/Foo>
        unless($link_text) {
          $ell->[1]{'content-implicit'} = 'yes';
          $link_text = [];
          push @$link_text, '"', @$section_name, '"' if $section_name;
  
          if(@ell_content) {
            $link_text->[-1] .= ' in ' if $section_name;
            push @$link_text, @ell_content;
          }
        }
  
  
        # And the E resolver will have to deal with all our treeletty things:
  
        if(@ell_content == 1 and !ref($ell_content[0])
           and $ell_content[0] =~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s
        ) {
          $ell->[1]{'type'}    = 'man';
          DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n";
        } else {
          $ell->[1]{'type'}    = 'pod';
          DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n";
        }
  
        if( defined $section_name ) {
          $ell->[1]{'section'} = Pod::Simple::LinkSection->new(
            ['', {}, @$section_name]
          );
          DEBUG > 3 and print STDERR "L-section content: ", pretty($ell->[1]{'section'}), "\n";
        }
  
        if( @ell_content ) {
          $ell->[1]{'to'} = Pod::Simple::LinkSection->new(
            ['', {}, @ell_content]
          );
          DEBUG > 3 and print STDERR "L-to content: ", pretty($ell->[1]{'to'}), "\n";
        }
        
        # And update children to be the link-text:
        @$ell = (@$ell[0,1], defined($link_text) ? splice(@$link_text) : '');
        
        DEBUG > 2 and print STDERR "End of L-parsing for this node $treelet->[$i]\n";
  
        unshift @stack, $treelet->[$i]; # might as well recurse
      }
    }
  
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Es {
    my($self,@stack) = @_;
  
    my($i, $treelet, $content, $replacer, $charnum);
    my $start_line = $stack[0][1]{'start_line'};
  
    # A recursive algorithm implemented iteratively!  Whee!
  
  
    # Has frightening side effects on L nodes' attributes.
  
    #my @ells_to_tweak;
  
    while($treelet = shift @stack) {
      for(my $i = 2; $i < @$treelet; ++$i) { # iterate over children
        next unless ref $treelet->[$i];  # text nodes are uninteresting
        if($treelet->[$i][0] eq 'L') {
          # SPECIAL STUFF for semi-processed L<>'s
          
          my $thing;
          foreach my $attrname ('section', 'to') {        
            if(defined($thing = $treelet->[$i][1]{$attrname}) and ref $thing) {
              unshift @stack, $thing;
              DEBUG > 2 and print STDERR "  Enqueuing ",
               pretty( $treelet->[$i][1]{$attrname} ),
               " as an attribute value to tweak.\n";
            }
          }
          
          unshift @stack, $treelet->[$i]; # recurse
          next;
        } elsif($treelet->[$i][0] ne 'E') {
          unshift @stack, $treelet->[$i]; # recurse
          next;
        }
        
        DEBUG > 1 and print STDERR "Ogling E node ", pretty($treelet->[$i]), "\n";
  
        # bitch if it's empty
        if(  @{$treelet->[$i]} == 2
         or (@{$treelet->[$i]} == 3 and $treelet->[$i][2] eq '')
        ) {
          $self->whine( $start_line, "An empty E<>" );
          $treelet->[$i] = 'E<>'; # splice in a literal
          next;
        }
          
        # bitch if content is weird
        unless(@{$treelet->[$i]} == 3 and !ref($content = $treelet->[$i][2])) {
          $self->whine( $start_line, "An E<...> surrounding strange content" );
          $replacer = $treelet->[$i]; # scratch
          splice(@$treelet, $i, 1,   # fake out a literal
            'E<',
            splice(@$replacer,2), # promote its content
            '>'
          );
          # Don't need to do --$i, as the 'E<' we just added isn't interesting.
          next;
        }
  
        DEBUG > 1 and print STDERR "Ogling E<$content>\n";
  
        # XXX E<>'s contents *should* be a valid char in the scope of the current
        # =encoding directive. Defaults to iso-8859-1, I believe. Fix this in the
        # future sometime.
  
        $charnum  = Pod::Escapes::e2charnum($content);
        DEBUG > 1 and print STDERR " Considering E<$content> with char ",
          defined($charnum) ? $charnum : "undef", ".\n";
  
        if(!defined( $charnum )) {
          DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";
          $self->whine( $start_line, "Unknown E content in E<$content>" );
          $replacer = "E<$content>"; # better than nothing
        } elsif($charnum >= 255 and !UNICODE) {
          $replacer = ASCII ? "\xA4" : "?";
          DEBUG > 1 and print STDERR "This Perl version can't handle ",
            "E<$content> (chr $charnum), so replacing with $replacer\n";
        } else {
          $replacer = Pod::Escapes::e2char($content);
          DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n";
        }
  
        splice(@$treelet, $i, 1, $replacer); # no need to back up $i, tho
      }
    }
  
    return;
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _treat_Ss {
    my($self,$treelet) = @_;
    
    _change_S_to_nbsp($treelet,0) if $self->{'nbsp_for_S'};
  
    # TODO: or a change_nbsp_to_S
    #  Normalizing nbsp's to S is harder: for each text node, make S content
    #  out of anything matching m/([^ \xA0]*(?:\xA0+[^ \xA0]*)+)/
  
  
    return;
  }
  
  sub _change_S_to_nbsp { #  a recursive function
    # Sanely assumes that the top node in the excursion won't be an S node.
    my($treelet, $in_s) = @_;
    
    my $is_s = ('S' eq $treelet->[0]);
    $in_s ||= $is_s; # So in_s is on either by this being an S element,
                     #  or by an ancestor being an S element.
  
    for(my $i = 2; $i < @$treelet; ++$i) {
      if(ref $treelet->[$i]) {
        if( _change_S_to_nbsp( $treelet->[$i], $in_s ) ) {
          my $to_pull_up = $treelet->[$i];
          splice @$to_pull_up,0,2;   # ...leaving just its content
          splice @$treelet, $i, 1, @$to_pull_up;  # Pull up content
          $i +=  @$to_pull_up - 1;   # Make $i skip the pulled-up stuff
        }
      } else {
        $treelet->[$i] =~ s/\s/$Pod::Simple::nbsp/g if $in_s;
         
         # Note that if you apply nbsp_for_S to text, and so turn
         # "foo S<bar baz> quux" into "foo bar&#160;faz quux", you
         # end up with something that fails to say "and don't hyphenate
         # any part of 'bar baz'".  However, hyphenation is such a vexing
         # problem anyway, that most Pod renderers just don't render it
         # at all.  But if you do want to implement hyphenation, I guess
         # that you'd better have nbsp_for_S off.
      }
    }
  
    return $is_s;
  }
  
  #-----------------------------------------------------------------------------
  
  sub _accessorize {  # A simple-minded method-maker
    no strict 'refs';
    foreach my $attrname (@_) {
      next if $attrname =~ m/::/; # a hack
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
        (@_ == 1) ?  $_[0]->{$attrname}
                  : ($_[0]->{$attrname} = $_[1]);
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #=============================================================================
  
  sub filter {
    my($class, $source) = @_;
    my $new = $class->new;
    $new->output_fh(*STDOUT{IO});
    
    if(ref($source || '') eq 'SCALAR') {
      $new->parse_string_document( $$source );
    } elsif(ref($source)) {  # it's a file handle
      $new->parse_file($source);
    } else {  # it's a filename
      $new->parse_file($source);
    }
    
    return $new;
  }
  
  
  #-----------------------------------------------------------------------------
  
  sub _out {
    # For use in testing: Class->_out($source)
    #  returns the transformation of $source
    
    my $class = shift(@_);
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    DEBUG and print STDERR "\n\n", '#' x 76,
     "\nAbout to parse source: {{\n$_[0]\n}}\n\n";
    
    
    my $parser = ref $class && $class->isa(__PACKAGE__) ? $class : $class->new;
    $parser->hide_line_numbers(1);
  
    my $out = '';
    $parser->output_string( \$out );
    DEBUG and print STDERR " _out to ", \$out, "\n";
    
    $mutor->($parser) if $mutor;
  
    $parser->parse_string_document( $_[0] );
    # use Data::Dumper; print STDERR Dumper($parser), "\n";
    return $out;
  }
  
  
  sub _duo {
    # For use in testing: Class->_duo($source1, $source2)
    #  returns the parse trees of $source1 and $source2.
    # Good in things like: &ok( Class->duo(... , ...) );
    
    my $class = shift(@_);
    
    Carp::croak "But $class->_duo is useful only in list context!"
     unless wantarray;
  
    my $mutor = shift(@_) if @_ and ref($_[0] || '') eq 'CODE';
  
    Carp::croak "But $class->_duo takes two parameters, not: @_"
     unless @_ == 2;
  
    my(@out);
    
    while( @_ ) {
      my $parser = $class->new;
  
      push @out, '';
      $parser->output_string( \( $out[-1] ) );
  
      DEBUG and print STDERR " _duo out to ", $parser->output_string(),
        " = $parser->{'output_string'}\n";
  
      $parser->hide_line_numbers(1);
      $mutor->($parser) if $mutor;
      $parser->parse_string_document( shift( @_ ) );
      # use Data::Dumper; print STDERR Dumper($parser), "\n";
    }
  
    return @out;
  }
  
  
  
  #-----------------------------------------------------------------------------
  1;
  __END__
  
  TODO:
  A start_formatting_code and end_formatting_code methods, which in the
  base class call start_L, end_L, start_C, end_C, etc., if they are
  defined.
  
  have the POD FORMATTING ERRORS section note the localtime, and the
  version of Pod::Simple.
  
  option to delete all E<shy>s?
  option to scream if under-0x20 literals are found in the input, or
  under-E<32> E codes are found in the tree. And ditto \x7f-\x9f
  
  Option to turn highbit characters into their compromised form? (applies
  to E parsing too)
  
  TODO: BOM/encoding things.
  
  TODO: ascii-compat things in the XML classes?
  
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;
  #
  # "What's in the box?"  "Pain."
  #
  ###########################################################################
  #
  # This is where all the scary things happen: parsing lines into
  #  paragraphs; and then into directives, verbatims, and then also
  #  turning formatting sequences into treelets.
  #
  # Are you really sure you want to read this code?
  #
  #-----------------------------------------------------------------------------
  #
  # The basic work of this module Pod::Simple::BlackBox is doing the dirty work
  # of parsing Pod into treelets (generally one per non-verbatim paragraph), and
  # to call the proper callbacks on the treelets.
  #
  # Every node in a treelet is a ['name', {attrhash}, ...children...]
  
  use integer; # vroom!
  use strict;
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.32';
  #use constant DEBUG => 7;
  BEGIN {
    require Pod::Simple;
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
  }
  
  # Matches a character iff the character will have a different meaning
  # if we choose CP1252 vs UTF-8 if there is no =encoding line.
  # This is broken for early Perls on non-ASCII platforms.
  my $non_ascii_re = eval "qr/[[:^ascii:]]/";
  $non_ascii_re = qr/[\x80-\xFF]/ if ! defined $non_ascii_re;
  
  my $utf8_bom;
  if (($] ge 5.007_003)) {
    $utf8_bom = "\x{FEFF}";
    utf8::encode($utf8_bom);
  } else {
    $utf8_bom = "\xEF\xBB\xBF";   # No EBCDIC BOM detection for early Perls.
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub parse_line { shift->parse_lines(@_) } # alias
  
  # - - -  Turn back now!  Run away!  - - -
  
  sub parse_lines {             # Usage: $parser->parse_lines(@lines)
    # an undef means end-of-stream
    my $self = shift;
  
    my $code_handler = $self->{'code_handler'};
    my $cut_handler  = $self->{'cut_handler'};
    my $wl_handler   = $self->{'whiteline_handler'};
    $self->{'line_count'} ||= 0;
   
    my $scratch;
  
    DEBUG > 4 and 
     print STDERR "# Parsing starting at line ", $self->{'line_count'}, ".\n";
  
    DEBUG > 5 and
     print STDERR "#  About to parse lines: ",
       join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
  
    my $paras = ($self->{'paras'} ||= []);
     # paragraph buffer.  Because we need to defer processing of =over
     # directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
     # to process this.
    
    $self->{'pod_para_count'} ||= 0;
  
    my $line;
    foreach my $source_line (@_) {
      if( $self->{'source_dead'} ) {
        DEBUG > 4 and print STDERR "# Source is dead.\n";
        last;
      }
  
      unless( defined $source_line ) {
        DEBUG > 4 and print STDERR "# Undef-line seen.\n";
  
        push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
        push @$paras, $paras->[-1], $paras->[-1];
         # So that it definitely fills the buffer.
        $self->{'source_dead'} = 1;
        $self->_ponder_paragraph_buffer;
        next;
      }
  
  
      if( $self->{'line_count'}++ ) {
        ($line = $source_line) =~ tr/\n\r//d;
         # If we don't have two vars, we'll end up with that there
         # tr/// modding the (potentially read-only) original source line!
      
      } else {
        DEBUG > 2 and print STDERR "First line: [$source_line]\n";
  
        if( ($line = $source_line) =~ s/^$utf8_bom//s ) {
          DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
          $self->_handle_encoding_line( "=encoding utf8" );
          delete $self->{'_processed_encoding'};
          $line =~ tr/\n\r//d;
          
        } elsif( $line =~ s/^\xFE\xFF//s ) {
          DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
  
        } elsif( $line =~ s/^\xFF\xFE//s ) {
          DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
          $self->scream(
            $self->{'line_count'},
            "UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
          );
          splice @_;
          push @_, undef;
          next;
  
          # TODO: implement somehow?
          
        } else {
          DEBUG > 2 and print STDERR "First line is BOM-less.\n";
          ($line = $source_line) =~ tr/\n\r//d;
        }
      }
  
      if(!$self->{'parse_characters'} && !$self->{'encoding'}
        && ($self->{'in_pod'} || $line =~ /^=/s)
        && $line =~ /$non_ascii_re/
      ) {
  
        my $encoding;
  
        # No =encoding line, and we are at the first line in the input that
        # contains a non-ascii byte, that is one whose meaning varies depending
        # on whether the file is encoded in UTF-8 or CP1252, which are the two
        # possibilities permitted by the pod spec.  (ASCII is assumed if the
        # file only contains ASCII bytes.)  In order to process this line, we
        # need to figure out what encoding we will use for the file.
        #
        # Strictly speaking ISO 8859-1 (Latin 1) refers to the code points
        # 160-255, but it is used here, as it often colloquially is, to refer to
        # the complete set of code points 0-255, including ASCII (0-127), the C1
        # controls (128-159), and strict Latin 1 (160-255).
        #
        # CP1252 is effectively a superset of Latin 1, because it differs only
        # from colloquial 8859-1 in the C1 controls, which are very unlikely to
        # actually be present in 8859-1 files, so can be used for other purposes
        # without conflict.  CP 1252 uses most of them for graphic characters.
        #
        # Note that all ASCII-range bytes represent their corresponding code
        # points in CP1252 and UTF-8.  In ASCII platform UTF-8 all other code
        # points require multiple (non-ASCII) bytes to represent.  (A separate
        # paragraph for EBCDIC is below.)  The multi-byte representation is
        # quite structured.  If we find an isolated byte that requires multiple
        # bytes to represent in UTF-8, we know that the encoding is not UTF-8.
        # If we find a sequence of bytes that violates the UTF-8 structure, we
        # also can presume the encoding isn't UTF-8, and hence must be 1252.
        #
        # But there are ambiguous cases where we could guess wrong.  If so, the
        # user will end up having to supply an =encoding line.  We use all
        # readily available information to improve our chances of guessing
        # right.  The odds of something not being UTF-8, but still passing a
        # UTF-8 validity test go down very rapidly with increasing length of the
        # sequence.  Therefore we look at all the maximal length non-ascii
        # sequences on the line.  If any of the sequences can't be UTF-8, we
        # quit there and choose CP1252.  If all could be UTF-8, we guess UTF-8.
        #
        # On EBCDIC platforms, the situation is somewhat different.  In
        # UTF-EBCDIC, not only do ASCII-range bytes represent their code points,
        # but so do the bytes that are for the C1 controls.  Recall that these
        # correspond to the unused portion of 8859-1 that 1252 mostly takes
        # over.  That means that there are fewer code points that are
        # represented by multi-bytes.  But, note that the these controls are
        # very unlikely to be in pod text.  So if we encounter one of them, it
        # means that it is quite likely CP1252 and not UTF-8.  The net result is
        # the same code below is used for both platforms.
        while ($line =~ m/($non_ascii_re+)/g) {
          my $non_ascii_seq = $1;
  
          if (length $non_ascii_seq == 1) {
            $encoding = 'CP1252';
            goto guessed;
          } elsif ($] ge 5.007_003) {
  
            # On Perls that have this function, we can see if the sequence is
            # valid UTF-8 or not.
            if (! utf8::decode($non_ascii_seq)) {
              $encoding = 'CP1252';
              goto guessed;
            }
          } elsif (ord("A") == 65) {  # An early Perl, ASCII platform
  
            # Without utf8::decode, it's a lot harder to do a rigorous check
            # (though some early releases had a different function that
            # accomplished the same thing).  Since these are ancient Perls, not
            # likely to be in use today, we take the easy way out, and look at
            # just the first two bytes of the sequence to see if they are the
            # start of a UTF-8 character.  In ASCII UTF-8, continuation bytes
            # must be between 0x80 and 0xBF.  Start bytes can range from 0xC2
            # through 0xFF, but anything above 0xF4 is not Unicode, and hence
            # extremely unlikely to be in a pod.
            if ($non_ascii_seq !~ /^[\xC2-\xF4][\x80-\xBF]/) {
              $encoding = 'CP1252';
              goto guessed;
            }
  
            # We don't bother doing anything special for EBCDIC on early Perls.
            # If there is a solitary variant, CP1252 will be chosen; otherwise
            # UTF-8.
          }
        } # End of loop through all variant sequences on the line
  
        # All sequences in the line could be UTF-8.  Guess that.
        $encoding = 'UTF-8';
  
      guessed:
        $self->_handle_encoding_line( "=encoding $encoding" );
        delete $self->{'_processed_encoding'};
        $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
        my ($word) = $line =~ /(\S*$non_ascii_re\S*)/;
  
        $self->whine(
          $self->{'line_count'},
          "Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
        );
      }
  
      DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";
  
      if(!$self->{'in_pod'}) {
        if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s) {
          if($1 eq 'cut') {
            $self->scream(
              $self->{'line_count'},
              "=cut found outside a pod block.  Skipping to next block."
            );
            
            ## Before there were errata sections in the world, it was
            ## least-pessimal to abort processing the file.  But now we can
            ## just barrel on thru (but still not start a pod block).
            #splice @_;
            #push @_, undef;
            
            next;
          } else {
            $self->{'in_pod'} = $self->{'start_of_pod_block'}
                              = $self->{'last_was_blank'}     = 1;
            # And fall thru to the pod-mode block further down
          }
        } else {
          DEBUG > 5 and print STDERR "# It's a code-line.\n";
          $code_handler->(map $_, $line, $self->{'line_count'}, $self)
           if $code_handler;
          # Note: this may cause code to be processed out of order relative
          #  to pods, but in order relative to cuts.
          
          # Note also that we haven't yet applied the transcoding to $line
          #  by time we call $code_handler!
  
          if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
            # That RE is from perlsyn, section "Plain Old Comments (Not!)",
            #$fname = $2 if defined $2;
            #DEBUG > 1 and defined $2 and print STDERR "# Setting fname to \"$fname\"\n";
            DEBUG > 1 and print STDERR "# Setting nextline to $1\n";
            $self->{'line_count'} = $1 - 1;
          }
          
          next;
        }
      }
      
      # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
      # Else we're in pod mode:
  
      # Apply any necessary transcoding:
      $self->{'_transcoder'} && $self->{'_transcoder'}->($line);
  
      # HERE WE CATCH =encoding EARLY!
      if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
        next if $self->parse_characters;   # Ignore this line
        $line = $self->_handle_encoding_line( $line );
      }
  
      if($line =~ m/^=cut/s) {
        # here ends the pod block, and therefore the previous pod para
        DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";
        $self->{'in_pod'} = 0;
        # ++$self->{'pod_para_count'};
        $self->_ponder_paragraph_buffer();
         # by now it's safe to consider the previous paragraph as done.
        $cut_handler->(map $_, $line, $self->{'line_count'}, $self)
         if $cut_handler;
  
        # TODO: add to docs: Note: this may cause cuts to be processed out
        #  of order relative to pods, but in order relative to code.
        
      } elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
        if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
          $wl_handler->(map $_, $line, $self->{'line_count'}, $self)
            if $wl_handler;
        }
  
        if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
          DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";
          push @{$paras->[-1]}, $line;
        }  # otherwise it's not interesting
        
        if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
          DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n";
        }
        
        $self->{'last_was_blank'} = 1;
        
      } elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
        
        if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(?:\s+|$)(.*)/s) {
          # THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
          my $new = [$1, {'start_line' => $self->{'line_count'}}, $2];
           # Note that in "=head1 foo", the WS is lost.
           # Example: ['=head1', {'start_line' => 123}, ' foo']
          
          ++$self->{'pod_para_count'};
          
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
                  
          push @$paras, $new; # the new incipient paragraph
          DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
          
        } elsif($line =~ m/^\s/s) {
  
          if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
            DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";
            push @{$paras->[-1]}, $line;
          } else {
            ++$self->{'pod_para_count'};
            $self->_ponder_paragraph_buffer();
             # by now it's safe to consider the previous paragraph as done.
            DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";
            push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
          }
        } else {
          ++$self->{'pod_para_count'};
          $self->_ponder_paragraph_buffer();
           # by now it's safe to consider the previous paragraph as done.
          push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
          DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
  
      } else {
        # It's a non-blank line /continuing/ the current para
        if(@$paras) {
          DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";
          push @{$paras->[-1]}, $line;
        } else {
          # Unexpected case!
          die "Continuing a paragraph but \@\$paras is empty?";
        }
        $self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
      }
      
    } # ends the big while loop
  
    DEBUG > 1 and print STDERR (pretty(@$paras), "\n");
    return $self;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_encoding_line {
    my($self, $line) = @_;
    
    return if $self->parse_characters;
  
    # The point of this routine is to set $self->{'_transcoder'} as indicated.
  
    return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
    DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";
  
    my $e    = $1;
    my $orig = $e;
    push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
  
    my $enc_error;
  
    # Cf.   perldoc Encode   and   perldoc Encode::Supported
  
    require Pod::Simple::Transcode;
  
    if( $self->{'encoding'} ) {
      my $norm_current = $self->{'encoding'};
      my $norm_e = $e;
      foreach my $that ($norm_current, $norm_e) {
        $that =  lc($that);
        $that =~ s/[-_]//g;
      }
      if($norm_current eq $norm_e) {
        DEBUG > 1 and print STDERR "The '=encoding $orig' line is ",
         "redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
        $enc_error = '';
         # But that doesn't necessarily mean that the earlier one went okay
      } else {
        $enc_error = "Encoding is already set to " . $self->{'encoding'};
        DEBUG > 1 and print STDERR $enc_error;
      }
    } elsif (
      # OK, let's turn on the encoding
      do {
        DEBUG > 1 and print STDERR " Setting encoding to $e\n";
        $self->{'encoding'} = $e;
        1;
      }
      and $e eq 'HACKRAW'
    ) {
      DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n";
  
    } elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
  
      die($enc_error = "WHAT? _transcoder is already set?!")
       if $self->{'_transcoder'};   # should never happen
      require Pod::Simple::Transcode;
      $self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
      eval {
        my @x = ('', "abc", "123");
        $self->{'_transcoder'}->(@x);
      };
      $@ && die( $enc_error =
        "Really unexpected error setting up encoding $e: $@\nAborting"
      );
      $self->{'detected_encoding'} = $e;
  
    } else {
      my @supported = Pod::Simple::Transcode::->all_encodings;
  
      # Note unsupported, and complain
      DEBUG and print STDERR " Encoding [$e] is unsupported.",
        "\nSupporteds: @supported\n";
      my $suggestion = '';
  
      # Look for a near match:
      my $norm = lc($e);
      $norm =~ tr[-_][]d;
      my $n;
      foreach my $enc (@supported) {
        $n = lc($enc);
        $n =~ tr[-_][]d;
        next unless $n eq $norm;
        $suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
        last;
      }
      my $encmodver = Pod::Simple::Transcode::->encmodver;
      $enc_error = join '' =>
        "This document probably does not appear as it should, because its ",
        "\"=encoding $e\" line calls for an unsupported encoding.",
        $suggestion, "  [$encmodver\'s supported encodings are: @supported]"
      ;
  
      $self->scream( $self->{'line_count'}, $enc_error );
    }
    push @{ $self->{'encoding_command_statuses'} }, $enc_error;
    if (defined($self->{'_processed_encoding'})) {
      # Double declaration.
      $self->scream( $self->{'line_count'}, 'Cannot have multiple =encoding directives');
    }
    $self->{'_processed_encoding'} = $orig;
  
    return $line;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _handle_encoding_second_level {
    # By time this is called, the encoding (if well formed) will already
    #  have been acted one.
    my($self, $para) = @_;
    my @x = @$para;
    my $content = join ' ', splice @x, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
  
    DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";
    
    if (defined($self->{'_processed_encoding'})) {
      #if($content ne $self->{'_processed_encoding'}) {
      #  Could it happen?
      #}
      delete $self->{'_processed_encoding'};
      # It's already been handled.  Check for errors.
      if(! $self->{'encoding_command_statuses'} ) {
        DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n";
      } elsif( $self->{'encoding_command_statuses'}[-1] ) {
        $self->whine( $para->[1]{'start_line'},
          sprintf "Couldn't do %s: %s",
            $self->{'encoding_command_reqs'  }[-1],
            $self->{'encoding_command_statuses'}[-1],
        );
      } else {
        DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n";
      }
      
    } else {
      # Otherwise it's a syntax error
      $self->whine( $para->[1]{'start_line'},
        "Invalid =encoding syntax: $content"
      );
    }
    
    return;
  }
  
  #~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
  
  {
  my $m = -321;   # magic line number
  
  sub _gen_errata {
    my $self = $_[0];
    # Return 0 or more fake-o paragraphs explaining the accumulated
    #  errors on this document.
  
    return() unless $self->{'errata'} and keys %{$self->{'errata'}};
  
    my @out;
    
    foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
      push @out,
        ['=item', {'start_line' => $m}, "Around line $line:"],
        map( ['~Para', {'start_line' => $m, '~cooked' => 1},
          #['~Top', {'start_line' => $m},
          $_
          #]
          ],
          @{$self->{'errata'}{$line}}
        )
      ;
    }
    
    # TODO: report of unknown entities? unrenderable characters?
  
    unshift @out,
      ['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
      ['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
       "Hey! ",
       ['B', {},
        'The above document had some coding errors, which are explained below:'
       ]
      ],
      ['=over',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    push @out, 
      ['=back',  {'start_line' => $m, 'errata' => 1}, ''],
    ;
  
    DEBUG and print STDERR "\n<<\n", pretty(\@out), "\n>>\n\n";
  
    return @out;
  }
  
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  ##############################################################################
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##                         HERE IT BECOMES REALLY SCARY
  ##
  ##  stop reading now stop reading now stop reading now stop reading now stop
  ##
  ##############################################################################
  
  sub _ponder_paragraph_buffer {
  
    # Para-token types as found in the buffer.
    #   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
    #   =over, =back, =item
    #   and the null =pod (to be complained about if over one line)
    #
    # "~data" paragraphs are something we generate at this level, depending on
    # a currently open =over region
  
    # Events fired:  Begin and end for:
    #                   directivename (like head1 .. head4), item, extend,
    #                   for (from =begin...=end, =for),
    #                   over-bullet, over-number, over-text, over-block,
    #                   item-bullet, item-number, item-text,
    #                   Document,
    #                   Data, Para, Verbatim
    #                   B, C, longdirname (TODO -- wha?), etc. for all directives
    # 
  
    my $self = $_[0];
    my $paras;
    return unless @{$paras = $self->{'paras'}};
    my $curr_open = ($self->{'curr_open'} ||= []);
  
    my $scratch;
  
    DEBUG > 10 and print STDERR "# Paragraph buffer: <<", pretty($paras), ">>\n";
  
    # We have something in our buffer.  So apparently the document has started.
    unless($self->{'doc_has_started'}) {
      $self->{'doc_has_started'} = 1;
      
      my $starting_contentless;
      $starting_contentless =
       (
         !@$curr_open  
         and @$paras and ! grep $_->[0] ne '~end', @$paras
          # i.e., if the paras is all ~ends
       )
      ;
      DEBUG and print STDERR "# Starting ",
        $starting_contentless ? 'contentless' : 'contentful',
        " document\n"
      ;
      
      $self->_handle_element_start(
        ($scratch = 'Document'),
        {
          'start_line' => $paras->[0][1]{'start_line'},
          $starting_contentless ? ( 'contentless' => 1 ) : (),
        },
      );
    }
  
    my($para, $para_type);
    while(@$paras) {
      last if @$paras == 1 and
        ( $paras->[0][0] eq '=over' or $paras->[0][0] eq '~Verbatim'
          or $paras->[0][0] eq '=item' )
      ;
      # Those're the three kinds of paragraphs that require lookahead.
      #   Actually, an "=item Foo" inside an <over type=text> region
      #   and any =item inside an <over type=block> region (rare)
      #   don't require any lookahead, but all others (bullets
      #   and numbers) do.
  
  # TODO: whinge about many kinds of directives in non-resolving =for regions?
  # TODO: many?  like what?  =head1 etc?
  
      $para = shift @$paras;
      $para_type = $para->[0];
  
      DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",
        $self->_dump_curr_open(), ")\n";
      
      if($para_type eq '=for') {
        next if $self->_ponder_for($para,$curr_open,$paras);
  
      } elsif($para_type eq '=begin') {
        next if $self->_ponder_begin($para,$curr_open,$paras);
  
      } elsif($para_type eq '=end') {
        next if $self->_ponder_end($para,$curr_open,$paras);
  
      } elsif($para_type eq '~end') { # The virtual end-document signal
        next if $self->_ponder_doc_end($para,$curr_open,$paras);
      }
  
  
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      if(grep $_->[1]{'~ignore'}, @$curr_open) {
        DEBUG > 1 and
         print STDERR "Skipping $para_type paragraph because in ignore mode.\n";
        next;
      }
      #~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
      if($para_type eq '=pod') {
        $self->_ponder_pod($para,$curr_open,$paras);
  
      } elsif($para_type eq '=over') {
        next if $self->_ponder_over($para,$curr_open,$paras);
  
      } elsif($para_type eq '=back') {
        next if $self->_ponder_back($para,$curr_open,$paras);
  
      } else {
  
        # All non-magical codes!!!
        
        # Here we start using $para_type for our own twisted purposes, to
        #  mean how it should get treated, not as what the element name
        #  should be.
  
        DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";
  
        my $i;
  
        # Enforce some =headN discipline
        if($para_type =~ m/^=head\d$/s
           and ! $self->{'accept_heads_anywhere'}
           and @$curr_open
           and $curr_open->[-1][0] eq '=over'
        ) {
          DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";
          $self->whine(
            $para->[1]{'start_line'},
            "You forgot a '=back' before '$para_type'"
          );
          unshift @$paras, ['=back', {}, ''], $para;   # close the =over
          next;
        }
  
  
        if($para_type eq '=item') {
  
          my $over;
          unless(@$curr_open and
                 $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
            $self->whine(
              $para->[1]{'start_line'},
              "'=item' outside of any '=over'"
            );
            unshift @$paras,
              ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
              $para
            ;
            next;
          }
          
          
          my $over_type = $over->[1]{'~type'};
          
          if(!$over_type) {
            # Shouldn't happen1
            die "Typeless over in stack, starting at line "
             . $over->[1]{'start_line'};
  
          } elsif($over_type eq 'block') {
            unless($curr_open->[-1][1]{'~bitched_about'}) {
              $curr_open->[-1][1]{'~bitched_about'} = 1;
              $self->whine(
                $curr_open->[-1][1]{'start_line'},
                "You can't have =items (as at line "
                . $para->[1]{'start_line'}
                . ") unless the first thing after the =over is an =item"
              );
            }
            # Just turn it into a paragraph and reconsider it
            $para->[0] = '~Para';
            unshift @$paras, $para;
            next;
  
          } elsif($over_type eq 'text') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            if($item_type eq 'text') {
              # Nothing special needs doing for 'text'
            } elsif($item_type eq 'number' or $item_type eq 'bullet') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected text after =item, not a $item_type"
              );
              # Undo our clobbering:
              push @$para, $para->[1]{'~orig_content'};
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
            
            # =item-text thingies don't need any assimilation, it seems.
  
          } elsif($over_type eq 'number') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
            
            if($item_type eq 'bullet') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              push @$para, $para->[1]{'~orig_content'};
                # restore the bullet, blocking the assimilation of next para
  
            } elsif($item_type eq 'text') {
              # Hm, it's not numeric.  Correct for this.
              $para->[1]{'number'} = $expected_value;
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item $expected_value'"
              );
              # Text content will still be there and will block next ~Para
  
            } elsif($item_type ne 'number') {
              die "Unknown item type $item_type"; # should never happen
  
            } elsif($expected_value == $para->[1]{'number'}) {
              DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
              
            } else {
              DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
               " instead of the expected value of $expected_value\n";
              $self->whine(
                $para->[1]{'start_line'},
                "You have '=item " . $para->[1]{'number'} .
                "' instead of the expected '=item $expected_value'"
              );
              $para->[1]{'number'} = $expected_value;  # correcting!!
            }
              
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
  
          } elsif($over_type eq 'bullet') {
            my $item_type = $self->_get_item_type($para);
              # That kills the content of the item if it's a number or bullet.
            DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
            
            if($item_type eq 'bullet') {
              # as expected!
  
              if( $para->[1]{'~_freaky_para_hack'} ) {
                DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
                push @$para, delete $para->[1]{'~_freaky_para_hack'};
              }
  
            } elsif($item_type eq 'number') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
              push @$para, $para->[1]{'~orig_content'};
               # and block assimilation of the next paragraph
              delete $para->[1]{'number'};
               # Only a PROPER item-number element is allowed
               #  to have a number attribute.
            } elsif($item_type eq 'text') {
              $self->whine(
                $para->[1]{'start_line'},
                "Expected '=item *'"
              );
               # But doesn't need processing.  But it'll block assimilation
               #  of the next para.
            } else {
              die "Unhandled item type $item_type"; # should never happen
            }
  
            if(@$para == 2) {
              # For the cases where we /didn't/ push to @$para
              if($paras->[0][0] eq '~Para') {
                DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
                push @$para, splice @{shift @$paras},2;
              } else {
                DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
                push @$para, '';  # Just so it's not contentless
              }
            }
  
          } else {
            die "Unhandled =over type \"$over_type\"?";
            # Shouldn't happen!
          }
  
          $para_type = 'Plain';
          $para->[0] .= '-' . $over_type;
          # Whew.  Now fall thru and process it.
  
  
        } elsif($para_type eq '=extend') {
          # Well, might as well implement it here.
          $self->_ponder_extend($para);
          next;  # and skip
        } elsif($para_type eq '=encoding') {
          # Not actually acted on here, but we catch errors here.
          $self->_handle_encoding_second_level($para);
          next unless $self->keep_encoding_directive;
          $para_type = 'Plain';
        } elsif($para_type eq '~Verbatim') {
          $para->[0] = 'Verbatim';
          $para_type = '?Verbatim';
        } elsif($para_type eq '~Para') {
          $para->[0] = 'Para';
          $para_type = '?Plain';
        } elsif($para_type eq 'Data') {
          $para->[0] = 'Data';
          $para_type = '?Data';
        } elsif( $para_type =~ s/^=//s
          and defined( $para_type = $self->{'accept_directives'}{$para_type} )
        ) {
          DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n";
        } else {
          # An unknown directive!
          DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",
           $para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
          ;
          $self->whine(
            $para->[1]{'start_line'},
            "Unknown directive: $para->[0]"
          );
  
          # And maybe treat it as text instead of just letting it go?
          next;
        }
  
        if($para_type =~ s/^\?//s) {
          if(! @$curr_open) {  # usual case
            DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n";
          } else {
            my @fors = grep $_->[0] eq '=for', @$curr_open;
            DEBUG > 1 and print STDERR "Containing fors: ",
              join(',', map $_->[1]{'target'}, @fors), "\n";
            
            if(! @fors) {
              DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n";
              
            #} elsif(grep $_->[1]{'~resolve'}, @fors) {
            #} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
            } elsif( $fors[-1][1]{'~resolve'} ) {
              # Look to the immediately containing for
            
              if($para_type eq 'Data') {
                DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
                $para->[0] = 'Para';
                $para_type = 'Plain';
              } else {
                DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
              }
            } else {
              DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
              $para->[0] = $para_type = 'Data';
            }
          }
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if($para_type eq 'Plain') {
          $self->_ponder_Plain($para);
        } elsif($para_type eq 'Verbatim') {
          $self->_ponder_Verbatim($para);        
        } elsif($para_type eq 'Data') {
          $self->_ponder_Data($para);
        } else {
          die "\$para type is $para_type -- how did that happen?";
          # Shouldn't happen.
        }
  
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        $para->[0] =~ s/^[~=]//s;
  
        DEBUG and print STDERR "\n", pretty($para), "\n";
  
        # traverse the treelet (which might well be just one string scalar)
        $self->{'content_seen'} ||= 1;
        $self->_traverse_treelet_bit(@$para);
      }
    }
    
    return;
  }
  
  ###########################################################################
  # The sub-ponderers...
  
  
  
  sub _ponder_for {
    my ($self,$para,$curr_open,$paras) = @_;
  
    # Fake it out as a begin/end
    my $target;
  
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";
      return 1;
    }
  
    for(my $i = 2; $i < @$para; ++$i) {
      if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
        $target = $1;
        last;
      }
    }
    unless(defined $target) {
      $self->whine(
        $para->[1]{'start_line'},
        "=for without a target?"
      );
      return 1;
    }
    DEBUG > 1 and
     print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";
    
    $para->[0] = 'Data';
    
    unshift @$paras,
      ['=begin',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
      $para,
      ['=end',
        {'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
        $target,
      ],
    ;
    
    return 1;
  }
  
  sub _ponder_begin {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "=begin without a target?"
      );
      DEBUG and print STDERR "Ignoring targetless =begin\n";
      return 1;
    }
    
    my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
    $para->[1]{'title'} = $title if ($title);
    $para->[1]{'target'} = $target;  # without any ':'
    $content = $target; # strip off the title
    
    $content =~ s/^:!/!:/s;
    my $neg;  # whether this is a negation-match
    $neg = 1        if $content =~ s/^!//s;
    my $to_resolve;  # whether to process formatting codes
    $to_resolve = 1 if $content =~ s/^://s;
    
    my $dont_ignore; # whether this target matches us
    
    foreach my $target_name (
      split(',', $content, -1),
      $neg ? () : '*'
    ) {
      DEBUG > 2 and
       print STDERR " Considering whether =begin $content matches $target_name\n";
      next unless $self->{'accept_targets'}{$target_name};
      
      DEBUG > 2 and
       print STDERR "  It DOES match the acceptable target $target_name!\n";
      $to_resolve = 1
        if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
      $dont_ignore = 1;
      $para->[1]{'target_matching'} = $target_name;
      last; # stop looking at other target names
    }
  
    if($neg) {
      if( $dont_ignore ) {
        $dont_ignore = '';
        delete $para->[1]{'target_matching'};
        DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n";
      } else {
        $dont_ignore = 1;
        $para->[1]{'target_matching'} = '!';
        DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n";
      }
    }
  
    $para->[0] = '=for';  # Just what we happen to call these, internally
    $para->[1]{'~really'} ||= '=begin';
    $para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
    $para->[1]{'~resolve'}  = $to_resolve || 0;
  
    DEBUG > 1 and print STDERR " Making note to ", $dont_ignore ? 'not ' : '',
      "ignore contents of this region\n";
    DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",
      ($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
    DEBUG > 1 and print STDERR " (Stack now: ", $self->_dump_curr_open(), ")\n";
  
    push @$curr_open, $para;
    if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n";
    } else {
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_start((my $scratch='for'), $para->[1]);
    }
  
    return 1;
  }
  
  sub _ponder_end {
    my ($self,$para,$curr_open,$paras) = @_;
    my $content = join ' ', splice @$para, 2;
    $content =~ s/^\s+//s;
    $content =~ s/\s+$//s;
    DEBUG and print STDERR "Ogling '=end $content' directive\n";
  
    unless(length($content)) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=end' without a target?" . (
          ( @$curr_open and $curr_open->[-1][0] eq '=for' )
          ? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
          : ''
        )
      );
      DEBUG and print STDERR "Ignoring targetless =end\n";
      return 1;
    }
    
    unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
      $self->whine(
        $para->[1]{'start_line'},
        "'=end $content' is invalid.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
    
    unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content without matching =begin.  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content\n";
      return 1;
    }
    
    unless($content eq $curr_open->[-1][1]{'target'}) {
      $self->whine(
        $para->[1]{'start_line'},
        "=end $content doesn't match =begin " 
        . $curr_open->[-1][1]{'target'}
        . ".  (Stack: "
        . $self->_dump_curr_open() . ')'
      );
      DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
      return 1;
    }
  
    # Else it's okay to close...
    if(grep $_->[1]{'~ignore'}, @$curr_open) {
      DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n";
      # And that may be because of this to-be-closed =for region, or some
      #  other one, but it doesn't matter.
    } else {
      $curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
        # what's that for?
      
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_end( my $scratch = 'for', $para->[1]);
    }
    DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
    pop @$curr_open;
  
    return 1;
  } 
  
  sub _ponder_doc_end {
    my ($self,$para,$curr_open,$paras) = @_;
    if(@$curr_open) { # Deal with things left open
      DEBUG and print STDERR "Stack is nonempty at end-document: (",
        $self->_dump_curr_open(), ")\n";
        
      DEBUG > 9 and print STDERR "Stack: ", pretty($curr_open), "\n";
      unshift @$paras, $self->_closers_for_all_curr_open;
      # Make sure there is exactly one ~end in the parastack, at the end:
      @$paras = grep $_->[0] ne '~end', @$paras;
      push @$paras, $para, $para;
       # We need two -- once for the next cycle where we
       #  generate errata, and then another to be at the end
       #  when that loop back around to process the errata.
      return 1;
      
    } else {
      DEBUG and print STDERR "Okay, stack is empty now.\n";
    }
    
    # Try generating errata section, if applicable
    unless($self->{'~tried_gen_errata'}) {
      $self->{'~tried_gen_errata'} = 1;
      my @extras = $self->_gen_errata();
      if(@extras) {
        unshift @$paras, @extras;
        DEBUG and print STDERR "Generated errata... relooping...\n";
        return 1;  # I.e., loop around again to process these fake-o paragraphs
      }
    }
    
    splice @$paras; # Well, that's that for this paragraph buffer.
    DEBUG and print STDERR "Throwing end-document event.\n";
  
    $self->_handle_element_end( my $scratch = 'Document' );
    return 1; # Hasta la byebye
  }
  
  sub _ponder_pod {
    my ($self,$para,$curr_open,$paras) = @_;
    $self->whine(
      $para->[1]{'start_line'},
      "=pod directives shouldn't be over one line long!  Ignoring all "
       . (@$para - 2) . " lines of content"
    ) if @$para > 3;
  
    # Content ignored unless 'pod_handler' is set
    if (my $pod_handler = $self->{'pod_handler'}) {
        my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
        $line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
        $pod_handler->($line, $line_num, $self);
    }
  
    # The surrounding methods set content_seen, so let us remain consistent.
    # I do not know why it was not here before -- should it not be here?
    # $self->{'content_seen'} ||= 1;
  
    return;
  }
  
  sub _ponder_over {
    my ($self,$para,$curr_open,$paras) = @_;
    return 1 unless @$paras;
    my $list_type;
  
    if($paras->[0][0] eq '=item') { # most common case
      $list_type = $self->_get_initial_item_type($paras->[0]);
  
    } elsif($paras->[0][0] eq '=back') {
      # Ignore empty lists by default
      if ($self->{'parse_empty_lists'}) {
        $list_type = 'empty';
      } else {
        shift @$paras;
        return 1;
      }
    } elsif($paras->[0][0] eq '~end') {
      $self->whine(
        $para->[1]{'start_line'},
        "=over is the last thing in the document?!"
      );
      return 1; # But feh, ignore it.
    } else {
      $list_type = 'block';
    }
    $para->[1]{'~type'} = $list_type;
    push @$curr_open, $para;
     # yes, we reuse the paragraph as a stack item
    
    my $content = join ' ', splice @$para, 2;
    my $overness;
    if($content =~ m/^\s*$/s) {
      $para->[1]{'indent'} = 4;
    } elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
      no integer;
      $para->[1]{'indent'} = $1;
      if($1 == 0) {
        $self->whine(
          $para->[1]{'start_line'},
          "Can't have a 0 in =over $content"
        );
        $para->[1]{'indent'} = 4;
      }
    } else {
      $self->whine(
        $para->[1]{'start_line'},
        "=over should be: '=over' or '=over positive_number'"
      );
      $para->[1]{'indent'} = 4;
    }
    DEBUG > 1 and print STDERR "=over found of type $list_type\n";
    
    $self->{'content_seen'} ||= 1;
    $self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
  
    return;
  }
        
  sub _ponder_back {
    my ($self,$para,$curr_open,$paras) = @_;
    # TODO: fire off </item-number> or </item-bullet> or </item-text> ??
  
    my $content = join ' ', splice @$para, 2;
    if($content =~ m/\S/) {
      $self->whine(
        $para->[1]{'start_line'},
        "=back doesn't take any parameters, but you said =back $content"
      );
    }
  
    if(@$curr_open and $curr_open->[-1][0] eq '=over') {
      DEBUG > 1 and print STDERR "=back happily closes matching =over\n";
      # Expected case: we're closing the most recently opened thing
      #my $over = pop @$curr_open;
      $self->{'content_seen'} ||= 1;
      $self->_handle_element_end( my $scratch =
        'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
      );
    } else {
      DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",
          join(', ', map $_->[0], @$curr_open), ").\n";
      $self->whine(
        $para->[1]{'start_line'},
        '=back without =over'
      );
      return 1; # and ignore it
    }
  }
  
  sub _ponder_item {
    my ($self,$para,$curr_open,$paras) = @_;
    my $over;
    unless(@$curr_open and
           $over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
      $self->whine(
        $para->[1]{'start_line'},
        "'=item' outside of any '=over'"
      );
      unshift @$paras,
        ['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
        $para
      ;
      return 1;
    }
    
    
    my $over_type = $over->[1]{'~type'};
    
    if(!$over_type) {
      # Shouldn't happen1
      die "Typeless over in stack, starting at line "
       . $over->[1]{'start_line'};
  
    } elsif($over_type eq 'block') {
      unless($curr_open->[-1][1]{'~bitched_about'}) {
        $curr_open->[-1][1]{'~bitched_about'} = 1;
        $self->whine(
          $curr_open->[-1][1]{'start_line'},
          "You can't have =items (as at line "
          . $para->[1]{'start_line'}
          . ") unless the first thing after the =over is an =item"
        );
      }
      # Just turn it into a paragraph and reconsider it
      $para->[0] = '~Para';
      unshift @$paras, $para;
      return 1;
  
    } elsif($over_type eq 'text') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      if($item_type eq 'text') {
        # Nothing special needs doing for 'text'
      } elsif($item_type eq 'number' or $item_type eq 'bullet') {
        $self->whine(
            $para->[1]{'start_line'},
            "Expected text after =item, not a $item_type"
        );
        # Undo our clobbering:
        push @$para, $para->[1]{'~orig_content'};
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
      
      # =item-text thingies don't need any assimilation, it seems.
  
    } elsif($over_type eq 'number') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
      
      if($item_type eq 'bullet') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        push @$para, $para->[1]{'~orig_content'};
          # restore the bullet, blocking the assimilation of next para
  
      } elsif($item_type eq 'text') {
        # Hm, it's not numeric.  Correct for this.
        $para->[1]{'number'} = $expected_value;
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item $expected_value'"
        );
        # Text content will still be there and will block next ~Para
  
      } elsif($item_type ne 'number') {
        die "Unknown item type $item_type"; # should never happen
  
      } elsif($expected_value == $para->[1]{'number'}) {
        DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n";
        
      } else {
        DEBUG > 1 and print STDERR " Numeric item has ", $para->[1]{'number'},
         " instead of the expected value of $expected_value\n";
        $self->whine(
          $para->[1]{'start_line'},
          "You have '=item " . $para->[1]{'number'} .
          "' instead of the expected '=item $expected_value'"
        );
        $para->[1]{'number'} = $expected_value;  # correcting!!
      }
        
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
  
    } elsif($over_type eq 'bullet') {
      my $item_type = $self->_get_item_type($para);
        # That kills the content of the item if it's a number or bullet.
      DEBUG and print STDERR " Item is of type ", $para->[0], " under $over_type\n";
      
      if($item_type eq 'bullet') {
        # as expected!
  
        if( $para->[1]{'~_freaky_para_hack'} ) {
          DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";
          push @$para, delete $para->[1]{'~_freaky_para_hack'};
        }
  
      } elsif($item_type eq 'number') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
        push @$para, $para->[1]{'~orig_content'};
         # and block assimilation of the next paragraph
        delete $para->[1]{'number'};
         # Only a PROPER item-number element is allowed
         #  to have a number attribute.
      } elsif($item_type eq 'text') {
        $self->whine(
          $para->[1]{'start_line'},
          "Expected '=item *'"
        );
         # But doesn't need processing.  But it'll block assimilation
         #  of the next para.
      } else {
        die "Unhandled item type $item_type"; # should never happen
      }
  
      if(@$para == 2) {
        # For the cases where we /didn't/ push to @$para
        if($paras->[0][0] eq '~Para') {
          DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";
          push @$para, splice @{shift @$paras},2;
        } else {
          DEBUG and print STDERR "Can't assimilate following ", $paras->[0][0], "\n";
          push @$para, '';  # Just so it's not contentless
        }
      }
  
    } else {
      die "Unhandled =over type \"$over_type\"?";
      # Shouldn't happen!
    }
    $para->[0] .= '-' . $over_type;
  
    return;
  }
  
  sub _ponder_Plain {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving plain treatment...\n";
    unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
      or $para->[1]{'~cooked'}
    ) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}
      )};
    }
    # Empty paragraphs don't need a treelet for any reason I can see.
    # And precooked paragraphs already have a treelet.
    return;
  }
  
  sub _ponder_Verbatim {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving verbatim treatment...\n";
  
    $para->[1]{'xml:space'} = 'preserve';
  
    my $indent = $self->strip_verbatim_indent;
    if ($indent && ref $indent eq 'CODE') {
        my @shifted = (shift @{$para}, shift @{$para});
        $indent = $indent->($para);
        unshift @{$para}, @shifted;
    }
  
    for(my $i = 2; $i < @$para; $i++) {
      foreach my $line ($para->[$i]) { # just for aliasing
        # Strip indentation.
        $line =~ s/^\Q$indent// if $indent
            && !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
        while( $line =~
          # Sort of adapted from Text::Tabs -- yes, it's hardwired in that
          # tabs are at every EIGHTH column.  For portability, it has to be
          # one setting everywhere, and 8th wins.
          s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e
        ) {}
  
        # TODO: whinge about (or otherwise treat) unindented or overlong lines
  
      }
    }
    
    # Now the VerbatimFormatted hoodoo...
    if( $self->{'accept_codes'} and
        $self->{'accept_codes'}{'VerbatimFormatted'}
    ) {
      while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
       # Kill any number of terminal newlines
      $self->_verbatim_format($para);
    } elsif ($self->{'codes_in_verbatim'}) {
      push @$para,
      @{$self->_make_treelet(
        join("\n", splice(@$para, 2)),
        $para->[1]{'start_line'}, $para->[1]{'xml:space'}
      )};
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    } else {
      push @$para, join "\n", splice(@$para, 2) if @$para > 3;
      $para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
    }
    return;
  }
  
  sub _ponder_Data {
    my ($self,$para) = @_;
    DEBUG and print STDERR " giving data treatment...\n";
    $para->[1]{'xml:space'} = 'preserve';
    push @$para, join "\n", splice(@$para, 2) if @$para > 3;
    return;
  }
  
  
  
  
  ###########################################################################
  
  sub _traverse_treelet_bit {  # for use only by the routine above
    my($self, $name) = splice @_,0,2;
  
    my $scratch;
    $self->_handle_element_start(($scratch=$name), shift @_);
    
    while (@_) {
      my $x = shift;
      if (ref($x)) {
        &_traverse_treelet_bit($self, @$x);
      } else {
        $x .= shift while @_ && !ref($_[0]);
        $self->_handle_text($x);
      }
    }
    
    $self->_handle_element_end($scratch=$name);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _closers_for_all_curr_open {
    my $self = $_[0];
    my @closers;
    foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
      my @copy = @$still_open;
      $copy[1] = {%{ $copy[1] }};
      #$copy[1]{'start_line'} = -1;
      if($copy[0] eq '=for') {
        $copy[0] = '=end';
      } elsif($copy[0] eq '=over') {
        $self->whine(
          $still_open->[1]{start_line} ,
          "=over without closing =back"
        );
  
        $copy[0] = '=back';
      } else {
        die "I don't know how to auto-close an open $copy[0] region";
      }
  
      unless( @copy > 2 ) {
        push @copy, $copy[1]{'target'};
        $copy[-1] = '' unless defined $copy[-1];
         # since =over's don't have targets
      }
  
      $copy[1]{'fake-closer'} = 1;
  
      DEBUG and print STDERR "Queuing up fake-o event: ", pretty(\@copy), "\n";
      unshift @closers, \@copy;
    }
    return @closers;
  }
  
  #--------------------------------------------------------------------------
  
  sub _verbatim_format {
    my($it, $p) = @_;
    
    my $formatting;
  
    for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
      DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";
      $p->[$i] .= "\n";
       # Unlike with simple Verbatim blocks, we don't end up just doing
       # a join("\n", ...) on the contents, so we have to append a
       # newline to ever line, and then nix the last one later.
    }
  
    if( DEBUG > 4 ) {
      print STDERR "<<\n";
      for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
        print STDERR "_verbatim_format $i: $p->[$i]";
      }
      print STDERR ">>\n";
    }
  
    for(my $i = $#$p; $i > 2; $i--) {
      # work backwards over the lines, except the first (#2)
      
      #next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
      #        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
       # look at a formatty line preceding a nonformatty one
      DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";
      if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
        DEBUG > 5 and print STDERR "  It's a formatty line.  ",
         "Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
        
        if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
          DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";
          next;
        } else {
          DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n";
        }
      } else {
        DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";
        next;
      }
  
      # A formatty line has to have #: in the first two columns, and uses
      # "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
      # Example:
      #   What do you want?  i like pie. [or whatever]
      # #:^^^^^^^^^^^^^^^^^              /////////////         
      
  
      DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
      
      $formatting = '  ' . $1;
      $formatting =~ s/\s+$//s; # nix trailing whitespace
      unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
        splice @$p,$i,1; # remove this line
        $i--; # don't consider next line
        next;
      }
  
      if( length($formatting) >= length($p->[$i-1]) ) {
        $formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
      } else {
        $formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
      }
      # Make $formatting and the previous line be exactly the same length,
      # with $formatting having a " " as the last character.
   
      DEBUG > 4 and print STDERR "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
  
  
      my @new_line;
      while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
        #print STDERR "Format matches $1\n";
  
        if($2) {
          #print STDERR "SKIPPING <$2>\n";
          push @new_line,
            substr($p->[$i-1], pos($formatting)-length($1), length($1));
        } else {
          #print STDERR "SNARING $+\n";
          push @new_line, [
            (
              $3 ? 'VerbatimB'  :
              $4 ? 'VerbatimI'  :
              $5 ? 'VerbatimBI' : die("Should never get called")
            ), {},
            substr($p->[$i-1], pos($formatting)-length($1), length($1))
          ];
          #print STDERR "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
        }
      }
      my @nixed =    
        splice @$p, $i-1, 2, @new_line; # replace myself and the next line
      DEBUG > 10 and print STDERR "Nixed count: ", scalar(@nixed), "\n";
      
      DEBUG > 6 and print STDERR "New version of the above line is these tokens (",
        scalar(@new_line), "):",
        map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
      $i--; # So the next line we scrutinize is the line before the one
            #  that we just went and formatted
    }
  
    $p->[0] = 'VerbatimFormatted';
  
    # Collapse adjacent text nodes, just for kicks.
    for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
      if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
        DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
        $p->[$i] .= splice @$p, $i+1, 1; # merge
        --$i;  # and back up
      }
    }
  
    # Now look for the last text token, and remove the terminal newline
    for( my $i = $#$p; $i >= 2; $i-- ) {
      # work backwards over the tokens, even the first
      if( !ref($p->[$i]) ) {
        if($p->[$i] =~ s/\n$//s) {
          DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
        } else {
          DEBUG > 5 and print STDERR
           "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
        }
        last; # we only want the next one
      }
    }
  
    return;
  }
  
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  
  sub _treelet_from_formatting_codes {
    # Given a paragraph, returns a treelet.  Full of scary tokenizing code.
    #  Like [ '~Top', {'start_line' => $start_line},
    #            "I like ",
    #            [ 'B', {}, "pie" ],
    #            "!"
    #       ]
    
    my($self, $para, $start_line, $preserve_space) = @_;
    
    my $treelet = ['~Top', {'start_line' => $start_line},];
    
    unless ($preserve_space || $self->{'preserve_whitespace'}) {
      $para =~ s/\s+/ /g; # collapse and trim all whitespace first.
      $para =~ s/ $//;
      $para =~ s/^ //;
    }
    
    # Only apparent problem the above code is that N<<  >> turns into
    # N<< >>.  But then, word wrapping does that too!  So don't do that!
    
    my @stack;
    my @lineage = ($treelet);
    my $raw = ''; # raw content of L<> fcode before splitting/processing
      # XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
      # into just 1 ' '. Is this the regex's doing or 'raw's?
    my $inL = 0;
  
    DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";
   
    # Here begins our frightening tokenizer RE.  The following regex matches
    # text in four main parts:
    #
    #  * Start-codes.  The first alternative matches C< or C<<, the latter
    #    followed by some whitespace.  $1 will hold the entire start code
    #    (including any space following a multiple-angle-bracket delimiter),
    #    and $2 will hold only the additional brackets past the first in a
    #    multiple-bracket delimiter.  length($2) + 1 will be the number of
    #    closing brackets we have to find.
    #
    #  * Closing brackets.  Match some amount of whitespace followed by
    #    multiple close brackets.  The logic to see if this closes anything
    #    is down below.  Note that in order to parse C<<  >> correctly, we
    #    have to use look-behind (?<=\s\s), since the match of the starting
    #    code will have consumed the whitespace.
    #
    #  * A single closing bracket, to close a simple code like C<>.
    #
    #  * Something that isn't a start or end code.  We have to be careful
    #    about accepting whitespace, since perlpodspec says that any whitespace
    #    before a multiple-bracket closing delimiter should be ignored.
    #
    while($para =~
      m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo
    ) {
      DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";
      if(defined $1) {
        if(defined $2) {
          DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";
          push @stack, length($2) + 1; 
            # length of the necessary complex end-code string
        } else {
          DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";
          push @stack, 0;  # signal that we're looking for simple
        }
        push @lineage, [ substr($1,0,1), {}, ];  # new node object
        push @{ $lineage[-2] }, $lineage[-1];
        if ('L' eq substr($1,0,1)) {
          $raw = $inL ? $raw.$1 : ''; # reset raw content accumulator
          $inL = 1;
        } else {
          $raw .= $1 if $inL;
        }
  
      } elsif(defined $4) {
        DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";
        # This is where it gets messy...
        if(! @stack) {
          # We saw " >>>>" but needed nothing.  This is ALL just stuff then.
          DEBUG > 4 and print STDERR " But it's really just stuff.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        } elsif(!$stack[-1]) {
          # We saw " >>>>" but needed only ">".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";
          push @{ $lineage[-1] }, $3; # That was a for-real space, too.
          pos($para) = pos($para) - length($4) + 1;
        } elsif($stack[-1] == length($4)) {
          # We found " >>>>", and it was exactly what we needed.  Commonest case.
          DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n";
        } elsif($stack[-1] < length($4)) {
          # We saw " >>>>" but needed only " >>".  Back pos up.
          DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";
          pos($para) = pos($para) - length($4) + $stack[-1];
        } else {
          # We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
          DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";
          push @{ $lineage[-1] }, $3, $4;
          next;
        }
        #print STDERR "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
  
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Keep the element from being childless
        
        pop @stack;
        pop @lineage;
  
        unless (@stack) { # not in an L if there are no open fcodes
          $inL = 0;
          if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
            $lineage[-1][-1][1]{'raw'} = $raw
          }
        }
        $raw .= $3.$4 if $inL;
        
      } elsif(defined $5) {
        DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";
  
        if(@stack and ! $stack[-1]) {
          # We're indeed expecting a simple end-code
          DEBUG > 4 and print STDERR " It's indeed an end-code.\n";
  
          if(length($5) == 2) { # There was a space there: " >"
            push @{ $lineage[-1] }, ' ';
          } elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
            push @{ $lineage[-1] }, ''; # keep it from being really childless
          }
  
          pop @stack;
          pop @lineage;
        } else {
          DEBUG > 4 and print STDERR " It's just stuff.\n";
          push @{ $lineage[-1] }, $5;
        }
  
        unless (@stack) { # not in an L if there are no open fcodes
          $inL = 0;
          if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
            $lineage[-1][-1][1]{'raw'} = $raw
          }
        }
        $raw .= $5 if $inL;
  
      } elsif(defined $6) {
        DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";
        push @{ $lineage[-1] }, $6;
        $raw .= $6 if $inL;
          # XXX does not capture multiplace whitespaces -- 'raw' ends up with
          #     at most 1 leading/trailing whitespace, why not all of it?
  
      } else {
        # should never ever ever ever happen
        DEBUG and print STDERR "AYYAYAAAAA at line ", __LINE__, "\n";
        die "SPORK 512512!";
      }
    }
  
    if(@stack) { # Uhoh, some sequences weren't closed.
      my $x= "...";
      while(@stack) {
        push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
        # Hmmmmm!
  
        my $code         = (pop @lineage)->[0];
        my $ender_length =  pop @stack;
        if($ender_length) {
          --$ender_length;
          $x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
        } else {
          $x = $code . "<$x>";
        }
      }
      DEBUG > 1 and print STDERR "Unterminated $x sequence\n";
      $self->whine($start_line,
        "Unterminated $x sequence",
      );
    }
  
    return $treelet;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
    return stringify_lol($_[1]);
  }
  
  sub stringify_lol {  # function: stringify_lol($lol)
    my $string_form = '';
    _stringify_lol( $_[0] => \$string_form );
    return $string_form;
  }
  
  sub _stringify_lol {  # the real recursor
    my($lol, $to) = @_;
    for(my $i = 2; $i < @$lol; ++$i) {
      if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
        _stringify_lol( $lol->[$i], $to);  # recurse!
      } else {
        $$to .= $lol->[$i];
      }
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _dump_curr_open { # return a string representation of the stack
    my $curr_open = $_[0]{'curr_open'};
  
    return '[empty]' unless @$curr_open;
    return join '; ',
      map {;
             ($_->[0] eq '=for')
               ? ( ($_->[1]{'~really'} || '=over')
                 . ' ' . $_->[1]{'target'})
               : $_->[0]
          }
      @$curr_open
    ;
  }
  
  ###########################################################################
  my %pretty_form = (
    "\a" => '\a', # ding!
    "\b" => '\b', # BS
    "\e" => '\e', # ESC
    "\f" => '\f', # FF
    "\t" => '\t', # tab
    "\cm" => '\cm',
    "\cj" => '\cj',
    "\n" => '\n', # probably overrides one of either \cm or \cj
    '"' => '\"',
    '\\' => '\\\\',
    '$' => '\\$',
    '@' => '\\@',
    '%' => '\\%',
    '#' => '\\#',
  );
  
  sub pretty { # adopted from Class::Classless
    # Not the most brilliant routine, but passable.
    # Don't give it a cyclic data structure!
    my @stuff = @_; # copy
    my $x;
    my $out =
      # join ",\n" .
      join ", ",
      map {;
      if(!defined($_)) {
        "undef";
      } elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
        $x = "[ " . pretty(@$_) . " ]" ;
        $x;
      } elsif(ref($_) eq 'SCALAR') {
        $x = "\\" . pretty($$_) ;
        $x;
      } elsif(ref($_) eq 'HASH') {
        my $hr = $_;
        $x = "{" . join(", ",
          map(pretty($_) . '=>' . pretty($hr->{$_}),
              sort keys %$hr ) ) . "}" ;
        $x;
      } elsif(!length($_)) { q{''} # empty string
      } elsif(
        $_ eq '0' # very common case
        or(
           m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
           and $_ ne '-0' # the strange case that RE lets thru
        )
      ) { $_;
      } else {
          # Yes, explicitly name every character desired. There are shorcuts one
          # could make, but I (Karl Williamson) was afraid that some Perl
          # releases would have bugs in some of them. For example [A-Z] works
          # even on EBCDIC platforms to match exactly the 26 uppercase English
          # letters, but I don't know if it has always worked without bugs. It
          # seemed safest just to list the characters.
          # s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
          s<([^ !#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
           #<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
        qq{"$_"};
      }
    } @stuff;
    # $out =~ s/\n */ /g if length($out) < 75;
    return $out;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # A rather unsubtle method of blowing away all the state information
  # from a parser object so it can be reused. Provided as a utility for
  # backward compatibility in Pod::Man, etc. but not recommended for
  # general use.
  
  sub reinit {
    my $self = shift;
    foreach (qw(source_dead source_filename doc_has_started
  start_of_pod_block content_seen last_was_blank paras curr_open
  line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen
  Title)) {
  
      delete $self->{$_};
    }
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  
  # A quite dimwitted pod2plaintext that need only know how to format whatever
  # text comes out of Pod::BlackBox's _gen_errata
  
  require 5;
  package Pod::Simple::Checker;
  use strict;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION );
  $VERSION = '3.32';
  @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 (); # was 2001.0131, but I don't think we need that
  $Text::Wrap::wrap = 'overflow';
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub any_errata_seen {  # read-only accessor
    return $_[1]->{'Errata_seen'};
  }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    $new->{'Errata_seen'} = 0;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Errata_seen'} and $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  
  sub start_head1 {
    if($_[0]{'Errata_seen'}) {
      $_[0]{'Thispara'} = '';
    } else {
      if($_[1]{'errata'}) { # start of errata!
        $_[0]{'Errata_seen'} = 1;
        $_[0]{'Thispara'} = $_[0]{'source_filename'} ?
          "$_[0]{'source_filename'} -- " : ''
      }
    }
  }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = '* ' }
  sub start_item_number { $_[0]{'Thispara'} = "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  
  sub emit_par {
    return unless $_[0]{'Errata_seen'};
    my($self, $tweak_indent) = splice(@_,0,2);
    my $indent = ' ' x ( 2 * $self->{'Indent'} + ($tweak_indent||0) );
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out,
      #"\n"
    ;
    $self->{'Thispara'} = '';
    
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    return unless $_[0]{'Errata_seen'};
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    
    $self->{'Thispara'} =~ s/^/$i/mg;
    
    print { $self->{'output_fh'} }   '', 
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Checker -- check the Pod syntax of a document
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Checker -e \
     "exit Pod::Simple::Checker->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for checking the syntactic validity of Pod.
  It works by basically acting like a simple-minded version of
  L<Pod::Simple::Text> that formats only the "Pod Errors" section
  (if Pod::Simple even generates one for the given document).
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Checker>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;
  package Pod::Simple::Debug;
  use strict;
  use vars qw($VERSION );
  $VERSION = '3.32';
  
  sub import {
    my($value,$variable);
    
    if(@_ == 2) {
      $value = $_[1];
    } elsif(@_ == 3) {
      ($variable, $value) = @_[1,2];
      
      ($variable, $value) = ($value, $variable)
         if     defined $value    and ref($value)    eq 'SCALAR'
        and not(defined $variable and ref($variable) eq 'SCALAR')
      ; # tolerate getting it backwards
      
      unless( defined $variable and ref($variable) eq 'SCALAR') {
        require Carp;
        Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                  . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
      }
    } else {
      require Carp;
      Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined &Pod::Simple::DEBUG ) {
      require Carp;
      Carp::croak("It's too late to call Pod::Simple::Debug -- "
                . "Pod::Simple has already loaded\nAborting");
    }
    
    $value = 0 unless defined $value;
  
    unless($value =~ m/^-?\d+$/) {
      require Carp;
      Carp::croak( "$value isn't a numeric value."
              . "\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor"
                      . "\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting");
    }
  
    if( defined $variable ) {
      # make a not-really-constant
      *Pod::Simple::DEBUG = sub () { $$variable } ;
      $$variable = $value;
      print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n";
    } else {
      *Pod::Simple::DEBUG = eval " sub () { $value } ";
      print STDERR "# Starting Pod::Simple::DEBUG = $value\n";
    }
    
    require Pod::Simple;
    return;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Debug -- put Pod::Simple into trace/debug mode
  
  =head1 SYNOPSIS
  
   use Pod::Simple::Debug (5);  # or some integer
  
  Or:
  
   my $debuglevel;
   use Pod::Simple::Debug (\$debuglevel, 0);
   ...some stuff that uses Pod::Simple to do stuff, but which
    you don't want debug output from...
  
   $debug_level = 4;
   ...some stuff that uses Pod::Simple to do stuff, but which
    you DO want debug output from...
  
   $debug_level = 0;
  
  =head1 DESCRIPTION
  
  This is an internal module for controlling the debug level (a.k.a. trace
  level) of Pod::Simple.  This is of interest only to Pod::Simple
  developers.
  
  
  =head1 CAVEATS
  
  Note that you should load this module I<before> loading Pod::Simple (or
  any Pod::Simple-based class).  If you try loading Pod::Simple::Debug
  after &Pod::Simple::DEBUG is already defined, Pod::Simple::Debug will
  throw a fatal error to the effect that
  "It's too late to call Pod::Simple::Debug".
  
  Note that the C<use Pod::Simple::Debug (\$x, I<somenum>)> mode will make
  Pod::Simple (et al) run rather slower, since &Pod::Simple::DEBUG won't
  be a constant sub anymore, and so Pod::Simple (et al) won't compile with
  constant-folding.
  
  
  =head1 GUTS
  
  Doing this:
  
    use Pod::Simple::Debug (5);  # or some integer
  
  is basically equivalent to:
  
    BEGIN { sub Pod::Simple::DEBUG () {5} }  # or some integer
    use Pod::Simple ();
  
  And this:
  
    use Pod::Simple::Debug (\$debug_level,0);  # or some integer
  
  is basically equivalent to this:
  
    my $debug_level;
    BEGIN { $debug_level = 0 }
    BEGIN { sub Pod::Simple::DEBUG () { $debug_level }
    use Pod::Simple ();
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  The article "Constants in Perl", in I<The Perl Journal> issue
  21.  See L<http://interglacial.com/tpj/21/>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  
  require 5;
  package Pod::Simple::DumpAsText;
  $VERSION = '3.32';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  
  use Carp ();
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "++", $_[1], "\n";
    $_[0]{'indent'}++;
    while(($key,$value) = each %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _perly_escape($key);
        _perly_escape($value);
        printf $fh qq{%s \\ "%s" => "%s"\n},
          '  ' x ($_[0]{'indent'} || 0), $key, $value;
      }
    }
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _perly_escape($text);
      $text =~  # A not-totally-brilliant wrapping algorithm:
        s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx     # => line-break here
      ;
      
      print {$_[0]{'output_fh'}} $indent, '* "', $text, "\"\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "--", $_[1], "\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _perly_escape {
    foreach my $x (@_) {
      $x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;
      # Escape things very cautiously:
      $x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg;
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsText -- dump Pod-parsing events as text
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsText -e \
     "exit Pod::Simple::DumpAsText->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is for dumping, as text, the events gotten from parsing a Pod
  document.  This class is of interest to people writing Pod formatters
  based on Pod::Simple. It is useful for seeing exactly what events you
  get out of some Pod that you feed in.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML>
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  
  require 5;
  package Pod::Simple::DumpAsXML;
  $VERSION = '3.32';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  
  use Carp ();
  use Text::Wrap qw(wrap);
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_codes('VerbatimFormatted');
    $new->keep_encoding_directive(1);
    return $new;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    
    print $fh   '  ' x ($_[0]{'indent'} || 0),  "<", $_[1];
  
    foreach my $key (sort keys %{$_[2]}) {
      unless($key =~ m/^~/s) {
        next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
        _xml_escape($value = $_[2]{$key});
        print $fh ' ', $key, '="', $value, '"';
      }
    }
  
  
    print $fh ">\n";
    $_[0]{'indent'}++;
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $indent = '  ' x $_[0]{'indent'};
      my $text = $_[1];
      _xml_escape($text);
      local $Text::Wrap::huge = 'overflow';
      $text = wrap('', $indent, $text);
      print {$_[0]{'output_fh'}} $indent, $text, "\n";
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}}
     '  ' x --$_[0]{'indent'}, "</", $_[1], ">\n";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::DumpAsXML -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::DumpAsXML -e \
     "exit Pod::Simple::DumpAsXML->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::DumpAsXML is a subclass of L<Pod::Simple> that parses Pod
  and turns it into indented and wrapped XML.  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  Pod::Simple::DumpAsXML inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::XMLOutStream> is rather like this class.
  Pod::Simple::XMLOutStream's output is space-padded in a way
  that's better for sending to an XML processor (that is, it has
  no ignorable whitespace). But
  Pod::Simple::DumpAsXML's output is much more human-readable, being
  (more-or-less) one token per line, with line-wrapping.
  
  L<Pod::Simple::DumpAsText> is rather like this class,
  except that it doesn't dump with XML syntax.  Try them and see
  which one you like best!
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>
  
  The older libraries L<Pod::PXML>, L<Pod::XML>, L<Pod::SAX>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;
  package Pod::Simple::HTML;
  use strict;
  use Pod::Simple::PullParser ();
  use vars qw(
    @ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION
    $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix
    $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex
    $Doctype_decl  $Content_decl
  );
  @ISA = ('Pod::Simple::PullParser');
  $VERSION = '3.32';
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  $Doctype_decl ||= '';  # No.  Just No.  Don't even ask me for it.
   # qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   #    "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  $Content_decl ||=
   q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};
  
  $HTML_EXTENSION = '.html' unless defined $HTML_EXTENSION;
  $Computerese =  "" unless defined $Computerese;
  $LamePad = '' unless defined $LamePad;
  
  $Linearization_Limit = 120 unless defined $Linearization_Limit;
   # headings/items longer than that won't get an <a name="...">
  $Perldoc_URL_Prefix  = 'http://search.cpan.org/perldoc?'
   unless defined $Perldoc_URL_Prefix;
  $Perldoc_URL_Postfix = ''
   unless defined $Perldoc_URL_Postfix;
  
  
  $Man_URL_Prefix  = 'http://man.he.net/man';
  $Man_URL_Postfix = '';
  
  $Title_Prefix  = '' unless defined $Title_Prefix;
  $Title_Postfix = '' unless defined $Title_Postfix;
  %ToIndex = map {; $_ => 1 } qw(head1 head2 head3 head4 ); # item-text
    # 'item-text' stuff in the index doesn't quite work, and may
    # not be a good idea anyhow.
  
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
     # In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
     #  to put before the "Foo%3a%3aBar".
     # (for singleton mode only?)
   'perldoc_url_postfix',
     # what to put after "Foo%3a%3aBar" in the URL.  Normally "".
  
   'man_url_prefix',
     # In turning L<crontab(5)> into http://whatever/man/1/crontab, what
     #  to put before the "1/crontab".
   'man_url_postfix',
     #  what to put after the "1/crontab" in the URL. Normally "".
  
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
      
   'title_prefix',  'title_postfix',
    # What to put before and after the title in the head.
    # Should already be &-escaped
  
   'html_h_level',
    
   'html_header_before_title',
   'html_header_after_title',
   'html_footer',
   'top_anchor',
  
   'index', # whether to add an index at the top of each page
      # (actually it's a table-of-contents, but we'll call it an index,
      #  out of apparently longstanding habit)
  
   'html_css', # URL of CSS file to point to
   'html_javascript', # URL of Javascript file to point to
  
   'force_title',   # should already be &-escaped
   'default_title', # should already be &-escaped
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  my @_to_accept;
  
  %Tagmap = (
    'Verbatim'  => "\n<pre$Computerese>",
    '/Verbatim' => "</pre>\n",
    'VerbatimFormatted'  => "\n<pre$Computerese>",
    '/VerbatimFormatted' => "</pre>\n",
    'VerbatimB'  => "<b>",
    '/VerbatimB' => "</b>",
    'VerbatimI'  => "<i>",
    '/VerbatimI' => "</i>",
    'VerbatimBI'  => "<b><i>",
    '/VerbatimBI' => "</i></b>",
  
  
    'Data'  => "\n",
    '/Data' => "\n",
    
    'head1' => "\n<h1>",  # And also stick in an <a name="...">
    'head2' => "\n<h2>",  #  ''
    'head3' => "\n<h3>",  #  ''
    'head4' => "\n<h4>",  #  ''
    '/head1' => "</a></h1>\n",
    '/head2' => "</a></h2>\n",
    '/head3' => "</a></h3>\n",
    '/head4' => "</a></h4>\n",
  
    'X'  => "<!--\n\tINDEX: ",
    '/X' => "\n-->",
  
    changes(qw(
      Para=p
      B=b I=i
      over-bullet=ul
      over-number=ol
      over-text=dl
      over-block=blockquote
      item-bullet=li
      item-number=li
      item-text=dt
    )),
    changes2(
      map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
      qw[
        sample=samp
        definition=dfn
        keyboard=kbd
        variable=var
        citation=cite
        abbreviation=abbr
        acronym=acronym
        subscript=sub
        superscript=sup
        big=big
        small=small
        underline=u
        strikethrough=s
        preformat=pre
        teletype=tt
      ]  # no point in providing a way to get <q>...</q>, I think
    ),
    
    '/item-bullet' => "</li>$LamePad\n",
    '/item-number' => "</li>$LamePad\n",
    '/item-text'   => "</a></dt>$LamePad\n",
    'item-body'    => "\n<dd>",
    '/item-body'   => "</dd>\n",
  
  
    'B'      =>  "<b>",                  '/B'     =>  "</b>",
    'I'      =>  "<i>",                  '/I'     =>  "</i>",
    'F'      =>  "<em$Computerese>",     '/F'     =>  "</em>",
    'C'      =>  "<code$Computerese>",   '/C'     =>  "</code>",
    'L'  =>  "<a href='YOU_SHOULD_NEVER_SEE_THIS'>", # ideally never used!
    '/L' =>  "</a>",
  );
  
  sub changes {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "\n<$2>", "/$1", => "</$2>\n" ) : die "Funky $_"
    } @_;
  }
  sub changes2 {
    return map {; m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s
       ? ( $1, => "<$2>", "/$1", => "</$2>" ) : die "Funky $_"
    } @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub go { Pod::Simple::HTML->parse_from_file(@ARGV); exit 0 }
   # Just so we can run from the command line.  No options.
   #  For that, use perldoc!
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $new = shift->SUPER::new(@_);
    #$new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'html', 'HTML' );
    $new->accept_codes('VerbatimFormatted');
    $new->accept_codes(@_to_accept);
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
  
    $new->perldoc_url_prefix(  $Perldoc_URL_Prefix  );
    $new->perldoc_url_postfix( $Perldoc_URL_Postfix );
    $new->man_url_prefix(  $Man_URL_Prefix  );
    $new->man_url_postfix( $Man_URL_Postfix );
    $new->title_prefix(  $Title_Prefix  );
    $new->title_postfix( $Title_Postfix );
  
    $new->html_header_before_title(
     qq[$Doctype_decl<html><head><title>]
    );
    $new->html_header_after_title( join "\n" =>
      "</title>",
      $Content_decl,
      "</head>\n<body class='pod'>",
      $new->version_tag_comment,
      "<!-- start doc -->\n",
    );
    $new->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
    $new->top_anchor( "<a name='___top' class='dummyTopAnchor' ></a>\n" );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    return $new;
  }
  
  sub __adjust_html_h_levels {
    my ($self) = @_;
    my $Tagmap = $self->{'Tagmap'};
  
    my $add = $self->html_h_level;
    return unless defined $add;
    return if ($self->{'Adjusted_html_h_levels'}||0) == $add;
  
    $add -= 1;
    for (1 .. 4) {
      $Tagmap->{"head$_"}  =~ s/$_/$_ + $add/e;
      $Tagmap->{"/head$_"} =~ s/$_/$_ + $add/e;
    }
  }
  
  sub batch_mode_page_object_init {
    my($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    DEBUG and print STDERR "Initting $self\n  for $module\n",
      "  in $infile\n  out $outfile\n  depth $depth\n";
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub do_beginning {
    my $self = $_[0];
  
    my $title;
    
    if(defined $self->force_title) {
      $title = $self->force_title;
      DEBUG and print STDERR "Forcing title to be $title\n";
    } else {
      # Actually try looking for the title in the document:
      $title = $self->get_short_title();
      unless($self->content_seen) {
        DEBUG and print STDERR "No content seen in search for title.\n";
        return;
      }
      $self->{'Title'} = $title;
  
      if(defined $title and $title =~ m/\S/) {
        $title = $self->title_prefix . esc($title) . $self->title_postfix;
      } else {
        $title = $self->default_title;    
        $title = '' unless defined $title;
        DEBUG and print STDERR "Title defaults to $title\n";
      }
    }
  
    
    my $after = $self->html_header_after_title  || '';
    if($self->html_css) {
      my $link =
      $self->html_css =~ m/</
       ? $self->html_css # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],
        $self->html_css,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
    $self->_add_top_anchor(\$after);
  
    if($self->html_javascript) {
      my $link =
      $self->html_javascript =~ m/</
       ? $self->html_javascript # It's a big blob of markup, let's drop it in
       : sprintf(        # It's just a URL, so let's wrap it up
        qq[<script type="text/javascript" src="%s"></script>\n],
        $self->html_javascript,
      );
      $after =~ s{(</head>)}{$link\n$1}i;  # otherwise nevermind
    }
  
    print {$self->{'output_fh'}}
      $self->html_header_before_title || '',
      $title, # already escaped
      $after,
    ;
  
    DEBUG and print STDERR "Returning from do_beginning...\n";
    return 1;
  }
  
  sub _add_top_anchor {
    my($self, $text_r) = @_;
    unless($$text_r and $$text_r =~ m/name=['"]___top['"]/) { # a hack
      $$text_r .= $self->top_anchor || '';
    }
    return;
  }
  
  sub version_tag_comment {
    my $self = shift;
    return sprintf
     "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",
     esc(
      ref($self), $self->VERSION(), $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime),
     ), $self->_modnote(),
    ;
  }
  
  sub _modnote {
    my $class = ref($_[0]) || $_[0];
    return join "\n   " => grep m/\S/, split "\n",
  
  qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  };
  
  }
  
  sub do_end {
    my $self = $_[0];
    print {$self->{'output_fh'}}  $self->html_footer || '';
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Normally this would just be a call to _do_middle_main_loop -- but we
  #  have to do some elaborate things to emit all the content and then
  #  summarize it and output it /before/ the content that it's a summary of.
  
  sub do_middle {
    my $self = $_[0];
    return $self->_do_middle_main_loop unless $self->index;
  
    if( $self->output_string ) {
      # An efficiency hack
      my $out = $self->output_string; #it's a reference to it
      my $sneakytag = "\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";
      $$out .= $sneakytag;
      $self->_do_middle_main_loop;
      $sneakytag = quotemeta($sneakytag);
      my $index = $self->index_as_html();
      if( $$out =~ s/$sneakytag/$index/s ) {
        # Expected case
        DEBUG and print STDERR "Inserted ", length($index), " bytes of index HTML into $out.\n";
      } else {
        DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n";
        # I don't think this should ever happen.
      }
      return 1;
    }
  
    unless( $self->output_fh ) {
      require Carp;
      Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.");
    }
  
    # If we get here, we're outputting to a FH.  So we need to do some magic.
    # Namely, divert all content to a string, which we output after the index.
    my $fh = $self->output_fh;
    my $content = '';
    {
      # Our horrible bait and switch:
      $self->output_string( \$content );
      $self->_do_middle_main_loop;
      $self->abandon_output_string();
      $self->output_fh($fh);
    }
    print $fh $self->index_as_html();
    print $fh $content;
  
    return 1;
  }
  
  ###########################################################################
  
  sub index_as_html {
    my $self = $_[0];
    # This is meant to be called AFTER the input document has been parsed!
  
    my $points = $self->{'PSHTML_index_points'} || [];
    
    @$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];
     # There's no point in having a 0-item or 1-item index, I dare say.
    
    my(@out) = qq{\n<div class='indexgroup'>};
    my $level = 0;
  
    my( $target_level, $previous_tagname, $tagname, $text, $anchorname, $indent);
    foreach my $p (@$points, ['head0', '(end)']) {
      ($tagname, $text) = @$p;
      $anchorname = $self->section_escape($text);
      if( $tagname =~ m{^head(\d+)$} ) {
        $target_level = 0 + $1;
      } else {  # must be some kinda list item
        if($previous_tagname =~ m{^head\d+$} ) {
          $target_level = $level + 1;
        } else {
          $target_level = $level;  # no change needed
        }
      }
      
      # Get to target_level by opening or closing ULs
      while($level > $target_level)
       { --$level; push @out, ("  " x $level) . "</ul>"; }
      while($level < $target_level)
       { ++$level; push @out, ("  " x ($level-1))
         . "<ul   class='indexList indexList$level'>"; }
  
      $previous_tagname = $tagname;
      next unless $level;
      
      $indent = '  '  x $level;
      push @out, sprintf
        "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",
        $indent, $level, esc($anchorname), esc($text)
      ;
    }
    push @out, "</div>\n";
    return join "\n", @out;
  }
  
  ###########################################################################
  
  sub _do_middle_main_loop {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    my $tagmap = $self->{'Tagmap'};
  
    $self->__adjust_html_h_levels;
    
    my($token, $type, $tagname, $linkto, $linktype);
    my @stack;
    my $dont_wrap = 0;
  
    while($token = $self->get_token) {
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if( ($type = $token->type) eq 'start' ) {
        if(($tagname = $token->tagname) eq 'L') {
          $linktype = $token->attr('type') || 'insane';
          
          $linkto = $self->do_link($token);
  
          if(defined $linkto and length $linkto) {
            esc($linkto);
              #   (Yes, SGML-escaping applies on top of %-escaping!
              #   But it's rarely noticeable in practice.)
            print $fh qq{<a href="$linkto" class="podlink$linktype"\n>};
          } else {
            print $fh "<a>"; # Yes, an 'a' element with no attributes!
          }
  
        } elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s) {
          print $fh $tagmap->{$tagname} || next;
  
          my @to_unget;
          while(1) {
            push @to_unget, $self->get_token;
            last if $to_unget[-1]->is_end
                and $to_unget[-1]->tagname eq $tagname;
            
            # TODO: support for X<...>'s found in here?  (maybe hack into linearize_tokens)
          }
  
          my $name = $self->linearize_tokens(@to_unget);
          $name = $self->do_section($name, $token) if defined $name;
  
          print $fh "<a ";
          if ($tagname =~ m/^head\d$/s) {
              print $fh "class='u'", $self->index
                  ? " href='#___top' title='click to go to top of document'\n"
                  : "\n";
          }
          
          if(defined $name) {
            my $esc = esc(  $self->section_name_tidy( $name ) );
            print $fh qq[name="$esc"];
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens as \"$name\".\n";
            push @{ $self->{'PSHTML_index_points'} }, [$tagname, $name]
             if $ToIndex{ $tagname };
              # Obviously, this discards all formatting codes (saving
              #  just their content), but ahwell.
             
          } else {  # ludicrously long, so nevermind
            DEBUG and print STDERR "Linearized ", scalar(@to_unget),
             " tokens, but it was too long, so nevermind.\n";
          }
          print $fh "\n>";
          $self->unget_token(@to_unget);
  
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          # The parser sometimes preserves newlines and sometimes doesn't!
          (my $text = $next->text) =~ s/\n\z//;
          print $fh $text, "\n";
          next;
         
        } else {
          if( $tagname =~ m/^over-/s ) {
            push @stack, '';
          } elsif( $tagname =~ m/^item-/s and @stack and $stack[-1] ) {
            print $fh $stack[-1];
            $stack[-1] = '';
          }
          print $fh $tagmap->{$tagname} || next;
          ++$dont_wrap if $tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted"
            or $tagname eq 'X';
        }
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'end' ) {
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          if( my $end = pop @stack ) {
            print $fh $end;
          }
        } elsif( $tagname =~ m/^item-/s and @stack) {
          $stack[-1] = $tagmap->{"/$tagname"};
          if( $tagname eq 'item-text' and defined(my $next = $self->get_token) ) {
            $self->unget_token($next);
            if( $next->type eq 'start' ) {
              print $fh $tagmap->{"/item-text"},$tagmap->{"item-body"};
              $stack[-1] = $tagmap->{"/item-body"};
            }
          }
          next;
        }
        print $fh $tagmap->{"/$tagname"} || next;
        --$dont_wrap if $tagname eq 'Verbatim' or $tagname eq 'X';
  
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      } elsif( $type eq 'text' ) {
        esc($type = $token->text);  # reuse $type, why not
        $type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless $dont_wrap;
        print $fh $type;
      }
  
    }
    return 1;
  }
  
  ###########################################################################
  #
  
  sub do_section {
    my($self, $name, $token) = @_;
    return $name;
  }
  
  sub do_link {
    my($self, $token) = @_;
    my $type = $token->attr('type');
    if(!defined $type) {
      $self->whine("Typeless L!?", $token->attr('start_line'));
    } elsif( $type eq 'pod') { return $self->do_pod_link($token);
    } elsif( $type eq 'url') { return $self->do_url_link($token);
    } elsif( $type eq 'man') { return $self->do_man_link($token);
    } else {
      $self->whine("L of unknown type $type!?", $token->attr('start_line'));
    }
    return 'FNORG'; # should never get called
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub do_url_link { return $_[1]->attr('to') }
  
  sub do_man_link {
    my ($self, $link) = @_;
    my $to = $link->attr('to');
    my $frag = $link->attr('section');
  
    return undef unless defined $to and length $to; # should never happen
  
    $frag = $self->section_escape($frag)
     if defined $frag and length($frag .= ''); # (stringify)
  
    DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";
  
    return $self->resolve_man_page_link($to, $frag);
  }
  
  
  sub do_pod_link {
    # And now things get really messy...
    my($self, $link) = @_;
    my $to = $link->attr('to');
    my $section = $link->attr('section');
    return undef unless(  # should never happen
      (defined $to and length $to) or
      (defined $section and length $section)
    );
  
    $section = $self->section_escape($section)
     if defined $section and length($section .= ''); # (stringify)
  
    DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",
     $to || "(nil)",  $section || "(nil)";
     
    {
      # An early hack:
      my $complete_url = $self->resolve_pod_link_by_table($to, $section);
      if( $complete_url ) {
        DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",
          $complete_url, "\n  (Returning that.)\n";
        return $complete_url;
      } else {
        DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)",
         " didn't return anything interesting.\n";
      }
    }
  
    if(defined $to and length $to) {
      # Give this routine first hack again
      my $there = $self->resolve_pod_link_by_table($to);
      if(defined $there and length $there) {
        DEBUG > 1
         and print STDERR "resolve_pod_link_by_table(T) gives $there\n";
      } else {
        $there = 
          $self->resolve_pod_page_link($to, $section);
           # (I pass it the section value, but I don't see a
           #  particular reason it'd use it.)
        DEBUG > 1 and print STDERR "resolve_pod_page_link gives ", $there || "(nil)", "\n";
        unless( defined $there and length $there ) {
          DEBUG and print STDERR "Can't resolve $to\n";
          return undef;
        }
        # resolve_pod_page_link returning undef is how it
        #  can signal that it gives up on making a link
      }
      $to = $there;
    }
  
    #DEBUG and print STDERR "So far [", $to||'nil', "] [", $section||'nil', "]\n";
  
    my $out = (defined $to and length $to) ? $to : '';
    $out .= "#" . $section if defined $section and length $section;
    
    unless(length $out) { # sanity check
      DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",
       $to || "(nil)",  $section || "(nil)";
      return undef;
    }
  
    DEBUG and print STDERR "Resolved to $out\n";
    return $out;  
  }
  
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
  sub section_escape {
    my($self, $section) = @_;
    return $self->section_url_escape(
      $self->section_name_tidy($section)
    );
  }
  
  sub section_name_tidy {
    my($self, $section) = @_;
    $section =~ s/^\s+//;
    $section =~ s/\s+$//;
    $section =~ tr/ /_/;
    if ($] ge 5.006) {
      $section =~ s/[[:cntrl:][:^ascii:]]//g; # drop crazy characters
    } elsif ('A' eq chr(65)) { # But not on early EBCDIC
      $section =~ tr/\x00-\x1F\x80-\x9F//d;
    }
    $section = $self->unicode_escape_url($section);
    $section = '_' unless length $section;
    return $section;
  }
  
  sub section_url_escape  { shift->general_url_escape(@_) }
  sub pagepath_url_escape { shift->general_url_escape(@_) }
  sub manpage_url_escape  { shift->general_url_escape(@_) }
  
  sub general_url_escape {
    my($self, $string) = @_;
   
    $string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;
       # express Unicode things as urlencode(utf(orig)).
    
    # A pretty conservative escaping, behoovey even for query components
    #  of a URL (see RFC 2396)
    
    if ($] ge 5.007_003) {
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg;
    } else { # Is broken for non-ASCII platforms on early perls
      $string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg;
    }
     # Yes, stipulate the list without a range, so that this can work right on
     #  all charsets that this module happens to run under.
    
    return $string;
  }
  
  #--------------------------------------------------------------------------
  #
  # Oh look, a yawning portal to Hell!  Let's play touch football right by it!
  #
  
  sub resolve_pod_page_link {
    # resolve_pod_page_link must return a properly escaped URL
    my $self = shift;
    return $self->batch_mode()
     ? $self->resolve_pod_page_link_batch_mode(@_)
     : $self->resolve_pod_page_link_singleton_mode(@_)
    ;
  }
  
  sub resolve_pod_page_link_singleton_mode {
    my($self, $it) = @_;
    return undef unless defined $it and length $it;
    my $url = $self->pagepath_url_escape($it);
    
    $url =~ s{::$}{}s; # probably never comes up anyway
    $url =~ s{::}{/}g unless $self->perldoc_url_prefix =~ m/\?/s; # sane DWIM?
    
    return undef unless length $url;
    return $self->perldoc_url_prefix . $url . $self->perldoc_url_postfix;
  }
  
  sub resolve_pod_page_link_batch_mode {
    my($self, $to) = @_;
    DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";
    my @path = grep length($_), split m/::/s, $to, -1;
    unless( @path ) { # sanity
      DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";
      return undef;
    }
    $self->batch_mode_rectify_path(\@path);
    my $out = join('/', map $self->pagepath_url_escape($_), @path)
      . $HTML_EXTENSION;
    DEBUG > 1 and print STDERR " => $out\n";
    return $out;
  }
  
  sub batch_mode_rectify_path {
    my($self, $pathbits) = @_;
    my $level = $self->batch_mode_current_level;
    $level--; # how many levels up to go to get to the root
    if($level < 1) {
      unshift @$pathbits, '.'; # just to be pretty
    } else {
      unshift @$pathbits, ('..') x $level;
    }
    return;
  }
  
  sub resolve_man_page_link {
    my ($self, $to, $frag) = @_;
    my ($page, $section) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
  
    return undef unless defined $page and length $page;
    $section ||= 1;
  
    return $self->man_url_prefix . "$section/"
        . $self->manpage_url_escape($page)
        . $self->man_url_postfix;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub resolve_pod_link_by_table {
    # A crazy hack to allow specifying custom L<foo> => URL mappings
  
    return unless $_[0]->{'podhtml_LOT'};  # An optimizy shortcut
  
    my($self, $to, $section) = @_;
  
    # TODO: add a method that actually populates podhtml_LOT from a file?
  
    if(defined $section) {
      $to = '' unless defined $to and length $to;
      return $self->{'podhtml_LOT'}{"$to#$section"}; # quite possibly undef!
    } else {
      return $self->{'podhtml_LOT'}{$to};            # quite possibly undef!
    }
    return;
  }
  
  ###########################################################################
  
  sub linearize_tokens {  # self, tokens
    my $self = shift;
    my $out = '';
    
    my $t;
    while($t = shift @_) {
      if(!ref $t or !UNIVERSAL::can($t, 'is_text')) {
        $out .= $t; # a string, or some insane thing
      } elsif($t->is_text) {
        $out .= $t->text;
      } elsif($t->is_start and $t->tag eq 'X') {
        # Ignore until the end of this X<...> sequence:
        my $x_open = 1;
        while($x_open) {
          next if( ($t = shift @_)->is_text );
          if(   $t->is_start and $t->tag eq 'X') { ++$x_open }
          elsif($t->is_end   and $t->tag eq 'X') { --$x_open }
        }
      }
    }
    return undef if length $out > $Linearization_Limit;
    return $out;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub unicode_escape_url {
    my($self, $string) = @_;
    $string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;
      #  Turn char 1234 into "(1234)"
    return $string;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub esc { # a function.
    if(defined wantarray) {
      if(wantarray) {
        @_ = splice @_; # break aliasing
      } else {
        my $x = shift;
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
        }
        return $x;
      }
    }
    foreach my $x (@_) {
      # Escape things very cautiously:
      if (defined $x) {
        if ($] ge 5.007_003) {
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg
        } else { # Is broken for non-ASCII platforms on early perls
          $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg
        }
      }
      # Leave out "- so that "--" won't make it thru in X-generated comments
      #  with text in them.
  
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return @_;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::HTML - convert Pod to HTML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go thingy.pod
  
  
  =head1 DESCRIPTION
  
  This class is for making an HTML rendering of a Pod document.
  
  This is a subclass of L<Pod::Simple::PullParser> and inherits all its
  methods (and options).
  
  Note that if you want to do a batch conversion of a lot of Pod
  documents to HTML, you should see the module L<Pod::Simple::HTMLBatch>.
  
  
  
  =head1 CALLING FROM THE COMMAND LINE
  
  TODO
  
    perl -MPod::Simple::HTML -e Pod::Simple::HTML::go Thing.pod Thing.html
  
  
  
  =head1 CALLING FROM PERL
  
  =head2 Minimal code
  
    use Pod::Simple::HTML;
    my $p = Pod::Simple::HTML->new;
    $p->output_string(\my $html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  =head2 More detailed example
  
    use Pod::Simple::HTML;
  
  Set the content type:
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
    my $p = Pod::Simple::HTML->new;
  
  Include a single javascript source:
  
    $p->html_javascript('http://abc.com/a.js');
  
  Or insert multiple javascript source in the header 
  (or for that matter include anything, thought this is not recommended)
  
    $p->html_javascript('
        <script type="text/javascript" src="http://abc.com/b.js"></script>
        <script type="text/javascript" src="http://abc.com/c.js"></script>');
  
  Include a single css source in the header:
  
    $p->html_css('/style.css');
  
  or insert multiple css sources:
  
    $p->html_css('
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://remote.server.com/jquery.css">
        <link rel="stylesheet" type="text/css" title="pod_stylesheet" href="/style.css">');
  
  Tell the parser where should the output go. In this case it will be placed in the $html variable:
  
    my $html;
    $p->output_string(\$html);
  
  Parse and process a file with pod in it:
  
    $p->parse_file('path/to/Module/Name.pm');
  
  =head1 METHODS
  
  TODO
  all (most?) accessorized methods
  
  The following variables need to be set B<before> the call to the ->new constructor.
  
  Set the string that is included before the opening <html> tag:
  
    $Pod::Simple::HTML::Doctype_decl = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
  	 "http://www.w3.org/TR/html4/loose.dtd">\n};
  
  Set the content-type in the HTML head: (defaults to ISO-8859-1)
  
    $Pod::Simple::HTML::Content_decl =  q{<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >};
  
  Set the value that will be embedded in the opening tags of F, C tags and verbatim text.
  F maps to <em>, C maps to <code>, Verbatim text maps to <pre> (Computerese defaults to "")
  
    $Pod::Simple::HTML::Computerese =  ' class="some_class_name';
  
  =head2 html_css
  
  =head2 html_javascript
  
  =head2 title_prefix
  
  =head2 title_postfix
  
  =head2 html_header_before_title
  
  This includes everything before the <title> opening tag including the Document type
  and including the opening <title> tag. The following call will set it to be a simple HTML
  file:
  
    $p->html_header_before_title('<html><head><title>');
  
  =head2 top_anchor
  
  By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML.
  You can change it by calling
  
    $p->top_anchor('<a name="zz" >');
  
  =head2 html_h_level
  
  Normally =head1 will become <h1>, =head2 will become <h2> etc.
  Using the html_h_level method will change these levels setting the h level
  of =head1 tags:
  
    $p->html_h_level(3);
  
  Will make sure that =head1 will become <h3> and =head2 will become <h4> etc...
  
  
  =head2 index
  
  Set it to some true value if you want to have an index (in reality a table of contents)
  to be added at the top of the generated HTML.
  
    $p->index(1);
  
  =head2 html_header_after_title
  
  Includes the closing tag of </title> and through the rest of the head
  till the opening of the body
  
    $p->html_header_after_title('</title>...</head><body id="my_id">');
  
  =head2 html_footer
  
  The very end of the document:
  
    $p->html_footer( qq[\n<!-- end doc -->\n\n</body></html>\n] );
  
  =head1 SUBCLASSING
  
  Can use any of the methods described above but for further customization
  one needs to override some of the methods:
  
    package My::Pod;
    use strict;
    use warnings;
  
    use base 'Pod::Simple::HTML';
  
    # needs to return a URL string such
    # http://some.other.com/page.html
    # #anchor_in_the_same_file
    # /internal/ref.html
    sub do_pod_link {
      # My::Pod object and Pod::Simple::PullParserStartToken object
      my ($self, $link) = @_;
  
      say $link->tagname;          # will be L for links
      say $link->attr('to');       # 
      say $link->attr('type');     # will be 'pod' always
      say $link->attr('section');
  
      # Links local to our web site
      if ($link->tagname eq 'L' and $link->attr('type') eq 'pod') {
        my $to = $link->attr('to');
        if ($to =~ /^Padre::/) {
            $to =~ s{::}{/}g;
            return "/docs/Padre/$to.html";
        }
      }
  
      # all other links are generated by the parent class
      my $ret = $self->SUPER::do_pod_link($link);
      return $ret;
    }
  
    1;
  
  Meanwhile in script.pl:
  
    use My::Pod;
  
    my $p = My::Pod->new;
  
    my $html;
    $p->output_string(\$html);
    $p->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die;
    print $out $html;
  
  TODO
  
  maybe override do_beginning do_end
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>
  
  TODO: a corpus of sample Pod input and HTML output?  Or common
  idioms?
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  
  require 5;
  package Pod::Simple::HTMLBatch;
  use strict;
  use vars qw( $VERSION $HTML_RENDER_CLASS $HTML_EXTENSION
   $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA
  );
  $VERSION = '3.32';
  @ISA = ();  # Yup, we're NOT a subclass of Pod::Simple::HTML!
  
  # TODO: nocontents stylesheets. Strike some of the color variations?
  
  use Pod::Simple::HTML ();
  BEGIN {*esc = \&Pod::Simple::HTML::esc }
  use File::Spec ();
  
  use Pod::Simple::Search;
  $SEARCH_CLASS ||= 'Pod::Simple::Search';
  
  BEGIN {
    if(defined &DEBUG) { } # no-op
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG }
    else { *DEBUG = sub () {0}; }
  }
  
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
  # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  $HTML_RENDER_CLASS ||= "Pod::Simple::HTML";
  
  #
  # Methods beginning with "_" are particularly internal and possibly ugly.
  #
  
  Pod::Simple::_accessorize( __PACKAGE__,
   'verbose', # how verbose to be during batch conversion
   'html_render_class', # what class to use to render
   'search_class', # what to use to search for POD documents
   'contents_file', # If set, should be the name of a file (in current directory)
                    # to write the list of all modules to
   'index', # will set $htmlpage->index(...) to this (true or false)
   'progress', # progress object
   'contents_page_start',  'contents_page_end',
  
   'css_flurry', '_css_wad', 'javascript_flurry', '_javascript_wad',
   'no_contents_links', # set to true to suppress automatic adding of << links.
   '_contents',
  );
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Just so we can run from the command line more easily
  sub go {
    @ARGV == 2 or die sprintf(
      "Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",
      __PACKAGE__, __PACKAGE__, 
    );
    
    if(defined($ARGV[1]) and length($ARGV[1])) {
      my $d = $ARGV[1];
      -e $d or die "I see no output directory named \"$d\"\nAborting";
      -d $d or die "But \"$d\" isn't a directory!\nAborting";
      -w $d or die "Directory \"$d\" isn't writeable!\nAborting";
    }
    
    __PACKAGE__->batch_convert(@ARGV);
  }
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  
  sub new {
    my $new = bless {}, ref($_[0]) || $_[0];
    $new->html_render_class($HTML_RENDER_CLASS);
    $new->search_class($SEARCH_CLASS);
    $new->verbose(1 + DEBUG);
    $new->_contents([]);
    
    $new->index(1);
  
    $new->       _css_wad([]);         $new->css_flurry(1);
    $new->_javascript_wad([]);  $new->javascript_flurry(1);
    
    $new->contents_file(
      'index' . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION)
    );
    
    $new->contents_page_start( join "\n", grep $_,
      $Pod::Simple::HTML::Doctype_decl,
      "<html><head>",
      "<title>Perl Documentation</title>",
      $Pod::Simple::HTML::Content_decl,
      "</head>",
      "\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n"
    ); # override if you need a different title
    
    
    $new->contents_page_end( sprintf(
      "\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT, which is %s local time.</p>\n\n</body></html>\n",
      esc(
        ref($new),
        eval {$new->VERSION} || $VERSION,
        $], scalar(gmtime), scalar(localtime), 
    )));
  
    return $new;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub muse {
    my $self = shift;
    if($self->verbose) {
      print 'T+', int(time() - $self->{'_batch_start_time'}), "s: ", @_, "\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub batch_convert {
    my($self, $dirs, $outdir) = @_;
    $self ||= __PACKAGE__; # tolerate being called as an optionless function
    $self = $self->new unless ref $self; # tolerate being used as a class method
  
    if(!defined($dirs)  or  $dirs eq ''  or  $dirs eq '@INC' ) {
      $dirs = '';
    } elsif(ref $dirs) {
      # OK, it's an explicit set of dirs to scan, specified as an arrayref.
    } else {
      # OK, it's an explicit set of dirs to scan, specified as a
      #  string like "/thing:/also:/whatever/perl" (":"-delim, as usual)
      #  or, under MSWin, like "c:/thing;d:/also;c:/whatever/perl" (";"-delim!)
      require Config;
      my $ps = quotemeta( $Config::Config{'path_sep'} || ":" );
      $dirs = [ grep length($_), split qr/$ps/, $dirs ];
    }
  
    $outdir = $self->filespecsys->curdir
     unless defined $outdir and length $outdir;
  
    $self->_batch_convert_main($dirs, $outdir);
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _batch_convert_main {
    my($self, $dirs, $outdir) = @_;
    # $dirs is either false, or an arrayref.    
    # $outdir is a pathspec.
    
    $self->{'_batch_start_time'} ||= time();
  
    $self->muse( "= ", scalar(localtime) );
    $self->muse( "Starting batch conversion to \"$outdir\"" );
  
    my $progress = $self->progress;
    if(!$progress and $self->verbose > 0 and $self->verbose() <= 5) {
      require Pod::Simple::Progress;
      $progress = Pod::Simple::Progress->new(
          ($self->verbose  < 2) ? () # Default omission-delay
        : ($self->verbose == 2) ? 1  # Reduce the omission-delay
                                : 0  # Eliminate the omission-delay
      );
      $self->progress($progress);
    }
    
    if($dirs) {
      $self->muse(scalar(@$dirs), " dirs to scan: @$dirs");
    } else {
      $self->muse("Scanning \@INC.  This could take a minute or two.");
    }
    my $mod2path = $self->find_all_pods($dirs ? $dirs : ());
    $self->muse("Done scanning.");
  
    my $total = keys %$mod2path;
    unless($total) {
      $self->muse("No pod found.  Aborting batch conversion.\n");
      return $self;
    }
  
    $progress and $progress->goal($total);
    $self->muse("Now converting pod files to HTML.",
      ($total > 25) ? "  This will take a while more." : ()
    );
  
    $self->_spray_css(        $outdir );
    $self->_spray_javascript( $outdir );
  
    $self->_do_all_batch_conversions($mod2path, $outdir);
  
    $progress and $progress->done(sprintf (
      "Done converting %d files.",  $self->{"__batch_conv_page_count"}
    ));
    return $self->_batch_convert_finish($outdir);
    return $self;
  }
  
  
  sub _do_all_batch_conversions {
    my($self, $mod2path, $outdir) = @_;
    $self->{"__batch_conv_page_count"} = 0;
  
    foreach my $module (sort {lc($a) cmp lc($b)} keys %$mod2path) {
      $self->_do_one_batch_conversion($module, $mod2path, $outdir);
      sleep($SLEEPY - 1) if $SLEEPY;
    }
  
    return;
  }
  
  sub _batch_convert_finish {
    my($self, $outdir) = @_;
    $self->write_contents_file($outdir);
    $self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");
    $self->muse( "= ", scalar(localtime) );
    $self->progress and $self->progress->done("All done!");
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _do_one_batch_conversion {
    my($self, $module, $mod2path, $outdir, $outfile) = @_;
  
    my $retval;
    my $total    = scalar keys %$mod2path;
    my $infile   = $mod2path->{$module};
    my @namelets = grep m/\S/, split "::", $module;
          # this can stick around in the contents LoL
    my $depth    = scalar @namelets;
    die "Contentless thingie?! $module $infile" unless @namelets; #sanity
      
    $outfile  ||= do {
      my @n = @namelets;
      $n[-1] .= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;
      $self->filespecsys->catfile( $outdir, @n );
    };
  
    my $progress = $self->progress;
  
    my $page = $self->html_render_class->new;
    if(DEBUG > 5) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: ",
        ref($page), " render ($depth) $module => $outfile");
    } elsif(DEBUG > 2) {
      $self->muse($self->{"__batch_conv_page_count"} + 1, "/$total: $module => $outfile")
    }
  
    # Give each class a chance to init the converter:
    $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_init');
    # Init for the index (TOC), too.
    $self->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_init');
      
    # Now get busy...
    $self->makepath($outdir => \@namelets);
  
    $progress and $progress->reach($self->{"__batch_conv_page_count"}, "Rendering $module");
  
    if( $retval = $page->parse_from_file($infile, $outfile) ) {
      ++ $self->{"__batch_conv_page_count"} ;
      $self->note_for_contents_file( \@namelets, $infile, $outfile );
    } else {
      $self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.");
    }
  
    $page->batch_mode_page_object_kill($self, $module, $infile, $outfile, $depth)
     if $page->can('batch_mode_page_object_kill');
    # The following isn't a typo.  Note that it switches $self and $page.
    $self->batch_mode_page_object_kill($page, $module, $infile, $outfile, $depth)
     if $self->can('batch_mode_page_object_kill');
      
    DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",
       $outfile, -s $outfile, $infile, -s $infile
    ;
  
    undef($page);
    return $retval;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub filespecsys { $_[0]{'_filespecsys'} || 'File::Spec' }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub note_for_contents_file {
    my($self, $namelets, $infile, $outfile) = @_;
  
    # I think the infile and outfile parts are never used. -- SMB
    # But it's handy to have them around for debugging.
  
    if( $self->contents_file ) {
      my $c = $self->_contents();
      push @$c,
       [ join("::", @$namelets), $infile, $outfile, $namelets ]
       #            0               1         2         3
      ;
      DEBUG > 3 and print STDERR "Noting @$c[-1]\n";
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub write_contents_file {
    my($self, $outdir) = @_;
    my $outfile  = $self->_contents_filespec($outdir) || return;
  
    $self->muse("Preparing list of modules for ToC");
  
    my($toplevel,           # maps  toplevelbit => [all submodules]
       $toplevel_form_freq, # ends up being  'foo' => 'Foo'
      ) = $self->_prep_contents_breakdown;
  
    my $Contents = eval { $self->_wopen($outfile) };
    if( $Contents ) {
      $self->muse( "Writing contents file $outfile" );
    } else {
      warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";
      return;
    }
  
    $self->_write_contents_start(  $Contents, $outfile, );
    $self->_write_contents_middle( $Contents, $outfile, $toplevel, $toplevel_form_freq );
    $self->_write_contents_end(    $Contents, $outfile, );
    return $outfile;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_start {
    my($self, $Contents, $outfile) = @_;
    my $starter = $self->contents_page_start || '';
    
    {
      my $css_wad = $self->_css_wad_to_markup(1);
      if( $css_wad ) {
        $starter =~ s{(</head>)}{\n$css_wad\n$1}i;  # otherwise nevermind
      }
      
      my $javascript_wad = $self->_javascript_wad_to_markup(1);
      if( $javascript_wad ) {
        $starter =~ s{(</head>)}{\n$javascript_wad\n$1}i;   # otherwise nevermind
      }
    }
  
    unless(print $Contents $starter, "<dl class='superindex'>\n" ) {
      warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Contents);
      return 0;
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_middle {
    my($self, $Contents, $outfile, $toplevel2submodules, $toplevel_form_freq) = @_;
  
    foreach my $t (sort keys %$toplevel2submodules) {
      my @downlines = sort {$a->[-1] cmp $b->[-1]}
                            @{ $toplevel2submodules->{$t} };
      
      printf $Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],
        esc( $t, $toplevel_form_freq->{$t} )
      ;
      
      my($path, $name);
      foreach my $e (@downlines) {
        $name = $e->[0];
        $path = join( "/", '.', esc( @{$e->[3]} ) )
          . ($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);
        print $Contents qq{  <a href="$path">}, esc($name), "</a>&nbsp;&nbsp;\n";
      }
      print $Contents "</dd>\n\n";
    }
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _write_contents_end {
    my($self, $Contents, $outfile) = @_;
    unless(
      print $Contents "</dl>\n",
        $self->contents_page_end || '',
    ) {
      warn "Couldn't write to $outfile: $!";
    }
    close($Contents) or warn "Couldn't close $outfile: $!";
    return 1;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _prep_contents_breakdown {
    my($self) = @_;
    my $contents = $self->_contents;
    my %toplevel; # maps  lctoplevelbit => [all submodules]
    my %toplevel_form_freq; # ends up being  'foo' => 'Foo'
                                 # (mapping anycase forms to most freq form)
    
    foreach my $entry (@$contents) {
      my $toplevel = 
        $entry->[0] =~ m/^perl\w*$/ ? 'perl_core_docs'
            # group all the perlwhatever docs together
        : $entry->[3][0] # normal case
      ;
      ++$toplevel_form_freq{ lc $toplevel }{ $toplevel };
      push @{ $toplevel{ lc $toplevel } }, $entry;
      push @$entry, lc($entry->[0]); # add a sort-order key to the end
    }
  
    foreach my $toplevel (sort keys %toplevel) {
      my $fgroup = $toplevel_form_freq{$toplevel};
      $toplevel_form_freq{$toplevel} =
      (
        sort { $fgroup->{$b} <=> $fgroup->{$a}  or  $a cmp $b }
          keys %$fgroup
        # This hash is extremely unlikely to have more than 4 members, so this
        # sort isn't so very wasteful
      )[0];
    }
  
    return(\%toplevel, \%toplevel_form_freq) if wantarray;
    return \%toplevel;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _contents_filespec {
    my($self, $outdir) = @_;
    my $outfile = $self->contents_file;
    return unless $outfile;
    return $self->filespecsys->catfile( $outdir, $outfile );
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub makepath {
    my($self, $outdir, $namelets) = @_;
    return unless @$namelets > 1;
    for my $i (0 .. ($#$namelets - 1)) {
      my $dir = $self->filespecsys->catdir( $outdir, @$namelets[0 .. $i] );
      if(-e $dir) {
        die "$dir exists but not as a directory!?" unless -d $dir;
        next;
      }
      DEBUG > 3 and print STDERR "  Making $dir\n";
      mkdir $dir, 0777
       or die "Can't mkdir $dir: $!\nAborting"
      ;
    }
    return;
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub batch_mode_page_object_init {
    my $self = shift;
    my($page, $module, $infile, $outfile, $depth) = @_;
    
    # TODO: any further options to percolate onto this new object here?
  
    $page->default_title($module);
    $page->index( $self->index );
  
    $page->html_css(        $self->       _css_wad_to_markup($depth) );
    $page->html_javascript( $self->_javascript_wad_to_markup($depth) );
  
    $self->add_header_backlink($page, $module, $infile, $outfile, $depth);
    $self->add_footer_backlink($page, $module, $infile, $outfile, $depth);
  
  
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub add_header_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_header_after_title( join '',
      $page->html_header_after_title || '',
  
      qq[<p class="backlinktop"><b><a name="___top" href="],
      $self->url_up_to_contents($depth),
      qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub add_footer_backlink {
    my $self = shift;
    return if $self->no_contents_links;
    my($page, $module, $infile, $outfile, $depth) = @_;
    $page->html_footer( join '',
      qq[<p class="backlinkbottom"><b><a name="___bottom" href="],
      $self->url_up_to_contents($depth),
      qq[" title="All Documents">&lt;&lt;</a></b></p>\n],
      
      $page->html_footer || '',
    )
     if $self->contents_file
    ;
    return;
  }
  
  sub url_up_to_contents {
    my($self, $depth) = @_;
    --$depth;
    return join '/', ('..') x $depth, esc($self->contents_file);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub find_all_pods {
    my($self, $dirs) = @_;
    # You can override find_all_pods in a subclass if you want to
    #  do extra filtering or whatnot.  But for the moment, we just
    #  pass to modnames2paths:
    return $self->modnames2paths($dirs);
  }
  
  #_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
  
  sub modnames2paths { # return a hashref mapping modulenames => paths
    my($self, $dirs) = @_;
  
    my $m2p;
    {
      my $search = $self->search_class->new;
      DEBUG and print STDERR "Searching via $search\n";
      $search->verbose(1) if DEBUG > 10;
      $search->progress( $self->progress->copy->goal(0) ) if $self->progress;
      $search->shadows(0);  # don't bother noting shadowed files
      $search->inc(     $dirs ? 0      :  1 );
      $search->survey(  $dirs ? @$dirs : () );
      $m2p = $search->name2path;
      die "What, no name2path?!" unless $m2p;
    }
  
    $self->muse("That's odd... no modules found!") unless keys %$m2p;
    if( DEBUG > 4 ) {
      print STDERR "Modules found (name => path):\n";
      foreach my $m (sort {lc($a) cmp lc($b)} keys %$m2p) {
        print STDERR "  $m  $$m2p{$m}\n";
      }
      print STDERR "(total ",     scalar(keys %$m2p), ")\n\n";
    } elsif( DEBUG ) {
      print STDERR      "Found ", scalar(keys %$m2p), " modules.\n";
    }
    $self->muse( "Found ", scalar(keys %$m2p), " modules." );
    
    # return the Foo::Bar => /whatever/Foo/Bar.pod|pm hashref
    return $m2p;
  }
  
  #===========================================================================
  
  sub _wopen {
    # this is abstracted out so that the daemon class can override it
    my($self, $outpath) = @_;
    require Symbol;
    my $out_fh = Symbol::gensym();
    DEBUG > 5 and print STDERR "Write-opening to $outpath\n";
    return $out_fh if open($out_fh, "> $outpath");
    require Carp;  
    Carp::croak("Can't write-open $outpath: $!");
  }
  
  #==========================================================================
  
  sub add_css {
    my($self, $url, $is_default, $name, $content_type, $media, $_code) = @_;
    return unless $url;
    unless($name) {
      # cook up a reasonable name based on the URL
      $name = $url;
      if( $name !~ m/\?/ and $name =~ m{([^/]+)$}s ) {
        $name = $1;
        $name =~ s/\.css//i;
      }
    }
    $media        ||= 'all';
    $content_type ||= 'text/css';
    
    my $bunch = [$url, $name, $content_type, $media, $_code];
    if($is_default) { unshift @{ $self->_css_wad }, $bunch }
    else            { push    @{ $self->_css_wad }, $bunch }
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _spray_css {
    my($self, $outdir) = @_;
  
    return unless $self->css_flurry();
    $self->_gen_css_wad();
  
    my $lol = $self->_css_wad;
    foreach my $chunk (@$lol) {
      my $url = $chunk->[0];
      my $outfile;
      if( ref($chunk->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.css$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";
        # Requires no further attention.
        next;
      }
      
      #$self->muse( "Writing autogenerated CSS file $outfile" );
      my $Cssout = $self->_wopen($outfile);
      print $Cssout ${$chunk->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Cssout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub _css_wad_to_markup {
    my($self, $depth) = @_;
    
    my @css  = @{ $self->_css_wad || return '' };
    return '' unless @css;
    
    my $rel = 'stylesheet';
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $chunk (@css) {
      next unless $chunk and @$chunk;
  
      my( $url1, $url2, $title, $type, $media) = (
        $self->_maybe_uplink( $chunk->[0], $uplink ),
        esc(grep !ref($_), @$chunk)
      );
  
      $out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};
  
      $rel = 'alternate stylesheet'; # alternates = all non-first iterations
    }
    return $out;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _maybe_uplink {
    # if the given URL looks relative, return the given uplink string --
    # otherwise return emptystring
    my($self, $url, $uplink) = @_;
    ($url =~ m{^\./} or $url !~ m{[/\:]} )
      ? $uplink
      : ''
      # qualify it, if/as needed
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sub _gen_css_wad {
    my $self = $_[0];
    my $css_template = $self->_css_template;
    foreach my $variation (
  
     # Commented out for sake of concision:
     #
     #  011n=black_with_red_on_white
     #  001n=black_with_yellow_on_white
     #  101n=black_with_green_on_white
     #  110=white_with_yellow_on_black
     #  010=white_with_green_on_black
     #  011=white_with_blue_on_black
     #  100=white_with_red_on_black
      '110n=blkbluw',  # black_with_blue_on_white
      '010n=blkmagw',  # black_with_magenta_on_white
      '100n=blkcynw',  # black_with_cyan_on_white
      '101=whtprpk',   # white_with_purple_on_black
      '001=whtnavk',   # white_with_navy_blue_on_black
      '010a=grygrnk',  # grey_with_green_on_black
      '010b=whtgrng',  # white_with_green_on_grey
      '101an=blkgrng', # black_with_green_on_grey
      '101bn=grygrnw', # grey_with_green_on_white
    ) {
  
      my $outname = $variation;
      my($flipmode, @swap) = ( ($4 || ''), $1,$2,$3)
        if $outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;
      @swap = () if '010' eq join '', @swap; # 010 is a swop-no-op!
    
      my $this_css =
        "/* This file is autogenerated.  Do not edit.  $variation */\n\n"
        . $css_template;
  
      # Only look at three-digitty colors, for now at least.
      if( $flipmode =~ m/n/ ) {
        $this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;
        $this_css =~ s/\bthin\b/medium/g;
      }
      $this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg   if @swap;
  
      if(   $flipmode =~ m/a/)
         { $this_css =~ s/#fff\b/#999/gi } # black -> dark grey
      elsif($flipmode =~ m/b/)
         { $this_css =~ s/#000\b/#666/gi } # white -> light grey
  
      my $name = $outname;    
      $name =~ tr/-_/  /;
      $self->add_css( "_$outname.css", 0, $name, 0, 0, \$this_css);
    }
  
    # Now a few indexless variations:
    foreach my $variation (
        'blkbluw', # black_with_blue_on_white
        'whtpurk', # white_with_purple_on_black
        'whtgrng', # white_with_green_on_grey
        'grygrnw', # grey_with_green_on_white
    ) {
      my $outname = $variation;
      my $this_css = join "\n",
        "/* This file is autogenerated.  Do not edit.  $outname */\n",
        "\@import url(\"./_$variation.css\");",
        ".indexgroup { display: none; }",
        "\n",
      ;
      my $name = $outname;    
      $name =~ tr/-_/  /;
      $self->add_css( "_$outname.css", 0, $name, 0, 0, \$this_css);
    }
  
    return;
  }
  
  sub _color_negate {
    my $x = lc $_[0];
    $x =~ tr[0123456789abcdef]
            [fedcba9876543210];
    return $x;
  }
  
  #===========================================================================
  
  sub add_javascript {
    my($self, $url, $content_type, $_code) = @_;
    return unless $url;
    push  @{ $self->_javascript_wad }, [
      $url, $content_type || 'text/javascript', $_code
    ];
    return;
  }
  
  sub _spray_javascript {
    my($self, $outdir) = @_;
    return unless $self->javascript_flurry();
    $self->_gen_javascript_wad();
  
    my $lol = $self->_javascript_wad;
    foreach my $script (@$lol) {
      my $url = $script->[0];
      my $outfile;
      
      if( ref($script->[-1]) and $url =~ m{^(_[-a-z0-9_]+\.js$)} ) {
        $outfile = $self->filespecsys->catfile( $outdir, "$1" );
        DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n";
      } else {
        DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";
        next;
      }
      
      #$self->muse( "Writing JavaScript file $outfile" );
      my $Jsout = $self->_wopen($outfile);
  
      print $Jsout ${$script->[-1]}
       or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";
      close($Jsout);
      DEBUG > 5 and print STDERR "Wrote $outfile\n";
    }
  
    return;
  }
  
  sub _gen_javascript_wad {
    my $self = $_[0];
    my $js_code = $self->_javascript || return;
    $self->add_javascript( "_podly.js", 0, \$js_code);
    return;
  }
  
  sub _javascript_wad_to_markup {
    my($self, $depth) = @_;
    
    my @scripts  = @{ $self->_javascript_wad || return '' };
    return '' unless @scripts;
    
    my $out = '';
  
    --$depth;
    my $uplink = $depth ? ('../' x $depth) : '';
  
    foreach my $s (@scripts) {
      next unless $s and @$s;
  
      my( $url1, $url2, $type, $media) = (
        $self->_maybe_uplink( $s->[0], $uplink ),
        esc(grep !ref($_), @$s)
      );
  
      $out .= qq{<script type="$type" src="$url1$url2"></script>\n};
    }
    return $out;
  }
  
  #===========================================================================
  
  sub _css_template { return $CSS }
  sub _javascript   { return $JAVASCRIPT }
  
  $CSS = <<'EOCSS';
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3, body.pod h4  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  #==========================================================================
  
  $JAVASCRIPT = <<'EOJAVASCRIPT';
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  1;
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::HTMLBatch - convert several Pod files to several HTML files
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::HTMLBatch -e 'Pod::Simple::HTMLBatch::go' in out
  
  
  =head1 DESCRIPTION
  
  This module is used for running batch-conversions of a lot of HTML
  documents 
  
  This class is NOT a subclass of Pod::Simple::HTML
  (nor of bad old Pod::Html) -- although it uses
  Pod::Simple::HTML for doing the conversion of each document.
  
  The normal use of this class is like so:
  
    use Pod::Simple::HTMLBatch;
    my $batchconv = Pod::Simple::HTMLBatch->new;
    $batchconv->some_option( some_value );
    $batchconv->some_other_option( some_other_value );
    $batchconv->batch_convert( \@search_dirs, $output_dir );
  
  =head2 FROM THE COMMAND LINE
  
  Note that this class also provides
  (but does not export) the function Pod::Simple::HTMLBatch::go.
  This is basically just a shortcut for C<<
  Pod::Simple::HTMLBatch->batch_convert(@ARGV) >>.
  It's meant to be handy for calling from the command line.
  
  However, the shortcut requires that you specify exactly two command-line
  arguments, C<indirs> and C<outdir>.
  
  Example:
  
    % mkdir out_html
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go @INC out_html
        (to convert the pod from Perl's @INC
         files under the directory ./out_html)
  
  (Note that the command line there contains a literal atsign-I-N-C.  This
  is handled as a special case by batch_convert, in order to save you having
  to enter the odd-looking "" as the first command-line parameter when you
  mean "just use whatever's in @INC".)
  
  Example:
  
    % mkdir ../seekrut
    % chmod og-rx ../seekrut
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go . ../seekrut
        (to convert the pod under the current dir into HTML
         files under the directory ./seekrut)
  
  Example:
  
    % perl -MPod::Simple::HTMLBatch -e Pod::Simple::HTMLBatch::go happydocs .
        (to convert all pod from happydocs into the current directory)
  
  
  
  =head1 MAIN METHODS
  
  =over
  
  =item $batchconv = Pod::Simple::HTMLBatch->new;
  
  This TODO
  
  
  =item $batchconv->batch_convert( I<indirs>, I<outdir> );
  
  this TODO
  
  =item $batchconv->batch_convert( undef    , ...);
  
  =item $batchconv->batch_convert( q{@INC}, ...);
  
  These two values for I<indirs> specify that the normal Perl @INC
  
  =item $batchconv->batch_convert( \@dirs , ...);
  
  This specifies that the input directories are the items in
  the arrayref C<\@dirs>.
  
  =item $batchconv->batch_convert( "somedir" , ...);
  
  This specifies that the director "somedir" is the input.
  (This can be an absolute or relative path, it doesn't matter.)
  
  A common value you might want would be just "." for the current
  directory:
  
       $batchconv->batch_convert( "." , ...);
  
  
  =item $batchconv->batch_convert( 'somedir:someother:also' , ...);
  
  This specifies that you want the dirs "somedir", "someother", and "also"
  scanned, just as if you'd passed the arrayref
  C<[qw( somedir someother also)]>.  Note that a ":"-separator is normal
  under Unix, but Under MSWin, you'll need C<'somedir;someother;also'>
  instead, since the pathsep on MSWin is ";" instead of ":".  (And
  I<that> is because ":" often comes up in paths, like
  C<"c:/perl/lib">.)
  
  (Exactly what separator character should be used, is gotten from
  C<$Config::Config{'path_sep'}>, via the L<Config> module.)
  
  =item $batchconv->batch_convert( ... , undef );
  
  This specifies that you want the HTML output to go into the current
  directory.
  
  (Note that a missing or undefined value means a different thing in
  the first slot than in the second.  That's so that C<batch_convert()>
  with no arguments (or undef arguments) means "go from @INC, into
  the current directory.)
  
  =item $batchconv->batch_convert( ... , 'somedir' );
  
  This specifies that you want the HTML output to go into the
  directory 'somedir'.
  (This can be an absolute or relative path, it doesn't matter.)
  
  =back
  
  
  Note that you can also call C<batch_convert> as a class method,
  like so:
  
    Pod::Simple::HTMLBatch->batch_convert( ... );
  
  That is just short for this:
  
    Pod::Simple::HTMLBatch-> new-> batch_convert(...);
  
  That is, it runs a conversion with default options, for
  whatever inputdirs and output dir you specify.
  
  
  =head2 ACCESSOR METHODS
  
  The following are all accessor methods -- that is, they don't do anything
  on their own, but just alter the contents of the conversion object,
  which comprises the options for this particular batch conversion.
  
  We show the "put" form of the accessors below (i.e., the syntax you use
  for setting the accessor to a specific value).  But you can also
  call each method with no parameters to get its current value.  For
  example, C<< $self->contents_file() >> returns the current value of
  the contents_file attribute.
  
  =over
  
  
  =item $batchconv->verbose( I<nonnegative_integer> );
  
  This controls how verbose to be during batch conversion, as far as
  notes to STDOUT (or whatever is C<select>'d) about how the conversion
  is going.  If 0, no progress information is printed.
  If 1 (the default value), some progress information is printed.
  Higher values print more information.
  
  
  =item $batchconv->index( I<true-or-false> );
  
  This controls whether or not each HTML page is liable to have a little
  table of contents at the top (which we call an "index" for historical
  reasons).  This is true by default.
  
  
  =item $batchconv->contents_file( I<filename> );
  
  If set, should be the name of a file (in the output directory)
  to write the HTML index to.  The default value is "index.html".
  If you set this to a false value, no contents file will be written.
  
  =item $batchconv->contents_page_start( I<HTML_string> );
  
  This specifies what string should be put at the beginning of
  the contents page.
  The default is a string more or less like this:
  
    <html>
    <head><title>Perl Documentation</title></head>
    <body class='contentspage'>
    <h1>Perl Documentation</h1>
  
  =item $batchconv->contents_page_end( I<HTML_string> );
  
  This specifies what string should be put at the end of the contents page.
  The default is a string more or less like this:
  
    <p class='contentsfooty'>Generated by
    Pod::Simple::HTMLBatch v3.01 under Perl v5.008
    <br >At Fri May 14 22:26:42 2004 GMT,
    which is Fri May 14 14:26:42 2004 local time.</p>
  
  
  
  =item $batchconv->add_css( $url );
  
  TODO
  
  =item $batchconv->add_javascript( $url );
  
  TODO
  
  =item $batchconv->css_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate some CSS files in the
  output directory, and set our HTML files to use those.
  TODO: continue
  
  =item $batchconv->javascript_flurry( I<true-or-false> );
  
  If true (the default value), we autogenerate a JavaScript in the
  output directory, and set our HTML files to use it.  Currently,
  the JavaScript is used only to get the browser to remember what
  stylesheet it prefers.
  TODO: continue
  
  =item $batchconv->no_contents_links( I<true-or-false> );
  
  TODO
  
  =item $batchconv->html_render_class( I<classname> );
  
  This sets what class is used for rendering the files.
  The default is "Pod::Simple::HTML".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::HTML, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =item $batchconv->search_class( I<classname> );
  
  This sets what class is used for searching for the files.
  The default is "Pod::Simple::Search".  If you set it to something else,
  it should probably be a subclass of Pod::Simple::Search, and you should
  C<require> or C<use> that class so that's it's loaded before
  Pod::Simple::HTMLBatch tries loading it.
  
  =back
  
  
  
  
  =head1 NOTES ON CUSTOMIZATION
  
  TODO
  
    call add_css($someurl) to add stylesheet as alternate
    call add_css($someurl,1) to add as primary stylesheet
  
    call add_javascript
  
    subclass Pod::Simple::HTML and set $batchconv->html_render_class to
      that classname
    and maybe override
      $page->batch_mode_page_object_init($self, $module, $infile, $outfile, $depth)
    or maybe override
      $batchconv->batch_mode_page_object_init($page, $module, $infile, $outfile, $depth)
    subclass Pod::Simple::Search and set $batchconv->search_class to
      that classname
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::HTMLBatch>, L<perlpod>, L<perlpodspec>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  
  require 5;
  package Pod::Simple::HTMLLegacy;
  use strict;
  
  use vars qw($VERSION);
  use Getopt::Long;
  
  $VERSION = "5.01";
  
  #--------------------------------------------------------------------------
  # 
  # This class is meant to thinly emulate bad old Pod::Html
  #
  # TODO: some basic docs
  
  sub pod2html {
    my @args = (@_);
    
    my( $verbose, $infile, $outfile, $title );
    my $index = 1;
   
    {
      my($help);
  
      my($netscape); # dummy
      local @ARGV = @args;
      GetOptions(
        "help"       => \$help,
        "verbose!"   => \$verbose,
        "infile=s"   => \$infile,
        "outfile=s"  => \$outfile,
        "title=s"    => \$title,
        "index!"     => \$index,
  
        "netscape!"   => \$netscape,
      ) or return bad_opts(@args);
      bad_opts(@args) if @ARGV; # it should be all switches!
      return help_message() if $help;
    }
  
    for($infile, $outfile) { $_ = undef unless defined and length }
    
    if($verbose) {
      warn sprintf "%s version %s\n", __PACKAGE__, $VERSION;
      warn "OK, processed args [@args] ...\n";
      warn sprintf
        " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",
        map defined($_) ? $_ : "(nil)",
         $verbose,     $index,     $infile,     $outfile,     $title,
      ;
      *Pod::Simple::HTML::DEBUG = sub(){1};
    }
    require Pod::Simple::HTML;
    Pod::Simple::HTML->VERSION(3);
    
    die "No such input file as $infile\n"
     if defined $infile and ! -e $infile;
  
    
    my $pod = Pod::Simple::HTML->new;
    $pod->force_title($title) if defined $title;
    $pod->index($index);
    return $pod->parse_from_file($infile, $outfile);
  }
  
  #--------------------------------------------------------------------------
  
  sub bad_opts     { die _help_message();         }
  sub help_message { print STDOUT _help_message() }
  
  #--------------------------------------------------------------------------
  
  sub _help_message {
  
    join '',
  
  "[", __PACKAGE__, " version ", $VERSION, qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~;
  
  }
  
  1;
  __END__
  
  OVER the underpass! UNDER the overpass! Around the FUTURE and BEYOND REPAIR!!
  
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  
  require 5;
  package Pod::Simple::LinkSection;
    # Based somewhat dimly on Array::Autojoin
  use vars qw($VERSION );
  $VERSION = '3.32';
  
  use strict;
  use Pod::Simple::BlackBox;
  use vars qw($VERSION );
  $VERSION = '3.32';
  
  use overload( # So it'll stringify nice
    '""'   => \&Pod::Simple::BlackBox::stringify_lol,
    'bool' => \&Pod::Simple::BlackBox::stringify_lol,
    # '.='   => \&tack_on,  # grudgingly support
    
    'fallback' => 1,         # turn on cleverness
  );
  
  sub tack_on {
    $_[0] = ['', {}, "$_[0]" ];
    return $_[0][2] .= $_[1];
  }
  
  sub as_string {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  sub stringify {
    goto &Pod::Simple::BlackBox::stringify_lol;
  }
  
  sub new {
    my $class = shift;
    $class = ref($class) || $class;
    my $new;
    if(@_ == 1) {
      if (!ref($_[0] || '')) { # most common case: one bare string
        return bless ['', {}, $_[0] ], $class;
      } elsif( ref($_[0] || '') eq 'ARRAY') {
        $new = [ @{ $_[0] } ];
      } else {
        Carp::croak( "$class new() doesn't know to clone $new" );
      }
    } else { # misc stuff
      $new = [ '', {}, @_ ];
    }
  
    # By now it's a treelet:  [ 'foo', {}, ... ]
    foreach my $x (@$new) {
      if(ref($x || '') eq 'ARRAY') {
        $x = $class->new($x); # recurse
      } elsif(ref($x || '') eq 'HASH') {
        $x = { %$x };
      }
       # otherwise leave it.
    }
  
    return bless $new, $class;
  }
  
  # Not much in this class is likely to be link-section specific --
  # but it just so happens that link-sections are about the only treelets
  # that are exposed to the user.
  
  1;
  
  __END__
  
  # TODO: let it be an option whether a given subclass even wants little treelets?
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::LinkSection -- represent "section" attributes of L codes
  
  =head1 SYNOPSIS
  
   # a long story
  
  =head1 DESCRIPTION
  
  This class is not of interest to general users.
  
  Pod::Simple uses this class for representing the value of the
  "section" attribute of "L" start-element events.  Most applications
  can just use the normal stringification of objects of this class;
  they stringify to just the text content of the section,
  such as "foo" for
  C<< LZ<><Stuff/foo> >>, and "bar" for 
  C<< LZ<><Stuff/bIZ<><ar>> >>.
  
  However, anyone particularly interested in getting the full value of
  the treelet, can just traverse the content of the treeleet
  @$treelet_object.  To wit:
  
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper($_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = bless( [
                     '',
                     {},
                     'b',
                     bless( [
                              'I',
                              {},
                              'ar'
                            ], 'Pod::Simple::LinkSection' ),
                     'baz'
                   ], 'Pod::Simple::LinkSection' );
  
  But stringify it and you get just the text content:
  
    % perl -MData::Dumper -e
      "use base qw(Pod::Simple::Methody);
       sub start_L { print Dumper( '' . $_[1]{'section'} ) }
       __PACKAGE__->new->parse_string_document('=head1 L<Foo/bI<ar>baz>>')
      "
  Output:
    $VAR1 = 'barbaz';
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  
  require 5;
  package Pod::Simple::Methody;
  use strict;
  use Pod::Simple ();
  use vars qw(@ISA $VERSION);
  $VERSION = '3.32';
  @ISA = ('Pod::Simple');
  
  # Yes, we could use named variables, but I want this to be impose
  # as little an additional performance hit as possible.
  
  sub _handle_element_start {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'start_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  sub _handle_text {
    ( $_[0]->can( 'handle_text' )
      || return
    )->(
      @_
    );
  }
  
  sub _handle_element_end {
    $_[1] =~ tr/-:./__/;
    ( $_[0]->can( 'end_' . $_[1] )
      || return
    )->(
      $_[0], $_[2]
    );
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Methody -- turn Pod::Simple events into method calls
  
  =head1 SYNOPSIS
  
   require 5;
   use strict;
   package SomePodFormatter;
   use base qw(Pod::Simple::Methody);
  
   sub handle_text {
     my($self, $text) = @_;
     ...
   }
  
   sub start_head1 {
     my($self, $attrs) = @_;
     ...
   }
   sub end_head1 {
     my($self) = @_;
     ...
   }
  
  ...and start_/end_ methods for whatever other events you want to catch.
  
  =head1 DESCRIPTION
  
  This class is of
  interest to people writing Pod formatters based on Pod::Simple.
  
  This class (which is very small -- read the source) overrides
  Pod::Simple's _handle_element_start, _handle_text, and
  _handle_element_end methods so that parser events are turned into method
  calls. (Otherwise, this is a subclass of L<Pod::Simple> and inherits all
  its methods.)
  
  You can use this class as the base class for a Pod formatter/processor.
  
  =head1 METHOD CALLING
  
  When Pod::Simple sees a "=head1 Hi there", for example, it basically does
  this:
  
    $parser->_handle_element_start( "head1", \%attributes );
    $parser->_handle_text( "Hi there" );
    $parser->_handle_element_end( "head1" );
  
  But if you subclass Pod::Simple::Methody, it will instead do this
  when it sees a "=head1 Hi there":
  
    $parser->start_head1( \%attributes ) if $parser->can('start_head1');
    $parser->handle_text( "Hi there" )   if $parser->can('handle_text');
    $parser->end_head1()                 if $parser->can('end_head1');
  
  If Pod::Simple sends an event where the element name has a dash,
  period, or colon, the corresponding method name will have a underscore
  in its place.  For example, "foo.bar:baz" becomes start_foo_bar_baz
  and end_foo_bar_baz.
  
  See the source for Pod::Simple::Text for an example of using this class.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  
  require 5;
  package Pod::Simple::Progress;
  $VERSION = '3.32';
  use strict;
  
  # Objects of this class are used for noting progress of an
  #  operation every so often.  Messages delivered more often than that
  #  are suppressed.
  #
  # There's actually nothing in here that's specific to Pod processing;
  #  but it's ad-hoc enough that I'm not willing to give it a name that
  #  implies that it's generally useful, like "IO::Progress" or something.
  #
  # -- sburke
  #
  #--------------------------------------------------------------------------
  
  sub new {
    my($class,$delay) = @_;
    my $self = bless {'quiet_until' => 1},  ref($class) || $class;
    $self->to(*STDOUT{IO});
    $self->delay(defined($delay) ? $delay : 5);
    return $self;
  }
  
  sub copy { 
    my $orig = shift;
    bless {%$orig, 'quiet_until' => 1}, ref($orig);
  }
  #--------------------------------------------------------------------------
  
  sub reach {
    my($self, $point, $note) = @_;
    if( (my $now = time) >= $self->{'quiet_until'}) {
      my $goal;
      my    $to = $self->{'to'};
      print $to join('',
        ($self->{'quiet_until'} == 1) ? () : '... ',
        (defined $point) ? (
          '#',
          ($goal = $self->{'goal'}) ? (
            ' ' x (length($goal) - length($point)),
            $point, '/', $goal,
          ) : $point,
          $note ? ': ' : (),
        ) : (),
        $note || '',
        "\n"
      );
      $self->{'quiet_until'} = $now + $self->{'delay'};
    }
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub done {
    my($self, $note) = @_;
    $self->{'quiet_until'} = 1;
    return $self->reach( undef, $note );
  }
  
  #--------------------------------------------------------------------------
  # Simple accessors:
  
  sub delay {
    return $_[0]{'delay'} if @_ == 1; $_[0]{'delay'} = $_[1]; return $_[0] }
  sub goal {
    return $_[0]{'goal' } if @_ == 1; $_[0]{'goal' } = $_[1]; return $_[0] }
  sub to   {
    return $_[0]{'to'   } if @_ == 1; $_[0]{'to'   } = $_[1]; return $_[0] }
  
  #--------------------------------------------------------------------------
  
  unless(caller) { # Simple self-test:
    my $p = __PACKAGE__->new->goal(5);
    $p->reach(1, "Primus!");
    sleep 1;
    $p->reach(2, "Secundus!");
    sleep 3;
    $p->reach(3, "Tertius!");
    sleep 5;
    $p->reach(4);
    $p->reach(5, "Quintus!");
    sleep 1;
    $p->done("All done");
  }
  
  #--------------------------------------------------------------------------
  1;
  __END__
  
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;
  package Pod::Simple::PullParser;
  $VERSION = '3.32';
  use Pod::Simple ();
  BEGIN {@ISA = ('Pod::Simple')}
  
  use strict;
  use Carp ();
  
  use Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserTextToken;
  
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  __PACKAGE__->_accessorize(
    'source_fh',         # the filehandle we're reading from
    'source_scalar_ref', # the scalarref we're reading from
    'source_arrayref',   # the arrayref we're reading from
  );
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  And here is how we implement a pull-parser on top of a push-parser...
  
  sub filter {
    my($self, $source) = @_;
    $self = $self->new unless ref $self;
  
    $source = *STDIN{IO} unless defined $source;
    $self->set_source($source);
    $self->output_fh(*STDOUT{IO});
  
    $self->run; # define run() in a subclass if you want to use filter()!
    return $self;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  sub parse_string_document {
    my $this = shift;
    $this->set_source(\ $_[0]);
    $this->run;
  }
  
  sub parse_file {
    my($this, $filename) = @_;
    $this->set_source($filename);
    $this->run;
  }
  
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #  In case anyone tries to use them:
  
  sub run {
    use Carp ();
    if( __PACKAGE__ eq ref($_[0]) || $_[0]) { # I'm not being subclassed!
      Carp::croak "You can call run() only on subclasses of "
       . __PACKAGE__;
    } else {
      Carp::croak join '',
        "You can't call run() because ",
        ref($_[0]) || $_[0], " didn't define a run() method";
    }
  }
  
  sub parse_lines {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_lines";
  }
  
  sub parse_line {
    use Carp ();
    Carp::croak "Use set_source with ", __PACKAGE__,
      " and subclasses, not parse_line";
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $class = shift;
    my $self = $class->SUPER::new(@_);
    die "Couldn't construct for $class" unless $self;
  
    $self->{'token_buffer'} ||= [];
    $self->{'start_token_class'} ||= 'Pod::Simple::PullParserStartToken';
    $self->{'text_token_class'}  ||= 'Pod::Simple::PullParserTextToken';
    $self->{'end_token_class'}   ||= 'Pod::Simple::PullParserEndToken';
  
    DEBUG > 1 and print STDERR "New pullparser object: $self\n";
  
    return $self;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_token {
    my $self = shift;
    DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";
    DEBUG > 2 and print STDERR " Items in token-buffer (",
     scalar( @{ $self->{'token_buffer'} } ) ,
     ") :\n", map(
       "    " . $_->dump . "\n", @{ $self->{'token_buffer'} }
     ),
     @{ $self->{'token_buffer'} } ? '' : '       (no tokens)',
     "\n"
    ;
  
    until( @{ $self->{'token_buffer'} } ) {
      DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";
      if($self->{'source_dead'}) {
        DEBUG and print STDERR "$self 's source is dead.\n";
        push @{ $self->{'token_buffer'} }, undef;
      } elsif(exists $self->{'source_fh'}) {
        my @lines;
        my $fh = $self->{'source_fh'}
         || Carp::croak('You have to call set_source before you can call get_token');
         
        DEBUG and print STDERR "$self 's source is filehandle $fh.\n";
        # Read those many lines at a time
        for(my $i = Pod::Simple::MANY_LINES; $i--;) {
          DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";
          local $/ = $Pod::Simple::NL;
          push @lines, scalar(<$fh>); # readline
          DEBUG > 3 and print STDERR "  Line is: ",
            defined($lines[-1]) ? $lines[-1] : "<undef>\n";
          unless( defined $lines[-1] ) {
            DEBUG and print STDERR "That's it for that source fh!  Killing.\n";
            delete $self->{'source_fh'}; # so it can be GC'd
            last;
          }
           # but pass thru the undef, which will set source_dead to true
  
          # TODO: look to see if $lines[-1] is =encoding, and if so,
          # do horribly magic things
  
        }
        
        if(DEBUG > 8) {
          print STDERR "* I've gotten ", scalar(@lines), " lines:\n";
          foreach my $l (@lines) {
            if(defined $l) {
              print STDERR "  line {$l}\n";
            } else {
              print STDERR "  line undef\n";
            }
          }
          print STDERR "* end of ", scalar(@lines), " lines\n";
        }
  
        $self->SUPER::parse_lines(@lines);
        
      } elsif(exists $self->{'source_arrayref'}) {
        DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",
         scalar(@{$self->{'source_arrayref'}}), " items left in it.\n";
  
        DEBUG > 3 and print STDERR "  Fetching ", Pod::Simple::MANY_LINES, " lines.\n";
        $self->SUPER::parse_lines(
          splice @{ $self->{'source_arrayref'} },
          0,
          Pod::Simple::MANY_LINES
        );
        unless( @{ $self->{'source_arrayref'} } ) {
          DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_arrayref'}; # so it can be GC'd
        }
         # to make sure that an undef is always sent to signal end-of-stream
  
      } elsif(exists $self->{'source_scalar_ref'}) {
  
        DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",
          length(${ $self->{'source_scalar_ref'} }) -
          (pos(${ $self->{'source_scalar_ref'} }) || 0),
          " characters left to parse.\n";
  
        DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";
        if( ${ $self->{'source_scalar_ref'} } =~
          m/([^\n\r]*)((?:\r?\n)?)/g
        ) {
          #print(">> $1\n"),
          $self->SUPER::parse_lines($1)
           if length($1) or length($2)
            or pos(     ${ $self->{'source_scalar_ref'} })
             != length( ${ $self->{'source_scalar_ref'} });
           # I.e., unless it's a zero-length "empty line" at the very
           #  end of "foo\nbar\n" (i.e., between the \n and the EOS).
        } else { # that's the end.  Byebye
          $self->SUPER::parse_lines(undef);
          delete $self->{'source_scalar_ref'};
          DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n";
        }
  
        
      } else {
        die "What source??";
      }
    }
    DEBUG and print STDERR "get_token about to return ",
     Pod::Simple::pretty( @{$self->{'token_buffer'}}
       ? $self->{'token_buffer'}[-1] : undef
     ), "\n";
    return shift @{$self->{'token_buffer'}}; # that's an undef if empty
  }
  
  sub unget_token {
    my $self = shift;
    DEBUG and print STDERR "Ungetting ", scalar(@_), " tokens: ",
     @_ ? "@_\n" : "().\n";
    foreach my $t (@_) {
      Carp::croak "Can't unget that, because it's not a token -- it's undef!"
       unless defined $t;
      Carp::croak "Can't unget $t, because it's not a token -- it's a string!"
       unless ref $t;
      Carp::croak "Can't unget $t, because it's not a token object!"
       unless UNIVERSAL::can($t, 'type');
    }
    
    unshift @{$self->{'token_buffer'}}, @_;
    DEBUG > 1 and print STDERR "Token buffer now has ",
     scalar(@{$self->{'token_buffer'}}), " items in it.\n";
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  # $self->{'source_filename'} = $source;
  
  sub set_source {
    my $self = shift @_;
    return $self->{'source_fh'} unless @_;
    Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")
        if $self->{'source_fh'} || $self->{'source_scalar_ref'} || $self->{'source_arrayref'};
    my $handle;
    if(!defined $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } elsif(ref(\( $_[0] )) eq 'GLOB') {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is glob $_[0]\n";
      # and fall thru   
    } elsif(ref( $_[0] ) eq 'SCALAR') {
      $self->{'source_scalar_ref'} = $_[0];
      DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";
      return;
    } elsif(ref( $_[0] ) eq 'ARRAY') {
      $self->{'source_arrayref'} = $_[0];
      DEBUG and print STDERR "$self 's source is array ref $_[0]\n";
      return;
    } elsif(ref $_[0]) {
      $self->{'source_filename'} = '' . ($handle = $_[0]);
      DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n";
    } elsif(!length $_[0]) {
      Carp::croak("Can't use empty-string as a source for set_source");
    } else {  # It's a filename!
      DEBUG and print STDERR "$self 's source is filename $_[0]\n";
      {
        local *PODSOURCE;
        open(PODSOURCE, "<$_[0]") || Carp::croak "Can't open $_[0]: $!";
        $handle = *PODSOURCE{IO};
      }
      $self->{'source_filename'} = $_[0];
      DEBUG and print STDERR "  Its name is $_[0].\n";
  
      # TODO: file-discipline things here!
    }
  
    $self->{'source_fh'} = $handle;
    DEBUG and print STDERR "  Its handle is $handle\n";
    return 1;
  }
  
  # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  
  sub get_title_short {  shift->get_short_title(@_)  } # alias
  
  sub get_short_title {
    my $title = shift->get_title(@_);
    $title = $1 if $title =~ m/^(\S{1,60})\s+--?\s+./s;
      # turn "Foo::Bar -- bars for your foo" into "Foo::Bar"
    return $title;
  }
  
  sub get_title       { shift->_get_titled_section(
    'NAME', max_token => 50, desperate => 1, @_)
  }
  sub get_version     { shift->_get_titled_section(
     'VERSION',
      max_token => 400,
      accept_verbatim => 1,
      max_content_length => 3_000,
     @_,
    );
  }
  sub get_description { shift->_get_titled_section(
     'DESCRIPTION',
      max_token => 400,
      max_content_length => 3_000,
     @_,
  ) }
  
  sub get_authors     { shift->get_author(@_) }  # a harmless alias
  
  sub get_author      {
    my $this = shift;
    # Max_token is so high because these are
    #  typically at the end of the document:
    $this->_get_titled_section('AUTHOR' , max_token => 10_000, @_) ||
    $this->_get_titled_section('AUTHORS', max_token => 10_000, @_);
  }
  
  #--------------------------------------------------------------------------
  
  sub _get_titled_section {
    # Based on a get_title originally contributed by Graham Barr
    my($self, $titlename, %options) = (@_);
    
    my $max_token            = delete $options{'max_token'};
    my $desperate_for_title  = delete $options{'desperate'};
    my $accept_verbatim      = delete $options{'accept_verbatim'};
    my $max_content_length   = delete $options{'max_content_length'};
    my $nocase               = delete $options{'nocase'};
    $max_content_length = 120 unless defined $max_content_length;
  
    Carp::croak( "Unknown " . ((1 == keys %options) ? "option: " : "options: ")
      . join " ", map "[$_]", sort keys %options
    )
     if keys %options;
  
    my %content_containers;
    $content_containers{'Para'} = 1;
    if($accept_verbatim) {
      $content_containers{'Verbatim'} = 1;
      $content_containers{'VerbatimFormatted'} = 1;
    }
  
    my $token_count = 0;
    my $title;
    my @to_unget;
    my $state = 0;
    my $depth = 0;
  
    Carp::croak "What kind of titlename is \"$titlename\"?!" unless
     defined $titlename and $titlename =~ m/^[A-Z ]{1,60}$/s; #sanity
    my $titlename_re = quotemeta($titlename);
  
    my $head1_text_content;
    my $para_text_content;
    my $skipX;
  
    while(
      ++$token_count <= ($max_token || 1_000_000)
      and defined(my $token = $self->get_token)
    ) {
      push @to_unget, $token;
  
      if ($state == 0) { # seeking =head1
        if( $token->is_start and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found head1.  Seeking content...\n";
          ++$state;
          $head1_text_content = '';
        }
      }
  
      elsif($state == 1) { # accumulating text until end of head1
        if( $token->is_text ) {
            unless ($skipX) {
              DEBUG and print STDERR "   Adding \"", $token->text, "\" to head1-content.\n";
              $head1_text_content .= $token->text;
            }
        } elsif( $token->is_tagname('X') ) {
            # We're going to want to ignore X<> stuff.
            $skipX = $token->is_start;
            DEBUG and print STDERR +($skipX ? 'Start' : 'End'), 'ing ignoring of X<> tag';
        } elsif( $token->is_end and $token->tagname eq 'head1' ) {
          DEBUG and print STDERR "  Found end of head1.  Considering content...\n";
          $head1_text_content = uc $head1_text_content if $nocase;
          if($head1_text_content eq $titlename
            or $head1_text_content =~ m/\($titlename_re\)/s
            # We accept "=head1 Nomen Modularis (NAME)" for sake of i18n
          ) {
            DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";
            ++$state;
          } elsif(
            $desperate_for_title
             # if we're so desperate we'll take the first
             #  =head1's content as a title
            and $head1_text_content =~ m/\S/
            and $head1_text_content !~ m/^[ A-Z]+$/s
            and $head1_text_content !~
              m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx
              # avoid accepting things like =head1 Thingy Thongy (DESCRIPTION)
            and ($max_content_length
              ? (length($head1_text_content) <= $max_content_length) # sanity
              : 1)
          ) {
            # Looks good; trim it
            ($title = $head1_text_content) =~ s/\s+$//;
            DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";
            last;
          } else {
            --$state;
            DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n",
              "\n  Dropping back to seeking-head1-content mode...\n";
          }
        }
      }
      
      elsif($state == 2) {
        # seeking start of para (which must immediately follow)
        if($token->is_start and $content_containers{ $token->tagname }) {
          DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";
          $para_text_content = '';
          ++$state;
        } else {
          DEBUG and print
           "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";
          $state = 0;
        }
      }
      
      elsif($state == 3) {
        # accumulating text until end of Para
        if( $token->is_text ) {
          DEBUG and print STDERR "   Adding \"", $token->text, "\" to para-content.\n";
          $para_text_content .= $token->text;
          # and keep looking
          
        } elsif( $token->is_end and $content_containers{ $token->tagname } ) {
          DEBUG and print STDERR "  Found end of Para.  Considering content: ",
            $para_text_content, "\n";
  
          if( $para_text_content =~ m/\S/
            and ($max_content_length
             ? (length($para_text_content) <= $max_content_length)
             : 1)
          ) {
            # Some minimal sanity constraints, I think.
            DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";
            $title = $para_text_content;
            last;
          } else {
            DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";
            undef $title;
            last;
          }
        }
      }
      
      else {
        die "IMPOSSIBLE STATE $state!\n";  # should never happen
      }
      
    }
    
    # Put it all back!
    $self->unget_token(@to_unget);
    
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
    
    return '' unless defined $title;
    $title =~ s/^\s+//;
    return $title;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  #
  #  Methods that actually do work at parse-time:
  
  sub _handle_element_start {
    my $self = shift;   # leaving ($element_name, $attr_hash_r)
    DEBUG > 2 and print STDERR "++ $_[0] (", map("<$_> ", %{$_[1]}), ")\n";
    
    push @{ $self->{'token_buffer'} },
         $self->{'start_token_class'}->new(@_);
    return;
  }
  
  sub _handle_text {
    my $self = shift;   # leaving ($text)
    DEBUG > 2 and print STDERR "== $_[0]\n";
    push @{ $self->{'token_buffer'} },
         $self->{'text_token_class'}->new(@_);
    return;
  }
  
  sub _handle_element_end {
    my $self = shift;   # leaving ($element_name);
    DEBUG > 2 and print STDERR "-- $_[0]\n";
    push @{ $self->{'token_buffer'} }, 
         $self->{'end_token_class'}->new(@_);
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParser -- a pull-parser interface to parsing Pod
  
  =head1 SYNOPSIS
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( "whatever.pod" );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( $some_filehandle_object );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \$document_source );
   $parser->run;
  
  Or:
  
   my $parser = SomePodProcessor->new;
   $parser->set_source( \@document_lines );
   $parser->run;
  
  And elsewhere:
  
   require 5;
   package SomePodProcessor;
   use strict;
   use base qw(Pod::Simple::PullParser);
  
   sub run {
     my $self = shift;
    Token:
     while(my $token = $self->get_token) {
       ...process each token...
     }
   }
  
  =head1 DESCRIPTION
  
  This class is for using Pod::Simple to build a Pod processor -- but
  one that uses an interface based on a stream of token objects,
  instead of based on events.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  A subclass of Pod::Simple::PullParser should define a C<run> method
  that calls C<< $token = $parser->get_token >> to pull tokens.
  
  See the source for Pod::Simple::RTF for an example of a formatter
  that uses Pod::Simple::PullParser.
  
  =head1 METHODS
  
  =over
  
  =item my $token = $parser->get_token
  
  This returns the next token object (which will be of a subclass of
  L<Pod::Simple::PullParserToken>), or undef if the parser-stream has hit
  the end of the document.
  
  =item $parser->unget_token( $token )
  
  =item $parser->unget_token( $token1, $token2, ... )
  
  This restores the token object(s) to the front of the parser stream.
  
  =back
  
  The source has to be set before you can parse anything.  The lowest-level
  way is to call C<set_source>:
  
  =over
  
  =item $parser->set_source( $filename )
  
  =item $parser->set_source( $filehandle_object )
  
  =item $parser->set_source( \$document_source )
  
  =item $parser->set_source( \@document_lines )
  
  =back
  
  Or you can call these methods, which Pod::Simple::PullParser has defined
  to work just like Pod::Simple's same-named methods:
  
  =over
  
  =item $parser->parse_file(...)
  
  =item $parser->parse_string_document(...)
  
  =item $parser->filter(...)
  
  =item $parser->parse_from_file(...)
  
  =back
  
  For those to work, the Pod-processing subclass of
  Pod::Simple::PullParser has to have defined a $parser->run method --
  so it is advised that all Pod::Simple::PullParser subclasses do so.
  See the Synopsis above, or the source for Pod::Simple::RTF.
  
  Authors of formatter subclasses might find these methods useful to
  call on a parser object that you haven't started pulling tokens
  from yet:
  
  =over
  
  =item my $title_string = $parser->get_title
  
  This tries to get the title string out of $parser, by getting some tokens,
  and scanning them for the title, and then ungetting them so that you can
  process the token-stream from the beginning.
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  $parser->get_title on that document will return "Hoo::Boy::Wowza --
  Stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_title(nocase => 1);
  
  In cases where get_title can't find the title, it will return empty-string
  ("").
  
  =item my $title_string = $parser->get_short_title
  
  This is just like get_title, except that it returns just the modulename, if
  the title seems to be of the form "SomeModuleName -- description".
  
  For example, suppose you have a document that starts out:
  
    =head1 NAME
  
    Hoo::Boy::Wowza -- Stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return
  "Hoo::Boy::Wowza".
  
  But if the document starts out:
  
    =head1 NAME
  
    Hooboy, stuff B<wow> yeah!
  
  then $parser->get_short_title on that document will return "Hooboy,
  stuff wow yeah!". If the document starts with:
  
    =head1 Name
  
    Hoo::Boy::W00t -- Stuff B<w00t> yeah!
  
  Then you'll need to pass the C<nocase> option in order to recognize "Name":
  
    $parser->get_short_title(nocase => 1);
  
  If the title can't be found, then get_short_title returns empty-string
  ("").
  
  =item $author_name   = $parser->get_author
  
  This works like get_title except that it returns the contents of the
  "=head1 AUTHOR\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Author\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_author(nocase => 1);
  
  (This method tolerates "AUTHORS" instead of "AUTHOR" too.)
  
  =item $description_name = $parser->get_description
  
  This works like get_title except that it returns the contents of the
  "=head1 DESCRIPTION\n\nParagraph...\n" section, assuming that that section
  isn't terribly long. To recognize a "=head1 Description\n\nParagraph\n"
  section, pass the C<nocase> option:
  
    $parser->get_description(nocase => 1);
  
  =item $version_block = $parser->get_version
  
  This works like get_title except that it returns the contents of
  the "=head1 VERSION\n\n[BIG BLOCK]\n" block.  Note that this does NOT
  return the module's C<$VERSION>!! To recognize a
  "=head1 Version\n\n[BIG BLOCK]\n" section, pass the C<nocase> option:
  
    $parser->get_version(nocase => 1);
  
  =back
  
  =head1 NOTE
  
  You don't actually I<have> to define a C<run> method.  If you're
  writing a Pod-formatter class, you should define a C<run> just so
  that users can call C<parse_file> etc, but you don't I<have> to.
  
  And if you're not writing a formatter class, but are instead just
  writing a program that does something simple with a Pod::PullParser
  object (and not an object of a subclass), then there's no reason to
  bother subclassing to add a C<run> method.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<Pod::Simple::PullParserToken> -- and its subclasses
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<HTML::TokeParser>, which inspired this.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
  
  JUNK:
  
  sub _old_get_title {  # some witchery in here
    my $self = $_[0];
    my $title;
    my @to_unget;
  
    while(1) {
      push @to_unget, $self->get_token;
      unless(defined $to_unget[-1]) { # whoops, short doc!
        pop @to_unget;
        last;
      }
  
      DEBUG and print STDERR "-Got token ", $to_unget[-1]->dump, "\n";
  
      (DEBUG and print STDERR "Too much in the buffer.\n"),
       last if @to_unget > 25; # sanity
      
      my $pattern = '';
      if( #$to_unget[-1]->type eq 'end'
          #and $to_unget[-1]->tagname eq 'Para'
          #and
          ($pattern = join('',
           map {;
              ($_->type eq 'start') ? ("<" . $_->tagname .">")
            : ($_->type eq 'end'  ) ? ("</". $_->tagname .">")
            : ($_->type eq 'text' ) ? ($_->text =~ m<^([A-Z]+)$>s ? $1 : 'X')
            : "BLORP"
           } @to_unget
         )) =~ m{<head1>NAME</head1><Para>(X|</?[BCIFLS]>)+</Para>$}s
      ) {
        # Whee, it fits the pattern
        DEBUG and print STDERR "Seems to match =head1 NAME pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname eq 'Para';
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
  
      } elsif ($pattern =~ m{<head(\d)>(.+)</head\d>$}
        and !( $1 eq '1' and $2 eq 'NAME' )
      ) {
        # Well, it fits a fallback pattern
        DEBUG and print STDERR "Seems to match NAMEless pattern.\n";
        $title = '';
        foreach my $t (reverse @to_unget) {
          last if $t->type eq 'start' and $t->tagname =~ m/^head\d$/s;
          $title = $t->text . $title if $t->type eq 'text';
        }
        undef $title if $title =~ m<^\s*$>; # make sure it's contentful!
        last;
        
      } else {
        DEBUG and $pattern and print STDERR "Leading pattern: $pattern\n";
      }
    }
    
    # Put it all back:
    $self->unget_token(@to_unget);
    
    if(DEBUG) {
      if(defined $title) { print STDERR "  Returning title <$title>\n" }
      else { print STDERR "Returning title <>\n" }
    }
    
    return '' unless defined $title;
    return $title;
  }
  
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  
  require 5;
  package Pod::Simple::PullParserEndToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.32';
  
  sub new {  # Class->new(tagname);
    my $class = shift;
    return bless ['end', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  # shortcut:
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserEndToken -- end-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this end-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this end-token object.
  You probably won't need to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserEndToken->new( I<tagname> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  
  require 5;
  package Pod::Simple::PullParserStartToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.32';
  
  sub new {  # Class->new(tagname, optional_attrhash);
    my $class = shift;
    return bless ['start', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub tagname   { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  sub tag { shift->tagname(@_) }
  
  sub is_tagname { $_[0][1] eq $_[1] }
  sub is_tag { shift->is_tagname(@_) }
  
  
  sub attr_hash { $_[0][2] ||= {} }
  
  sub attr      {
    if(@_ == 2) {      # Reading: $token->attr('attrname')
      ${$_[0][2] || return undef}{ $_[1] };
    } elsif(@_ > 2) {  # Writing: $token->attr('attrname', 'newval')
      ${$_[0][2] ||= {}}{ $_[1] } = $_[2];
    } else {
      require Carp;
      Carp::croak(
        'usage: $object->attr("val") or $object->attr("key", "newval")');
      return undef;
    }
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserStartToken -- start-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser> object, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->tagname
  
  This returns the tagname for this start-token object.
  For example, parsing a "=head1 ..." line will give you
  a start-token with the tagname of "head1", token(s) for its
  content, and then an end-token with the tagname of "head1".
  
  =item $token->tagname(I<somestring>)
  
  This changes the tagname for this start-token object.
  You probably won't need
  to do this.
  
  =item $token->tag(...)
  
  A shortcut for $token->tagname(...)
  
  =item $token->is_tag(I<somestring>) or $token->is_tagname(I<somestring>)
  
  These are shortcuts for C<< $token->tag() eq I<somestring> >>
  
  =item $token->attr(I<attrname>)
  
  This returns the value of the I<attrname> attribute for this start-token
  object, or undef.
  
  For example, parsing a LZ<><Foo/"Bar"> link will produce a start-token
  with a "to" attribute with the value "Foo", a "type" attribute with the
  value "pod", and a "section" attribute with the value "Bar".
  
  =item $token->attr(I<attrname>, I<newvalue>)
  
  This sets the I<attrname> attribute for this start-token object to
  I<newvalue>.  You probably won't need to do this.
  
  =item $token->attr_hash
  
  This returns the hashref that is the attribute set for this start-token.
  This is useful if (for example) you want to ask what all the attributes
  are -- you can just do C<< keys %{$token->attr_hash} >>
  
  =back
  
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserStartToken->new( I<tagname>, I<attrhash> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  
  require 5;
  package Pod::Simple::PullParserTextToken;
  use Pod::Simple::PullParserToken ();
  use strict;
  use vars qw(@ISA $VERSION);
  @ISA = ('Pod::Simple::PullParserToken');
  $VERSION = '3.32';
  
  sub new {  # Class->new(text);
    my $class = shift;
    return bless ['text', @_], ref($class) || $class;
  }
  
  # Purely accessors:
  
  sub text { (@_ == 2) ? ($_[0][1] = $_[1]) : $_[0][1] }
  
  sub text_r { \ $_[0][1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserTextToken -- text-tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  (See L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you might
  get an object of this class.
  
  This is a subclass of L<Pod::Simple::PullParserToken> and inherits all its methods,
  and adds these methods:
  
  =over
  
  =item $token->text
  
  This returns the text that this token holds.  For example, parsing
  CZ<><foo> will return a C start-token, a text-token, and a C end-token.  And
  if you want to get the "foo" out of the text-token, call C<< $token->text >>
  
  =item $token->text(I<somestring>)
  
  This changes the string that this token holds.  You probably won't need
  to do this.
  
  =item $token->text_r()
  
  This returns a scalar reference to the string that this token holds.
  This can be useful if you don't want to memory-copy the potentially
  large text value (well, as large as a paragraph or a verbatim block)
  as calling $token->text would do.
  
  Or, if you want to alter the value, you can even do things like this:
  
    for ( ${  $token->text_r  } ) {  # Aliases it with $_ !!
  
      s/ The / the /g; # just for example
  
      if( 'A' eq chr(65) ) {  # (if in an ASCII world)
        tr/\xA0/ /;
        tr/\xAD//d;
      }
  
      ...or however you want to alter the value...
      (Note that starting with Perl v5.8, you can use, e.g.,
  
          my $nbsp = chr utf8::unicode_to_native(0xA0);
          s/$nbsp/ /g;
  
      to handle the above regardless if it's an ASCII world or not)
    }
  
  =back
  
  You're unlikely to ever need to construct an object of this class for
  yourself, but if you want to, call
  C<<
  Pod::Simple::PullParserTextToken->new( I<text> )
  >>
  
  =head1 SEE ALSO
  
  L<Pod::Simple::PullParserToken>, L<Pod::Simple>, L<Pod::Simple::Subclassing>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  
  require 5;
  package Pod::Simple::PullParserToken;
   # Base class for tokens gotten from Pod::Simple::PullParser's $parser->get_token
  @ISA = ();
  $VERSION = '3.32';
  use strict;
  
  sub new {  # Class->new('type', stuff...);  ## Overridden in derived classes anyway
    my $class = shift;
    return bless [@_], ref($class) || $class;
  }
  
  sub type { $_[0][0] }  # Can't change the type of an object
  sub dump { Pod::Simple::pretty( [ @{ $_[0] } ] ) }
  
  sub is_start { $_[0][0] eq 'start' }
  sub is_end   { $_[0][0] eq 'end'   }
  sub is_text  { $_[0][0] eq 'text'  }
  
  1;
  __END__
  
  sub dump { '[' . _esc( @{ $_[0] } ) . ']' }
  
  # JUNK:
  
  sub _esc {
    return '' unless @_;
    my @out;
    foreach my $in (@_) {
      push @out, '"' . $in . '"';
      $out[-1] =~ s/([^- \:\:\.\,\'\>\<\"\/\=\?\+\|\[\]\{\}\_a-zA-Z0-9_\`\~\!\#\%\^\&\*\(\)])/
        sprintf( (ord($1) < 256) ? "\\x%02X" : "\\x{%X}", ord($1))
      /eg;
    }
    return join ', ', @out;
  }
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::PullParserToken -- tokens from Pod::Simple::PullParser
  
  =head1 SYNOPSIS
  
  Given a $parser that's an object of class Pod::Simple::PullParser
  (or a subclass)...
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      if($token->is_start) {
        ...access $token->tagname, $token->attr, etc...
  
      } elsif($token->is_text) {
        ...access $token->text, $token->text_r, etc...
  
      } elsif($token->is_end) {
        ...access $token->tagname...
  
      }
    }
  
  (Also see L<Pod::Simple::PullParser>)
  
  =head1 DESCRIPTION
  
  When you do $parser->get_token on a L<Pod::Simple::PullParser>, you should
  get an object of a subclass of Pod::Simple::PullParserToken.
  
  Subclasses will add methods, and will also inherit these methods:
  
  =over
  
  =item $token->type
  
  This returns the type of the token.  This will be either the string
  "start", the string "text", or the string "end".
  
  Once you know what the type of an object is, you then know what
  subclass it belongs to, and therefore what methods it supports.
  
  Yes, you could probably do the same thing with code like
  $token->isa('Pod::Simple::PullParserEndToken'), but that's not so
  pretty as using just $token->type, or even the following shortcuts:
  
  =item $token->is_start
  
  This is a shortcut for C<< $token->type() eq "start" >>
  
  =item $token->is_text
  
  This is a shortcut for C<< $token->type() eq "text" >>
  
  =item $token->is_end
  
  This is a shortcut for C<< $token->type() eq "end" >>
  
  =item $token->dump
  
  This returns a handy stringified value of this object.  This
  is useful for debugging, as in:
  
    while(my $token = $parser->get_token) {
      $DEBUG and print STDERR "Token: ", $token->dump, "\n";
      ...
    }
  
  =back
  
  =head1 SEE ALSO
  
  My subclasses:
  L<Pod::Simple::PullParserStartToken>,
  L<Pod::Simple::PullParserTextToken>, and
  L<Pod::Simple::PullParserEndToken>.
  
  L<Pod::Simple::PullParser> and L<Pod::Simple>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  
  require 5;
  package Pod::Simple::RTF;
  
  #sub DEBUG () {4};
  #sub Pod::Simple::DEBUG () {4};
  #sub Pod::Simple::PullParser::DEBUG () {4};
  
  use strict;
  use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);
  $VERSION = '3.32';
  use Pod::Simple::PullParser ();
  BEGIN {@ISA = ('Pod::Simple::PullParser')}
  
  use Carp ();
  BEGIN { *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG }
  
  $WRAP = 1 unless defined $WRAP;
  
  # These are broken for early Perls on EBCDIC; they could be fixed to work
  # better there, but not worth it.  These are part of a larger [...] class, so
  # are just the strings to substitute into it, as opposed to compiled patterns.
  my $cntrl = '[:cntrl:]';
  $cntrl = '\x00-\x1F\x7F' unless eval "qr/[$cntrl]/";
  
  my $not_ascii = '[:^ascii:]';
  $not_ascii = '\x80-\xFF' unless eval "qr/[$not_ascii]/";
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _openclose {
   return map {;
     m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";
     ( $1,  "{\\$2\n",   "/$1",  "}" );
   } @_;
  }
  
  my @_to_accept;
  
  %Tagmap = (
   # 'foo=bar' means ('foo' => '{\bar'."\n", '/foo' => '}')
   _openclose(
    'B=cs18\b',
    'I=cs16\i',
    'C=cs19\f1\lang1024\noproof',
    'F=cs17\i\lang1024\noproof',
  
    'VerbatimI=cs26\i',
    'VerbatimB=cs27\b',
    'VerbatimBI=cs28\b\i',
  
    map {; m/^([-a-z]+)/s && push @_to_accept, $1; $_ }
     qw[
         underline=ul         smallcaps=scaps  shadow=shad
         superscript=super    subscript=sub    strikethrough=strike
         outline=outl         emboss=embo      engrave=impr   
         dotted-underline=uld          dash-underline=uldash
         dot-dash-underline=uldashd    dot-dot-dash-underline=uldashdd     
         double-underline=uldb         thick-underline=ulth
         word-underline=ulw            wave-underline=ulwave
     ]
     # But no double-strikethrough, because MSWord can't agree with the
     #  RTF spec on whether it's supposed to be \strikedl or \striked1 (!!!)
   ),
  
   # Bit of a hack here:
   'L=pod' => '{\cs22\i'."\n",
   'L=url' => '{\cs23\i'."\n",
   'L=man' => '{\cs24\i'."\n",
   '/L' => '}',
  
   'Data'  => "\n",
   '/Data' => "\n",
  
   'Verbatim'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/Verbatim' => "\n\\par}\n",
   'VerbatimFormatted'  => "\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",
   '/VerbatimFormatted' => "\n\\par}\n",
   'Para'    => "\n{\\pard\\li#rtfindent#\\sa180\n",
   '/Para'   => "\n\\par}\n",
   'head1'   => "\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",
   '/head1'  => "\n}\\par}\n",
   'head2'   => "\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",
   '/head2'  => "\n}\\par}\n",
   'head3'   => "\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",
   '/head3'  => "\n}\\par}\n",
   'head4'   => "\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",
   '/head4'  => "\n}\\par}\n",
     # wordpad borks on \tc\tcl1, or I'd put that in =head1 and =head2
  
   'item-bullet'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-bullet' => "\n\\par}\n",
   'item-number'  => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-number' => "\n\\par}\n",
   'item-text'    => "\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",
   '/item-text'   => "\n\\par}\n",
  
   # we don't need any styles for over-* and /over-*
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub new {
    my $new = shift->SUPER::new(@_);
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->accept_targets( 'rtf', 'RTF' );
  
    $new->{'Tagmap'} = {%Tagmap};
  
    $new->accept_codes(@_to_accept);
    $new->accept_codes('VerbatimFormatted');
    DEBUG > 2 and print STDERR "To accept: ", join(' ',@_to_accept), "\n";
    $new->doc_lang(
      (  $ENV{'RTFDEFLANG'} || '') =~ m/^(\d{1,10})$/s ? $1
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1)
                                        # yes, tolerate hex!
      : ($ENV{'RTFDEFLANG'} || '') =~ m/^([a-fA-F0-9]{4})$/s ? hex($1)
                                        # yes, tolerate even more hex!
      : '1033'
    );
  
    $new->head1_halfpoint_size(32);
    $new->head2_halfpoint_size(28);
    $new->head3_halfpoint_size(25);
    $new->head4_halfpoint_size(22);
    $new->codeblock_halfpoint_size(18);
    $new->header_halfpoint_size(17);
    $new->normal_halfpoint_size(25);
  
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  __PACKAGE__->_accessorize(
   'doc_lang',
   'head1_halfpoint_size',
   'head2_halfpoint_size',
   'head3_halfpoint_size',
   'head4_halfpoint_size',
   'codeblock_halfpoint_size',
   'header_halfpoint_size',
   'normal_halfpoint_size',
   'no_proofing_exemptions',
  );
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub run {
    my $self = $_[0];
    return $self->do_middle if $self->bare_output;
    return
     $self->do_beginning && $self->do_middle && $self->do_end;
  }
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub do_middle {      # the main work
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    
    my($token, $type, $tagname, $scratch);
    my @stack;
    my @indent_stack;
    $self->{'rtfindent'} = 0 unless defined $self->{'rtfindent'};
    
    while($token = $self->get_token) {
    
      if( ($type = $token->type) eq 'text' ) {
        if( $self->{'rtfverbatim'} ) {
          DEBUG > 1 and print STDERR "  $type " , $token->text, " in verbatim!\n";
          rtf_esc_codely($scratch = $token->text);
          print $fh $scratch;
          next;
        }
  
        DEBUG > 1 and print STDERR "  $type " , $token->text, "\n";
        
        $scratch = $token->text;
        $scratch =~ tr/\t\cb\cc/ /d;
        
        $self->{'no_proofing_exemptions'} or $scratch =~
         s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             [a-zA-Z'${not_ascii}]+[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg
        ;
        
        rtf_esc($scratch);
        $scratch =~
           s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx     # and put a NL before those spaces
          if $WRAP;
          # This may wrap at well past the 65th column, but not past the 120th.
        
        print $fh $scratch;
  
      } elsif( $type eq 'start' ) {
        DEBUG > 1 and print STDERR "  +$type ",$token->tagname,
          " (", map("<$_> ", %{$token->attr_hash}), ")\n";
  
        if( ($tagname = $token->tagname) eq 'Verbatim'
            or $tagname eq 'VerbatimFormatted'
        ) {
          ++$self->{'rtfverbatim'};
          my $next = $self->get_token;
          next unless defined $next;
          my $line_count = 1;
          if($next->type eq 'text') {
            my $t = $next->text_r;
            while( $$t =~ m/$/mg ) {
              last if  ++$line_count  > 15; # no point in counting further
            }
            DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n";
          }
          $self->unget_token($next);
          $self->{'rtfkeep'} = ($line_count > 15) ? '' : '\keepn' ;     
  
        } elsif( $tagname =~ m/^item-/s ) {
          my @to_unget;
          my $text_count_here = 0;
          $self->{'rtfitemkeepn'} = '';
          # Some heuristics to stop item-*'s functioning as subheadings
          #  from getting split from the things they're subheadings for.
          #
          # It's not terribly pretty, but it really does make things pretty.
          #
          while(1) {
            push @to_unget, $self->get_token;
            pop(@to_unget), last unless defined $to_unget[-1];
             # Erroneously used to be "unshift" instead of pop!  Adds instead
             # of removes, and operates on the beginning instead of the end!
            
            if($to_unget[-1]->type eq 'text') {
              if( ($text_count_here += length ${$to_unget[-1]->text_r}) > 150 ){
                DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";
                last;
              }
            } elsif (@to_unget > 1 and
              $to_unget[-2]->type eq 'end' and
              $to_unget[-2]->tagname =~ m/^item-/s
            ) {
              # Bail out here, after setting rtfitemkeepn yea or nay.
              $self->{'rtfitemkeepn'} = '\keepn' if 
                $to_unget[-1]->type eq 'start' and
                $to_unget[-1]->tagname eq 'Para';
  
              DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",
                $to_unget[-1]->type,
                $to_unget[-1]->can('tagname') ? $to_unget[-1]->tagname : '',
                $self->{'rtfitemkeepn'} ? "gets" : "doesn't get";
              last;
            } elsif (@to_unget > 40) {
              DEBUG > 1 and print STDERR "    item-* now has too many tokens (",
                scalar(@to_unget),
                (DEBUG > 4) ? (q<: >, map($_->dump, @to_unget)) : (),
                ") to be keepn'd.\n";
              last; # give up
            }
            # else keep while'ing along
          }
          # Now put it aaaaall back...
          $self->unget_token(@to_unget);
  
        } elsif( $tagname =~ m/^over-/s ) {
          push @stack, $1;
          push @indent_stack,
           int($token->attr('indent') * 4 * $self->normal_halfpoint_size);
          DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} += $indent_stack[-1];
          
        } elsif ($tagname eq 'L') {
          $tagname .= '=' . ($token->attr('type') || 'pod');
          
        } elsif ($tagname eq 'Data') {
          my $next = $self->get_token;
          next unless defined $next;
          unless( $next->type eq 'text' ) {
            $self->unget_token($next);
            next;
          }
          DEBUG and print STDERR "    raw text ", $next->text, "\n";
          printf $fh "\n" . $next->text . "\n";
          next;
        }
  
        defined($scratch = $self->{'Tagmap'}{$tagname}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
        
        if ($tagname eq 'item-number') {
          print $fh $token->attr('number'), ". \n";
        } elsif ($tagname eq 'item-bullet') {
          print $fh "\\'", ord("_"), "\n";
          #for funky testing: print $fh '', rtf_esc("\x{4E4B}\x{9053}");
        }
  
      } elsif( $type eq 'end' ) {
        DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";
        if( ($tagname = $token->tagname) =~ m/^over-/s ) {
          DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";
          $self->{'rtfindent'} -= pop @indent_stack;
          pop @stack;
        } elsif( $tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted') {
          --$self->{'rtfverbatim'};
        }
        defined($scratch = $self->{'Tagmap'}{"/$tagname"}) or next;
        $scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g; # interpolate
        print $fh $scratch;
      }
    }
    return 1;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  sub do_beginning {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh join '',
      $self->doc_init,
      $self->font_table,
      $self->stylesheet,
      $self->color_table,
      $self->doc_info,
      $self->doc_start,
      "\n"
    ;
  }
  
  sub do_end {
    my $self = $_[0];
    my $fh = $self->{'output_fh'};
    return print $fh '}'; # that should do it
  }
  
  ###########################################################################
  
  sub stylesheet {
    return sprintf <<'END',
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  
     $_[0]->codeblock_halfpoint_size(),
     $_[0]->head1_halfpoint_size(),
     $_[0]->head2_halfpoint_size(),
     $_[0]->head3_halfpoint_size(),
     $_[0]->head4_halfpoint_size(),
    ;
  }
  
  ###########################################################################
  # Override these as necessary for further customization
  
  sub font_table {
    return <<'END';  # text font, code font, heading font
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  }
  
  sub doc_init {
     return <<'END';
  {\rtf1\ansi\deff0
  
  END
  }
  
  sub color_table {
     return <<'END';
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  }
  
  
  sub doc_info {
     my $self = $_[0];
  
     my $class = ref($self) || $self;
  
     my $tag = __PACKAGE__ . ' ' . $VERSION;
     
     unless($class eq __PACKAGE__) {
       $tag = " ($tag)";
       $tag = " v" . $self->VERSION . $tag   if   defined $self->VERSION;
       $tag = $class . $tag;
     }
  
     return sprintf <<'END',
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  
    # None of the following things should need escaping, I dare say!
      $tag, 
      $ISA[0], $ISA[0]->VERSION(),
      $], scalar(gmtime),
    ;
  }
  
  sub doc_start {
    my $self = $_[0];
    my $title = $self->get_short_title();
    DEBUG and print STDERR "Short Title: <$title>\n";
    $title .= ' ' if length $title;
    
    $title =~ s/ *$/ /s;
    $title =~ s/^ //s;
    $title =~ s/ $/, /s;
     # make sure it ends in a comma and a space, unless it's 0-length
  
    my $is_obviously_module_name;
    $is_obviously_module_name = 1
     if $title =~ m/^\S+$/s and $title =~ m/::/s;
      # catches the most common case, at least
  
    DEBUG and print STDERR "Title0: <$title>\n";
    $title = rtf_esc($title);
    DEBUG and print STDERR "Title1: <$title>\n";
    $title = '\lang1024\noproof ' . $title
     if $is_obviously_module_name;
  
    return sprintf <<'END', 
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
      ($self->doc_lang) x 2,
      $self->header_halfpoint_size,
      $title,
      $self->normal_halfpoint_size,
    ;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #-------------------------------------------------------------------------
  
  use integer;
  sub rtf_esc {
    my $x; # scratch
    if(!defined wantarray) { # void context: alter in-place!
      for(@_) {
        s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      }
      return;
    } elsif(wantarray) {  # return an array
      return map {; ($x = $_) =~
        s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
        $x;
      } @_;
    } else { # return a single scalar
      ($x = ((@_ == 1) ? $_[0] : join '', @_)
      ) =~ s/([F${cntrl}\-\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
               # Escape \, {, }, -, control chars, and 7f-ff.
      $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      return $x;
    }
  }
  
  sub rtf_esc_codely {
    # Doesn't change "-" to hard-hyphen, nor apply computerese style-smarts.
    # We don't want to change the "-" to hard-hyphen, because we want to
    #  be able to paste this into a file and run it without there being
    #  dire screaming about the mysterious hard-hyphen character (which
    #  looks just like a normal dash character).
    
    my $x; # scratch
    if(!defined wantarray) { # void context: alter in-place!
      for(@_) {
        s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      }
      return;
    } elsif(wantarray) {  # return an array
      return map {; ($x = $_) =~
        s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
        $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
        $x;
      } @_;
    } else { # return a single scalar
      ($x = ((@_ == 1) ? $_[0] : join '', @_)
      ) =~ s/([F${cntrl}\\\{\}${not_ascii}])/$Escape{$1}/g;  # ESCAPER
               # Escape \, {, }, -, control chars, and 7f-ff.
      $x =~ s/([^\x00-\xFF])/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg;
      return $x;
    }
  }
  
  %Escape = (
    (($] lt 5.007_003) # Broken for non-ASCII on early Perls
     ? (map( (chr($_),chr($_)), # things not apparently needing escaping
         0x20 .. 0x7E ),
        map( (chr($_),sprintf("\\'%02x", $_)), # apparently escapeworthy things
         0x00 .. 0x1F, 0x5c, 0x7b, 0x7d, 0x7f .. 0xFF, 0x46))
     : (map( (chr(utf8::unicode_to_native($_)),chr(utf8::unicode_to_native($_))),
         0x20 .. 0x7E ),
        map( (chr($_),sprintf("\\'%02x", utf8::unicode_to_native($_))),
         0x00 .. 0x1F, 0x5c, 0x7b, 0x7d, 0x7f .. 0xFF, 0x46))),
  
    # We get to escape out 'F' so that we can send RTF files thru the mail
    # without the slightest worry that paragraphs beginning with "From"
    # will get munged.
  
    # And some refinements:
    "\r"  => "\n",
    "\cj"  => "\n",
    "\n"   => "\n\\line ",
  
    "\t"   => "\\tab ",     # Tabs (altho theoretically raw \t's are okay)
    "\f"   => "\n\\page\n", # Formfeed
    "-"    => "\\_",        # Turn plaintext '-' into a non-breaking hyphen
    $Pod::Simple::nbsp => "\\~",        # Latin-1 non-breaking space
    $Pod::Simple::shy => "\\-",        # Latin-1 soft (optional) hyphen
  
    # CRAZY HACKS:
    "\n" => "\\line\n",
    "\r" => "\n",
    "\cb" => "{\n\\cs21\\lang1024\\noproof ",  # \\cf1
    "\cc" => "}",
  );
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::RTF -- format Pod as RTF
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::RTF -e \
     "exit Pod::Simple::RTF->filter(shift)->any_errata_seen" \
     thingy.pod > thingy.rtf
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as RTF, good for
  viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 FORMAT CONTROL ATTRIBUTES
  
  You can set these attributes on the parser object before you
  call C<parse_file> (or a similar method) on it:
  
  =over
  
  =item $parser->head1_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head2_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head3_halfpoint_size( I<halfpoint_integer> );
  
  =item $parser->head4_halfpoint_size( I<halfpoint_integer> );
  
  These methods set the size (in half-points, like 52 for 26-point)
  that these heading levels will appear as.
  
  =item $parser->codeblock_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 21 for 10.5-point)
  that codeblocks ("verbatim sections") will appear as.
  
  =item $parser->header_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 15 for 7.5-point)
  that the header on each page will appear in.  The header
  is usually just "I<modulename> p. I<pagenumber>".
  
  =item $parser->normal_halfpoint_size( I<halfpoint_integer> );
  
  This method sets the size (in half-points, like 26 for 13-point)
  that normal paragraphic text will appear in.
  
  =item $parser->no_proofing_exemptions( I<true_or_false> );
  
  Set this value to true if you don't want the formatter to try
  putting a hidden code on all Perl symbols (as best as it can
  notice them) that labels them as being not in English, and
  so not worth spellchecking.
  
  =item $parser->doc_lang( I<microsoft_decimal_language_code> )
  
  This sets the language code to tag this document as being in. By
  default, it is currently the value of the environment variable
  C<RTFDEFLANG>, or if that's not set, then the value
  1033 (for US English).
  
  Setting this appropriately is useful if you want to use the RTF
  to spellcheck, and/or if you want it to hyphenate right.
  
  Here are some notable values:
  
    1033  US English
    2057  UK English
    3081  Australia English
    4105  Canada English
    1034  Spain Spanish
    2058  Mexico Spanish
    1031  Germany German
    1036  France French
    3084  Canada French
    1035  Finnish
    1044  Norwegian (Bokmal)
    2068  Norwegian (Nynorsk)
  
  =back
  
  If you are particularly interested in customizing this module's output
  even more, see the source and/or write to me.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<RTF::Writer>, L<RTF::Cookbook>, L<RTF::Document>,
  L<RTF::Generator>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;
  package Pod::Simple::Search;
  use strict;
  
  use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);
  $VERSION = '3.32';   ## Current version of this package
  
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG; }   # set DEBUG level
  use Carp ();
  
  $SLEEPY = 1 if !defined $SLEEPY and $^O =~ /mswin|mac/i;
    # flag to occasionally sleep for $SLEEPY - 1 seconds.
  
  $MAX_VERSION_WITHIN ||= 60;
  my $IS_CASE_INSENSITIVE = -e uc __FILE__ && -e lc __FILE__;
  
  #############################################################################
  
  #use diagnostics;
  use File::Spec ();
  use File::Basename qw( basename dirname );
  use Config ();
  use Cwd qw( cwd );
  
  #==========================================================================
  __PACKAGE__->_accessorize(  # Make my dumb accessor methods
   'callback', 'progress', 'dir_prefix', 'inc', 'laborious', 'limit_glob',
   'limit_re', 'shadows', 'verbose', 'name2path', 'path2name', 'recurse',
   'ciseen'
  );
  #==========================================================================
  
  sub new {
    my $class = shift;
    my $self = bless {}, ref($class) || $class;
    $self->init;
    return $self;
  }
  
  sub init {
    my $self = shift;
    $self->inc(1);
    $self->recurse(1);
    $self->verbose(DEBUG);
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub survey {
    my($self, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    $self->_expand_inc( \@search_dirs );
  
    $self->{'_scan_count'} = 0;
    $self->{'_dirs_visited'} = {};
    $self->path2name( {} );
    $self->name2path( {} );
    $self->ciseen( {} );
    $self->limit_re( $self->_limit_glob_to_limit_re ) if $self->{'limit_glob'};
    my $cwd = cwd();
    my $verbose  = $self->verbose;
    local $_; # don't clobber the caller's $_ !
  
    foreach my $try (@search_dirs) {
      unless( File::Spec->file_name_is_absolute($try) ) {
        # make path absolute
        $try = File::Spec->catfile( $cwd ,$try);
      }
      # simplify path
      $try =  File::Spec->canonpath($try);
  
      my $start_in;
      my $modname_prefix;
      if($self->{'dir_prefix'}) {
        $start_in = File::Spec->catdir(
          $try,
          grep length($_), split '[\\/:]+', $self->{'dir_prefix'}
        );
        $modname_prefix = [grep length($_), split m{[:/\\]}, $self->{'dir_prefix'}];
        $verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ",
          "giving $start_in (= @$modname_prefix)\n";
      } else {
        $start_in = $try;
      }
  
      if( $self->{'_dirs_visited'}{$start_in} ) {
        $verbose and print "Directory '$start_in' already seen, skipping.\n";
        next;
      } else {
        $self->{'_dirs_visited'}{$start_in} = 1;
      }
    
      unless(-e $start_in) {
        $verbose and print "Skipping non-existent $start_in\n";
        next;
      }
  
      my $closure = $self->_make_search_callback;
      
      if(-d $start_in) {
        # Normal case:
        $verbose and print "Beginning excursion under $start_in\n";
        $self->_recurse_dir( $start_in, $closure, $modname_prefix );
        $verbose and print "Back from excursion under $start_in\n\n";
          
      } elsif(-f _) {
        # A excursion consisting of just one file!
        $_ = basename($start_in);
        $verbose and print "Pondering $start_in ($_)\n";
        $closure->($start_in, $_, 0, []);
          
      } else {
        $verbose and print "Skipping mysterious $start_in\n";
      }
    }
    $self->progress and $self->progress->done(
     "Noted $$self{'_scan_count'} Pod files total");
    $self->ciseen( {} );
  
    return unless defined wantarray; # void
    return $self->name2path unless wantarray; # scalar
    return $self->name2path, $self->path2name; # list
  }
  
  #==========================================================================
  sub _make_search_callback {
    my $self = $_[0];
  
    # Put the options in variables, for easy access
    my( $laborious, $verbose, $shadows, $limit_re, $callback, $progress,
        $path2name, $name2path, $recurse, $ciseen) =
      map scalar($self->$_()),
       qw(laborious verbose shadows limit_re callback progress
          path2name name2path recurse ciseen);
    my ($seen, $remember, $files_for);
    if ($IS_CASE_INSENSITIVE) {
        $seen      = sub { $ciseen->{ lc $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $ciseen->{ lc $_[0] } = $_[1]; };
        $files_for = sub { my $n = lc $_[0]; grep { lc $path2name->{$_} eq $n } %{ $path2name } };
    } else {
        $seen      = sub { $name2path->{ $_[0] } };
        $remember  = sub { $name2path->{ $_[0] } = $_[1] };
        $files_for = sub { my $n = $_[0]; grep { $path2name->{$_} eq $n } %{ $path2name } };
    }
  
    my($file, $shortname, $isdir, $modname_bits);
    return sub {
      ($file, $shortname, $isdir, $modname_bits) = @_;
  
      if($isdir) { # this never gets called on the startdir itself, just subdirs
  
        unless( $recurse ) {
          $verbose and print "Not recursing into '$file' as per requested.\n";
          return 'PRUNE';
        }
  
        if( $self->{'_dirs_visited'}{$file} ) {
          $verbose and print "Directory '$file' already seen, skipping.\n";
          return 'PRUNE';
        }
  
        print "Looking in dir $file\n" if $verbose;
  
        unless ($laborious) { # $laborious overrides pruning
          if( m/^(\d+\.[\d_]{3,})\z/s
               and do { my $x = $1; $x =~ tr/_//d; $x != $] }
             ) {
            $verbose and print "Perl $] version mismatch on $_, skipping.\n";
            return 'PRUNE';
          }
  
          if( m/^([A-Za-z][a-zA-Z0-9_]*)\z/s ) {
            $verbose and print "$_ is a well-named module subdir.  Looking....\n";
          } else {
            $verbose and print "$_ is a fishy directory name.  Skipping.\n";
            return 'PRUNE';
          }
        } # end unless $laborious
  
        $self->{'_dirs_visited'}{$file} = 1;
        return; # (not pruning);
      }
  
      # Make sure it's a file even worth even considering
      if($laborious) {
        unless(
          m/\.(pod|pm|plx?)\z/i || -x _ and -T _
           # Note that the cheapest operation (the RE) is run first.
        ) {
          $verbose > 1 and print " Brushing off uninteresting $file\n";
          return;
        }
      } else {
        unless( m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is ) {
          $verbose > 1 and print " Brushing off oddly-named $file\n";
          return;
        }
      }
  
      $verbose and print "Considering item $file\n";
      my $name = $self->_path2modname( $file, $shortname, $modname_bits );
      $verbose > 0.01 and print " Nominating $file as $name\n";
          
      if($limit_re and $name !~ m/$limit_re/i) {
        $verbose and print "Shunning $name as not matching $limit_re\n";
        return;
      }
  
      if( !$shadows and $seen->($name) ) {
        $verbose and print "Not worth considering $file ",
          "-- already saw $name as ",
          join(' ', $files_for->($name)), "\n";
        return;
      }
  
      # Put off until as late as possible the expense of
      #  actually reading the file:
      $progress and $progress->reach($self->{'_scan_count'}, "Scanning $file");
      return unless $self->contains_pod( $file );
      ++ $self->{'_scan_count'};
  
      # Or finally take note of it:
      if ( my $prev = $seen->($name)  ) {
        $verbose and print
         "Duplicate POD found (shadowing?): $name ($file)\n",
         "    Already seen in ", join(' ', $files_for->($name)), "\n";
      } else {
        $remember->($name, $file); # Noting just the first occurrence
      }
      $verbose and print "  Noting $name = $file\n";
      if( $callback ) {
        local $_ = $_; # insulate from changes, just in case
        $callback->($file, $name);
      }
      $path2name->{$file} = $name;
      return;
    }
  }
  
  #==========================================================================
  
  sub _path2modname {
    my($self, $file, $shortname, $modname_bits) = @_;
  
    # this code simplifies the POD name for Perl modules:
    # * remove "site_perl"
    # * remove e.g. "i586-linux" (from 'archname')
    # * remove e.g. 5.00503
    # * remove pod/ if followed by perl*.pod (e.g. in pod/perlfunc.pod)
    # * dig into the file for case-preserved name if not already mixed case
  
    my @m = @$modname_bits;
    my $x;
    my $verbose = $self->verbose;
  
    # Shaving off leading naughty-bits
    while(@m
      and defined($x = lc( $m[0] ))
      and(  $x eq 'site_perl'
         or($x eq 'pod' and @m == 1 and $shortname =~ m{^perl.*\.pod$}s )
         or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?}  # if looks like a vernum
         or $x eq lc( $Config::Config{'archname'} )
    )) { shift @m }
  
    my $name = join '::', @m, $shortname;
    $self->_simplify_base($name);
  
    # On VMS, case-preserved document names can't be constructed from
    # filenames, so try to extract them from the "=head1 NAME" tag in the
    # file instead.
    if ($^O eq 'VMS' && ($name eq lc($name) || $name eq uc($name))) {
        open PODFILE, "<$file" or die "_path2modname: Can't open $file: $!";
        my $in_pod = 0;
        my $in_name = 0;
        my $line;
        while ($line = <PODFILE>) {
          chomp $line;
          $in_pod = 1 if ($line =~ m/^=\w/);
          $in_pod = 0 if ($line =~ m/^=cut/);
          next unless $in_pod;         # skip non-pod text
          next if ($line =~ m/^\s*\z/);           # and blank lines
          next if ($in_pod && ($line =~ m/^X</)); # and commands
          if ($in_name) {
            if ($line =~ m/(\w+::)?(\w+)/) {
              # substitute case-preserved version of name
              my $podname = $2;
              my $prefix = $1 || '';
              $verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";
              unless ($name =~ s/$prefix$podname/$prefix$podname/i) {
                $verbose and print "Attempting case restore of '$name' from '$podname'\n";
                $name =~ s/$podname/$podname/i;
              }
              last;
            }
          }
          $in_name = 1 if ($line =~ m/^=head1 NAME/);
      }
      close PODFILE;
    }
  
    return $name;
  }
  
  #==========================================================================
  
  sub _recurse_dir {
    my($self, $startdir, $callback, $modname_bits) = @_;
  
    my $maxdepth = $self->{'fs_recursion_maxdepth'} || 10;
    my $verbose = $self->verbose;
  
    my $here_string = File::Spec->curdir;
    my $up_string   = File::Spec->updir;
    $modname_bits ||= [];
  
    my $recursor;
    $recursor = sub {
      my($dir_long, $dir_bare) = @_;
      if( @$modname_bits >= 10 ) {
        $verbose and print "Too deep! [@$modname_bits]\n";
        return;
      }
  
      unless(-d $dir_long) {
        $verbose > 2 and print "But it's not a dir! $dir_long\n";
        return;
      }
      unless( opendir(INDIR, $dir_long) ) {
        $verbose > 2 and print "Can't opendir $dir_long : $!\n";
        closedir(INDIR);
        return
      }
  
      # Load all items; put no extension before .pod before .pm before .plx?.
      my @items = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] || $b->[2] cmp $a->[2] }
        map {
          (my $t = $_) =~ s/[.]p(m|lx?|od)\z//;
          [$_, $t, lc($1 || 'z') ]
        } readdir(INDIR);
      closedir(INDIR);
  
      push @$modname_bits, $dir_bare unless $dir_bare eq '';
  
      my $i_full;
      foreach my $i (@items) {
        next if $i eq $here_string or $i eq $up_string or $i eq '';
        $i_full = File::Spec->catfile( $dir_long, $i );
  
        if(!-r $i_full) {
          $verbose and print "Skipping unreadable $i_full\n";
         
        } elsif(-f $i_full) {
          $_ = $i;
          $callback->(          $i_full, $i, 0, $modname_bits );
  
        } elsif(-d _) {
          $i =~ s/\.DIR\z//i if $^O eq 'VMS';
          $_ = $i;
          my $rv = $callback->( $i_full, $i, 1, $modname_bits ) || '';
  
          if($rv eq 'PRUNE') {
            $verbose > 1 and print "OK, pruning";
          } else {
            # Otherwise, recurse into it
            $recursor->( File::Spec->catdir($dir_long, $i) , $i);
          }
        } else {
          $verbose > 1 and print "Skipping oddity $i_full\n";
        }
      }
      pop @$modname_bits;
      return;
    };;
  
    local $_;
    $recursor->($startdir, '');
  
    undef $recursor;  # allow it to be GC'd
  
    return;  
  }
  
  
  #==========================================================================
  
  sub run {
    # A function, useful in one-liners
  
    my $self = __PACKAGE__->new;
    $self->limit_glob($ARGV[0]) if @ARGV;
    $self->callback( sub {
      my($file, $name) = @_;
      my $version = '';
       
      # Yes, I know we won't catch the version in like a File/Thing.pm
      #  if we see File/Thing.pod first.  That's just the way the
      #  cookie crumbles.  -- SMB
       
      if($file =~ m/\.pod$/i) {
        # Don't bother looking for $VERSION in .pod files
        DEBUG and print "Not looking for \$VERSION in .pod $file\n";
      } elsif( !open(INPOD, $file) ) {
        DEBUG and print "Couldn't open $file: $!\n";
        close(INPOD);
      } else {
        # Sane case: file is readable
        my $lines = 0;
        while(<INPOD>) {
          last if $lines++ > $MAX_VERSION_WITHIN; # some degree of sanity
          if( s/^\s*\$VERSION\s*=\s*//s and m/\d/ ) {
            DEBUG and print "Found version line (#$lines): $_";
            s/\s*\#.*//s;
            s/\;\s*$//s;
            s/\s+$//s;
            s/\t+/ /s; # nix tabs
            # Optimize the most common cases:
            $_ = "v$1"
              if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s
               # like in $VERSION = "3.14159";
               or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s
               # like in sprintf("%d.%02d", q$Revision: 4.13 $ =~ /(\d+)\.(\d+)/);
            ;
             
            # Like in sprintf("%d.%s", map {s/_//g; $_} q$Name: release-0_55-public $ =~ /-(\d+)_([\d_]+)/)
            $_ = sprintf("v%d.%s",
              map {s/_//g; $_}
                $1 =~ m/-(\d+)_([\d_]+)/) # snare just the numeric part
             if m{\$Name:\s*([^\$]+)\$}s 
            ;
            $version = $_;
            DEBUG and print "Noting $version as version\n";
            last;
          }
        }
        close(INPOD);
      }
      print "$name\t$version\t$file\n";
      return;
      # End of callback!
    });
  
    $self->survey;
  }
  
  #==========================================================================
  
  sub simplify_name {
    my($self, $str) = @_;
      
    # Remove all path components
    #                             XXX Why not just use basename()? -- SMB
  
    if ($^O eq 'MacOS') { $str =~ s{^.*:+}{}s }
    else                { $str =~ s{^.*/+}{}s }
    
    $self->_simplify_base($str);
    return $str;
  }
  
  #==========================================================================
  
  sub _simplify_base {   # Internal method only
  
    # strip Perl's own extensions
    $_[1] =~ s/\.(pod|pm|plx?)\z//i;
  
    # strip meaningless extensions on Win32 and OS/2
    $_[1] =~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;
  
    # strip meaningless extensions on VMS
    $_[1] =~ s/\.(com)\z//i if $^O eq 'VMS';
  
    return;
  }
  
  #==========================================================================
  
  sub _expand_inc {
    my($self, $search_dirs) = @_;
    
    return unless $self->{'inc'};
    my %seen = map { File::Spec->rel2abs($_) => 1 } @{ $search_dirs };
  
    if ($^O eq 'MacOS') {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } $self->_mac_whammy(@INC);
    # Any other OSs need custom handling here?
    } else {
      push @$search_dirs,
        grep { !$seen{ File::Spec->rel2abs($_) }++ } @INC;
    }
  
    $self->{'laborious'} = 0;   # Since inc said to use INC
    return;
  }
  
  #==========================================================================
  
  sub _mac_whammy { # Tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
    my @them;
    (undef,@them) = @_;
    for $_ (@them) {
      if ( $_ eq '.' ) {
        $_ = ':';
      } elsif ( $_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e ) {
        $_ = ':'. $_;
      } else {
        $_ =~ s|^\./|:|;
      }
    }
    return @them;
  }
  
  #==========================================================================
  
  sub _limit_glob_to_limit_re {
    my $self = $_[0];
    my $limit_glob = $self->{'limit_glob'} || return;
  
    my $limit_re = '^' . quotemeta($limit_glob) . '$';
    $limit_re =~ s/\\\?/./g;    # glob "?" => "."
    $limit_re =~ s/\\\*/.*?/g;  # glob "*" => ".*?"
    $limit_re =~ s/\.\*\?\$$//s; # final glob "*" => ".*?$" => ""
  
    $self->{'verbose'} and print "Turning limit_glob $limit_glob into re $limit_re\n";
  
    # A common optimization:
    if(!exists($self->{'dir_prefix'})
      and $limit_glob =~ m/^(?:\w+\:\:)+/s  # like "File::*" or "File::Thing*"
      # Optimize for sane and common cases (but not things like "*::File")
    ) {
      $self->{'dir_prefix'} = join "::", $limit_glob =~ m/^(?:\w+::)+/sg;
      $self->{'verbose'} and print " and setting dir_prefix to $self->{'dir_prefix'}\n";
    }
  
    return $limit_re;
  }
  
  #==========================================================================
  
  # contribution mostly from Tim Jenness <t.jenness@jach.hawaii.edu>
  
  sub _actual_filenames {
      my $dir = shift;
      my $fn = lc shift;
      opendir my $dh, $dir or return;
      return map { File::Spec->catdir($dir, $_) }
          grep { lc $_  eq $fn } readdir $dh;
  }
  
  sub find {
    my($self, $pod, @search_dirs) = @_;
    $self = $self->new unless ref $self; # tolerate being a class method
  
    # Check usage
    Carp::carp 'Usage: \$self->find($podname, ...)'
     unless defined $pod and length $pod;
  
    my $verbose = $self->verbose;
  
    # Split on :: and then join the name together using File::Spec
    my @parts = split /::/, $pod;
    $verbose and print "Chomping {$pod} => {@parts}\n";
  
    #@search_dirs = File::Spec->curdir unless @search_dirs;
    
    $self->_expand_inc(\@search_dirs);
    # Add location of binaries such as pod2text:
    push @search_dirs, $Config::Config{'scriptdir'} if $self->inc;
  
    my %seen_dir;
    while (my $dir = shift @search_dirs ) {
      next unless defined $dir and length $dir;
      next if $seen_dir{$dir};
      $seen_dir{$dir} = 1;
      unless(-d $dir) {
        print "Directory $dir does not exist\n" if $verbose;
      }
  
      print "Looking in directory $dir\n" if $verbose;
      my $fullname = File::Spec->catfile( $dir, @parts );
      print "Filename is now $fullname\n" if $verbose;
  
      foreach my $ext ('', '.pod', '.pm', '.pl') {   # possible extensions
        my $fullext = $fullname . $ext;
        if ( -f $fullext and $self->contains_pod($fullext) ) {
          print "FOUND: $fullext\n" if $verbose;
          if (@parts > 1 && lc $parts[0] eq 'pod' && $IS_CASE_INSENSITIVE && $ext eq '.pod') {
            # Well, this file could be for a program (perldoc) but we actually
            # want a module (Pod::Perldoc). So see if there is a .pm with the
            # proper casing.
            my $subdir = dirname $fullext;
            unless (grep { $fullext eq $_  } _actual_filenames $subdir, "$parts[-1].pod") {
              print "# Looking for alternate spelling in $subdir\n" if $verbose;
              # Try the .pm file.
              my $pm = $fullname . '.pm';
              if ( -f $pm and $self->contains_pod($pm) ) {
                # Prefer the .pm if its case matches.
                if (grep { $pm eq $_  } _actual_filenames $subdir, "$parts[-1].pm") {
                  print "FOUND: $fullext\n" if $verbose;
                  return $pm;
                }
              }
            }
          }
          return $fullext;
        }
      }
  
      # Case-insensitively Look for ./pod directories and slip them in.
      for my $subdir ( _actual_filenames($dir, 'pod') ) {
        if (-d $subdir) {
          $verbose and print "Noticing $subdir and looking there...\n";
          unshift @search_dirs, $subdir;
        }
      }
    }
  
    return undef;
  }
  
  #==========================================================================
  
  sub contains_pod {
    my($self, $file) = @_;
    my $verbose = $self->{'verbose'};
  
    # check for one line of POD
    $verbose > 1 and print " Scanning $file for pod...\n";
    unless( open(MAYBEPOD,"<$file") ) {
      print "Error: $file is unreadable: $!\n";
      return undef;
    }
  
    sleep($SLEEPY - 1) if $SLEEPY;
     # avoid totally hogging the processor on OSs with poor process control
    
    local $_;
    while( <MAYBEPOD> ) {
      if(m/^=(head\d|pod|over|item)\b/s) {
        close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
        chomp;
        $verbose > 1 and print "  Found some pod ($_) in $file\n";
        return 1;
      }
    }
    close(MAYBEPOD) || die "Bizarre error closing $file: $!\nAborting";
    $verbose > 1 and print "  No POD in $file, skipping.\n";
    return 0;
  }
  
  #==========================================================================
  
  sub _accessorize {  # A simple-minded method-maker
    shift;
    no strict 'refs';
    foreach my $attrname (@_) {
      *{caller() . '::' . $attrname} = sub {
        use strict;
        $Carp::CarpLevel = 1,  Carp::croak(
         "Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)"
        ) unless (@_ == 1 or @_ == 2) and ref $_[0];
  
        # Read access:
        return $_[0]->{$attrname} if @_ == 1;
  
        # Write access:
        $_[0]->{$attrname} = $_[1];
        return $_[0]; # RETURNS MYSELF!
      };
    }
    # Ya know, they say accessories make the ensemble!
    return;
  }
  
  #==========================================================================
  sub _state_as_string {
    my $self = $_[0];
    return '' unless ref $self;
    my @out = "{\n  # State of $self ...\n";
    foreach my $k (sort keys %$self) {
      push @out, "  ", _esc($k), " => ", _esc($self->{$k}), ",\n";
    }
    push @out, "}\n";
    my $x = join '', @out;
    $x =~ s/^/#/mg;
    return $x;
  }
  
  sub _esc {
    my $in = $_[0];
    return 'undef' unless defined $in;
    $in =~
      s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;
    return qq{"$in"};
  }
  
  #==========================================================================
  
  run() unless caller;  # run if "perl whatever/Search.pm"
  
  1;
  
  #==========================================================================
  
  __END__
  
  
  =head1 NAME
  
  Pod::Simple::Search - find POD documents in directory trees
  
  =head1 SYNOPSIS
  
    use Pod::Simple::Search;
    my $name2path = Pod::Simple::Search->new->limit_glob('LWP::*')->survey;
    print "Looky see what I found: ",
      join(' ', sort keys %$name2path), "\n";
  
    print "LWPUA docs = ",
      Pod::Simple::Search->new->find('LWP::UserAgent') || "?",
      "\n";
  
  =head1 DESCRIPTION
  
  B<Pod::Simple::Search> is a class that you use for running searches
  for Pod files.  An object of this class has several attributes
  (mostly options for controlling search options), and some methods
  for searching based on those attributes.
  
  The way to use this class is to make a new object of this class,
  set any options, and then call one of the search options
  (probably C<survey> or C<find>).  The sections below discuss the
  syntaxes for doing all that.
  
  
  =head1 CONSTRUCTOR
  
  This class provides the one constructor, called C<new>.
  It takes no parameters:
  
    use Pod::Simple::Search;
    my $search = Pod::Simple::Search->new;
  
  =head1 ACCESSORS
  
  This class defines several methods for setting (and, occasionally,
  reading) the contents of an object. With two exceptions (discussed at
  the end of this section), these attributes are just for controlling the
  way searches are carried out.
  
  Note that each of these return C<$self> when you call them as
  C<< $self->I<whatever(value)> >>.  That's so that you can chain
  together set-attribute calls like this:
  
    my $name2path =
      Pod::Simple::Search->new
      -> inc(0) -> verbose(1) -> callback(\&blab)
      ->survey(@there);
  
  ...which works exactly as if you'd done this:
  
    my $search = Pod::Simple::Search->new;
    $search->inc(0);
    $search->verbose(1);
    $search->callback(\&blab);
    my $name2path = $search->survey(@there);
  
  =over
  
  =item $search->inc( I<true-or-false> );
  
  This attribute, if set to a true value, means that searches should
  implicitly add perl's I<@INC> paths. This
  automatically considers paths specified in the C<PERL5LIB> environment
  as this is prepended to I<@INC> by the Perl interpreter itself.
  This attribute's default value is B<TRUE>.  If you want to search
  only specific directories, set $self->inc(0) before calling
  $inc->survey or $inc->find.
  
  
  =item $search->verbose( I<nonnegative-number> );
  
  This attribute, if set to a nonzero positive value, will make searches output
  (via C<warn>) notes about what they're doing as they do it.
  This option may be useful for debugging a pod-related module.
  This attribute's default value is zero, meaning that no C<warn> messages
  are produced.  (Setting verbose to 1 turns on some messages, and setting
  it to 2 turns on even more messages, i.e., makes the following search(es)
  even more verbose than 1 would make them.)
  
  =item $search->limit_glob( I<some-glob-string> );
  
  This option means that you want to limit the results just to items whose
  podnames match the given glob/wildcard expression. For example, you
  might limit your search to just "LWP::*", to search only for modules
  starting with "LWP::*" (but not including the module "LWP" itself); or
  you might limit your search to "LW*" to see only modules whose (full)
  names begin with "LW"; or you might search for "*Find*" to search for
  all modules with "Find" somewhere in their full name. (You can also use
  "?" in a glob expression; so "DB?" will match "DBI" and "DBD".)
  
  
  =item $search->callback( I<\&some_routine> );
  
  This attribute means that every time this search sees a matching
  Pod file, it should call this callback routine.  The routine is called
  with two parameters: the current file's filespec, and its pod name.
  (For example: C<("/etc/perljunk/File/Crunk.pm", "File::Crunk")> would
  be in C<@_>.)
  
  The callback routine's return value is not used for anything.
  
  This attribute's default value is false, meaning that no callback
  is called.
  
  =item $search->laborious( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Search will 
  apply Perl-specific heuristics to find the correct module PODs quickly.
  This attribute's default value is false.  You won't normally need
  to set this to true.
  
  Specifically: Turning on this option will disable the heuristics for
  seeing only files with Perl-like extensions, omitting subdirectories
  that are numeric but do I<not> match the current Perl interpreter's
  version ID, suppressing F<site_perl> as a module hierarchy name, etc.
  
  =item $search->recurse( I<true-or-false> );
  
  Unless you set this attribute to a false value, Pod::Search will
  recurse into subdirectories of the search directories.
  
  =item $search->shadows( I<true-or-false> );
  
  Unless you set this attribute to a true value, Pod::Simple::Search will
  consider only the first file of a given modulename as it looks thru the
  specified directories; that is, with this option off, if
  Pod::Simple::Search has seen a C<somepathdir/Foo/Bar.pm> already in this
  search, then it won't bother looking at a C<somelaterpathdir/Foo/Bar.pm>
  later on in that search, because that file is merely a "shadow". But if
  you turn on C<< $self->shadows(1) >>, then these "shadow" files are
  inspected too, and are noted in the pathname2podname return hash.
  
  This attribute's default value is false; and normally you won't
  need to turn it on.
  
  
  =item $search->limit_re( I<some-regxp> );
  
  Setting this attribute (to a value that's a regexp) means that you want
  to limit the results just to items whose podnames match the given
  regexp. Normally this option is not needed, and the more efficient
  C<limit_glob> attribute is used instead.
  
  
  =item $search->dir_prefix( I<some-string-value> );
  
  Setting this attribute to a string value means that the searches should
  begin in the specified subdirectory name (like "Pod" or "File::Find",
  also expressible as "File/Find"). For example, the search option
  C<< $search->limit_glob("File::Find::R*") >>
  is the same as the combination of the search options
  C<< $search->limit_re("^File::Find::R") -> dir_prefix("File::Find") >>.
  
  Normally you don't need to know about the C<dir_prefix> option, but I
  include it in case it might prove useful for someone somewhere.
  
  (Implementationally, searching with limit_glob ends up setting limit_re
  and usually dir_prefix.)
  
  
  =item $search->progress( I<some-progress-object> );
  
  If you set a value for this attribute, the value is expected
  to be an object (probably of a class that you define) that has a 
  C<reach> method and a C<done> method.  This is meant for reporting
  progress during the search, if you don't want to use a simple
  callback.
  
  Normally you don't need to know about the C<progress> option, but I
  include it in case it might prove useful for someone somewhere.
  
  While a search is in progress, the progress object's C<reach> and
  C<done> methods are called like this:
  
    # Every time a file is being scanned for pod:
    $progress->reach($count, "Scanning $file");   ++$count;
  
    # And then at the end of the search:
    $progress->done("Noted $count Pod files total");
  
  Internally, we often set this to an object of class
  Pod::Simple::Progress.  That class is probably undocumented,
  but you may wish to look at its source.
  
  
  =item $name2path = $self->name2path;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =item $path2name = $self->path2name;
  
  This attribute is not a search parameter, but is used to report the
  result of C<survey> method, as discussed in the next section.
  
  =back
  
  =head1 MAIN SEARCH METHODS
  
  Once you've actually set any options you want (if any), you can go
  ahead and use the following methods to search for Pod files
  in particular ways.
  
  
  =head2 C<< $search->survey( @directories ) >>
  
  The method C<survey> searches for POD documents in a given set of
  files and/or directories.  This runs the search according to the various
  options set by the accessors above.  (For example, if the C<inc> attribute
  is on, as it is by default, then the perl @INC directories are implicitly
  added to the list of directories (if any) that you specify.)
  
  The return value of C<survey> is two hashes:
  
  =over
  
  =item C<name2path>
  
  A hash that maps from each pod-name to the filespec (like
  "Stuff::Thing" => "/whatever/plib/Stuff/Thing.pm")
  
  =item C<path2name>
  
  A hash that maps from each Pod filespec to its pod-name (like
  "/whatever/plib/Stuff/Thing.pm" => "Stuff::Thing")
  
  =back
  
  Besides saving these hashes as the hashref attributes
  C<name2path> and C<path2name>, calling this function also returns
  these hashrefs.  In list context, the return value of
  C<< $search->survey >> is the list C<(\%name2path, \%path2name)>.
  In scalar context, the return value is C<\%name2path>.
  Or you can just call this in void context.
  
  Regardless of calling context, calling C<survey> saves
  its results in its C<name2path> and C<path2name> attributes.
  
  E.g., when searching in F<$HOME/perl5lib>, the file
  F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
  whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
  I<Myclass::Subclass>. The name information can be used for POD
  translators.
  
  Only text files containing at least one valid POD command are found.
  
  In verbose mode, a warning is printed if shadows are found (i.e., more
  than one POD file with the same POD name is found, e.g. F<CPAN.pm> in
  different directories).  This usually indicates duplicate occurrences of
  modules in the I<@INC> search path, which is occasionally inadvertent
  (but is often simply a case of a user's path dir having a more recent
  version than the system's general path dirs in general.)
  
  The options to this argument is a list of either directories that are
  searched recursively, or files.  (Usually you wouldn't specify files,
  but just dirs.)  Or you can just specify an empty-list, as in
  $name2path; with the C<inc> option on, as it is by default.
  
  The POD names of files are the plain basenames with any Perl-like
  extension (.pm, .pl, .pod) stripped, and path separators replaced by
  C<::>'s.
  
  Calling Pod::Simple::Search->search(...) is short for
  Pod::Simple::Search->new->search(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $search->simplify_name( $str ) >>
  
  The method B<simplify_name> is equivalent to B<basename>, but also
  strips Perl-like extensions (.pm, .pl, .pod) and extensions like
  F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.
  
  
  =head2 C<< $search->find( $pod ) >>
  
  =head2 C<< $search->find( $pod, @search_dirs ) >>
  
  Returns the location of a Pod file, given a Pod/module/script name
  (like "Foo::Bar" or "perlvar" or "perldoc"), and an idea of
  what files/directories to look in.
  It searches according to the various options set by the accessors above.
  (For example, if the C<inc> attribute is on, as it is by default, then
  the perl @INC directories are implicitly added to the list of
  directories (if any) that you specify.)
  
  This returns the full path of the first occurrence to the file.
  Package names (eg 'A::B') are automatically converted to directory
  names in the selected directory.  Additionally, '.pm', '.pl' and '.pod'
  are automatically appended to the search as required.
  (So, for example, under Unix, "A::B" is converted to "somedir/A/B.pm",
  "somedir/A/B.pod", or "somedir/A/B.pl", as appropriate.)
  
  If no such Pod file is found, this method returns undef.
  
  If any of the given search directories contains a F<pod/> subdirectory,
  then it is searched.  (That's how we manage to find F<perlfunc>,
  for example, which is usually in F<pod/perlfunc> in most Perl dists.)
  
  The C<verbose> and C<inc> attributes influence the behavior of this
  search; notably, C<inc>, if true, adds @INC I<and also
  $Config::Config{'scriptdir'}> to the list of directories to search.
  
  It is common to simply say C<< $filename = Pod::Simple::Search-> new 
  ->find("perlvar") >> so that just the @INC (well, and scriptdir)
  directories are searched.  (This happens because the C<inc>
  attribute is true by default.)
  
  Calling Pod::Simple::Search->find(...) is short for
  Pod::Simple::Search->new->find(...).  That is, a throwaway object
  with default attribute values is used.
  
  
  =head2 C<< $self->contains_pod( $file ) >>
  
  Returns true if the supplied filename (not POD module) contains some Pod
  documentation.
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org> with code borrowed
  from Marek Rouchal's L<Pod::Find>, which in turn heavily borrowed code from
  Nick Ing-Simmons' C<PodToHtml>.
  
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  
  require 5;
  package Pod::Simple::SimpleTree;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( $ATTR_PAD @ISA $VERSION $SORT_ATTRS);
  $VERSION = '3.32';
  BEGIN {
    @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  __PACKAGE__->_accessorize(
    'root',   # root of the tree
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start { # self, tagname, attrhash
    DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";
    my $x = [$_[1], $_[2]];
    if($_[0]{'_currpos'}) {
      push    @{ $_[0]{'_currpos'}[0] }, $x; # insert in parent's child-list
      unshift @{ $_[0]{'_currpos'} },    $x; # prefix to stack
    } else {
      DEBUG and print STDERR " And oo, it gets to be root!\n";
      $_[0]{'_currpos'} = [   $_[0]{'root'} = $x   ];
        # first event!  set to stack, and set as root.
    }
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_element_end { # self, tagname
    DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";
    shift @{$_[0]{'_currpos'}};
    DEBUG > 3 and print STDERR "Stack is now: ",
      join(">", map $_->[0], @{$_[0]{'_currpos'}}), "\n";
    return;
  }
  
  sub _handle_text { # self, text
    DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";
    push @{ $_[0]{'_currpos'}[0] }, $_[1];
    return;
  }
  
  
  # A bit of evil from the black box...  please avert your eyes, kind souls.
  sub _traverse_treelet_bit {
    DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";
    my $self = shift;
    push @{ $self->{'_currpos'}[0] }, [@_];
    return;
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  =head1 NAME
  
  Pod::Simple::SimpleTree -- parse Pod into a simple parse tree 
  
  =head1 SYNOPSIS
  
    % cat ptest.pod
  
    =head1 PIE
  
    I like B<pie>!
  
    % perl -MPod::Simple::SimpleTree -MData::Dumper -e \
       "print Dumper(Pod::Simple::SimpleTree->new->parse_file(shift)->root)" \
       ptest.pod
  
    $VAR1 = [
              'Document',
              { 'start_line' => 1 },
              [
                'head1',
                { 'start_line' => 1 },
                'PIE'
              ],
              [
                'Para',
                { 'start_line' => 3 },
                'I like ',
                [
                  'B',
                  {},
                  'pie'
                ],
                '!'
              ]
            ];
  
  =head1 DESCRIPTION
  
  This class is of interest to people writing a Pod processor/formatter.
  
  This class takes Pod and parses it, returning a parse tree made just
  of arrayrefs, and hashrefs, and strings.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  This class is inspired by XML::Parser's "Tree" parsing-style, although
  it doesn't use exactly the same LoL format.
  
  =head1 METHODS
  
  At the end of the parse, call C<< $parser->root >> to get the
  tree's top node.
  
  =head1 Tree Contents
  
  Every element node in the parse tree is represented by an arrayref of
  the form: C<[ I<elementname>, \%attributes, I<...subnodes...> ]>.
  See the example tree dump in the Synopsis, above.
  
  Every text node in the tree is represented by a simple (non-ref)
  string scalar.  So you can test C<ref($node)> to see whether you have
  an element node or just a text node.
  
  The top node in the tree is C<[ 'Document', \%attributes,
  I<...subnodes...> ]>
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple>
  
  L<perllol>
  
  L<The "Tree" subsubsection in XML::Parser|XML::Parser/"Tree">
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  
  require 5;
  package Pod::Simple::Text;
  use strict;
  use Carp ();
  use Pod::Simple::Methody ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION $FREAKYMODE);
  $VERSION = '3.32';
  @ISA = ('Pod::Simple::Methody');
  BEGIN { *DEBUG = defined(&Pod::Simple::DEBUG)
            ? \&Pod::Simple::DEBUG
            : sub() {0}
        }
  
  use Text::Wrap 98.112902 ();
  $Text::Wrap::huge = 'overflow';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->accept_target_as_text(qw( text plaintext plain ));
    $new->nix_X_codes(1);
    $new->nbsp_for_S(1);
    $new->{'Thispara'} = '';
    $new->{'Indent'} = 0;
    $new->{'Indentstring'} = '   ';
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_text {  $_[0]{'Thispara'} .= $_[1] }
  
  sub start_Para  {  $_[0]{'Thispara'} = '' }
  sub start_head1 {  $_[0]{'Thispara'} = '' }
  sub start_head2 {  $_[0]{'Thispara'} = '' }
  sub start_head3 {  $_[0]{'Thispara'} = '' }
  sub start_head4 {  $_[0]{'Thispara'} = '' }
  
  sub start_Verbatim    { $_[0]{'Thispara'} = ''   }
  sub start_item_bullet { $_[0]{'Thispara'} = $FREAKYMODE ? '' : '* ' }
  sub start_item_number { $_[0]{'Thispara'} = $FREAKYMODE ? '' : "$_[1]{'number'}. "  }
  sub start_item_text   { $_[0]{'Thispara'} = ''   }
  
  sub start_over_bullet  { ++$_[0]{'Indent'} }
  sub start_over_number  { ++$_[0]{'Indent'} }
  sub start_over_text    { ++$_[0]{'Indent'} }
  sub start_over_block   { ++$_[0]{'Indent'} }
  
  sub   end_over_bullet  { --$_[0]{'Indent'} }
  sub   end_over_number  { --$_[0]{'Indent'} }
  sub   end_over_text    { --$_[0]{'Indent'} }
  sub   end_over_block   { --$_[0]{'Indent'} }
  
  
  # . . . . . Now the actual formatters:
  
  sub end_head1       { $_[0]->emit_par(-4) }
  sub end_head2       { $_[0]->emit_par(-3) }
  sub end_head3       { $_[0]->emit_par(-2) }
  sub end_head4       { $_[0]->emit_par(-1) }
  sub end_Para        { $_[0]->emit_par( 0) }
  sub end_item_bullet { $_[0]->emit_par( 0) }
  sub end_item_number { $_[0]->emit_par( 0) }
  sub end_item_text   { $_[0]->emit_par(-2) }
  sub start_L         { $_[0]{'Link'} = $_[1] if $_[1]->{type} eq 'url' }
  sub end_L           {
      if (my $link = delete $_[0]{'Link'}) {
          # Append the URL to the output unless it's already present.
          $_[0]{'Thispara'} .= " <$link->{to}>"
              unless $_[0]{'Thispara'} =~ /\b\Q$link->{to}/;
      }
  }
  
  sub emit_par {
    my($self, $tweak_indent) = splice(@_,0,2);
    my $indent = ' ' x ( 2 * $self->{'Indent'} + 4 + ($tweak_indent||0) );
     # Yes, 'STRING' x NEGATIVE gives '', same as 'STRING' x 0
  
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
    my $out = Text::Wrap::wrap($indent, $indent, $self->{'Thispara'} .= "\n");
    $out =~ s/$Pod::Simple::nbsp/ /g;
    print {$self->{'output_fh'}} $out, "\n";
    $self->{'Thispara'} = '';
    
    return;
  }
  
  # . . . . . . . . . . And then off by its lonesome:
  
  sub end_Verbatim  {
    my $self = shift;
    $self->{'Thispara'} =~ s/$Pod::Simple::nbsp/ /g;
    $self->{'Thispara'} =~ s/$Pod::Simple::shy//g;
  
    my $i = ' ' x ( 2 * $self->{'Indent'} + 4);
    #my $i = ' ' x (4 + $self->{'Indent'});
    
    $self->{'Thispara'} =~ s/^/$i/mg;
    
    print { $self->{'output_fh'} }   '', 
      $self->{'Thispara'},
      "\n\n"
    ;
    $self->{'Thispara'} = '';
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::Text -- format Pod as plaintext
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::Text -e \
     "exit Pod::Simple::Text->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as
  wrapped plaintext.
  
  Its wrapping is done by L<Text::Wrap>, so you can change
  C<$Text::Wrap::columns> as you like.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::TextContent>, L<Pod::Text>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  
  
  require 5;
  package Pod::Simple::TextContent;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( @ISA $VERSION );
  $VERSION = '3.32';
  @ISA = ('Pod::Simple');
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->nix_X_codes(1);
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  sub _handle_text {
    $_[1] =~ s/$Pod::Simple::shy//g;
    $_[1] =~ s/$Pod::Simple::nbsp/ /g;
    print {$_[0]{'output_fh'}} $_[1];
    return;
  }
  
  sub _handle_element_end {
    print {$_[0]{'output_fh'}} "\n"  unless $_[1] =~ m/^[A-Z]$/s;
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::TextContent -- get the text content of Pod
  
  =head1 SYNOPSIS
  
   TODO
  
    perl -MPod::Simple::TextContent -e \
     "exit Pod::Simple::TextContent->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  This class is that parses Pod and dumps just the text content.  It is
  mainly meant for use by the Pod::Simple test suite, but you may find
  some other use for it.
  
  This is a subclass of L<Pod::Simple> and inherits all its methods.
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  
  use strict;
  package Pod::Simple::TiedOutFH;
  use Symbol ('gensym');
  use Carp ();
  use vars qw($VERSION );
  $VERSION = '3.32';
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub handle_on { # some horrible frightening things are encapsulated in here
    my $class = shift;
    $class = ref($class) || $class;
    
    Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;
    
    my $x = (defined($_[0]) and ref($_[0]))
      ? $_[0]
      : ( \( $_[0] ) )[0]
    ;
    $$x = '' unless defined $$x;
    
    #Pod::Simple::DEBUG and print STDERR "New $class handle on $x = \"$$x\"\n";
    
    my $new = gensym();
    tie *$new, $class, $x;
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub TIEHANDLE {  # Ties to just a scalar ref
    my($class, $scalar_ref) = @_;
    $$scalar_ref = '' unless defined $$scalar_ref;
    return bless \$scalar_ref,  ref($class) || $class;
  }
  
  sub PRINT {
    my $it = shift;
    foreach my $x (@_) { $$$it .= $x }
  
    #Pod::Simple::DEBUG > 10 and print STDERR " appended to $$it = \"$$$it\"\n";
  
    return 1;
  }
  
  sub FETCH {
    return ${$_[0]};
  }
  
  sub PRINTF {
    my $it = shift;
    my $format = shift;
    $$$it .= sprintf $format, @_;
    return 1;
  }
  
  sub FILENO { ${ $_[0] } + 100 } # just to produce SOME number
  
  sub CLOSE { 1 }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1;
  __END__
  
  Chole
  
   * 1 large red onion
   * 2 tomatillos
   * 4 or 5 roma tomatoes (optionally with the pulp discarded)
   * 1 tablespoons chopped ginger root (or more, to taste)
   * 2 tablespoons canola oil (or vegetable oil)
   
   * 1 tablespoon garam masala
   * 1/2 teaspoon red chili powder, or to taste
   * Salt, to taste (probably quite a bit)
   * 2 (15-ounce) cans chick peas or garbanzo beans, drained and rinsed
   * juice of one smallish lime
   * a dash of balsamic vinegar (to taste)
   * cooked rice, preferably long-grain white rice (whether plain,
      basmati rice, jasmine rice, or even a mild pilaf)
  
  In a blender or food processor, puree the onions, tomatoes, tomatillos,
  and ginger root.  You can even do it with a Braun hand "mixer", if you
  chop things finer to start with, and work at it.
  
  In a saucepan set over moderate heat, warm the oil until hot.
  
  Add the puree and the balsamic vinegar, and cook, stirring occasionally,
  for 20 to 40 minutes. (Cooking it longer will make it sweeter.)
  
  Add the Garam Masala, chili powder, and cook, stirring occasionally, for
  5 minutes.
  
  Add the salt and chick peas and cook, stirring, until heated through.
  
  Stir in the lime juice, and optionally one or two teaspoons of tahini.
  You can let it simmer longer, depending on how much softer you want the
  garbanzos to get.
  
  Serve over rice, like a curry.
  
  Yields 5 to 7 servings.
  
  
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  
  require 5;
  package Pod::Simple::Transcode;
  use strict;
  use vars qw($VERSION @ISA);
  $VERSION = '3.32';
  
  BEGIN {
    if(defined &DEBUG) {;} # Okay
    elsif( defined &Pod::Simple::DEBUG ) { *DEBUG = \&Pod::Simple::DEBUG; }
    else { *DEBUG = sub () {0}; }
  }
  
  foreach my $class (
    'Pod::Simple::TranscodeSmart',
    'Pod::Simple::TranscodeDumb',
    '',
  ) {
    $class or die "Couldn't load any encoding classes";
    DEBUG and print STDERR "About to try loading $class...\n";
    eval "require $class;";
    if($@) {
      DEBUG and print STDERR "Couldn't load $class: $@\n";
    } else {
      DEBUG and print STDERR "OK, loaded $class.\n";
      @ISA = ($class);
      last;
    }
  }
  
  sub _blorp { return; } # just to avoid any "empty class" warning
  
  1;
  __END__
  
  
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  
  require 5;
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeDumb;
  use strict;
  use vars qw($VERSION %Supported);
  $VERSION = '3.32';
  # This module basically pretends it knows how to transcode, except
  #  only for null-transcodings!  We use this when Encode isn't
  #  available.
  
  %Supported = (
    'ascii'       => 1,
    'ascii-ctrl'  => 1,
    'iso-8859-1'  => 1,
    'cp1252'      => 1,
    'null'        => 1,
    'latin1'      => 1,
    'latin-1'     => 1,
    %Supported,
  );
  
  sub is_dumb  {1}
  sub is_smart {0}
  
  sub all_encodings {
    return sort keys %Supported;
  }
  
  sub encoding_is_available {
    return exists $Supported{lc $_[1]};
  }
  
  sub encmodver {
    return __PACKAGE__ . " v" .($VERSION || '?');
  }
  
  sub make_transcoder {
      my ($e) = $_[1];
      die "WHAT ENCODING!?!?" unless $e;
      # No-op for all but CP1252.
      return sub {;} if $e !~ /^cp-?1252$/i;
  
      # Replace CP1252 nerbles with their ASCII equivalents.
      return sub {
          # Copied from Encode::ZapCP1252.
          my %ascii_for = (
              # http://en.wikipedia.org/wiki/Windows-1252
              "\x80" => 'e',    # EURO SIGN
              "\x82" => ',',    # SINGLE LOW-9 QUOTATION MARK
              "\x83" => 'f',    # LATIN SMALL LETTER F WITH HOOK
              "\x84" => ',,',   # DOUBLE LOW-9 QUOTATION MARK
              "\x85" => '...',  # HORIZONTAL ELLIPSIS
              "\x86" => '+',    # DAGGER
              "\x87" => '++',   # DOUBLE DAGGER
              "\x88" => '^',    # MODIFIER LETTER CIRCUMFLEX ACCENT
              "\x89" => '%',    # PER MILLE SIGN
              "\x8a" => 'S',    # LATIN CAPITAL LETTER S WITH CARON
              "\x8b" => '<',    # SINGLE LEFT-POINTING ANGLE QUOTATION MARK
              "\x8c" => 'OE',   # LATIN CAPITAL LIGATURE OE
              "\x8e" => 'Z',    # LATIN CAPITAL LETTER Z WITH CARON
              "\x91" => "'",    # LEFT SINGLE QUOTATION MARK
              "\x92" => "'",    # RIGHT SINGLE QUOTATION MARK
              "\x93" => '"',    # LEFT DOUBLE QUOTATION MARK
              "\x94" => '"',    # RIGHT DOUBLE QUOTATION MARK
              "\x95" => '*',    # BULLET
              "\x96" => '-',    # EN DASH
              "\x97" => '--',   # EM DASH
              "\x98" => '~',    # SMALL TILDE
              "\x99" => '(tm)', # TRADE MARK SIGN
              "\x9a" => 's',    # LATIN SMALL LETTER S WITH CARON
              "\x9b" => '>',    # SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
              "\x9c" => 'oe',   # LATIN SMALL LIGATURE OE
              "\x9e" => 'z',    # LATIN SMALL LETTER Z WITH CARON
              "\x9f" => 'Y',    # LATIN CAPITAL LETTER Y WITH DIAERESIS
          );
  
          s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  
  require 5;
  use 5.008;
  ## Anything before 5.8.0 is GIMPY!
  ## This module is to be use()'d only by Pod::Simple::Transcode
  
  package Pod::Simple::TranscodeSmart;
  use strict;
  use Pod::Simple;
  require Encode;
  use vars qw($VERSION );
  $VERSION = '3.32';
  
  sub is_dumb  {0}
  sub is_smart {1}
  
  sub all_encodings {
    return Encode::->encodings(':all');
  }
  
  sub encoding_is_available {
    return Encode::resolve_alias($_[1]);
  }
  
  sub encmodver {
    return "Encode.pm v" .($Encode::VERSION || '?');
  }
  
  sub make_transcoder {
    my $e = Encode::find_encoding($_[1]);
    die "WHAT ENCODING!?!?" unless $e;
    my $x;
    return sub {
      foreach $x (@_) {
        $x = $e->decode($x) unless Encode::is_utf8($x);
      }
      return;
    };
  }
  
  
  1;
  
  
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  =pod
  
  =head1 NAME
  
  Pod::Simple::XHTML -- format Pod as validating XHTML
  
  =head1 SYNOPSIS
  
    use Pod::Simple::XHTML;
  
    my $parser = Pod::Simple::XHTML->new();
  
    ...
  
    $parser->parse_file('path/to/file.pod');
  
  =head1 DESCRIPTION
  
  This class is a formatter that takes Pod and renders it as XHTML
  validating HTML.
  
  This is a subclass of L<Pod::Simple::Methody> and inherits all its
  methods. The implementation is entirely different than
  L<Pod::Simple::HTML>, but it largely preserves the same interface.
  
  =head2 Minimal code
  
    use Pod::Simple::XHTML;
    my $psx = Pod::Simple::XHTML->new;
    $psx->output_string(\my $html);
    $psx->parse_file('path/to/Module/Name.pm');
    open my $out, '>', 'out.html' or die "Cannot open 'out.html': $!\n";
    print $out $html;
  
  You can also control the character encoding and entities. For example, if
  you're sure that the POD is properly encoded (using the C<=encoding> command),
  you can prevent high-bit characters from being encoded as HTML entities and
  declare the output character set as UTF-8 before parsing, like so:
  
    $psx->html_charset('UTF-8');
    $psx->html_encode_chars(q{&<>'"});
  
  =cut
  
  package Pod::Simple::XHTML;
  use strict;
  use vars qw( $VERSION @ISA $HAS_HTML_ENTITIES );
  $VERSION = '3.32';
  use Pod::Simple::Methody ();
  @ISA = ('Pod::Simple::Methody');
  
  BEGIN {
    $HAS_HTML_ENTITIES = eval "require HTML::Entities; 1";
  }
  
  my %entities = (
    q{>} => 'gt',
    q{<} => 'lt',
    q{'} => '#39',
    q{"} => 'quot',
    q{&} => 'amp',
  );
  
  sub encode_entities {
    my $self = shift;
    my $ents = $self->html_encode_chars;
    return HTML::Entities::encode_entities( $_[0], $ents ) if $HAS_HTML_ENTITIES;
    if (defined $ents) {
        $ents =~ s,(?<!\\)([]/]),\\$1,g;
        $ents =~ s,(?<!\\)\\\z,\\\\,;
    } else {
        $ents = join '', keys %entities;
    }
    my $str = $_[0];
    $str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;
    return $str;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 METHODS
  
  Pod::Simple::XHTML offers a number of methods that modify the format of
  the HTML output. Call these after creating the parser object, but before
  the call to C<parse_file>:
  
    my $parser = Pod::PseudoPod::HTML->new();
    $parser->set_optional_param("value");
    $parser->parse_file($file);
  
  =head2 perldoc_url_prefix
  
  In turning L<Foo::Bar> into http://whatever/Foo%3a%3aBar, what
  to put before the "Foo%3a%3aBar". The default value is
  "http://search.cpan.org/perldoc?".
  
  =head2 perldoc_url_postfix
  
  What to put after "Foo%3a%3aBar" in the URL. This option is not set by
  default.
  
  =head2 man_url_prefix
  
  In turning C<< L<crontab(5)> >> into http://whatever/man/1/crontab, what
  to put before the "1/crontab". The default value is
  "http://man.he.net/man".
  
  =head2 man_url_postfix
  
  What to put after "1/crontab" in the URL. This option is not set by default.
  
  =head2 title_prefix, title_postfix
  
  What to put before and after the title in the head. The values should
  already be &-escaped.
  
  =head2 html_css
  
    $parser->html_css('path/to/style.css');
  
  The URL or relative path of a CSS file to include. This option is not
  set by default.
  
  =head2 html_javascript
  
  The URL or relative path of a JavaScript file to pull in. This option is
  not set by default.
  
  =head2 html_doctype
  
  A document type tag for the file. This option is not set by default.
  
  =head2 html_charset
  
  The character set to declare in the Content-Type meta tag created by default
  for C<html_header_tags>. Note that this option will be ignored if the value of
  C<html_header_tags> is changed. Defaults to "ISO-8859-1".
  
  =head2 html_header_tags
  
  Additional arbitrary HTML tags for the header of the document. The
  default value is just a content type header tag:
  
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  
  Add additional meta tags here, or blocks of inline CSS or JavaScript
  (wrapped in the appropriate tags).
  
  =head3 html_encode_chars
  
  A string containing all characters that should be encoded as HTML entities,
  specified using the regular expression character class syntax (what you find
  within brackets in regular expressions). This value will be passed as the
  second argument to the C<encode_entities> function of L<HTML::Entities>. If
  L<HTML::Entities> is not installed, then any characters other than C<&<>"'>
  will be encoded numerically.
  
  =head2 html_h_level
  
  This is the level of HTML "Hn" element to which a Pod "head1" corresponds.  For
  example, if C<html_h_level> is set to 2, a head1 will produce an H2, a head2
  will produce an H3, and so on.
  
  =head2 default_title
  
  Set a default title for the page if no title can be determined from the
  content. The value of this string should already be &-escaped.
  
  =head2 force_title
  
  Force a title for the page (don't try to determine it from the content).
  The value of this string should already be &-escaped.
  
  =head2 html_header, html_footer
  
  Set the HTML output at the beginning and end of each file. The default
  header includes a title, a doctype tag (if C<html_doctype> is set), a
  content tag (customized by C<html_header_tags>), a tag for a CSS file
  (if C<html_css> is set), and a tag for a Javascript file (if
  C<html_javascript> is set). The default footer simply closes the C<html>
  and C<body> tags.
  
  The options listed above customize parts of the default header, but
  setting C<html_header> or C<html_footer> completely overrides the
  built-in header or footer. These may be useful if you want to use
  template tags instead of literal HTML headers and footers or are
  integrating converted POD pages in a larger website.
  
  If you want no headers or footers output in the HTML, set these options
  to the empty string.
  
  =head2 index
  
  Whether to add a table-of-contents at the top of each page (called an
  index for the sake of tradition).
  
  =head2 anchor_items
  
  Whether to anchor every definition C<=item> directive. This needs to be
  enabled if you want to be able to link to specific C<=item> directives, which
  are output as C<< <dt> >> elements. Disabled by default.
  
  =head2 backlink
  
  Whether to turn every =head1 directive into a link pointing to the top 
  of the page (specifically, the opening body tag).
  
  =cut
  
  __PACKAGE__->_accessorize(
   'perldoc_url_prefix',
   'perldoc_url_postfix',
   'man_url_prefix',
   'man_url_postfix',
   'title_prefix',  'title_postfix',
   'html_css',
   'html_javascript',
   'html_doctype',
   'html_charset',
   'html_encode_chars',
   'html_h_level',
   'title', # Used internally for the title extracted from the content
   'default_title',
   'force_title',
   'html_header',
   'html_footer',
   'index',
   'anchor_items',
   'backlink',
   'batch_mode', # whether we're in batch mode
   'batch_mode_current_level',
      # When in batch mode, how deep the current module is: 1 for "LWP",
      #  2 for "LWP::Procotol", 3 for "LWP::Protocol::GHTTP", etc
  );
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head1 SUBCLASSING
  
  If the standard options aren't enough, you may want to subclass
  Pod::Simple::XHMTL. These are the most likely candidates for methods
  you'll want to override when subclassing.
  
  =cut
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->perldoc_url_prefix('http://search.cpan.org/perldoc?');
    $new->man_url_prefix('http://man.he.net/man');
    $new->html_charset('ISO-8859-1');
    $new->nix_X_codes(1);
    $new->{'scratch'} = '';
    $new->{'to_index'} = [];
    $new->{'output'} = [];
    $new->{'saved'} = [];
    $new->{'ids'} = { '_podtop_' => 1 }; # used in <body>
    $new->{'in_li'} = [];
  
    $new->{'__region_targets'}  = [];
    $new->{'__literal_targets'} = {};
    $new->accept_targets_as_html( 'html', 'HTML' );
  
    return $new;
  }
  
  sub html_header_tags {
      my $self = shift;
      return $self->{html_header_tags} = shift if @_;
      return $self->{html_header_tags}
          ||= '<meta http-equiv="Content-Type" content="text/html; charset='
              . $self->html_charset . '" />';
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  =head2 handle_text
  
  This method handles the body of text within any element: it's the body
  of a paragraph, or everything between a "=begin" tag and the
  corresponding "=end" tag, or the text within an L entity, etc. You would
  want to override this if you are adding a custom element type that does
  more than just display formatted text. Perhaps adding a way to generate
  HTML tables from an extended version of POD.
  
  So, let's say you want to add a custom element called 'foo'. In your
  subclass's C<new> method, after calling C<SUPER::new> you'd call:
  
    $new->accept_targets_as_text( 'foo' );
  
  Then override the C<start_for> method in the subclass to check for when
  "$flags->{'target'}" is equal to 'foo' and set a flag that marks that
  you're in a foo block (maybe "$self->{'in_foo'} = 1"). Then override the
  C<handle_text> method to check for the flag, and pass $text to your
  custom subroutine to construct the HTML output for 'foo' elements,
  something like:
  
    sub handle_text {
        my ($self, $text) = @_;
        if ($self->{'in_foo'}) {
            $self->{'scratch'} .= build_foo_html($text);
            return;
        }
        $self->SUPER::handle_text($text);
    }
  
  =head2 handle_code
  
  This method handles the body of text that is marked up to be code.
  You might for instance override this to plug in a syntax highlighter.
  The base implementation just escapes the text.
  
  The callback methods C<start_code> and C<end_code> emits the C<code> tags
  before and after C<handle_code> is invoked, so you might want to override these
  together with C<handle_code> if this wrapping isn't suitable.
  
  Note that the code might be broken into multiple segments if there are
  nested formatting codes inside a C<< CE<lt>...> >> sequence.  In between the
  calls to C<handle_code> other markup tags might have been emitted in that
  case.  The same is true for verbatim sections if the C<codes_in_verbatim>
  option is turned on.
  
  =head2 accept_targets_as_html
  
  This method behaves like C<accept_targets_as_text>, but also marks the region
  as one whose content should be emitted literally, without HTML entity escaping
  or wrapping in a C<div> element.
  
  =cut
  
  sub __in_literal_xhtml_region {
      return unless @{ $_[0]{__region_targets} };
      my $target = $_[0]{__region_targets}[-1];
      return $_[0]{__literal_targets}{ $target };
  }
  
  sub accept_targets_as_html {
      my ($self, @targets) = @_;
      $self->accept_targets(@targets);
      $self->{__literal_targets}{$_} = 1 for @targets;
  }
  
  sub handle_text {
      # escape special characters in HTML (<, >, &, etc)
      my $text = $_[0]->__in_literal_xhtml_region
          ? $_[1]
          : $_[0]->encode_entities( $_[1] );
  
      if ($_[0]{'in_code'} && @{$_[0]{'in_code'}}) {
          # Intentionally use the raw text in $_[1], even if we're not in a
          # literal xhtml region, since handle_code calls encode_entities.
          $_[0]->handle_code( $_[1], $_[0]{'in_code'}[-1] );
      } else {
          if ($_[0]->{in_for}) {
              my $newlines = $_[0]->__in_literal_xhtml_region ? "\n\n" : '';
              if ($_[0]->{started_for}) {
                  if ($text =~ /\S/) {
                      delete $_[0]->{started_for};
                      $_[0]{'scratch'} .= $text . $newlines;
                  }
                  # Otherwise, append nothing until we have something to append.
              } else {
                  # The parser sometimes preserves newlines and sometimes doesn't!
                  $text =~ s/\n\z//;
                  $_[0]{'scratch'} .= $text . $newlines;
              }
          } else {
              # Just plain text.
              $_[0]{'scratch'} .= $text;
          }
      }
  
      $_[0]{htext} .= $text if $_[0]{'in_head'};
  }
  
  sub start_code {
      $_[0]{'scratch'} .= '<code>';
  }
  
  sub end_code {
      $_[0]{'scratch'} .= '</code>';
  }
  
  sub handle_code {
      $_[0]{'scratch'} .= $_[0]->encode_entities( $_[1] );
  }
  
  sub start_Para {
      $_[0]{'scratch'} .= '<p>';
  }
  
  sub start_Verbatim {
      $_[0]{'scratch'} = '<pre>';
      push(@{$_[0]{'in_code'}}, 'Verbatim');
      $_[0]->start_code($_[0]{'in_code'}[-1]);
  }
  
  sub start_head1 {  $_[0]{'in_head'} = 1; $_[0]{htext} = ''; }
  sub start_head2 {  $_[0]{'in_head'} = 2; $_[0]{htext} = ''; }
  sub start_head3 {  $_[0]{'in_head'} = 3; $_[0]{htext} = ''; }
  sub start_head4 {  $_[0]{'in_head'} = 4; $_[0]{htext} = ''; }
  
  sub start_item_number {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_bullet {
      $_[0]{'scratch'} = "</li>\n" if ($_[0]{'in_li'}->[-1] && pop @{$_[0]{'in_li'}});
      $_[0]{'scratch'} .= '<li><p>';
      push @{$_[0]{'in_li'}}, 1;
  }
  
  sub start_item_text   {
      # see end_item_text
  }
  
  sub start_over_bullet { $_[0]{'scratch'} = '<ul>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_block  { $_[0]{'scratch'} = '<ul>'; $_[0]->emit }
  sub start_over_number { $_[0]{'scratch'} = '<ol>'; push @{$_[0]{'in_li'}}, 0; $_[0]->emit }
  sub start_over_text   {
      $_[0]{'scratch'} = '<dl>';
      $_[0]{'dl_level'}++;
      $_[0]{'in_dd'} ||= [];
      $_[0]->emit
  }
  
  sub end_over_block  { $_[0]{'scratch'} .= '</ul>'; $_[0]->emit }
  
  sub end_over_number   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ol>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_bullet   {
      $_[0]{'scratch'} = "</li>\n" if ( pop @{$_[0]{'in_li'}} );
      $_[0]{'scratch'} .= '</ul>';
      pop @{$_[0]{'in_li'}};
      $_[0]->emit;
  }
  
  sub end_over_text   {
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
      $_[0]{'scratch'} .= '</dl>';
      $_[0]{'dl_level'}--;
      $_[0]->emit;
  }
  
  # . . . . . Now the actual formatters:
  
  sub end_Para     { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_Verbatim {
      $_[0]->end_code(pop(@{$_[0]->{'in_code'}}));
      $_[0]{'scratch'} .= '</pre>';
      $_[0]->emit;
  }
  
  sub _end_head {
      my $h = delete $_[0]{in_head};
  
      my $add = $_[0]->html_h_level;
      $add = 1 unless defined $add;
      $h += $add - 1;
  
      my $id = $_[0]->idify($_[0]{htext});
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = $_[0]->backlink && ($h - $add == 0)
                           # backlinks enabled && =head1
                           ? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>}
                           : qq{<h$h id="$id">$text</h$h>};
      $_[0]->emit;
      push @{ $_[0]{'to_index'} }, [$h, $id, delete $_[0]{'htext'}];
  }
  
  sub end_head1       { shift->_end_head(@_); }
  sub end_head2       { shift->_end_head(@_); }
  sub end_head3       { shift->_end_head(@_); }
  sub end_head4       { shift->_end_head(@_); }
  
  sub end_item_bullet { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  sub end_item_number { $_[0]{'scratch'} .= '</p>'; $_[0]->emit }
  
  sub end_item_text   {
      # idify and anchor =item content if wanted
      my $dt_id = $_[0]{'anchor_items'} 
                   ? ' id="'. $_[0]->idify($_[0]{'scratch'}) .'"'
                   : '';
  
      # reset scratch
      my $text = $_[0]{scratch};
      $_[0]{'scratch'} = '';
  
      if ($_[0]{'in_dd'}[ $_[0]{'dl_level'} ]) {
          $_[0]{'scratch'} = "</dd>\n";
          $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 0;
      }
  
      $_[0]{'scratch'} .= qq{<dt$dt_id>$text</dt>\n<dd>};
      $_[0]{'in_dd'}[ $_[0]{'dl_level'} ] = 1;
      $_[0]->emit;
  }
  
  # This handles =begin and =for blocks of all kinds.
  sub start_for {
    my ($self, $flags) = @_;
  
    push @{ $self->{__region_targets} }, $flags->{target_matching};
    $self->{started_for} = 1;
    $self->{in_for} = 1;
  
    unless ($self->__in_literal_xhtml_region) {
      $self->{scratch} .= '<div';
      $self->{scratch} .= qq( class="$flags->{target}") if $flags->{target};
      $self->{scratch} .= ">\n\n";
    }
  }
  
  sub end_for {
    my ($self) = @_;
    delete $self->{started_for};
    delete $self->{in_for};
  
    if ($self->__in_literal_xhtml_region) {
      # Remove trailine newlines.
      $self->{'scratch'} =~ s/\s+\z//s;
    } else {
      $self->{'scratch'} .= '</div>';
    }
  
    pop @{ $self->{__region_targets} };
    $self->emit;
  }
  
  sub start_Document {
    my ($self) = @_;
    if (defined $self->html_header) {
      $self->{'scratch'} .= $self->html_header;
      $self->emit unless $self->html_header eq "";
    } else {
      my ($doctype, $title, $metatags, $bodyid);
      $doctype = $self->html_doctype || '';
      $title = $self->force_title || $self->title || $self->default_title || '';
      $metatags = $self->html_header_tags || '';
      if (my $css = $self->html_css) {
          if ($css !~ /<link/) {
              # this is required to be compatible with Pod::Simple::BatchHTML
              $metatags .= '<link rel="stylesheet" href="'
                  . $self->encode_entities($css) . '" type="text/css" />';
          } else {
              $metatags .= $css;
          }
      }
      if ($self->html_javascript) {
        $metatags .= qq{\n<script type="text/javascript" src="} .
                      $self->html_javascript . '"></script>';
      }
      $bodyid = $self->backlink ? ' id="_podtop_"' : '';
      $self->{'scratch'} .= <<"HTML";
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
      $self->emit;
    }
  }
  
  sub end_Document   {
    my ($self) = @_;
    my $to_index = $self->{'to_index'};
    if ($self->index && @{ $to_index } ) {
        my @out;
        my $level  = 0;
        my $indent = -1;
        my $space  = '';
        my $id     = ' id="index"';
  
        for my $h (@{ $to_index }, [0]) {
            my $target_level = $h->[0];
            # Get to target_level by opening or closing ULs
            if ($level == $target_level) {
                $out[-1] .= '</li>';
            } elsif ($level > $target_level) {
                $out[-1] .= '</li>' if $out[-1] =~ /^\s+<li>/;
                while ($level > $target_level) {
                    --$level;
                    push @out, ('  ' x --$indent) . '</li>' if @out && $out[-1] =~ m{^\s+<\/ul};
                    push @out, ('  ' x --$indent) . '</ul>';
                }
                push @out, ('  ' x --$indent) . '</li>' if $level;
            } else {
                while ($level < $target_level) {
                    ++$level;
                    push @out, ('  ' x ++$indent) . '<li>' if @out && $out[-1]=~ /^\s*<ul/;
                    push @out, ('  ' x ++$indent) . "<ul$id>";
                    $id = '';
                }
                ++$indent;
            }
  
            next unless $level;
            $space = '  '  x $indent;
            push @out, sprintf '%s<li><a href="#%s">%s</a>',
                $space, $h->[1], $h->[2];
        }
        # Splice the index in between the HTML headers and the first element.
        my $offset = defined $self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;
        splice @{ $self->{'output'} }, $offset, 0, join "\n", @out;
    }
  
    if (defined $self->html_footer) {
      $self->{'scratch'} .= $self->html_footer;
      $self->emit unless $self->html_footer eq "";
    } else {
      $self->{'scratch'} .= "</body>\n</html>";
      $self->emit;
    }
  
    if ($self->index) {
        print {$self->{'output_fh'}} join ("\n\n", @{ $self->{'output'} }), "\n\n";
        @{$self->{'output'}} = ();
    }
  
  }
  
  # Handling code tags
  sub start_B { $_[0]{'scratch'} .= '<b>' }
  sub end_B   { $_[0]{'scratch'} .= '</b>' }
  
  sub start_C { push(@{$_[0]{'in_code'}}, 'C'); $_[0]->start_code($_[0]{'in_code'}[-1]); }
  sub end_C   { $_[0]->end_code(pop(@{$_[0]{'in_code'}})); }
  
  sub start_F { $_[0]{'scratch'} .= '<i>' }
  sub end_F   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_I { $_[0]{'scratch'} .= '<i>' }
  sub end_I   { $_[0]{'scratch'} .= '</i>' }
  
  sub start_L {
    my ($self, $flags) = @_;
      my ($type, $to, $section) = @{$flags}{'type', 'to', 'section'};
      my $url = $self->encode_entities(
          $type eq 'url' ? $to
              : $type eq 'pod' ? $self->resolve_pod_page_link($to, $section)
              : $type eq 'man' ? $self->resolve_man_page_link($to, $section)
              :                  undef
      );
  
      # If it's an unknown type, use an attribute-less <a> like HTML.pm.
      $self->{'scratch'} .= '<a' . ($url ? ' href="'. $url . '">' : '>');
  }
  
  sub end_L   { $_[0]{'scratch'} .= '</a>' }
  
  sub start_S { $_[0]{'scratch'} .= '<span style="white-space: nowrap;">' }
  sub end_S   { $_[0]{'scratch'} .= '</span>' }
  
  sub emit {
    my($self) = @_;
    if ($self->index) {
        push @{ $self->{'output'} }, $self->{'scratch'};
    } else {
        print {$self->{'output_fh'}} $self->{'scratch'}, "\n\n";
    }
    $self->{'scratch'} = '';
    return;
  }
  
  =head2 resolve_pod_page_link
  
    my $url = $pod->resolve_pod_page_link('Net::Ping', 'INSTALL');
    my $url = $pod->resolve_pod_page_link('perlpodspec');
    my $url = $pod->resolve_pod_page_link(undef, 'SYNOPSIS');
  
  Resolves a POD link target (typically a module or POD file name) and section
  name to a URL. The resulting link will be returned for the above examples as:
  
    http://search.cpan.org/perldoc?Net::Ping#INSTALL
    http://search.cpan.org/perldoc?perlpodspec
    #SYNOPSIS
  
  Note that when there is only a section argument the URL will simply be a link
  to a section in the current document.
  
  =cut
  
  sub resolve_pod_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to || defined $section;
      if (defined $section) {
          $section = '#' . $self->idify($self->encode_entities($section), 1);
          return $section unless defined $to;
      } else {
          $section = ''
      }
  
      return ($self->perldoc_url_prefix || '')
          . $self->encode_entities($to) . $section
          . ($self->perldoc_url_postfix || '');
  }
  
  =head2 resolve_man_page_link
  
    my $url = $pod->resolve_man_page_link('crontab(5)', 'EXAMPLE CRON FILE');
    my $url = $pod->resolve_man_page_link('crontab');
  
  Resolves a man page link target and numeric section to a URL. The resulting
  link will be returned for the above examples as:
  
      http://man.he.net/man5/crontab
      http://man.he.net/man1/crontab
  
  Note that the first argument is required. The section number will be parsed
  from it, and if it's missing will default to 1. The second argument is
  currently ignored, as L<man.he.net|http://man.he.net> does not currently
  include linkable IDs or anchor names in its pages. Subclass to link to a
  different man page HTTP server.
  
  =cut
  
  sub resolve_man_page_link {
      my ($self, $to, $section) = @_;
      return undef unless defined $to;
      my ($page, $part) = $to =~ /^([^(]+)(?:[(](\d+)[)])?$/;
      return undef unless $page;
      return ($self->man_url_prefix || '')
          . ($part || 1) . "/" . $self->encode_entities($page)
          . ($self->man_url_postfix || '');
  
  }
  
  =head2 idify
  
    my $id   = $pod->idify($text);
    my $hash = $pod->idify($text, 1);
  
  This method turns an arbitrary string into a valid XHTML ID attribute value.
  The rules enforced, following
  L<http://webdesign.about.com/od/htmltags/a/aa031707.htm>, are:
  
  =over
  
  =item *
  
  The id must start with a letter (a-z or A-Z)
  
  =item *
  
  All subsequent characters can be letters, numbers (0-9), hyphens (-),
  underscores (_), colons (:), and periods (.).
  
  =item *
  
  The final character can't be a hyphen, colon, or period. URLs ending with these
  characters, while allowed by XHTML, can be awkward to extract from plain text.
  
  =item *
  
  Each id must be unique within the document.
  
  =back
  
  In addition, the returned value will be unique within the context of the
  Pod::Simple::XHTML object unless a second argument is passed a true value. ID
  attributes should always be unique within a single XHTML document, but pass
  the true value if you are creating not an ID but a URL hash to point to
  an ID (i.e., if you need to put the "#foo" in C<< <a href="#foo">foo</a> >>.
  
  =cut
  
  sub idify {
      my ($self, $t, $not_unique) = @_;
      for ($t) {
          s/<[^>]+>//g;            # Strip HTML.
          s/&[^;]+;//g;            # Strip entities.
          s/^\s+//; s/\s+$//;      # Strip white space.
          s/^([^a-zA-Z]+)$/pod$1/; # Prepend "pod" if no valid chars.
          s/^[^a-zA-Z]+//;         # First char must be a letter.
          s/[^-a-zA-Z0-9_:.]+/-/g; # All other chars must be valid.
          s/[-:.]+$//;             # Strip trailing punctuation.
      }
      return $t if $not_unique;
      my $i = '';
      $i++ while $self->{ids}{"$t$i"}++;
      return "$t$i";
  }
  
  =head2 batch_mode_page_object_init
  
    $pod->batch_mode_page_object_init($batchconvobj, $module, $infile, $outfile, $depth);
  
  Called by L<Pod::Simple::HTMLBatch> so that the class has a chance to
  initialize the converter. Internally it sets the C<batch_mode> property to
  true and sets C<batch_mode_current_level()>, but Pod::Simple::XHTML does not
  currently use those features. Subclasses might, though.
  
  =cut
  
  sub batch_mode_page_object_init {
    my ($self, $batchconvobj, $module, $infile, $outfile, $depth) = @_;
    $self->batch_mode(1);
    $self->batch_mode_current_level($depth);
    return $self;
  }
  
  sub html_header_after_title {
  }
  
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2003-2005 Allison Randal.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to L<Hurricane Electric|http://he.net/> for permission to use its
  L<Linux man pages online|http://man.he.net/> site for man page links.
  
  Thanks to L<search.cpan.org|http://search.cpan.org/> for permission to use the
  site for Perl module links.
  
  =head1 AUTHOR
  
  Pod::Simpele::XHTML was created by Allison Randal <allison@perl.org>.
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  
  require 5;
  package Pod::Simple::XMLOutStream;
  use strict;
  use Carp ();
  use Pod::Simple ();
  use vars qw( $ATTR_PAD @ISA $VERSION $SORT_ATTRS);
  $VERSION = '3.32';
  BEGIN {
    @ISA = ('Pod::Simple');
    *DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG;
  }
  
  $ATTR_PAD = "\n" unless defined $ATTR_PAD;
   # Don't mess with this unless you know what you're doing.
  
  $SORT_ATTRS = 0 unless defined $SORT_ATTRS;
  
  sub new {
    my $self = shift;
    my $new = $self->SUPER::new(@_);
    $new->{'output_fh'} ||= *STDOUT{IO};
    $new->keep_encoding_directive(1);
    #$new->accept_codes('VerbatimFormatted');
    return $new;
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  sub _handle_element_start {
    # ($self, $element_name, $attr_hash_r)
    my $fh = $_[0]{'output_fh'};
    my($key, $value);
    DEBUG and print STDERR "++ $_[1]\n";
    print $fh "<", $_[1];
    if($SORT_ATTRS) {
      foreach my $key (sort keys %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value = $_[2]{$key});
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    } else { # faster
      while(($key,$value) = each %{$_[2]}) {
        unless($key =~ m/^~/s) {
          next if $key eq 'start_line' and $_[0]{'hide_line_numbers'};
          _xml_escape($value);
          print $fh $ATTR_PAD, $key, '="', $value, '"';
        }
      }
    }
    print $fh ">";
    return;
  }
  
  sub _handle_text {
    DEBUG and print STDERR "== \"$_[1]\"\n";
    if(length $_[1]) {
      my $text = $_[1];
      _xml_escape($text);
      print {$_[0]{'output_fh'}} $text;
    }
    return;
  }
  
  sub _handle_element_end {
    DEBUG and print STDERR "-- $_[1]\n";
    print {$_[0]{'output_fh'}} "</", $_[1], ">";
    return;
  }
  
  # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  
  sub _xml_escape {
    foreach my $x (@_) {
      # Escape things very cautiously:
      if ($] ge 5.007_003) {
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg;
      } else { # Is broken for non-ASCII platforms on early perls
        $x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg;
      }
      # Yes, stipulate the list without a range, so that this can work right on
      #  all charsets that this module happens to run under.
    }
    return;
  }
  
  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Simple::XMLOutStream -- turn Pod into XML
  
  =head1 SYNOPSIS
  
    perl -MPod::Simple::XMLOutStream -e \
     "exit Pod::Simple::XMLOutStream->filter(shift)->any_errata_seen" \
     thingy.pod
  
  =head1 DESCRIPTION
  
  Pod::Simple::XMLOutStream is a subclass of L<Pod::Simple> that parses
  Pod and turns it into XML.
  
  Pod::Simple::XMLOutStream inherits methods from
  L<Pod::Simple>.
  
  
  =head1 SEE ALSO
  
  L<Pod::Simple::DumpAsXML> is rather like this class; see its
  documentation for a discussion of the differences.
  
  L<Pod::Simple>, L<Pod::Simple::DumpAsXML>, L<Pod::SAX>
  
  L<Pod::Simple::Subclassing>
  
  The older (and possibly obsolete) libraries L<Pod::PXML>, L<Pod::XML>
  
  
  =head1 ABOUT EXTENDING POD
  
  TODO: An example or two of =extend, then point to Pod::Simple::Subclassing
  
  =head1 SEE ALSO
  
  L<Pod::Simple>, L<Pod::Simple::Text>, L<Pod::Spell>
  
  =head1 SUPPORT
  
  Questions or discussion about POD and Pod::Simple should be sent to the
  pod-people@perl.org mail list. Send an empty email to
  pod-people-subscribe@perl.org to subscribe.
  
  This module is managed in an open GitHub repository,
  L<https://github.com/perl-pod/pod-simple/>. Feel free to fork and contribute, or
  to clone L<git://github.com/perl-pod/pod-simple.git> and send patches!
  
  Patches against Pod::Simple are welcome. Please send bug reports to
  <bug-pod-simple@rt.cpan.org>.
  
  =head1 COPYRIGHT AND DISCLAIMERS
  
  Copyright (c) 2002-2004 Sean M. Burke.
  
  This library is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Pod::Simple was created by Sean M. Burke <sburke@cpan.org>.
  But don't bother him, he's retired.
  
  Pod::Simple is maintained by:
  
  =over
  
  =item * Allison Randal C<allison@perl.org>
  
  =item * Hans Dieter Pearcey C<hdp@cpan.org>
  
  =item * David E. Wheeler C<dwheeler@cpan.org>
  
  =back
  
  =cut
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Spreadsheet/ParseExcel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL';
  package Spreadsheet::ParseExcel;
  
  ##############################################################################
  #
  # Spreadsheet::ParseExcel - Extract information from an Excel file.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2008 Takanori Kawai
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  use 5.008;
  
  use OLE::Storage_Lite;
  use File::Basename qw(fileparse);
  use IO::File;
  use Config;
  
  use Crypt::RC4;
  use Digest::Perl::MD5;
  
  our $VERSION = '0.65';
  
  use Spreadsheet::ParseExcel::Workbook;
  use Spreadsheet::ParseExcel::Worksheet;
  use Spreadsheet::ParseExcel::Font;
  use Spreadsheet::ParseExcel::Format;
  use Spreadsheet::ParseExcel::Cell;
  use Spreadsheet::ParseExcel::FmtDefault;
  
  my $currentbook;
  my @aColor = (
      '000000',    # 0x00
      'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF',
      'FFFFFF', 'FFFFFF', 'FFFFFF', '000000',    # 0x08
      'FFFFFF', 'FF0000', '00FF00', '0000FF',
      'FFFF00', 'FF00FF', '00FFFF', '800000',    # 0x10
      '008000', '000080', '808000', '800080',
      '008080', 'C0C0C0', '808080', '9999FF',    # 0x18
      '993366', 'FFFFCC', 'CCFFFF', '660066',
      'FF8080', '0066CC', 'CCCCFF', '000080',    # 0x20
      'FF00FF', 'FFFF00', '00FFFF', '800080',
      '800000', '008080', '0000FF', '00CCFF',    # 0x28
      'CCFFFF', 'CCFFCC', 'FFFF99', '99CCFF',
      'FF99CC', 'CC99FF', 'FFCC99', '3366FF',    # 0x30
      '33CCCC', '99CC00', 'FFCC00', 'FF9900',
      'FF6600', '666699', '969696', '003366',    # 0x38
      '339966', '003300', '333300', '993300',
      '993366', '333399', '333333', '000000'     # 0x40
  );
  use constant verExcel95 => 0x500;
  use constant verExcel97 => 0x600;
  use constant verBIFF2   => 0x00;
  use constant verBIFF3   => 0x02;
  use constant verBIFF4   => 0x04;
  use constant verBIFF5   => 0x08;
  use constant verBIFF8   => 0x18;
  
  use constant MS_BIFF_CRYPTO_NONE => 0;
  use constant MS_BIFF_CRYPTO_XOR  => 1;
  use constant MS_BIFF_CRYPTO_RC4  => 2;
  
  use constant sizeof_BIFF_8_FILEPASS => ( 6 + 3 * 16 );
  
  use constant REKEY_BLOCK => 0x400;
  
  # Error code for some of the common parsing errors.
  use constant ErrorNone          => 0;
  use constant ErrorNoFile        => 1;
  use constant ErrorNoExcelData   => 2;
  use constant ErrorFileEncrypted => 3;
  
  # Color index for the 'auto' color
  use constant AutoColor => 64;
  
  our %error_strings = (
      ErrorNone,          '',                               # 0
      ErrorNoFile,        'File not found',                 # 1
      ErrorNoExcelData,   'No Excel data found in file',    # 2
      ErrorFileEncrypted, 'File is encrypted',              # 3
  
  );
  
  
  our %ProcTbl = (
  
      #Develpers' Kit P291
      0x14   => \&_subHeader,            # Header
      0x15   => \&_subFooter,            # Footer
      0x18   => \&_subName,              # NAME(?)
      0x1A   => \&_subVPageBreak,        # Vertical Page Break
      0x1B   => \&_subHPageBreak,        # Horizontal Page Break
      0x22   => \&_subFlg1904,           # 1904 Flag
      0x26   => \&_subMargin,            # Left Margin
      0x27   => \&_subMargin,            # Right Margin
      0x28   => \&_subMargin,            # Top Margin
      0x29   => \&_subMargin,            # Bottom Margin
      0x2A   => \&_subPrintHeaders,      # Print Headers
      0x2B   => \&_subPrintGridlines,    # Print Gridlines
      0x3C   => \&_subContinue,          # Continue
      0x3D   => \&_subWindow1,           # Window1
      0x43   => \&_subXF,                # XF for Excel < 4.
      0x0443 => \&_subXF,                # XF for Excel = 4.
      0x862  => \&_subSheetLayout,       # Sheet Layout
      0x1B8  => \&_subHyperlink,         # HYPERLINK
  
      #Develpers' Kit P292
      0x55 => \&_subDefColWidth,         # Consider
      0x5C => \&_subWriteAccess,         # WRITEACCESS
      0x7D => \&_subColInfo,             # Colinfo
      0x7E => \&_subRK,                  # RK
      0x81 => \&_subWSBOOL,              # WSBOOL
      0x83 => \&_subHcenter,             # HCENTER
      0x84 => \&_subVcenter,             # VCENTER
      0x85 => \&_subBoundSheet,          # BoundSheet
  
      0x92 => \&_subPalette,             # Palette, fgp
  
      0x99 => \&_subStandardWidth,       # Standard Col
  
      #Develpers' Kit P293
      0xA1 => \&_subSETUP,               # SETUP
      0xBD => \&_subMulRK,               # MULRK
      0xBE => \&_subMulBlank,            # MULBLANK
      0xD6 => \&_subRString,             # RString
  
      #Develpers' Kit P294
      0xE0 => \&_subXF,                  # ExTended Format
      0xE5 => \&_subMergeArea,           # MergeArea (Not Documented)
      0xFC => \&_subSST,                 # Shared String Table
      0xFD => \&_subLabelSST,            # Label SST
  
      #Develpers' Kit P295
      0x201 => \&_subBlank,              # Blank
  
      0x202 => \&_subInteger,            # Integer(Not Documented)
      0x203 => \&_subNumber,             # Number
      0x204 => \&_subLabel,              # Label
      0x205 => \&_subBoolErr,            # BoolErr
      0x207 => \&_subString,             # STRING
      0x208 => \&_subRow,                # RowData
      0x221 => \&_subArray,              # Array (Consider)
      0x225 => \&_subDefaultRowHeight,   # Consider
  
      0x31  => \&_subFont,               # Font
      0x231 => \&_subFont,               # Font
  
      0x27E => \&_subRK,                 # RK
      0x41E => \&_subFormat,             # Format
  
      0x06  => \&_subFormula,            # Formula
      0x406 => \&_subFormula,            # Formula
  
      0x009 => \&_subBOF,                # BOF(BIFF2)
      0x209 => \&_subBOF,                # BOF(BIFF3)
      0x409 => \&_subBOF,                # BOF(BIFF4)
      0x809 => \&_subBOF,                # BOF(BIFF5-8)
  );
  
  our $BIGENDIAN;
  our $PREFUNC;
  our $_use_perlio;
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->new
  #------------------------------------------------------------------------------
  sub new {
      my ( $class, %hParam ) = @_;
  
      if ( not defined $_use_perlio ) {
          if (   exists $Config{useperlio}
              && defined $Config{useperlio}
              && $Config{useperlio} eq "define" )
          {
              $_use_perlio = 1;
          }
          else {
              $_use_perlio = 0;
              require IO::Scalar;
              import IO::Scalar;
          }
      }
  
      # Check ENDIAN(Little: Intel etc. BIG: Sparc etc)
      $BIGENDIAN =
          ( defined $hParam{Endian} ) ? $hParam{Endian}
        : ( unpack( "H08", pack( "L", 2 ) ) eq '02000000' ) ? 0
        :                                                     1;
      my $self = {};
      bless $self, $class;
  
      $self->{GetContent} = \&_subGetContent;
  
      if ( $hParam{EventHandlers} ) {
          $self->SetEventHandlers( $hParam{EventHandlers} );
      }
      else {
          $self->SetEventHandlers( \%ProcTbl );
      }
      if ( $hParam{AddHandlers} ) {
          foreach my $sKey ( keys( %{ $hParam{AddHandlers} } ) ) {
              $self->SetEventHandler( $sKey, $hParam{AddHandlers}->{$sKey} );
          }
      }
      $self->{CellHandler} = $hParam{CellHandler};
      $self->{NotSetCell}  = $hParam{NotSetCell};
      $self->{Object}      = $hParam{Object};
  
  
      if ( defined $hParam{Password} ) {
          $self->{Password} = $hParam{Password};
      }
      else {
          $self->{Password} = 'VelvetSweatshop';
      }
  
      $self->{_error_status} = ErrorNone;
      return $self;
  }
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->SetEventHandler
  #------------------------------------------------------------------------------
  sub SetEventHandler {
      my ( $self, $key, $sub_ref ) = @_;
      $self->{FuncTbl}->{$key} = $sub_ref;
  }
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->SetEventHandlers
  #------------------------------------------------------------------------------
  sub SetEventHandlers {
      my ( $self, $rhTbl ) = @_;
      $self->{FuncTbl} = undef;
      foreach my $sKey ( keys %$rhTbl ) {
          $self->{FuncTbl}->{$sKey} = $rhTbl->{$sKey};
      }
  }
  
  #------------------------------------------------------------------------------
  # Decryption routines
  # based on sources of gnumeric (ms-biff.c ms-excel-read.c)
  #------------------------------------------------------------------------------
  sub md5state {
      my ( $md5 ) = @_;
      my $s = '';
      for ( my $i = 0 ; $i < 4 ; $i++ ) {
          my $v = $md5->{_state}[$i];
          $s .= chr( $v & 0xff );
          $s .= chr( ( $v >> 8 ) & 0xff );
          $s .= chr( ( $v >> 16 ) & 0xff );
          $s .= chr( ( $v >> 24 ) & 0xff );
      }
  
      return $s;
  }
  
  sub MakeKey {
      my ( $block, $key, $valContext ) = @_;
  
      my $pwarray = "\0" x 64;
  
      substr( $pwarray, 0, 5 ) = substr( $valContext, 0, 5 );
  
      substr( $pwarray, 5, 1 ) = chr( $block & 0xff );
      substr( $pwarray, 6, 1 ) = chr( ( $block >> 8 ) & 0xff );
      substr( $pwarray, 7, 1 ) = chr( ( $block >> 16 ) & 0xff );
      substr( $pwarray, 8, 1 ) = chr( ( $block >> 24 ) & 0xff );
  
      substr( $pwarray, 9,  1 ) = "\x80";
      substr( $pwarray, 56, 1 ) = "\x48";
  
      my $md5 = Digest::Perl::MD5->new();
      $md5->add( $pwarray );
  
      my $s = md5state( $md5 );
  
      ${$key} = Crypt::RC4->new( $s );
  }
  
  sub VerifyPassword {
      my ( $password, $docid, $salt_data, $hashedsalt_data, $valContext ) = @_;
  
      my $pwarray = "\0" x 64;
      my $i;
      my $md5 = Digest::Perl::MD5->new();
  
      for ( $i = 0 ; $i < length( $password ) ; $i++ ) {
          my $o = ord( substr( $password, $i, 1 ) );
          substr( $pwarray, 2 * $i, 1 ) = chr( $o & 0xff );
          substr( $pwarray, 2 * $i + 1, 1 ) = chr( ( $o >> 8 ) & 0xff );
      }
      substr( $pwarray, 2 * $i, 1 ) = chr( 0x80 );
      substr( $pwarray, 56, 1 ) = chr( ( $i << 4 ) & 0xff );
  
      $md5->add( $pwarray );
  
      my $mdContext1 = md5state( $md5 );
  
      my $offset    = 0;
      my $keyoffset = 0;
      my $tocopy    = 5;
  
      $md5->reset;
  
      while ( $offset != 16 ) {
          if ( ( 64 - $offset ) < 5 ) {
              $tocopy = 64 - $offset;
          }
  
          substr( $pwarray, $offset, $tocopy ) =
            substr( $mdContext1, $keyoffset, $tocopy );
  
          $offset += $tocopy;
  
          if ( $offset == 64 ) {
              $md5->add( $pwarray );
              $keyoffset = $tocopy;
              $tocopy    = 5 - $tocopy;
              $offset    = 0;
              next;
          }
  
          $keyoffset = 0;
          $tocopy    = 5;
          substr( $pwarray, $offset, 16 ) = $docid;
          $offset += 16;
      }
  
      substr( $pwarray, 16, 1 )  = "\x80";
      substr( $pwarray, 17, 47 ) = "\0" x 47;
      substr( $pwarray, 56, 1 )  = "\x80";
      substr( $pwarray, 57, 1 )  = "\x0a";
  
      $md5->add( $pwarray );
      ${$valContext} = md5state( $md5 );
  
      my $key;
  
      MakeKey( 0, \$key, ${$valContext} );
  
      my $salt       = $key->RC4( $salt_data );
      my $hashedsalt = $key->RC4( $hashedsalt_data );
  
      $salt .= "\x80" . "\0" x 47;
  
      substr( $salt, 56, 1 ) = "\x80";
  
      $md5->reset;
      $md5->add( $salt );
      my $mdContext2 = md5state( $md5 );
  
      return ( $mdContext2 eq $hashedsalt );
  }
  
  sub SkipBytes {
      my ( $q, $start, $count ) = @_;
  
      my $scratch = "\0" x REKEY_BLOCK;
      my $block;
  
      $block = int( ( $start + $count ) / REKEY_BLOCK );
  
      if ( $block != $q->{block} ) {
          MakeKey( $q->{block} = $block, \$q->{rc4_key}, $q->{md5_ctxt} );
          $count = ( $start + $count ) % REKEY_BLOCK;
      }
  
      $q->{rc4_key}->RC4( substr( $scratch, 0, $count ) );
  
      return 1;
  }
  
  sub SetDecrypt {
      my ( $q, $version, $password ) = @_;
  
      if ( $q->{opcode} != 0x2f ) {
          return 0;
      }
  
      if ( $password eq '' ) {
          return 0;
      }
  
      # TODO old versions decryption
      #if (version < MS_BIFF_V8 || q->data[0] == 0)
      #    return ms_biff_pre_biff8_query_set_decrypt (q, password);
  
      if ( $q->{length} != sizeof_BIFF_8_FILEPASS ) {
          return 0;
      }
  
      unless (
          VerifyPassword(
              $password,
              substr( $q->{data}, 6,  16 ),
              substr( $q->{data}, 22, 16 ),
              substr( $q->{data}, 38, 16 ),
              \$q->{md5_ctxt}
          )
        )
      {
          return 0;
      }
  
      $q->{encryption} = MS_BIFF_CRYPTO_RC4;
      $q->{block}      = -1;
  
      # The first record after FILEPASS seems to be unencrypted
      $q->{dont_decrypt_next_record} = 1;
  
      # Pretend to decrypt the entire stream up till this point, it was
      # encrypted, but do it anyway to keep the rc4 state in sync
  
      SkipBytes( $q, 0, $q->{streamPos} );
  
      return 1;
  }
  
  sub InitStream {
      my ( $stream_data ) = @_;
      my %q;
  
      $q{opcode} = 0;
      $q{length} = 0;
      $q{data}   = '';
  
      $q{stream}    = $stream_data;              # data stream
      $q{streamLen} = length( $stream_data );    # stream length
      $q{streamPos} = 0;                         # stream position
  
      $q{encryption}               = 0;
      $q{xor_key}                  = '';
      $q{rc4_key}                  = '';
      $q{md5_ctxt}                 = '';
      $q{block}                    = 0;
      $q{dont_decrypt_next_record} = 0;
  
      return \%q;
  }
  
  sub QueryNext {
      my ( $q ) = @_;
  
      if ( $q->{streamPos} + 4 >= $q->{streamLen} ) {
          return 0;
      }
  
      my $data = substr( $q->{stream}, $q->{streamPos}, 4 );
  
      ( $q->{opcode}, $q->{length} ) = unpack( 'v2', $data );
  
      # No biff record should be larger than around 20,000.
      if ( $q->{length} >= 20000 ) {
          return 0;
      }
  
      if ( $q->{length} > 0 ) {
          $q->{data} = substr( $q->{stream}, $q->{streamPos} + 4, $q->{length} );
      }
      else {
          $q->{data}                     = undef;
          $q->{dont_decrypt_next_record} = 1;
      }
  
      if ( $q->{encryption} == MS_BIFF_CRYPTO_RC4 ) {
          if ( $q->{dont_decrypt_next_record} ) {
              SkipBytes( $q, $q->{streamPos}, 4 + $q->{length} );
              $q->{dont_decrypt_next_record} = 0;
          }
          else {
              my $pos  = $q->{streamPos};
              my $data = $q->{data};
              my $len  = $q->{length};
              my $res  = '';
  
              # Pretend to decrypt header.
              SkipBytes( $q, $pos, 4 );
              $pos += 4;
  
              while ( $q->{block} != int( ( $pos + $len ) / REKEY_BLOCK ) ) {
                  my $step = REKEY_BLOCK - ( $pos % REKEY_BLOCK );
                  $res .= $q->{rc4_key}->RC4( substr( $data, 0, $step ) );
                  $data = substr( $data, $step );
                  $pos += $step;
                  $len -= $step;
                  MakeKey( ++$q->{block}, \$q->{rc4_key}, $q->{md5_ctxt} );
              }
  
              $res .= $q->{rc4_key}->RC4( substr( $data, 0, $len ) );
              $q->{data} = $res;
          }
      }
      elsif ( $q->{encryption} == MS_BIFF_CRYPTO_XOR ) {
  
          # not implemented
          return 0;
      }
      elsif ( $q->{encryption} == MS_BIFF_CRYPTO_NONE ) {
  
      }
  
      $q->{streamPos} += 4 + $q->{length};
  
      return 1;
  }
  
  ###############################################################################
  #
  # Parse()
  #
  # Parse the Excel file and convert it into a tree of objects..
  #
  sub parse {
  
      my ( $self, $source, $formatter ) = @_;
  
      my $workbook = Spreadsheet::ParseExcel::Workbook->new();
      $currentbook = $workbook;
      $workbook->{SheetCount} = 0;
      $workbook->{CellHandler} = $self->{CellHandler};
      $workbook->{NotSetCell}  = $self->{NotSetCell};
      $workbook->{Object}      = $self->{Object};
      $workbook->{aColor}      = [ @aColor ];
  
      my ( $biff_data, $data_length ) = $self->_get_content( $source, $workbook );
      return undef if not $biff_data;
  
      if ( $formatter ) {
          $workbook->{FmtClass} = $formatter;
      }
      else {
          $workbook->{FmtClass} = Spreadsheet::ParseExcel::FmtDefault->new();
      }
  
      # Parse the BIFF data.
      my $stream = InitStream( $biff_data );
  
      while ( QueryNext( $stream ) ) {
  
          my $record        = $stream->{opcode};
          my $record_length = $stream->{length};
  
          my $record_header = $stream->{data};
  
          # If the file contains a FILEPASS record we assume that it is encrypted
          # and cannot be parsed.
          if ( $record == 0x002F ) {
              unless ( SetDecrypt( $stream, '', $self->{Password} ) ) {
                  $self->{_error_status} = ErrorFileEncrypted;
                  return undef;
              }
          }
  
          # Special case of a formula String with no string.
          if (   $workbook->{_PrevPos}
              && ( defined $self->{FuncTbl}->{$record} )
              && ( $record != 0x207 ) )
          {
              my $iPos = $workbook->{_PrevPos};
              $workbook->{_PrevPos} = undef;
  
              my ( $row, $col, $format_index ) = @$iPos;
              _NewCell(
                  $workbook, $row, $col,
                  Kind     => 'Formula String',
                  Val      => '',
                  FormatNo => $format_index,
                  Format   => $workbook->{Format}[$format_index],
                  Numeric  => 0,
                  Code     => undef,
                  Book     => $workbook,
              );
          }
  
          # If the BIFF record matches 0x0*09 then it is a BOF record.
          # We reset the _skip_chart flag to ensure we check the sheet type.
          if ( ( $record & 0xF0FF ) == 0x09 ) {
              $workbook->{_skip_chart} = 0;
          }
  
          if ( defined $self->{FuncTbl}->{$record} && !$workbook->{_skip_chart} )
          {
              $self->{FuncTbl}->{$record}
                ->( $workbook, $record, $record_length, $record_header );
          }
  
          $PREFUNC = $record if ( $record != 0x3C );    #Not Continue
  
          last if defined $workbook->{_ParseAbort};
      }
  
      foreach my $worksheet (@{$workbook->{Worksheet}} ) {
          # Install hyperlinks into each cell
          # Range is undocumented for user; allows reuse of data
  
          if ($worksheet->{HyperLinks}) {
              foreach my $link (@{$worksheet->{HyperLinks}}) {
                  for( my $row = $link->[3]; $row <= $link->[4]; $row++ ) {
                      for( my $col = $link->[5]; $col <= $link->[6]; $col++ ) {
                          $worksheet->{Cells}[$row][$col]{Hyperlink} = $link;
                      }
                  }
              }
          }
      }
      return $workbook;
  }
  
  ###############################################################################
  #
  # _get_content()
  #
  # Get the Excel BIFF content from the file or filehandle.
  #
  sub _get_content {
  
      my ( $self, $source, $workbook ) = @_;
      my ( $biff_data, $data_length );
  
      # Reset the error status in case method is called more than once.
      $self->{_error_status} = ErrorNone;
   
      my $ref = ref($source);
  
      if ( $ref ) {
           if ( $ref eq 'SCALAR' ) {
  
               # Specified by a scalar buffer.
               ( $biff_data, $data_length ) = $self->{GetContent}->( $source );
  
           }
           elsif ( $ref eq 'ARRAY' ) {
  
               # Specified by file content
               $workbook->{File} = undef;
               my $sData = join( '', @$source );
               ( $biff_data, $data_length ) = $self->{GetContent}->( \$sData );
          }
          else {
  
               # Assume filehandle
  
               # For CGI.pm (Light FileHandle)
               my $sBuff = '';
               if ( eval { binmode( $source ) } ) {
                   my $sWk;
  
                   while ( read( $source, $sWk, 4096 ) ) {
                       $sBuff .= $sWk;
                   }
               }
               else {
  
                   # Assume IO::Wrap or some other filehandle-like OO-only object
                   my $sWk;
  
                   # IO::Wrap does not implement binmode
                   eval { $source->binmode() };
  
                   while ( $source->read( $sWk, 4096 ) ) {
                       $sBuff .= $sWk;
                   }
               }
  
               ( $biff_data, $data_length ) = $self->{GetContent}->( \$sBuff );
  
           }
      }
      else {
  
          # Specified by filename .
          $workbook->{File} = $source;
  
          if ( !-e $source ) {
              $self->{_error_status} = ErrorNoFile;
              return undef;
          }
  
          ( $biff_data, $data_length ) = $self->{GetContent}->( $source );
      }
  
      # If the read was successful return the data.
      if ( $data_length ) {
          return ( $biff_data, $data_length );
      }
      else {
          $self->{_error_status} = ErrorNoExcelData;
          return undef;
      }
  
  }
  
  #------------------------------------------------------------------------------
  # _subGetContent (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _subGetContent {
      my ( $sFile ) = @_;
  
      my $oOl = OLE::Storage_Lite->new( $sFile );
      return ( undef, undef ) unless ( $oOl );
      my @aRes = $oOl->getPpsSearch(
          [
              OLE::Storage_Lite::Asc2Ucs( 'Book' ),
              OLE::Storage_Lite::Asc2Ucs( 'Workbook' )
          ],
          1, 1
      );
      return ( undef, undef ) if ( $#aRes < 0 );
  
      #Hack from Herbert
      if ( $aRes[0]->{Data} ) {
          return ( $aRes[0]->{Data}, length( $aRes[0]->{Data} ) );
      }
  
      #Same as OLE::Storage_Lite
      my $oIo;
  
      #1. $sFile is Ref of scalar
      if ( ref( $sFile ) eq 'SCALAR' ) {
          if ( $_use_perlio ) {
              open $oIo, "<", \$sFile;
          }
          else {
              $oIo = IO::Scalar->new;
              $oIo->open( $sFile );
          }
      }
  
      #2. $sFile is a IO::Handle object
      elsif ( UNIVERSAL::isa( $sFile, 'IO::Handle' ) ) {
          $oIo = $sFile;
          binmode( $oIo );
      }
  
      #3. $sFile is a simple filename string
      elsif ( !ref( $sFile ) ) {
          $oIo = IO::File->new;
          $oIo->open( "<$sFile" ) || return undef;
          binmode( $oIo );
      }
      my $sWk;
      my $sBuff = '';
  
      while ( $oIo->read( $sWk, 4096 ) ) {    #4_096 has no special meanings
          $sBuff .= $sWk;
      }
      $oIo->close();
  
      #Not Excel file (simple method)
      return ( undef, undef ) if ( substr( $sBuff, 0, 1 ) ne "\x09" );
      return ( $sBuff, length( $sBuff ) );
  }
  
  #------------------------------------------------------------------------------
  # _subBOF (for Spreadsheet::ParseExcel) Developers' Kit : P303
  #------------------------------------------------------------------------------
  sub _subBOF {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iVer, $iDt ) = unpack( "v2", $sWk );
  
      #Workbook Global
      if ( $iDt == 0x0005 ) {
          $oBook->{Version} = unpack( "v", $sWk );
          $oBook->{BIFFVersion} =
            ( $oBook->{Version} == verExcel95 ) ? verBIFF5 : verBIFF8;
          $oBook->{_CurSheet}  = undef;
          $oBook->{_CurSheet_} = -1;
      }
  
      #Worksheet or Dialogsheet
      elsif ( $iDt != 0x0020 ) {    #if($iDt == 0x0010)
          if ( defined $oBook->{_CurSheet_} ) {
              $oBook->{_CurSheet} = $oBook->{_CurSheet_} + 1;
              $oBook->{_CurSheet_}++;
  
              (
                  $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{SheetVersion},
                  $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{SheetType},
                )
                = unpack( "v2", $sWk )
                if ( length( $sWk ) > 4 );
          }
          else {
              $oBook->{BIFFVersion} = int( $bOp / 0x100 );
              if (   ( $oBook->{BIFFVersion} == verBIFF2 )
                  || ( $oBook->{BIFFVersion} == verBIFF3 )
                  || ( $oBook->{BIFFVersion} == verBIFF4 ) )
              {
                  $oBook->{Version}   = $oBook->{BIFFVersion};
                  $oBook->{_CurSheet} = 0;
                  $oBook->{Worksheet}[ $oBook->{SheetCount} ] =
                    Spreadsheet::ParseExcel::Worksheet->new(
                      _Name    => '',
                      Name     => '',
                      _Book    => $oBook,
                      _SheetNo => $oBook->{SheetCount},
                    );
                  $oBook->{SheetCount}++;
              }
          }
      }
      else {
  
          # Set flag to ignore all chart records until we reach another BOF.
          $oBook->{_skip_chart} = 1;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subBlank (for Spreadsheet::ParseExcel) DK:P303
  #------------------------------------------------------------------------------
  sub _subBlank {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'BLANK',
          Val      => '',
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subInteger (for Spreadsheet::ParseExcel) Not in DK
  #------------------------------------------------------------------------------
  sub _subInteger {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF, $sTxt, $sDum );
  
      ( $iR, $iC, $iF, $sDum, $sTxt ) = unpack( "v3cv", $sWk );
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'INTEGER',
          Val      => $sTxt,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subNumber (for Spreadsheet::ParseExcel)  : DK: P354
  #------------------------------------------------------------------------------
  sub _subNumber {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      my $dVal = _convDval( substr( $sWk, 6, 8 ) );
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'Number',
          Val      => $dVal,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 1,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _convDval (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _convDval {
      my ( $sWk ) = @_;
      return
        unpack( "d",
          ( $BIGENDIAN ) ? pack( "c8", reverse( unpack( "c8", $sWk ) ) ) : $sWk );
  }
  
  #------------------------------------------------------------------------------
  # _subRString (for Spreadsheet::ParseExcel) DK:P405
  #------------------------------------------------------------------------------
  sub _subRString {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF, $iL, $sTxt );
      ( $iR, $iC, $iF, $iL ) = unpack( "v4", $sWk );
      $sTxt = substr( $sWk, 8, $iL );
  
      #Has STRUN
      if ( length( $sWk ) > ( 8 + $iL ) ) {
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'RString',
              Val      => $sTxt,
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 0,
              Code     => '_native_',                        #undef,
              Book     => $oBook,
              Rich     => substr( $sWk, ( 8 + $iL ) + 1 ),
          );
      }
      else {
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'RString',
              Val      => $sTxt,
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 0,
              Code     => '_native_',
              Book     => $oBook,
          );
      }
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subBoolErr (for Spreadsheet::ParseExcel) DK:P306
  #------------------------------------------------------------------------------
  sub _subBoolErr {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      my ( $iVal, $iFlg ) = unpack( "cc", substr( $sWk, 6, 2 ) );
      my $sTxt = DecodeBoolErr( $iVal, $iFlg );
  
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'BoolError',
          Val      => $sTxt,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => undef,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  ###############################################################################
  #
  # _subRK()
  #
  # Decode the RK BIFF record.
  #
  sub _subRK {
  
      my ( $workbook, $biff_number, $length, $data ) = @_;
  
      my ( $row, $col, $format_index, $rk_number ) = unpack( 'vvvV', $data );
  
      my $number = _decode_rk_number( $rk_number );
  
      _NewCell(
          $workbook, $row, $col,
          Kind     => 'RK',
          Val      => $number,
          FormatNo => $format_index,
          Format   => $workbook->{Format}->[$format_index],
          Numeric  => 1,
          Code     => undef,
          Book     => $workbook,
      );
  
      # Store the max and min row/col values.
      _SetDimension( $workbook, $row, $col, $col );
  }
  
  #------------------------------------------------------------------------------
  # _subArray (for Spreadsheet::ParseExcel)   DK:P297
  #------------------------------------------------------------------------------
  sub _subArray {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iBR, $iER, $iBC, $iEC ) = unpack( "v2c2", $sWk );
  
  }
  
  #------------------------------------------------------------------------------
  # _subFormula (for Spreadsheet::ParseExcel) DK:P336
  #------------------------------------------------------------------------------
  sub _subFormula {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
  
      my ( $iFlg ) = unpack( "v", substr( $sWk, 12, 2 ) );
      if ( $iFlg == 0xFFFF ) {
          my ( $iKind ) = unpack( "c", substr( $sWk, 6, 1 ) );
          my ( $iVal )  = unpack( "c", substr( $sWk, 8, 1 ) );
  
          if ( ( $iKind == 1 ) or ( $iKind == 2 ) ) {
              my $sTxt =
                ( $iKind == 1 )
                ? DecodeBoolErr( $iVal, 0 )
                : DecodeBoolErr( $iVal, 1 );
              _NewCell(
                  $oBook, $iR, $iC,
                  Kind     => 'Formula Bool',
                  Val      => $sTxt,
                  FormatNo => $iF,
                  Format   => $oBook->{Format}[$iF],
                  Numeric  => 0,
                  Code     => undef,
                  Book     => $oBook,
              );
          }
          else {    # Result (Reserve Only)
              $oBook->{_PrevPos} = [ $iR, $iC, $iF ];
          }
      }
      else {
          my $dVal = _convDval( substr( $sWk, 6, 8 ) );
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'Formula Number',
              Val      => $dVal,
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 1,
              Code     => undef,
              Book     => $oBook,
          );
      }
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subString (for Spreadsheet::ParseExcel)  DK:P414
  #------------------------------------------------------------------------------
  sub _subString {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      #Position (not enough for ARRAY)
  
      my $iPos = $oBook->{_PrevPos};
      return undef unless ( $iPos );
      $oBook->{_PrevPos} = undef;
      my ( $iR, $iC, $iF ) = @$iPos;
  
      my ( $iLen, $sTxt, $sCode );
      if ( $oBook->{BIFFVersion} == verBIFF8 ) {
          my ( $raBuff, $iLen ) = _convBIFF8String( $oBook, $sWk, 1 );
          $sTxt = $raBuff->[0];
          $sCode = ( $raBuff->[1] ) ? 'ucs2' : undef;
      }
      elsif ( $oBook->{BIFFVersion} == verBIFF5 ) {
          $sCode = '_native_';
          $iLen  = unpack( "v", $sWk );
          $sTxt  = substr( $sWk, 2, $iLen );
      }
      else {
          $sCode = '_native_';
          $iLen  = unpack( "c", $sWk );
          $sTxt  = substr( $sWk, 1, $iLen );
      }
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'String',
          Val      => $sTxt,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => $sCode,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subLabel (for Spreadsheet::ParseExcel)   DK:P344
  #------------------------------------------------------------------------------
  sub _subLabel {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF ) = unpack( "v3", $sWk );
      my ( $sLbl, $sCode );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          my ( $raBuff, $iLen, $iStPos, $iLenS ) =
            _convBIFF8String( $oBook, substr( $sWk, 6 ), 1 );
          $sLbl = $raBuff->[0];
          $sCode = ( $raBuff->[1] ) ? 'ucs2' : undef;
      }
  
      #Before BIFF8
      else {
          $sLbl = substr( $sWk, 8 );
          $sCode = '_native_';
      }
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'Label',
          Val      => $sLbl,
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => $sCode,
          Book     => $oBook,
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  ###############################################################################
  #
  # _subMulRK()
  #
  # Decode the Multiple RK BIFF record.
  #
  sub _subMulRK {
  
      my ( $workbook, $biff_number, $length, $data ) = @_;
  
      # JMN: I don't know why this is here.
      return if $workbook->{SheetCount} <= 0;
  
      my ( $row, $first_col ) = unpack( "v2", $data );
      my $last_col = unpack( "v", substr( $data, length( $data ) - 2, 2 ) );
  
      # Iterate over the RK array and decode the data.
      my $pos = 4;
      for my $col ( $first_col .. $last_col ) {
  
          my $data = substr( $data, $pos, 6 );
          my ( $format_index, $rk_number ) = unpack 'vV', $data;
          my $number = _decode_rk_number( $rk_number );
  
          _NewCell(
              $workbook, $row, $col,
              Kind     => 'MulRK',
              Val      => $number,
              FormatNo => $format_index,
              Format   => $workbook->{Format}->[$format_index],
              Numeric  => 1,
              Code     => undef,
              Book     => $workbook,
          );
          $pos += 6;
      }
  
      # Store the max and min row/col values.
      _SetDimension( $workbook, $row, $first_col, $last_col );
  }
  
  #------------------------------------------------------------------------------
  # _subMulBlank (for Spreadsheet::ParseExcel) DK:P349
  #------------------------------------------------------------------------------
  sub _subMulBlank {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iSc ) = unpack( "v2", $sWk );
      my $iEc = unpack( "v", substr( $sWk, length( $sWk ) - 2, 2 ) );
      my $iPos = 4;
      for ( my $iC = $iSc ; $iC <= $iEc ; $iC++ ) {
          my $iF = unpack( 'v', substr( $sWk, $iPos, 2 ) );
          _NewCell(
              $oBook, $iR, $iC,
              Kind     => 'MulBlank',
              Val      => '',
              FormatNo => $iF,
              Format   => $oBook->{Format}[$iF],
              Numeric  => 0,
              Code     => undef,
              Book     => $oBook,
          );
          $iPos += 2;
      }
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iSc, $iEc );
  }
  
  #------------------------------------------------------------------------------
  # _subLabelSST (for Spreadsheet::ParseExcel) DK: P345
  #------------------------------------------------------------------------------
  sub _subLabelSST {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iR, $iC, $iF, $iIdx ) = unpack( 'v3V', $sWk );
  
      _NewCell(
          $oBook, $iR, $iC,
          Kind     => 'PackedIdx',
          Val      => $oBook->{PkgStr}[$iIdx]->{Text},
          FormatNo => $iF,
          Format   => $oBook->{Format}[$iF],
          Numeric  => 0,
          Code     => ( $oBook->{PkgStr}[$iIdx]->{Unicode} ) ? 'ucs2' : undef,
          Book     => $oBook,
          Rich     => $oBook->{PkgStr}[$iIdx]->{Rich},
      );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iC, $iC );
  }
  
  #------------------------------------------------------------------------------
  # _subFlg1904 (for Spreadsheet::ParseExcel) DK:P296
  #------------------------------------------------------------------------------
  sub _subFlg1904 {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      $oBook->{Flg1904} = unpack( "v", $sWk );
  }
  
  #------------------------------------------------------------------------------
  # _subRow (for Spreadsheet::ParseExcel) DK:P403
  #------------------------------------------------------------------------------
  sub _subRow {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #0. Get Worksheet info (MaxRow, MaxCol, MinRow, MinCol)
      my ( $iR, $iSc, $iEc, $iHght, $undef1, $undef2, $iGr, $iXf ) =
        unpack( "v8", $sWk );
      $iEc--;
  
      if ( $iGr & 0x20 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RowHidden}[$iR] = 1;
      }
  
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RowHeight}[$iR] = $iHght / 20;
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      _SetDimension( $oBook, $iR, $iSc, $iEc );
  }
  
  #------------------------------------------------------------------------------
  # _SetDimension (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _SetDimension {
      my ( $oBook, $iR, $iSc, $iEc ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #2.MaxRow, MaxCol, MinRow, MinCol
      #2.1 MinRow
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinRow} = $iR
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinRow} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinRow} <= $iR );
  
      #2.2 MaxRow
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxRow} = $iR
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxRow} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxRow} > $iR );
  
      #2.3 MinCol
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinCol} = $iSc
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinCol} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MinCol} <= $iSc );
  
      #2.4 MaxCol
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxCol} = $iEc
        unless ( defined $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxCol} )
        and ( $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{MaxCol} > $iEc );
  
  }
  
  #------------------------------------------------------------------------------
  # _subDefaultRowHeight (for Spreadsheet::ParseExcel)    DK: P318
  #------------------------------------------------------------------------------
  sub _subDefaultRowHeight {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #1. RowHeight
      my ( $iDum, $iHght ) = unpack( "v2", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{DefRowHeight} = $iHght / 20;
  
  }
  
  #------------------------------------------------------------------------------
  # _subStandardWidth(for Spreadsheet::ParseExcel)    DK:P413
  #------------------------------------------------------------------------------
  sub _subStandardWidth {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my $iW = unpack( "v", $sWk );
      $oBook->{StandardWidth} = _convert_col_width( $oBook, $iW );
  }
  
  ###############################################################################
  #
  # _subDefColWidth()
  #
  # Read the DEFCOLWIDTH Biff record. This gives the width in terms of chars
  # and is different from the width in the COLINFO record.
  #
  sub _subDefColWidth {
  
      my ( $self, $record, $length, $data ) = @_;
  
      my $width = unpack 'v', $data;
  
      # Adjustment for default Arial 10 width.
      $width = 8.43 if $width == 8;
  
      $self->{Worksheet}->[ $self->{_CurSheet} ]->{DefColWidth} = $width;
  }
  
  ###############################################################################
  #
  # _convert_col_width()
  #
  # Converts from the internal Excel column width units to user units seen in the
  # interface. It is first necessary to convert the internal width to pixels and
  # then to user units. The conversion is specific to a default font of Arial 10.
  # TODO, the conversion should be extended to other fonts and sizes.
  #
  sub _convert_col_width {
  
      my $self        = shift;
      my $excel_width = shift;
  
      # Convert from Excel units to pixels (rounded up).
      my $pixels = int( 0.5 + $excel_width * 7 / 256 );
  
      # Convert from pixels to user units.
      # The conversion is different for columns <= 1 user unit (12 pixels).
      my $user_width;
      if ( $pixels <= 12 ) {
          $user_width = $pixels / 12;
      }
      else {
          $user_width = ( $pixels - 5 ) / 7;
      }
  
      # Round up to 2 decimal places.
      $user_width = int( $user_width * 100 + 0.5 ) / 100;
  
      return $user_width;
  }
  
  #------------------------------------------------------------------------------
  # _subColInfo (for Spreadsheet::ParseExcel) DK:P309
  #------------------------------------------------------------------------------
  sub _subColInfo {
  
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      return undef unless defined $oBook->{_CurSheet};
  
      my ( $iSc, $iEc, $iW, $iXF, $iGr ) = unpack( "v5", $sWk );
  
      for ( my $i = $iSc ; $i <= $iEc ; $i++ ) {
  
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{ColWidth}[$i] =
            _convert_col_width( $oBook, $iW );
  
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{ColFmtNo}[$i] = $iXF;
  
          if ( $iGr & 0x01 ) {
              $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{ColHidden}[$i] = 1;
          }
      }
  }
  
  #------------------------------------------------------------------------------
  # _subWindow1 Window information P 273
  #------------------------------------------------------------------------------
  sub _subWindow1 {
      my ( $workbook, $op, $len, $wk ) = @_;
  
      return if ( $workbook->{BIFFVersion} <= verBIFF4() );
  
      my (
          $hpos,     $vpos,        $width,
          $height,   $options,     $active,
          $firsttab, $numselected, $tabbarwidth
      ) = unpack( "v9", $wk );
  
      $workbook->{ActiveSheet} = $active;
  }
  
  #------------------------------------------------------------------------------
  # _subSheetLayout OpenOffice 5.96 (P207)
  #------------------------------------------------------------------------------
  sub _subSheetLayout {
      my ( $workbook, $op, $len, $wk ) = @_;
  
      my @unused;
      (
          my $rc,
          @unused[ 1 .. 10 ],
          @unused[ 11 .. 14 ],
          my $color, @unused[ 15, 16 ]
      ) = unpack( "vC10C4vC2", $wk );
  
      return unless ( $rc == 0x0862 );
  
      $workbook->{Worksheet}[ $workbook->{_CurSheet} ]->{TabColor} = $color;
  }
  
  #------------------------------------------------------------------------------
  # _subHyperlink OpenOffice 5.96 (P182)
  #
  # Also see: http://msdn.microsoft.com/en-us/library/gg615407(v=office.14).aspx
  #------------------------------------------------------------------------------
  
  # Helper: Extract a GID, returns as text string
  
  sub _getguid {
      my( $wk ) = @_;
      my( $text, $guidl, $guids1, $guids2, @guidb );
  
      ( $guidl, $guids1, $guids2, @guidb[0..7] ) = unpack( 'Vv2C8', $wk );
  
      $text =  sprintf( '%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X', $guidl, $guids1, $guids2, @guidb);
      return $text;
  }
  
  # Helper: Extract a counted (16-bit) unicode string, returns string,
  # updates $offset
  # $zterm == 1 if string is null-terminated. 
  # $bc if length is in bytes (not chars)
  
  sub _getustr {
      my( $wk, $offset, $zterm, $bc ) = @_;
  
      my $len = unpack( 'V', substr( $wk, $offset ) );
      $offset += 4;
  
      if( $bc ) {
          $len /= 2;
      }
      $len -= $zterm;
      my $text = join( '', map { chr $_ } unpack( "v$len", substr( $wk, $offset ) ) );
      $text =~ s/\0.*\z// if( $zterm );
      $_[1] = ( $offset += ($len + $zterm) *2 );
      return $text;
  }
  
  # HYPERLINK record
  
  sub _subHyperlink {
      my ( $workbook, $op, $len, $wk ) = @_;
  
      # REF
      my( $srow, $erow, $scol, $ecol ) = unpack( 'v4', $wk );
  
      my $guid = _getguid( substr( $wk, 8 ) );
      return unless( $guid eq '79EAC9D0-BAF9-11CE-8C82-00AA004BA90B' );
  
      my( $stmvers, $flags ) = unpack( 'VV', substr( $wk, 24 ) );
      return if( $flags & 0x60 || $stmvers != 2 );
  
      my $offset = 32;
      my( $desc,$frame, $link, $mark );
  
      if( ($flags & 0x14) == 0x14 ) {
          $desc = _getustr( $wk, $offset, 1, 0 );
      }
  
      if( $flags & 0x80 ) {
          $frame = _getustr( $wk, $offset, 1, 0 );
      }
  
      $link = '';
      if( $flags & 0x100 ) {
          # UNC path
          $link = 'file:///' . _getustr( $wk, $offset, 1, 0 );
      } elsif( $flags & 0x1 )  {
          # Has link (URI)
          $guid = _getguid( substr( $wk, $offset ) );
          $offset += 16;
          if( $guid eq '79EAC9E0-BAF9-11CE-8C82-00AA004BA90B' ) {
              # URI
              $link = _getustr( $wk, $offset, 1, 1 );
          } elsif( $guid eq '00000303-0000-0000-C000-000000000046' ) {
              # Local file
              $link = 'file:///';
              # !($flags & 2) = 'relative path'
              if( !($flags & 0x2) ) {
                  my $file = $workbook->{File};
                  if( defined $file && length $file ) {
                      $link .= (fileparse($file))[1];
                  }
                  else {
                      $link .= '%REL%'
                  }
              }
              my $dirn = unpack( 'v', substr( $wk, $offset ) );
              $offset += 2;
              $link .= '..\\' x $dirn;
              my $namelen = unpack( 'V', substr( $wk, $offset ) );
              $offset += 4;
              my $name = unpack( 'Z*', substr( $wk, $offset ) );
              $offset += $namelen;
              $offset += 24;
              my $size = unpack( 'V', substr( $wk, $offset ) );
              $offset += 4;
              if( $size ) {
                  my $xlen = unpack( 'V', substr( $wk, $offset ) ) / 2;
                  $name = join( '', map { chr $_} unpack( "v$xlen", substr( $wk, $offset+4+2) ) );
                  $offset += $size;
              }
              $link .= $name;
          } else {
              return;
          }
      }
  
      # Text mark (Fragment identifier)
      if( $flags & 0x8 ) {
          # Cellrefs contain reserved characters, so url-encode
          my $fragment = _getustr( $wk, $offset, 1 );
          $fragment =~ s/([^\w.~-])/sprintf( '%%%02X', ord( $1 ) )/gems;
          $link .= '#' . $fragment;
      }
  
      # Update loop at end of parse() if this changes
  
      push @{ $workbook->{Worksheet}[ $workbook->{_CurSheet} ]->{HyperLinks} }, [
                           $desc, $link, $frame, $srow, $erow, $scol, $ecol ];
  }
  
  #------------------------------------------------------------------------------
  # _subSST (for Spreadsheet::ParseExcel) DK:P413
  #------------------------------------------------------------------------------
  sub _subSST {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      _subStrWk( $oBook, substr( $sWk, 8 ) );
  }
  
  #------------------------------------------------------------------------------
  # _subContinue (for Spreadsheet::ParseExcel)    DK:P311
  #------------------------------------------------------------------------------
  sub _subContinue {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      #if(defined $self->{FuncTbl}->{$bOp}) {
      #    $self->{FuncTbl}->{$PREFUNC}->($oBook, $bOp, $bLen, $sWk);
      #}
  
      _subStrWk( $oBook, $sWk, 1 ) if ( $PREFUNC == 0xFC );
  }
  
  #------------------------------------------------------------------------------
  # _subWriteAccess (for Spreadsheet::ParseExcel) DK:P451
  #------------------------------------------------------------------------------
  sub _subWriteAccess {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return if ( defined $oBook->{_Author} );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          $oBook->{Author} = _convBIFF8String( $oBook, $sWk );
      }
  
      #Before BIFF8
      else {
          my ( $iLen ) = unpack( "c", $sWk );
          $oBook->{Author} =
            $oBook->{FmtClass}->TextFmt( substr( $sWk, 1, $iLen ), '_native_' );
      }
  }
  
  #------------------------------------------------------------------------------
  # _convBIFF8String (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _convBIFF8String {
      my ( $oBook, $sWk, $iCnvFlg ) = @_;
      my ( $iLen, $iFlg ) = unpack( "vc", $sWk );
      my ( $iHigh, $iExt, $iRich ) = ( $iFlg & 0x01, $iFlg & 0x04, $iFlg & 0x08 );
      my ( $iStPos, $iExtCnt, $iRichCnt, $sStr );
  
      #2. Rich and Ext
      if ( $iRich && $iExt ) {
          $iStPos = 9;
          ( $iRichCnt, $iExtCnt ) = unpack( 'vV', substr( $sWk, 3, 6 ) );
      }
      elsif ( $iRich ) {    #Only Rich
          $iStPos   = 5;
          $iRichCnt = unpack( 'v', substr( $sWk, 3, 2 ) );
          $iExtCnt  = 0;
      }
      elsif ( $iExt ) {     #Only Ext
          $iStPos   = 7;
          $iRichCnt = 0;
          $iExtCnt  = unpack( 'V', substr( $sWk, 3, 4 ) );
      }
      else {                #Nothing Special
          $iStPos   = 3;
          $iExtCnt  = 0;
          $iRichCnt = 0;
      }
  
      #3.Get String
      if ( $iHigh ) {       #Compressed
          $iLen *= 2;
          $sStr = substr( $sWk, $iStPos, $iLen );
          _SwapForUnicode( \$sStr );
          $sStr = $oBook->{FmtClass}->TextFmt( $sStr, 'ucs2' )
            unless ( $iCnvFlg );
      }
      else {                #Not Compressed
          $sStr = substr( $sWk, $iStPos, $iLen );
          $sStr = $oBook->{FmtClass}->TextFmt( $sStr, undef ) unless ( $iCnvFlg );
      }
  
      #4. return
      if ( wantarray ) {
  
          #4.1 Get Rich and Ext
          if ( length( $sWk ) < $iStPos + $iLen + $iRichCnt * 4 + $iExtCnt ) {
              return (
                  [ undef, $iHigh, undef, undef ],
                  $iStPos + $iLen + $iRichCnt * 4 + $iExtCnt,
                  $iStPos, $iLen
              );
          }
          else {
              return (
                  [
                      $sStr,
                      $iHigh,
                      substr( $sWk, $iStPos + $iLen, $iRichCnt * 4 ),
                      substr( $sWk, $iStPos + $iLen + $iRichCnt * 4, $iExtCnt )
                  ],
                  $iStPos + $iLen + $iRichCnt * 4 + $iExtCnt,
                  $iStPos, $iLen
              );
          }
      }
      else {
          return $sStr;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subXF (for Spreadsheet::ParseExcel)     DK:P453
  #------------------------------------------------------------------------------
  sub _subXF {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
  
      my ( $iFnt, $iIdx );
      my (
          $iLock,    $iHidden, $iStyle,  $i123,   $iAlH,    $iWrap,
          $iAlV,     $iJustL,  $iRotate, $iInd,   $iShrink, $iMerge,
          $iReadDir, $iBdrD,   $iBdrSL,  $iBdrSR, $iBdrST,  $iBdrSB,
          $iBdrSD,   $iBdrCL,  $iBdrCR,  $iBdrCT, $iBdrCB,  $iBdrCD,
          $iFillP,   $iFillCF, $iFillCB
      );
  
  
      if ( $oBook->{BIFFVersion} == verBIFF4 ) {
  
          # Minimal support for Excel 4. We just get the font and format indices
          # so that the cell data value can be formatted.
          ( $iFnt, $iIdx, ) = unpack( "CC", $sWk );
      }
      elsif ( $oBook->{BIFFVersion} == verBIFF8 ) {
          my ( $iGen, $iAlign, $iGen2, $iBdr1, $iBdr2, $iBdr3, $iPtn );
  
          ( $iFnt, $iIdx, $iGen, $iAlign, $iGen2, $iBdr1, $iBdr2, $iBdr3, $iPtn )
            = unpack( "v7Vv", $sWk );
          $iLock   = ( $iGen & 0x01 )   ? 1 : 0;
          $iHidden = ( $iGen & 0x02 )   ? 1 : 0;
          $iStyle  = ( $iGen & 0x04 )   ? 1 : 0;
          $i123    = ( $iGen & 0x08 )   ? 1 : 0;
          $iAlH    = ( $iAlign & 0x07 );
          $iWrap   = ( $iAlign & 0x08 ) ? 1 : 0;
          $iAlV    = ( $iAlign & 0x70 ) / 0x10;
          $iJustL  = ( $iAlign & 0x80 ) ? 1 : 0;
  
          $iRotate = ( ( $iAlign & 0xFF00 ) / 0x100 ) & 0x00FF;
          $iRotate = 90            if ( $iRotate == 255 );
          $iRotate = 90 - $iRotate if ( $iRotate > 90 );
  
          $iInd     = ( $iGen2 & 0x0F );
          $iShrink  = ( $iGen2 & 0x10 ) ? 1 : 0;
          $iMerge   = ( $iGen2 & 0x20 ) ? 1 : 0;
          $iReadDir = ( ( $iGen2 & 0xC0 ) / 0x40 ) & 0x03;
          $iBdrSL   = $iBdr1 & 0x0F;
          $iBdrSR   = ( ( $iBdr1 & 0xF0 ) / 0x10 ) & 0x0F;
          $iBdrST   = ( ( $iBdr1 & 0xF00 ) / 0x100 ) & 0x0F;
          $iBdrSB   = ( ( $iBdr1 & 0xF000 ) / 0x1000 ) & 0x0F;
  
          $iBdrCL = ( ( $iBdr2 & 0x7F ) ) & 0x7F;
          $iBdrCR = ( ( $iBdr2 & 0x3F80 ) / 0x80 ) & 0x7F;
          $iBdrD  = ( ( $iBdr2 & 0xC000 ) / 0x4000 ) & 0x3;
  
          $iBdrCT = ( ( $iBdr3 & 0x7F ) ) & 0x7F;
          $iBdrCB = ( ( $iBdr3 & 0x3F80 ) / 0x80 ) & 0x7F;
          $iBdrCD = ( ( $iBdr3 & 0x1FC000 ) / 0x4000 ) & 0x7F;
          $iBdrSD = ( ( $iBdr3 & 0x1E00000 ) / 0x200000 ) & 0xF;
          $iFillP = ( ( $iBdr3 & 0xFC000000 ) / 0x4000000 ) & 0x3F;
  
          $iFillCF = ( $iPtn & 0x7F );
          $iFillCB = ( ( $iPtn & 0x3F80 ) / 0x80 ) & 0x7F;
      }
      else {
          my ( $iGen, $iAlign, $iPtn, $iPtn2, $iBdr1, $iBdr2 );
  
          ( $iFnt, $iIdx, $iGen, $iAlign, $iPtn, $iPtn2, $iBdr1, $iBdr2 ) =
            unpack( "v8", $sWk );
          $iLock   = ( $iGen & 0x01 ) ? 1 : 0;
          $iHidden = ( $iGen & 0x02 ) ? 1 : 0;
          $iStyle  = ( $iGen & 0x04 ) ? 1 : 0;
          $i123    = ( $iGen & 0x08 ) ? 1 : 0;
  
          $iAlH   = ( $iAlign & 0x07 );
          $iWrap  = ( $iAlign & 0x08 ) ? 1 : 0;
          $iAlV   = ( $iAlign & 0x70 ) / 0x10;
          $iJustL = ( $iAlign & 0x80 ) ? 1 : 0;
  
          $iRotate = ( ( $iAlign & 0x300 ) / 0x100 ) & 0x3;
  
          $iFillCF = ( $iPtn & 0x7F );
          $iFillCB = ( ( $iPtn & 0x1F80 ) / 0x80 ) & 0x7F;
  
          $iFillP = ( $iPtn2 & 0x3F );
          $iBdrSB = ( ( $iPtn2 & 0x1C0 ) / 0x40 ) & 0x7;
          $iBdrCB = ( ( $iPtn2 & 0xFE00 ) / 0x200 ) & 0x7F;
  
          $iBdrST = ( $iBdr1 & 0x07 );
          $iBdrSL = ( ( $iBdr1 & 0x38 ) / 0x8 ) & 0x07;
          $iBdrSR = ( ( $iBdr1 & 0x1C0 ) / 0x40 ) & 0x07;
          $iBdrCT = ( ( $iBdr1 & 0xFE00 ) / 0x200 ) & 0x7F;
  
          $iBdrCL = ( $iBdr2 & 0x7F ) & 0x7F;
          $iBdrCR = ( ( $iBdr2 & 0x3F80 ) / 0x80 ) & 0x7F;
      }
  
      push @{ $oBook->{Format} }, Spreadsheet::ParseExcel::Format->new(
          FontNo => $iFnt,
          Font   => $oBook->{Font}[$iFnt],
          FmtIdx => $iIdx,
  
          Lock     => $iLock,
          Hidden   => $iHidden,
          Style    => $iStyle,
          Key123   => $i123,
          AlignH   => $iAlH,
          Wrap     => $iWrap,
          AlignV   => $iAlV,
          JustLast => $iJustL,
          Rotate   => $iRotate,
  
          Indent  => $iInd,
          Shrink  => $iShrink,
          Merge   => $iMerge,
          ReadDir => $iReadDir,
  
          BdrStyle => [ $iBdrSL, $iBdrSR,  $iBdrST, $iBdrSB ],
          BdrColor => [ $iBdrCL, $iBdrCR,  $iBdrCT, $iBdrCB ],
          BdrDiag  => [ $iBdrD,  $iBdrSD,  $iBdrCD ],
          Fill     => [ $iFillP, $iFillCF, $iFillCB ],
      );
  }
  
  #------------------------------------------------------------------------------
  # _subFormat (for Spreadsheet::ParseExcel)  DK: P336
  #------------------------------------------------------------------------------
  sub _subFormat {
  
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my $sFmt;
  
      if ( $oBook->{BIFFVersion} <= verBIFF5 ) {
          $sFmt = substr( $sWk, 3, unpack( 'c', substr( $sWk, 2, 1 ) ) );
          $sFmt = $oBook->{FmtClass}->TextFmt( $sFmt, '_native_' );
      }
      else {
          $sFmt = _convBIFF8String( $oBook, substr( $sWk, 2 ) );
      }
  
      my $format_index = unpack( 'v', substr( $sWk, 0, 2 ) );
  
      # Excel 4 and earlier used an index of 0 to indicate that a built-in format
      # that was stored implicitly.
      if ( $oBook->{BIFFVersion} <= verBIFF4 && $format_index == 0 ) {
          $format_index = keys %{ $oBook->{FormatStr} };
      }
  
      $oBook->{FormatStr}->{$format_index} = $sFmt;
  }
  
  #------------------------------------------------------------------------------
  # _subPalette (for Spreadsheet::ParseExcel) DK: P393
  #------------------------------------------------------------------------------
  sub _subPalette {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      for ( my $i = 0 ; $i < unpack( 'v', $sWk ) ; $i++ ) {
  
          #        push @aColor, unpack('H6', substr($sWk, $i*4+2));
          $oBook->{aColor}[ $i + 8 ] = unpack( 'H6', substr( $sWk, $i * 4 + 2 ) );
      }
  }
  
  #------------------------------------------------------------------------------
  # _subFont (for Spreadsheet::ParseExcel) DK:P333
  #------------------------------------------------------------------------------
  sub _subFont {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iHeight, $iAttr, $iCIdx, $iBold, $iSuper, $iUnderline, $sFntName );
      my ( $bBold, $bItalic, $bUnderline, $bStrikeout );
  
      if ( $oBook->{BIFFVersion} == verBIFF8 ) {
          ( $iHeight, $iAttr, $iCIdx, $iBold, $iSuper, $iUnderline ) =
            unpack( "v5c", $sWk );
          my ( $iSize, $iHigh ) = unpack( 'cc', substr( $sWk, 14, 2 ) );
          if ( $iHigh ) {
              $sFntName = substr( $sWk, 16, $iSize * 2 );
              _SwapForUnicode( \$sFntName );
              $sFntName = $oBook->{FmtClass}->TextFmt( $sFntName, 'ucs2' );
          }
          else {
              $sFntName = substr( $sWk, 16, $iSize );
              $sFntName = $oBook->{FmtClass}->TextFmt( $sFntName, '_native_' );
          }
          $bBold      = ( $iBold >= 0x2BC ) ? 1 : 0;
          $bItalic    = ( $iAttr & 0x02 )   ? 1 : 0;
          $bStrikeout = ( $iAttr & 0x08 )   ? 1 : 0;
          $bUnderline = ( $iUnderline )     ? 1 : 0;
      }
      elsif ( $oBook->{BIFFVersion} == verBIFF5 ) {
          ( $iHeight, $iAttr, $iCIdx, $iBold, $iSuper, $iUnderline ) =
            unpack( "v5c", $sWk );
          $sFntName =
            $oBook->{FmtClass}
            ->TextFmt( substr( $sWk, 15, unpack( "c", substr( $sWk, 14, 1 ) ) ),
              '_native_' );
          $bBold      = ( $iBold >= 0x2BC ) ? 1 : 0;
          $bItalic    = ( $iAttr & 0x02 )   ? 1 : 0;
          $bStrikeout = ( $iAttr & 0x08 )   ? 1 : 0;
          $bUnderline = ( $iUnderline )     ? 1 : 0;
      }
      else {
          ( $iHeight, $iAttr ) = unpack( "v2", $sWk );
          $iCIdx  = undef;
          $iSuper = 0;
  
          $bBold      = ( $iAttr & 0x01 ) ? 1 : 0;
          $bItalic    = ( $iAttr & 0x02 ) ? 1 : 0;
          $bUnderline = ( $iAttr & 0x04 ) ? 1 : 0;
          $bStrikeout = ( $iAttr & 0x08 ) ? 1 : 0;
  
          $sFntName = substr( $sWk, 5, unpack( "c", substr( $sWk, 4, 1 ) ) );
      }
      push @{ $oBook->{Font} }, Spreadsheet::ParseExcel::Font->new(
          Height         => $iHeight / 20.0,
          Attr           => $iAttr,
          Color          => $iCIdx,
          Super          => $iSuper,
          UnderlineStyle => $iUnderline,
          Name           => $sFntName,
  
          Bold      => $bBold,
          Italic    => $bItalic,
          Underline => $bUnderline,
          Strikeout => $bStrikeout,
      );
  
      #Skip Font[4]
      push @{ $oBook->{Font} }, {} if ( scalar( @{ $oBook->{Font} } ) == 4 );
  
  }
  
  #------------------------------------------------------------------------------
  # _subBoundSheet (for Spreadsheet::ParseExcel): DK: P307
  #------------------------------------------------------------------------------
  sub _subBoundSheet {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my ( $iPos, $iGr, $iKind ) = unpack( "Lc2", $sWk );
      $iKind &= 0x0F;
      return if ( ( $iKind != 0x00 ) && ( $iKind != 0x01 ) );
  
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          my ( $iSize, $iUni ) = unpack( "cc", substr( $sWk, 6, 2 ) );
          my $sWsName = substr( $sWk, 8 );
          if ( $iUni & 0x01 ) {
              _SwapForUnicode( \$sWsName );
              $sWsName = $oBook->{FmtClass}->TextFmt( $sWsName, 'ucs2' );
          }
          $oBook->{Worksheet}[ $oBook->{SheetCount} ] =
            Spreadsheet::ParseExcel::Worksheet->new(
              Name        => $sWsName,
              Kind        => $iKind,
              _Pos        => $iPos,
              _Book       => $oBook,
              _SheetNo    => $oBook->{SheetCount},
              SheetHidden => $iGr & 0x03
            );
      }
      else {
          $oBook->{Worksheet}[ $oBook->{SheetCount} ] =
            Spreadsheet::ParseExcel::Worksheet->new(
              Name =>
                $oBook->{FmtClass}->TextFmt( substr( $sWk, 7 ), '_native_' ),
              Kind        => $iKind,
              _Pos        => $iPos,
              _Book       => $oBook,
              _SheetNo    => $oBook->{SheetCount},
              SheetHidden => $iGr & 0x03
            );
      }
      $oBook->{SheetCount}++;
  }
  
  #------------------------------------------------------------------------------
  # _subHeader (for Spreadsheet::ParseExcel) DK: P340
  #------------------------------------------------------------------------------
  sub _subHeader {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
      my $sW;
  
      if ( !defined $sWk ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Header} = undef;
          return;
      }
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          $sW = _convBIFF8String( $oBook, $sWk );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Header} =
            ( $sW eq "\x00" ) ? undef : $sW;
      }
  
      #Before BIFF8
      else {
          my ( $iLen ) = unpack( "c", $sWk );
          $sW =
            $oBook->{FmtClass}->TextFmt( substr( $sWk, 1, $iLen ), '_native_' );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Header} =
            ( $sW eq "\x00\x00\x00" ) ? undef : $sW;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subFooter (for Spreadsheet::ParseExcel) DK: P335
  #------------------------------------------------------------------------------
  sub _subFooter {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
      my $sW;
  
      if ( !defined $sWk ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Footer} = undef;
          return;
      }
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          $sW = _convBIFF8String( $oBook, $sWk );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Footer} =
            ( $sW eq "\x00" ) ? undef : $sW;
      }
  
      #Before BIFF8
      else {
          my ( $iLen ) = unpack( "c", $sWk );
          $sW =
            $oBook->{FmtClass}->TextFmt( substr( $sWk, 1, $iLen ), '_native_' );
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Footer} =
            ( $sW eq "\x00\x00\x00" ) ? undef : $sW;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subHPageBreak (for Spreadsheet::ParseExcel) DK: P341
  #------------------------------------------------------------------------------
  sub _subHPageBreak {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my @aBreak;
      my $iCnt = unpack( "v", $sWk );
  
      return undef unless ( defined $oBook->{_CurSheet} );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iRow, $iColB, $iColE ) =
                unpack( 'v3', substr( $sWk, 2 + $i * 6, 6 ) );
  
              #            push @aBreak, [$iRow, $iColB, $iColE];
              push @aBreak, $iRow;
          }
      }
  
      #Before BIFF8
      else {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iRow ) = unpack( 'v', substr( $sWk, 2 + $i * 2, 2 ) );
              push @aBreak, $iRow;
  
              #            push @aBreak, [$iRow, 0, 255];
          }
      }
      @aBreak = sort { $a <=> $b } @aBreak;
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{HPageBreak} = \@aBreak;
  }
  
  #------------------------------------------------------------------------------
  # _subVPageBreak (for Spreadsheet::ParseExcel) DK: P447
  #------------------------------------------------------------------------------
  sub _subVPageBreak {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my @aBreak;
      my $iCnt = unpack( "v", $sWk );
  
      #BIFF8
      if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iCol, $iRowB, $iRowE ) =
                unpack( 'v3', substr( $sWk, 2 + $i * 6, 6 ) );
              push @aBreak, $iCol;
  
              #            push @aBreak, [$iCol, $iRowB, $iRowE];
          }
      }
  
      #Before BIFF8
      else {
          for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
              my ( $iCol ) = unpack( 'v', substr( $sWk, 2 + $i * 2, 2 ) );
              push @aBreak, $iCol;
  
              #            push @aBreak, [$iCol, 0, 65535];
          }
      }
      @aBreak = sort { $a <=> $b } @aBreak;
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{VPageBreak} = \@aBreak;
  }
  
  #------------------------------------------------------------------------------
  # _subMargin (for Spreadsheet::ParseExcel) DK: P306, 345, 400, 440
  #------------------------------------------------------------------------------
  sub _subMargin {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      # The "Mergin" options are a workaround for a backward compatible typo.
  
      my $dWk = _convDval( substr( $sWk, 0, 8 ) );
      if ( $bOp == 0x26 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{LeftMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{LeftMargin} = $dWk;
      }
      elsif ( $bOp == 0x27 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RightMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{RightMargin} = $dWk;
      }
      elsif ( $bOp == 0x28 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{TopMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{TopMargin} = $dWk;
      }
      elsif ( $bOp == 0x29 ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{BottomMergin} = $dWk;
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{BottomMargin} = $dWk;
      }
  }
  
  #------------------------------------------------------------------------------
  # _subHcenter (for Spreadsheet::ParseExcel) DK: P340
  #------------------------------------------------------------------------------
  sub _subHcenter {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{HCenter} = $iWk;
  
  }
  
  #------------------------------------------------------------------------------
  # _subVcenter (for Spreadsheet::ParseExcel) DK: P447
  #------------------------------------------------------------------------------
  sub _subVcenter {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{VCenter} = $iWk;
  }
  
  #------------------------------------------------------------------------------
  # _subPrintGridlines (for Spreadsheet::ParseExcel) DK: P397
  #------------------------------------------------------------------------------
  sub _subPrintGridlines {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{PrintGrid} = $iWk;
  
  }
  
  #------------------------------------------------------------------------------
  # _subPrintHeaders (for Spreadsheet::ParseExcel) DK: P397
  #------------------------------------------------------------------------------
  sub _subPrintHeaders {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iWk = unpack( "v", $sWk );
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{PrintHeaders} = $iWk;
  }
  
  #------------------------------------------------------------------------------
  # _subSETUP (for Spreadsheet::ParseExcel) DK: P409
  #------------------------------------------------------------------------------
  sub _subSETUP {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      # Workaround for some apps and older Excels that don't write a
      # complete SETUP record.
      return undef if $bLen != 34;
  
      my $oWkS = $oBook->{Worksheet}[ $oBook->{_CurSheet} ];
      my $iGrBit;
  
      (
          $oWkS->{PaperSize}, $oWkS->{Scale},     $oWkS->{PageStart},
          $oWkS->{FitWidth},  $oWkS->{FitHeight}, $iGrBit,
          $oWkS->{Res},       $oWkS->{VRes},
      ) = unpack( 'v8', $sWk );
  
      $oWkS->{HeaderMargin} = _convDval( substr( $sWk, 16, 8 ) );
      $oWkS->{FooterMargin} = _convDval( substr( $sWk, 24, 8 ) );
      $oWkS->{Copis} = unpack( 'v2', substr( $sWk, 32, 2 ) );
      $oWkS->{LeftToRight} = ( ( $iGrBit & 0x01 ) ? 1 : 0 );
      $oWkS->{Landscape}   = ( ( $iGrBit & 0x02 ) ? 1 : 0 );
      $oWkS->{NoPls}       = ( ( $iGrBit & 0x04 ) ? 1 : 0 );
      $oWkS->{NoColor}     = ( ( $iGrBit & 0x08 ) ? 1 : 0 );
      $oWkS->{Draft}       = ( ( $iGrBit & 0x10 ) ? 1 : 0 );
      $oWkS->{Notes}       = ( ( $iGrBit & 0x20 ) ? 1 : 0 );
      $oWkS->{NoOrient}    = ( ( $iGrBit & 0x40 ) ? 1 : 0 );
      $oWkS->{UsePage}     = ( ( $iGrBit & 0x80 ) ? 1 : 0 );
  
      # The NoPls flag indicates that the values have not been taken from an
      # actual printer and thus may not be accurate.
  
      # Set default scale if NoPls otherwise it may be an invalid value of 0XFF.
      $oWkS->{Scale} = 100 if $oWkS->{NoPls};
  
      # Workaround for a backward compatible typo.
      $oWkS->{HeaderMergin} = $oWkS->{HeaderMargin};
      $oWkS->{FooterMergin} = $oWkS->{FooterMargin};
  
  }
  
  #------------------------------------------------------------------------------
  # _subName (for Spreadsheet::ParseExcel) DK: P350
  #------------------------------------------------------------------------------
  sub _subName {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      my (
          $iGrBit, $cKey,    $cCh,    $iCce,   $ixAls,
          $iTab,   $cchCust, $cchDsc, $cchHep, $cchStatus
      ) = unpack( 'vc2v3c4', $sWk );
  
      #Builtin Name + Length == 1
      if ( ( $iGrBit & 0x20 ) && ( $cCh == 1 ) ) {
  
          #BIFF8
          if ( $oBook->{BIFFVersion} >= verBIFF8 ) {
              my $iName  = unpack( 'n', substr( $sWk, 14 ) );
              my $iSheet = unpack( 'v', substr( $sWk, 8 ) ) - 1;
  
              # Workaround for mal-formed Excel workbooks where Print_Title is
              # set as Global (i.e. itab = 0). Note, this will have to be
              # treated differently when we get around to handling global names.
              return undef if $iSheet == -1;
  
              if ( $iName == 6 ) {    #PrintArea
                  my ( $iSheetW, $raArea ) = _ParseNameArea( substr( $sWk, 16 ) );
                  $oBook->{PrintArea}[$iSheet] = $raArea;
              }
              elsif ( $iName == 7 ) {    #Title
                  my ( $iSheetW, $raArea ) = _ParseNameArea( substr( $sWk, 16 ) );
                  my @aTtlR = ();
                  my @aTtlC = ();
                  foreach my $raI ( @$raArea ) {
                      if ( $raI->[3] == 0xFF ) {    #Row Title
                          push @aTtlR, [ $raI->[0], $raI->[2] ];
                      }
                      else {                        #Col Title
                          push @aTtlC, [ $raI->[1], $raI->[3] ];
                      }
                  }
                  $oBook->{PrintTitle}[$iSheet] =
                    { Row => \@aTtlR, Column => \@aTtlC };
              }
          }
          else {
              my $iName = unpack( 'c', substr( $sWk, 14 ) );
              if ( $iName == 6 ) {                  #PrintArea
                  my ( $iSheet, $raArea ) =
                    _ParseNameArea95( substr( $sWk, 15 ) );
                  $oBook->{PrintArea}[$iSheet] = $raArea;
              }
              elsif ( $iName == 7 ) {               #Title
                  my ( $iSheet, $raArea ) =
                    _ParseNameArea95( substr( $sWk, 15 ) );
                  my @aTtlR = ();
                  my @aTtlC = ();
                  foreach my $raI ( @$raArea ) {
                      if ( $raI->[3] == 0xFF ) {    #Row Title
                          push @aTtlR, [ $raI->[0], $raI->[2] ];
                      }
                      else {                        #Col Title
                          push @aTtlC, [ $raI->[1], $raI->[3] ];
                      }
                  }
                  $oBook->{PrintTitle}[$iSheet] =
                    { Row => \@aTtlR, Column => \@aTtlC };
              }
          }
      }
  }
  
  #------------------------------------------------------------------------------
  # ParseNameArea (for Spreadsheet::ParseExcel) DK: 494 (ptgAread3d)
  #------------------------------------------------------------------------------
  sub _ParseNameArea {
      my ( $sObj ) = @_;
      my ( $iOp );
      my @aRes = ();
      $iOp = unpack( 'C', $sObj );
      my $iSheet;
      if ( $iOp == 0x3b ) {
          my ( $iWkS, $iRs, $iRe, $iCs, $iCe ) =
            unpack( 'v5', substr( $sObj, 1 ) );
          $iSheet = $iWkS;
          push @aRes, [ $iRs, $iCs, $iRe, $iCe ];
      }
      elsif ( $iOp == 0x29 ) {
          my $iLen = unpack( 'v', substr( $sObj, 1, 2 ) );
          my $iSt = 0;
          while ( $iSt < $iLen ) {
              my ( $iOpW, $iWkS, $iRs, $iRe, $iCs, $iCe ) =
                unpack( 'cv5', substr( $sObj, $iSt + 3, 11 ) );
  
              if ( $iOpW == 0x3b ) {
                  $iSheet = $iWkS;
                  push @aRes, [ $iRs, $iCs, $iRe, $iCe ];
              }
  
              if ( $iSt == 0 ) {
                  $iSt += 11;
              }
              else {
                  $iSt += 12;    #Skip 1 byte;
              }
          }
      }
      return ( $iSheet, \@aRes );
  }
  
  #------------------------------------------------------------------------------
  # ParseNameArea95 (for Spreadsheet::ParseExcel) DK: 494 (ptgAread3d)
  #------------------------------------------------------------------------------
  sub _ParseNameArea95 {
      my ( $sObj ) = @_;
      my ( $iOp );
      my @aRes = ();
      $iOp = unpack( 'C', $sObj );
      my $iSheet;
      if ( $iOp == 0x3b ) {
          $iSheet = unpack( 'v', substr( $sObj, 11, 2 ) );
          my ( $iRs, $iRe, $iCs, $iCe ) =
            unpack( 'v2C2', substr( $sObj, 15, 6 ) );
          push @aRes, [ $iRs, $iCs, $iRe, $iCe ];
      }
      elsif ( $iOp == 0x29 ) {
          my $iLen = unpack( 'v', substr( $sObj, 1, 2 ) );
          my $iSt = 0;
          while ( $iSt < $iLen ) {
              my $iOpW = unpack( 'c', substr( $sObj, $iSt + 3, 6 ) );
              $iSheet = unpack( 'v', substr( $sObj, $iSt + 14, 2 ) );
              my ( $iRs, $iRe, $iCs, $iCe ) =
                unpack( 'v2C2', substr( $sObj, $iSt + 18, 6 ) );
              push @aRes, [ $iRs, $iCs, $iRe, $iCe ] if ( $iOpW == 0x3b );
  
              if ( $iSt == 0 ) {
                  $iSt += 21;
              }
              else {
                  $iSt += 22;    #Skip 1 byte;
              }
          }
      }
      return ( $iSheet, \@aRes );
  }
  
  #------------------------------------------------------------------------------
  # _subBOOL (for Spreadsheet::ParseExcel) DK: P452
  #------------------------------------------------------------------------------
  sub _subWSBOOL {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{PageFit} =
        ( ( unpack( 'v', $sWk ) & 0x100 ) ? 1 : 0 );
  }
  
  #------------------------------------------------------------------------------
  # _subMergeArea (for Spreadsheet::ParseExcel) DK: (Not)
  #------------------------------------------------------------------------------
  sub _subMergeArea {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $iCnt = unpack( "v", $sWk );
      my $oWkS = $oBook->{Worksheet}[ $oBook->{_CurSheet} ];
      $oWkS->{MergedArea} = [] unless ( defined $oWkS->{MergedArea} );
      for ( my $i = 0 ; $i < $iCnt ; $i++ ) {
          my ( $iRs, $iRe, $iCs, $iCe ) =
            unpack( 'v4', substr( $sWk, $i * 8 + 2, 8 ) );
          for ( my $iR = $iRs ; $iR <= $iRe ; $iR++ ) {
              for ( my $iC = $iCs ; $iC <= $iCe ; $iC++ ) {
                  $oWkS->{Cells}[$iR][$iC]->{Merged} = 1
                    if ( defined $oWkS->{Cells}[$iR][$iC] );
              }
          }
          push @{ $oWkS->{MergedArea} }, [ $iRs, $iCs, $iRe, $iCe ];
      }
  }
  
  #------------------------------------------------------------------------------
  # DecodeBoolErr (for Spreadsheet::ParseExcel) DK: P306
  #------------------------------------------------------------------------------
  sub DecodeBoolErr {
      my ( $iVal, $iFlg ) = @_;
      if ( $iFlg ) {    # ERROR
          if ( $iVal == 0x00 ) {
              return "#NULL!";
          }
          elsif ( $iVal == 0x07 ) {
              return "#DIV/0!";
          }
          elsif ( $iVal == 0x0F ) {
              return "#VALUE!";
          }
          elsif ( $iVal == 0x17 ) {
              return "#REF!";
          }
          elsif ( $iVal == 0x1D ) {
              return "#NAME?";
          }
          elsif ( $iVal == 0x24 ) {
              return "#NUM!";
          }
          elsif ( $iVal == 0x2A ) {
              return "#N/A!";
          }
          else {
              return "#ERR";
          }
      }
      else {
          return ( $iVal ) ? "TRUE" : "FALSE";
      }
  }
  
  ###############################################################################
  #
  # _decode_rk_number()
  #
  # Convert an encoded RK number into a real number. The RK encoding is
  # explained in some detail in the MS docs. It is a way of storing applicable
  # ints and doubles in 32bits (30 data + 2 info bits) in order to save space.
  #
  sub _decode_rk_number {
  
      my $rk_number = shift;
      my $number;
  
      # Check the main RK type.
      if ( $rk_number & 0x02 ) {
  
          # RK Type 2 and 4, a packed integer.
  
          # Shift off the info bits.
          $number = $rk_number >> 2;
  
          # Convert from unsigned to signed if required.
          $number -= 0x40000000 if $number & 0x20000000;
      }
      else {
  
          # RK Type 1 and 3, a truncated IEEE Double.
  
          # Pack the RK number into the high 30 bits of an IEEE double.
          $number = pack "VV", 0x0000, $rk_number & 0xFFFFFFFC;
  
          # Reverse the packed IEEE double on big-endian machines.
          $number = reverse $number if $BIGENDIAN;
  
          # Unpack the number.
          $number = unpack "d", $number;
      }
  
      # RK Types 3 and 4 were multiplied by 100 prior to encoding.
      $number /= 100 if $rk_number & 0x01;
  
      return $number;
  }
  
  ###############################################################################
  #
  # _subStrWk()
  #
  # Extract the workbook strings from the SST (Shared String Table) record and
  # any following CONTINUE records.
  #
  # The workbook strings are initially contained in the SST block but may also
  # occupy one or more CONTINUE blocks. Reading the CONTINUE blocks is made a
  # little tricky by the fact that they can contain an additional initial byte
  # if a string is continued from a previous block.
  #
  # Parsing is further complicated by the fact that the continued section of the
  # string may have a different encoding (ASCII or UTF-8) from the previous
  # section. Excel does this to save space.
  #
  sub _subStrWk {
  
      my ( $self, $biff_data, $is_continue ) = @_;
  
      if ( $is_continue ) {
  
          # We are reading a CONTINUE record.
  
          if ( $self->{_buffer} eq '' ) {
  
              # A CONTINUE block with no previous SST.
              $self->{_buffer} .= $biff_data;
          }
          elsif ( !defined $self->{_string_continued} ) {
  
              # The CONTINUE block starts with a new (non-continued) string.
  
              # Strip the Grbit byte and store the string data.
              $self->{_buffer} .= substr $biff_data, 1;
          }
          else {
  
              # A CONTINUE block that starts with a continued string.
  
              # The first byte (Grbit) of the CONTINUE record indicates if (0)
              # the continued string section is single bytes or (1) double bytes.
              my $grbit = ord $biff_data;
  
              my ( $str_position, $str_length ) = @{ $self->{_previous_info} };
              my $buff_length = length $self->{_buffer};
  
              if ( $buff_length >= ( $str_position + $str_length ) ) {
  
                  # Not in a string.
                  $self->{_buffer} .= $biff_data;
              }
              elsif ( ( $self->{_string_continued} & 0x01 ) == ( $grbit & 0x01 ) )
              {
  
                  # Same encoding as the previous block of the string.
                  $self->{_buffer} .= substr( $biff_data, 1 );
              }
              else {
  
                  # Different encoding to the previous block of the string.
                  if ( $grbit & 0x01 ) {
  
                      # Current block is UTF-16, previous was ASCII.
                      my ( undef, $cch ) = unpack 'vc', $self->{_buffer};
                      substr( $self->{_buffer}, 2, 1 ) = pack( 'C', $cch | 0x01 );
  
                      # Convert the previous ASCII, single character, portion of
                      # the string into a double character UTF-16 string by
                      # inserting zero bytes.
                      for (
                          my $i = ( $buff_length - $str_position ) ;
                          $i >= 1 ;
                          $i--
                        )
                      {
                          substr( $self->{_buffer}, $str_position + $i, 0 ) =
                            "\x00";
                      }
  
                  }
                  else {
  
                      # Current block is ASCII, previous was UTF-16.
  
                      # Convert the current ASCII, single character, portion of
                      # the string into a double character UTF-16 string by
                      # inserting null bytes.
                      my $change_length =
                        ( $str_position + $str_length ) - $buff_length;
  
                      # Length of the current CONTINUE record data.
                      my $biff_length = length $biff_data;
  
                      # Restrict the portion to be changed to the current block
                      # if the string extends over more than one block.
                      if ( $change_length > ( $biff_length - 1 ) * 2 ) {
                          $change_length = ( $biff_length - 1 ) * 2;
                      }
  
                      # Insert the null bytes.
                      for ( my $i = ( $change_length / 2 ) ; $i >= 1 ; $i-- ) {
                          substr( $biff_data, $i + 1, 0 ) = "\x00";
                      }
  
                  }
  
                  # Strip the Grbit byte and store the string data.
                  $self->{_buffer} .= substr $biff_data, 1;
              }
          }
      }
      else {
  
          # Not a CONTINUE block therefore an SST block.
          $self->{_buffer} .= $biff_data;
      }
  
      # Reset the state variables.
      $self->{_string_continued} = undef;
      $self->{_previous_info}    = undef;
  
      # Extract out any full strings from the current buffer leaving behind a
      # partial string that is continued into the next block, or an empty
      # buffer is no string is continued.
      while ( length $self->{_buffer} >= 4 ) {
          my ( $str_info, $length, $str_position, $str_length ) =
            _convBIFF8String( $self, $self->{_buffer}, 1 );
  
          if ( defined $str_info->[0] ) {
              push @{ $self->{PkgStr} },
                {
                  Text    => $str_info->[0],
                  Unicode => $str_info->[1],
                  Rich    => $str_info->[2],
                  Ext     => $str_info->[3],
                };
              $self->{_buffer} = substr( $self->{_buffer}, $length );
          }
          else {
              $self->{_string_continued} = $str_info->[1];
              $self->{_previous_info} = [ $str_position, $str_length ];
              last;
          }
      }
  }
  
  #------------------------------------------------------------------------------
  # _SwapForUnicode (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _SwapForUnicode {
      my ( $sObj ) = @_;
  
      #    for(my $i = 0; $i<length($$sObj); $i+=2){
      for ( my $i = 0 ; $i < ( int( length( $$sObj ) / 2 ) * 2 ) ; $i += 2 ) {
          my $sIt = substr( $$sObj, $i, 1 );
          substr( $$sObj, $i, 1 ) = substr( $$sObj, $i + 1, 1 );
          substr( $$sObj, $i + 1, 1 ) = $sIt;
      }
  }
  
  #------------------------------------------------------------------------------
  # _NewCell (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub _NewCell {
      my ( $oBook, $iR, $iC, %rhKey ) = @_;
      my ( $sWk, $iLen );
      return undef unless ( defined $oBook->{_CurSheet} );
  
      my $FmtClass = $oBook->{FmtClass};
      $rhKey{Type} =
        $FmtClass->ChkType( $rhKey{Numeric}, $rhKey{Format}{FmtIdx} );
      my $FmtStr = $oBook->{FormatStr}{ $rhKey{Format}{FmtIdx} };
  
      # Set "Date" type if required for numbers in a MulRK BIFF block.
      if ( defined $FmtStr && $rhKey{Type} eq "Numeric" ) {
  
          # Match a range of possible date formats. Note: this isn't important
          # except for reporting. The number will still be converted to a date
          # by ExcelFmt() even if 'Type' isn't set to 'Date'.
          if ( $FmtStr =~ m{^[dmy][-\\/dmy]*$}i ) {
              $rhKey{Type} = "Date";
          }
      }
  
      my $oCell = Spreadsheet::ParseExcel::Cell->new(
          Val      => $rhKey{Val},
          FormatNo => $rhKey{FormatNo},
          Format   => $rhKey{Format},
          Code     => $rhKey{Code},
          Type     => $rhKey{Type},
      );
      $oCell->{_Kind} = $rhKey{Kind};
      $oCell->{_Value} = $FmtClass->ValFmt( $oCell, $oBook );
      if ( $rhKey{Rich} ) {
          my @aRich = ();
          my $sRich = $rhKey{Rich};
          for ( my $iWk = 0 ; $iWk < length( $sRich ) ; $iWk += 4 ) {
              my ( $iPos, $iFnt ) = unpack( 'v2', substr( $sRich, $iWk ) );
              push @aRich, [ $iPos, $oBook->{Font}[$iFnt] ];
          }
          $oCell->{Rich} = \@aRich;
      }
  
      if ( defined $oBook->{CellHandler} ) {
          if ( defined $oBook->{Object} ) {
              no strict;
              ref( $oBook->{CellHandler} ) eq "CODE"
                ? $oBook->{CellHandler}->(
                  $_Object, $oBook, $oBook->{_CurSheet}, $iR, $iC, $oCell
                )
                : $oBook->{CellHandler}->callback( $_Object, $oBook, $oBook->{_CurSheet},
                  $iR, $iC, $oCell );
          }
          else {
              $oBook->{CellHandler}->( $oBook, $oBook->{_CurSheet}, $iR, $iC, $oCell );
          }
      }
      unless ( $oBook->{NotSetCell} ) {
          $oBook->{Worksheet}[ $oBook->{_CurSheet} ]->{Cells}[$iR][$iC] = $oCell;
      }
      return $oCell;
  }
  
  #------------------------------------------------------------------------------
  # ColorIdxToRGB (for Spreadsheet::ParseExcel)
  #
  # Returns for most recently opened book for compatibility, use
  # Workbook::color_idx_to_rgb instead
  #
  #------------------------------------------------------------------------------
  sub ColorIdxToRGB {
      my ( $sPkg, $iIdx ) = @_;
  
  
      unless( defined $currentbook ) {
  	return ( ( defined $aColor[$iIdx] ) ? $aColor[$iIdx] : $aColor[0] );
      }
  
      return $currentbook->color_idx_to_rgb( $iIdx );
  }
  
  
  ###############################################################################
  #
  # error().
  #
  # Return an error string for a failed parse().
  #
  sub error {
  
      my $self = shift;
  
      my $parse_error = $self->{_error_status};
  
      if ( exists $error_strings{$parse_error} ) {
          return $error_strings{$parse_error};
      }
      else {
          return 'Unknown parse error';
      }
  }
  
  
  ###############################################################################
  #
  # error_code().
  #
  # Return an error code for a failed parse().
  #
  sub error_code {
  
      my $self = shift;
  
      return $self->{_error_status};
  }
  
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *Parse = *parse;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Spreadsheet::ParseExcel - Read information from an Excel file.
  
  =head1 SYNOPSIS
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die $parser->error(), ".\n";
      }
  
      for my $worksheet ( $workbook->worksheets() ) {
  
          my ( $row_min, $row_max ) = $worksheet->row_range();
          my ( $col_min, $col_max ) = $worksheet->col_range();
  
          for my $row ( $row_min .. $row_max ) {
              for my $col ( $col_min .. $col_max ) {
  
                  my $cell = $worksheet->get_cell( $row, $col );
                  next unless $cell;
  
                  print "Row, Col    = ($row, $col)\n";
                  print "Value       = ", $cell->value(),       "\n";
                  print "Unformatted = ", $cell->unformatted(), "\n";
                  print "\n";
              }
          }
      }
  
  
  =head1 DESCRIPTION
  
  The Spreadsheet::ParseExcel module can be used to read information from Excel 95-2003 binary files.
  
  The module cannot read files in the Excel 2007 Open XML XLSX format. See the L<Spreadsheet::XLSX> module instead.
  
  =head1 Parser
  
  =head2 new()
  
  The C<new()> method is used to create a new C<Spreadsheet::ParseExcel> parser object.
  
      my $parser = Spreadsheet::ParseExcel->new();
  
  It is possible to pass a password to decrypt an encrypted file:
  
      $parser = Spreadsheet::ParseExcel->new( Password => 'secret' );
  
  Only the default Excel encryption scheme is currently supported. See L</Decryption>.
  
  As an advanced feature it is also possible to pass a call-back handler to the parser to control the parsing of the spreadsheet.
  
      $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1,
      );
  
  The call-back can be used to ignore certain cells or to reduce memory usage. See the section L<Reducing the memory usage of Spreadsheet::ParseExcel> for more information.
  
  
  =head2 parse($filename, $formatter)
  
  The Parser C<parse()> method returns a L</Workbook> object.
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
  If an error occurs C<parse()> returns C<undef>. In general, programs should contain a test for failed parsing as follows:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die $parser->error(), ".\n";
      }
  
  The C<$filename> parameter is generally the file to be parsed. However, it can also be a filehandle or a scalar reference.
  
  The optional C<$formatter> parameter can be an reference to a L</Formatter Class> to format the value of cells. This is useful for parsing workbooks with Unicode or Asian characters:
  
      my $parser    = Spreadsheet::ParseExcel->new();
      my $formatter = Spreadsheet::ParseExcel::FmtJapan->new();
      my $workbook  = $parser->parse( 'Book1.xls', $formatter );
  
  The L<Spreadsheet::ParseExcel::FmtJapan> formatter also supports Unicode. If you encounter any encoding problems with the default formatter try that instead.
  
  
  =head2 error()
  
  The Parser C<error()> method returns an error string if a C<parse()> fails:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die $parser->error(), ".\n";
      }
  
  If you wish to generate you own error string you can use the C<error_code()> method instead (see below). The C<error()> and C<error_code()> values are as follows:
  
      error()                         error_code()
      =======                         ============
      ''                              0
      'File not found'                1
      'No Excel data found in file'   2
      'File is encrypted'             3
  
  
  The C<error_code()> method is explained below.
  
  Spreadsheet::ParseExcel will try to decrypt an encrypted Excel file using the default password or a user supplied password passed to C<new()>, see above. If these fail the module will return the C<'File is encrypted'> error. Only the default Excel encryption scheme is currently supported, see L</Decryption>.
  
  
  =head2 error_code()
  
  The Parser C<error_code()> method returns an error code if a C<parse()> fails:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
      if ( !defined $workbook ) {
          die "Got error code ", $parser->error_code, ".\n";
      }
  
  This can be useful if you wish to employ you own error strings or error handling methods.
  
  
  =head1 Workbook
  
  A C<Spreadsheet::ParseExcel::Workbook> is created via the C<Spreadsheet::ParseExcel> C<parse()> method:
  
      my $parser   = Spreadsheet::ParseExcel->new();
      my $workbook = $parser->parse('Book1.xls');
  
  The main methods of the Workbook class are:
  
      $workbook->worksheets()
      $workbook->worksheet()
      $workbook->worksheet_count()
      $workbook->get_filename()
  
  These more commonly used methods of the Workbook class are outlined below. The other, less commonly used, methods are documented in L<Spreadsheet::ParseExcel::Worksheet>.
  
  
  =head2 worksheets()
  
  Returns an array of L</Worksheet> objects. This was most commonly used to iterate over the worksheets in a workbook:
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
  
  =head2 worksheet()
  
  The C<worksheet()> method returns a single C<Worksheet> object using either its name or index:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  Returns C<undef> if the sheet name or index doesn't exist.
  
  
  =head2 worksheet_count()
  
  The C<worksheet_count()> method returns the number of Worksheet objects in the Workbook.
  
      my $worksheet_count = $workbook->worksheet_count();
  
  
  =head2 get_filename()
  
  The C<get_filename()> method returns the name of the Excel file of C<undef> if the data was read from a filehandle rather than a file.
  
      my $filename = $workbook->get_filename();
  
  
  =head2 Other Workbook Methods
  
  For full documentation of the methods available via a Workbook object see L<Spreadsheet::ParseExcel::Workbook>.
  
  =head1 Worksheet
  
  The C<Spreadsheet::ParseExcel::Worksheet> class encapsulates the properties of an Excel worksheet.
  
  A Worksheet object is obtained via the L</worksheets()> or L</worksheet()> methods.
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
      # Or:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  The most commonly used methods of the Worksheet class are:
  
      $worksheet->get_cell()
      $worksheet->row_range()
      $worksheet->col_range()
      $worksheet->get_name()
  
  The Spreadsheet::ParseExcel::Worksheet class exposes a lot of methods but in general very few are required unless you are writing an advanced filter.
  
  The most commonly used methods are detailed below. The others are documented in L<Spreadsheet::ParseExcel::Worksheet>.
  
  =head2 get_cell($row, $col)
  
  Return the L</Cell> object at row C<$row> and column C<$col> if it is defined. Otherwise returns undef.
  
      my $cell = $worksheet->get_cell($row, $col);
  
  
  =head2 row_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum defined rows in the worksheet. If there is no row defined C<$max> is smaller than C<$min>.
  
      my ( $row_min, $row_max ) = $worksheet->row_range();
  
  
  =head2 col_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum of defined columns in the worksheet. If there is no column defined C<$max> is smaller than C<$min>.
  
      my ( $col_min, $col_max ) = $worksheet->col_range();
  
  
  =head2 get_name()
  
  The C<get_name()> method returns the name of the worksheet, such as 'Sheet1'.
  
      my $name = $worksheet->get_name();
  
  =head2 Other Worksheet Methods
  
  For other, less commonly used, Worksheet methods see L<Spreadsheet::ParseExcel::Worksheet>.
  
  =head1 Cell
  
  The C<Spreadsheet::ParseExcel::Cell> class has the following main methods.
  
      $cell->value()
      $cell->unformatted()
  
  =head2 value()
  
  The C<value()> method returns the formatted value of the cell.
  
      my $value = $cell->value();
  
  Formatted in this sense refers to the numeric format of the cell value. For example a number such as 40177 might be formatted as 40,117, 40117.000 or even as the date 2009/12/30.
  
  If the cell doesn't contain a numeric format then the formatted and unformatted cell values are the same, see the C<unformatted()> method below.
  
  For a defined C<$cell> the C<value()> method will always return a value.
  
  In the case of a cell with formatting but no numeric or string contents the method will return the empty string C<''>.
  
  
  =head2 unformatted()
  
  The C<unformatted()> method returns the unformatted value of the cell.
  
      my $unformatted = $cell->unformatted();
  
  Returns the cell value without a numeric format. See the C<value()> method above.
  
  =head2 Other Cell Methods
  
  For other, less commonly used, Worksheet methods see L<Spreadsheet::ParseExcel::Cell>.
  
  
  =head1 Format
  
  The C<Spreadsheet::ParseExcel::Format> class has the following properties:
  
  =head2 Format properties
  
      $format->{Font}
      $format->{AlignH}
      $format->{AlignV}
      $format->{Indent}
      $format->{Wrap}
      $format->{Shrink}
      $format->{Rotate}
      $format->{JustLast}
      $format->{ReadDir}
      $format->{BdrStyle}
      $format->{BdrColor}
      $format->{BdrDiag}
      $format->{Fill}
      $format->{Lock}
      $format->{Hidden}
      $format->{Style}
  
  These properties are generally only of interest to advanced users. Casual users can skip this section.
  
  =head2 $format->{Font}
  
  Returns the L</Font> object for the Format.
  
  =head2 $format->{AlignH}
  
  Returns the horizontal alignment of the format where the value has the following meaning:
  
      0 => No alignment
      1 => Left
      2 => Center
      3 => Right
      4 => Fill
      5 => Justify
      6 => Center across
      7 => Distributed/Equal spaced
  
  =head2 $format->{AlignV}
  
  Returns the vertical alignment of the format where the value has the following meaning:
  
      0 => Top
      1 => Center
      2 => Bottom
      3 => Justify
      4 => Distributed/Equal spaced
  
  =head2 $format->{Indent}
  
  Returns the indent level of the C<Left> horizontal alignment.
  
  =head2 $format->{Wrap}
  
  Returns true if textwrap is on.
  
  =head2 $format->{Shrink}
  
  Returns true if "Shrink to fit" is set for the format.
  
  =head2 $format->{Rotate}
  
  Returns the text rotation. In Excel97+, it returns the angle in degrees of the text rotation.
  
  In Excel95 or earlier it returns a value as follows:
  
      0 => No rotation
      1 => Top down
      2 => 90 degrees anti-clockwise,
      3 => 90 clockwise
  
  =head2 $format->{JustLast}
  
  Return true if the "justify last" property is set for the format.
  
  =head2 $format->{ReadDir}
  
  Returns the direction that the text is read from.
  
  =head2 $format->{BdrStyle}
  
  Returns an array ref of border styles as follows:
  
      [ $left, $right, $top, $bottom ]
  
  =head2 $format->{BdrColor}
  
  Returns an array ref of border color indexes as follows:
  
      [ $left, $right, $top, $bottom ]
  
  =head2 $format->{BdrDiag}
  
  Returns an array ref of diagonal border kind, style and color index as follows:
  
      [$kind, $style, $color ]
  
  Where kind is:
  
      0 => None
      1 => Right-Down
      2 => Right-Up
      3 => Both
  
  =head2 $format->{Fill}
  
  Returns an array ref of fill pattern and color indexes as follows:
  
      [ $pattern, $front_color, $back_color ]
  
  =head2 $format->{Lock}
  
  Returns true if the cell is locked.
  
  =head2 $format->{Hidden}
  
  Returns true if the cell is Hidden.
  
  =head2 $format->{Style}
  
  Returns true if the format is a Style format.
  
  
  
  
  =head1 Font
  
  I<Spreadsheet::ParseExcel::Font>
  
  Format class has these properties:
  
  =head1 Font Properties
  
      $font->{Name}
      $font->{Bold}
      $font->{Italic}
      $font->{Height}
      $font->{Underline}
      $font->{UnderlineStyle}
      $font->{Color}
      $font->{Strikeout}
      $font->{Super}
  
  =head2 $font->{Name}
  
  Returns the name of the font, for example 'Arial'.
  
  =head2 $font->{Bold}
  
  Returns true if the font is bold.
  
  =head2 $font->{Italic}
  
  Returns true if the font is italic.
  
  =head2 $font->{Height}
  
  Returns the size (height) of the font.
  
  =head2 $font->{Underline}
  
  Returns true if the font in underlined.
  
  =head2 $font->{UnderlineStyle}
  
  Returns the style of an underlined font where the value has the following meaning:
  
       0 => None
       1 => Single
       2 => Double
      33 => Single accounting
      34 => Double accounting
  
  =head2 $font->{Color}
  
  Returns the color index for the font. The mapping to an RGB color is defined by each workbook.
  
  The index can be converted to a RGB string using the C<$workbook->ColorIdxToRGB()> Parser method.
  
  (Older versions of C<Spreadsheet::ParseExcel> provided the C<ColorIdxToRGB> class method, which is deprecated.)
  
  
  =head2 $font->{Strikeout}
  
  Returns true if the font has the strikeout property set.
  
  =head2 $font->{Super}
  
  Returns one of the following values if the superscript or subscript property of the font is set:
  
      0 => None
      1 => Superscript
      2 => Subscript
  
  =head1 Formatter Class
  
  Formatters can be passed to the C<parse()> method to deal with Unicode or Asian formatting.
  
  Spreadsheet::ParseExcel includes 2 formatter classes. C<FmtDefault> and C<FmtJapanese>. It is also possible to create a user defined formatting class.
  
  The formatter class C<Spreadsheet::ParseExcel::Fmt*> should provide the following functions:
  
  
  =head2 ChkType($self, $is_numeric, $format_index)
  
  Method to check the type of data in the cell. Should return C<Date>, C<Numeric> or C<Text>. It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $is_numeric
  
  If true, the value seems to be number.
  
  =item $format_index
  
  The index number for the cell Format object.
  
  =back
  
  =head2 TextFmt($self, $string_data, $string_encoding)
  
  Converts the string data in the cell into the correct encoding.  It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $string_data
  
  The original string/text data.
  
  =item $string_encoding
  
  The character encoding of original string/text.
  
  =back
  
  =head2 ValFmt($self, $cell, $workbook)
  
  Convert the original unformatted cell value into the appropriate formatted value. For instance turn a number into a formatted date.  It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $cell
  
  A scalar reference to the Cell object.
  
  =item $workbook
  
  A scalar reference to the Workbook object.
  
  =back
  
  
  =head2 FmtString($self, $cell, $workbook)
  
  Get the format string for the Cell.  It is passed the following parameters:
  
  =over
  
  =item $self
  
  A scalar reference to the Formatter object.
  
  =item $cell
  
  A scalar reference to the Cell object.
  
  =item $workbook
  
  A scalar reference to the Workbook object.
  
  =back
  
  
  =head1 Reducing the memory usage of Spreadsheet::ParseExcel
  
  In some cases a C<Spreadsheet::ParseExcel> application may consume a lot of memory when processing a large Excel file and, as a result, may fail to complete. The following explains why this can occur and how to resolve it.
  
  C<Spreadsheet::ParseExcel> processes an Excel file in two stages. In the first stage it extracts the Excel binary stream from the OLE container file using C<OLE::Storage_Lite>. In the second stage it parses the binary stream to read workbook, worksheet and cell data which it then stores in memory. The majority of the memory usage is required for storing cell data.
  
  The reason for this is that as the Excel file is parsed and each cell is encountered a cell handling function creates a relatively large nested cell object that contains the cell value and all of the data that relates to the cell formatting. For large files (a 10MB Excel file on a 256MB system) this overhead can cause the system to grind to a halt.
  
  However, in a lot of cases when an Excel file is being processed the only information that is required are the cell values. In these cases it is possible to avoid most of the memory overhead by specifying your own cell handling function and by telling Spreadsheet::ParseExcel not to store the parsed cell data. This is achieved by passing a cell handler function to C<new()> when creating the parse object. Here is an example.
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1
      );
  
      my $workbook = $parser->parse('file.xls');
  
      sub cell_handler {
  
          my $workbook    = $_[0];
          my $sheet_index = $_[1];
          my $row         = $_[2];
          my $col         = $_[3];
          my $cell        = $_[4];
  
          # Do something useful with the formatted cell value
          print $cell->value(), "\n";
  
      }
  
  
  The user specified cell handler is passed as a code reference to C<new()> along with the parameter C<NotSetCell> which tells Spreadsheet::ParseExcel not to store the parsed cell. Note, you don't have to iterate over the rows and columns, this happens automatically as part of the parsing.
  
  The cell handler is passed 5 arguments. The first, C<$workbook>, is a reference to the C<Spreadsheet::ParseExcel::Workbook> object that represent the parsed workbook. This can be used to access any of the C<Spreadsheet::ParseExcel::Workbook> methods, see L</Workbook>. The second C<$sheet_index> is the zero-based index of the worksheet being parsed. The third and fourth, C<$row> and C<$col>, are the zero-based row and column number of the cell. The fifth, C<$cell>, is a reference to the C<Spreadsheet::ParseExcel::Cell> object. This is used to extract the data from the cell. See L</Cell> for more information.
  
  This technique can be useful if you are writing an Excel to database filter since you can put your DB calls in the cell handler.
  
  If you don't want all of the data in the spreadsheet you can add some control logic to the cell handler. For example we can extend the previous example so that it only prints the first 10 rows of the first two worksheets in the parsed workbook by adding some C<if()> statements to the cell handler:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1
      );
  
      my $workbook = $parser->parse('file.xls');
  
      sub cell_handler {
  
          my $workbook    = $_[0];
          my $sheet_index = $_[1];
          my $row         = $_[2];
          my $col         = $_[3];
          my $cell        = $_[4];
  
          # Skip some worksheets and rows (inefficiently).
          return if $sheet_index >= 3;
          return if $row >= 10;
  
          # Do something with the formatted cell value
          print $cell->value(), "\n";
  
      }
  
  
  However, this still processes the entire workbook. If you wish to save some additional processing time you can abort the parsing after you have read the data that you want, using the workbook C<ParseAbort> method:
  
      #!/usr/bin/perl -w
  
      use strict;
      use Spreadsheet::ParseExcel;
  
      my $parser = Spreadsheet::ParseExcel->new(
          CellHandler => \&cell_handler,
          NotSetCell  => 1
      );
  
      my $workbook = $parser->parse('file.xls');
  
      sub cell_handler {
  
          my $workbook    = $_[0];
          my $sheet_index = $_[1];
          my $row         = $_[2];
          my $col         = $_[3];
          my $cell        = $_[4];
  
          # Skip some worksheets and rows (more efficiently).
          if ( $sheet_index >= 1 and $row >= 10 ) {
              $workbook->ParseAbort(1);
              return;
          }
  
          # Do something with the formatted cell value
          print $cell->value(), "\n";
  
      }
  
  =head1 Decryption
  
  If a workbook is "protected" then Excel will encrypt the file whether a password is supplied or not. As of version 0.59 Spreadsheet::ParseExcel supports decrypting Excel workbooks using a default or user supplied password. However, only the following encryption scheme is supported:
  
      Office 97/2000 Compatible encryption
  
  The following encryption methods are not supported:
  
      Weak Encryption (XOR)
      RC4, Microsoft Base Cryptographic Provider v1.0
      RC4, Microsoft Base DSS and Diffie-Hellman Cryptographic Provider
      RC4, Microsoft DH SChannel Cryptographic Provider
      RC4, Microsoft Enhanced Cryptographic Provider v1.0
      RC4, Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider
      RC4, Microsoft Enhanced RSA and AES Cryptographic Provider
      RC4, Microsoft RSA SChannel Cryptographic Provider
      RC4, Microsoft Strong Cryptographic Provider
  
  See the following for more information on Excel encryption: L<http://office.microsoft.com/en-us/office-2003-resource-kit/important-aspects-of-password-and-encryption-protection-HA001140311.aspx>.
  
  
  
  =head1 KNOWN PROBLEMS
  
  =over
  
  =item * Issues reported by users: L<http://rt.cpan.org/Public/Dist/Display.html?Name=Spreadsheet-ParseExcel>
  
  =item * This module cannot read the values of formulas from files created with Spreadsheet::WriteExcel unless the user specified the values when creating the file (which is generally not the case). The reason for this is that Spreadsheet::WriteExcel writes the formula but not the formula result since it isn't in a position to calculate arbitrary Excel formulas without access to Excel's formula engine.
  
  =item * If Excel has date fields where the specified format is equal to the system-default for the short-date locale, Excel does not store the format, but defaults to an internal format which is system dependent. In these cases ParseExcel uses the date format 'yyyy-mm-dd'.
  
  =back
  
  
  
  
  =head1 REPORTING A BUG
  
  Bugs can be reported via rt.cpan.org. See the following for instructions on bug reporting for Spreadsheet::ParseExcel
  
  L<http://rt.cpan.org/Public/Dist/Display.html?Name=Spreadsheet-ParseExcel>
  
  
  
  
  =head1 SEE ALSO
  
  =over
  
  =item * xls2csv by Ken Prows L<http://search.cpan.org/~ken/xls2csv-1.06/script/xls2csv>.
  
  =item * xls2csv and xlscat by H.Merijn Brand (these utilities are part of Spreadsheet::Read, see below).
  
  =item * excel2txt by Ken Youens-Clark, L<http://search.cpan.org/~kclark/excel2txt/excel2txt>. This is an excellent example of an Excel filter using Spreadsheet::ParseExcel. It can produce CSV, Tab delimited, Html, XML and Yaml.
  
  =item * XLSperl by Jon Allen L<http://search.cpan.org/~jonallen/XLSperl/bin/XLSperl>. This application allows you to use Perl "one-liners" with Microsoft Excel files.
  
  =item * Spreadsheet::XLSX L<http://search.cpan.org/~dmow/Spreadsheet-XLSX/lib/Spreadsheet/XLSX.pm> by Dmitry Ovsyanko. A module with a similar interface to Spreadsheet::ParseExcel for parsing Excel 2007 XLSX OpenXML files.
  
  =item * Spreadsheet::Read L<http://search.cpan.org/~hmbrand/Spreadsheet-Read/Read.pm> by H.Merijn Brand. A single interface for reading several different spreadsheet formats.
  
  =item * Spreadsheet::WriteExcel L<http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm>. A perl module for creating new Excel files.
  
  =item * Spreadsheet::ParseExcel::SaveParser L<http://search.cpan.org/~jmcnamara/Spreadsheet-ParseExcel/lib/Spreadsheet/ParseExcel/SaveParser.pm>. This is a combination of Spreadsheet::ParseExcel and Spreadsheet::WriteExcel and it allows you to "rewrite" an Excel file. See the following example L<http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm#MODIFYING_AND_REWRITING_EXCEL_FILES>. It is part of the Spreadsheet::ParseExcel distro.
  
  =item * Text::CSV_XS L<http://search.cpan.org/~hmbrand/Text-CSV_XS/CSV_XS.pm> by H.Merijn Brand. A fast and rigorous module for reading and writing CSV data. Don't consider rolling your own CSV handling, use this module instead.
  
  =back
  
  
  
  
  =head1 MAILING LIST
  
  There is a Google group for discussing and asking questions about Spreadsheet::ParseExcel. This is a good place to search to see if your question has been asked before:  L<http://groups-beta.google.com/group/spreadsheet-parseexcel/>
  
  
  
  
  =head1 DONATIONS
  
  If you'd care to donate to the Spreadsheet::ParseExcel project, you can do so via PayPal: L<http://tinyurl.com/7ayes>
  
  
  
  
  =head1 TODO
  
  =over
  
  =item * The current maintenance work is directed towards making the documentation more useful, improving and simplifying the API, and improving the maintainability of the code base. After that new features will be added.
  
  =item * Fix open bugs and documentation for SaveParser.
  
  =item * Add Formula support, Hyperlink support, Named Range support.
  
  =item * Improve Spreadsheet::ParseExcel::SaveParser compatibility with Spreadsheet::WriteExcel.
  
  =item * Improve Unicode and other encoding support. This will probably require dropping support for perls prior to 5.8+.
  
  =back
  
  
  
  =head1 ACKNOWLEDGEMENTS
  
  From Kawai Takanori:
  
  First of all, I would like to acknowledge the following valuable programs and modules:
  XHTML, OLE::Storage and Spreadsheet::WriteExcel.
  
  In no particular order: Yamaji Haruna, Simamoto Takesi, Noguchi Harumi, Ikezawa Kazuhiro, Suwazono Shugo, Hirofumi Morisada, Michael Edwards, Kim Namusk, Slaven Rezic, Grant Stevens, H.Merijn Brand and many many people + Kawai Mikako.
  
  Alexey Mazurin added the decryption facility.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the software "as is" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the software is with you. Should the software prove defective, you assume the cost of all necessary servicing, repair, or correction.
  
  In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for damages, including any general, special, incidental, or consequential damages arising out of the use or inability to use the software (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the software to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
  
  
  
  
  =head1 LICENSE
  
  Either the Perl Artistic Licence L<http://dev.perl.org/licenses/artistic.html> or the GPL L<http://www.opensource.org/licenses/gpl-license.php>
  
  
  
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori (Hippo2000) kwitknr@cpan.org
  
  
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved. This is free software. You may distribute under the terms of either the GNU General Public License or the Artistic License.
  
  
  =cut
SPREADSHEET_PARSEEXCEL

$fatpacked{"Spreadsheet/ParseExcel/Cell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_CELL';
  package Spreadsheet::ParseExcel::Cell;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Cell - A class for Cell data and formatting.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.65';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
      my ( $package, %properties ) = @_;
      my $self = \%properties;
  
      bless $self, $package;
  }
  
  ###############################################################################
  #
  # value()
  #
  # Returns the formatted value of the cell.
  #
  sub value {
  
      my $self = shift;
  
      return $self->{_Value};
  }
  
  ###############################################################################
  #
  # unformatted()
  #
  # Returns the unformatted value of the cell.
  #
  sub unformatted {
  
      my $self = shift;
  
      return $self->{Val};
  }
  
  ###############################################################################
  #
  # get_format()
  #
  # Returns the Format object for the cell.
  #
  sub get_format {
  
      my $self = shift;
  
      return $self->{Format};
  }
  
  ###############################################################################
  #
  # type()
  #
  # Returns the type of cell such as Text, Numeric or Date.
  #
  sub type {
  
      my $self = shift;
  
      return $self->{Type};
  }
  
  ###############################################################################
  #
  # encoding()
  #
  # Returns the character encoding of the cell.
  #
  sub encoding {
  
      my $self = shift;
  
      if ( !defined $self->{Code} ) {
          return 1;
      }
      elsif ( $self->{Code} eq 'ucs2' ) {
          return 2;
      }
      elsif ( $self->{Code} eq '_native_' ) {
          return 3;
      }
      else {
          return 0;
      }
  
      return $self->{Code};
  }
  
  ###############################################################################
  #
  # is_merged()
  #
  # Returns true if the cell is merged.
  #
  sub is_merged {
  
      my $self = shift;
  
      return $self->{Merged};
  }
  
  ###############################################################################
  #
  # get_rich_text()
  #
  # Returns an array ref of font information about each string block in a "rich",
  # i.e. multi-format, string.
  #
  sub get_rich_text {
  
      my $self = shift;
  
      return $self->{Rich};
  }
  
  ###############################################################################
  #
  # get_hyperlink {
  #
  # Returns an array ref of hyperlink information if the cell contains a hyperlink.
  # Returns undef otherwise
  #
  # [0] : Description of link (You may want $cell->value, as it will have rich text)
  # [1] : URL - the link expressed as a URL. N.B. relative URLs will be defaulted to
  #       the directory of the input file, if the input file name is known. Otherwise
  #       %REL% will be inserted as a place-holder.  Depending on your application,
  #       you should either remove %REL% or replace it with the appropriate path.
  # [2] : Target frame (or undef if none)
  
  sub get_hyperlink {
      my $self = shift;
  
      return $self->{Hyperlink} if exists $self->{Hyperlink};
      return undef;
  }
  
  # 
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *Value = \&value;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Cell - A class for Cell data and formatting.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 Methods
  
  The following Cell methods are available:
  
      $cell->value()
      $cell->unformatted()
      $cell->get_format()
      $cell->type()
      $cell->encoding()
      $cell->is_merged()
      $cell->get_rich_text()
      $cell->get_hyperlink()
  
  
  =head2 value()
  
  The C<value()> method returns the formatted value of the cell.
  
      my $value = $cell->value();
  
  Formatted in this sense refers to the numeric format of the cell value. For example a number such as 40177 might be formatted as 40,117, 40117.000 or even as the date 2009/12/30.
  
  If the cell doesn't contain a numeric format then the formatted and unformatted cell values are the same, see the C<unformatted()> method below.
  
  For a defined C<$cell> the C<value()> method will always return a value.
  
  In the case of a cell with formatting but no numeric or string contents the method will return the empty string C<''>.
  
  
  =head2 unformatted()
  
  The C<unformatted()> method returns the unformatted value of the cell.
  
      my $unformatted = $cell->unformatted();
  
  Returns the cell value without a numeric format. See the C<value()> method above.
  
  
  =head2 get_format()
  
  The C<get_format()> method returns the L<Spreadsheet::ParseExcel::Format> object for the cell.
  
      my $format = $cell->get_format();
  
  If a user defined format hasn't been applied to the cell then the default cell format is returned.
  
  
  =head2 type()
  
  The C<type()> method returns the type of cell such as Text, Numeric or Date. If the type was detected as Numeric, and the Cell Format matches C<m{^[dmy][-\\/dmy]*$}i>, it will be treated as a Date type.
  
      my $type = $cell->type();
  
  See also L<Dates and Time in Excel>.
  
  
  =head2 encoding()
  
  The C<encoding()> method returns the character encoding of the cell.
  
      my $encoding = $cell->encoding();
  
  This method is only of interest to developers. In general Spreadsheet::ParseExcel will return all character strings in UTF-8 regardless of the encoding used by Excel.
  
  The C<encoding()> method returns one of the following values:
  
  =over
  
  =item * 0: Unknown format. This shouldn't happen. In the default case the format should be 1.
  
  =item * 1: 8bit ASCII or single byte UTF-16. This indicates that the characters are encoded in a single byte. In Excel 95 and earlier This usually meant ASCII or an international variant. In Excel 97 it refers to a compressed UTF-16 character string where all of the high order bytes are 0 and are omitted to save space.
  
  =item * 2: UTF-16BE.
  
  =item * 3: Native encoding. In Excel 95 and earlier this encoding was used to represent multi-byte character encodings such as SJIS.
  
  =back
  
  
  =head2 is_merged()
  
  The C<is_merged()> method returns true if the cell is merged.
  
      my $is_merged = $cell->is_merged();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_rich_text()
  
  The C<get_rich_text()> method returns an array ref of font information about each string block in a "rich", i.e. multi-format, string.
  
      my $rich_text = $cell->get_rich_text();
  
  The return value is an arrayref of arrayrefs in the form:
  
      [
          [ $start_position, $font_object ],
           ...,
      ]
  
  Returns undef if the property isn't set.
  
  =head2 get_hyperlink()
  
  If a cell contains a hyperlink, the C<get_hyperlink()> method returns an array ref of information about it.
  
  A cell can contain at most one hyperlink.  If it does, it contains no other value.
  
  Otherwise, it returns undef;
  
  The array contains:
  
  =over
  
  =item * 0: Description (what's displayed); undef if not present
  
  =item * 1: Link, converted to an appropriate URL - Note: Relative links are based on the input file.  %REL% is used if the input file is unknown (e.g. a file handle or scalar)
  
  =item * 2: Target - target frame (or undef if none)
  
  =back
  
  =head1 Dates and Time in Excel
  
  Dates and times in Excel are represented by real numbers, for example "Jan 1 2001 12:30 PM" is represented by the number 36892.521.
  
  The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day.
  
  A date or time in Excel is just like any other number. The way in which it is displayed is controlled by the number format:
  
      Number format               $cell->value()            $cell->unformatted()
      =============               ==============            ==============
      'dd/mm/yy'                  '28/02/08'                39506.5
      'mm/dd/yy'                  '02/28/08'                39506.5
      'd-m-yyyy'                  '28-2-2008'               39506.5
      'dd/mm/yy hh:mm'            '28/02/08 12:00'          39506.5
      'd mmm yyyy'                '28 Feb 2008'             39506.5
      'mmm d yyyy hh:mm AM/PM'    'Feb 28 2008 12:00 PM'    39506.5
  
  
  The L<Spreadsheet::ParseExcel::Utility> module contains a function called C<ExcelLocaltime> which will convert between an unformatted Excel date/time number and a C<localtime()> like array.
  
  For date conversions using the CPAN C<DateTime> framework see L<DateTime::Format::Excel> http://search.cpan.org/search?dist=DateTime-Format-Excel
  
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_CELL

$fatpacked{"Spreadsheet/ParseExcel/Dump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_DUMP';
  package Spreadsheet::ParseExcel::Dump;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Dump - A class for dumping Excel records.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.65';
  
  my %NameTbl = (
  
      #P291
      0x0A => 'EOF',
      0x0C => 'CALCCOUNT',
      0x0D => 'CALCMODE',
      0x0E => 'PRECISION',
      0x0F => 'REFMODE',
      0x10 => 'DELTA',
      0x11 => 'ITERATION',
      0x12 => 'PROTECT',
      0x13 => 'PASSWORD',
      0x14 => 'HEADER',
  
      0x15 => 'FOOTER',
      0x16 => 'EXTERNCOUNT',
      0x17 => 'EXTERNSHEET',
      0x19 => 'WINDOWPROTECT',
      0x1A => 'VERTICALPAGEBREAKS',
      0x1B => 'HORIZONTALPAGEBREAKS',
      0x1C => 'NOTE',
      0x1D => 'SELECTION',
      0x22 => '1904',
      0x26 => 'LEFTMARGIN',
  
      0x27 => 'RIGHTMARGIN',
      0x28 => 'TOPMARGIN',
      0x29 => 'BOTTOMMARGIN',
      0x2A => 'PRINTHEADERS',
      0x2B => 'PRINTGRIDLINES',
      0x2F => 'FILEPASS',
      0x3C => 'COUNTINUE',
      0x3D => 'WINDOW1',
      0x40 => 'BACKUP',
      0x41 => 'PANE',
  
      0x42 => 'CODEPAGE',
      0x4D => 'PLS',
      0x50 => 'DCON',
      0x51 => 'DCONREF',
  
      #P292
      0x52 => 'DCONNAME',
      0x55 => 'DEFCOLWIDTH',
      0x59 => 'XCT',
      0x5A => 'CRN',
      0x5B => 'FILESHARING',
      0x5C => 'WRITEACCES',
      0x5D => 'OBJ',
      0x5E => 'UNCALCED',
      0x5F => 'SAVERECALC',
      0x60 => 'TEMPLATE',
  
      0x63 => 'OBJPROTECT',
      0x7D => 'COLINFO',
      0x7E => 'RK',
      0x7F => 'IMDATA',
      0x80 => 'GUTS',
      0x81 => 'WSBOOL',
      0x82 => 'GRIDSET',
      0x83 => 'HCENTER',
      0x84 => 'VCENTER',
      0x85 => 'BOUNDSHEET',
  
      0x86 => 'WRITEPROT',
      0x87 => 'ADDIN',
      0x88 => 'EDG',
      0x89 => 'PUB',
      0x8C => 'COUNTRY',
      0x8D => 'HIDEOBJ',
      0x90 => 'SORT',
      0x91 => 'SUB',
      0x92 => 'PALETTE',
      0x94 => 'LHRECORD',
  
      0x95 => 'LHNGRAPH',
      0x96 => 'SOUND',
      0x98 => 'LPR',
      0x99 => 'STANDARDWIDTH',
      0x9A => 'FNGROUPNAME',
      0x9B => 'FILTERMODE',
      0x9C => 'FNGROUPCOUNT',
  
      #P293
      0x9D => 'AUTOFILTERINFO',
      0x9E => 'AUTOFILTER',
      0xA0 => 'SCL',
      0xA1 => 'SETUP',
      0xA9 => 'COORDLIST',
      0xAB => 'GCW',
      0xAE => 'SCENMAN',
      0xAF => 'SCENARIO',
      0xB0 => 'SXVIEW',
      0xB1 => 'SXVD',
  
      0xB2 => 'SXV',
      0xB4 => 'SXIVD',
      0xB5 => 'SXLI',
      0xB6 => 'SXPI',
      0xB8 => 'DOCROUTE',
      0xB9 => 'RECIPNAME',
      0xBC => 'SHRFMLA',
      0xBD => 'MULRK',
      0xBE => 'MULBLANK',
      0xBF => 'TOOLBARHDR',
      0xC0 => 'TOOLBAREND',
      0xC1 => 'MMS',
  
      0xC2 => 'ADDMENU',
      0xC3 => 'DELMENU',
      0xC5 => 'SXDI',
      0xC6 => 'SXDB',
      0xCD => 'SXSTRING',
      0xD0 => 'SXTBL',
      0xD1 => 'SXTBRGIITM',
      0xD2 => 'SXTBPG',
      0xD3 => 'OBPROJ',
      0xD5 => 'SXISDTM',
  
      0xD6 => 'RSTRING',
      0xD7 => 'DBCELL',
      0xDA => 'BOOKBOOL',
      0xDC => 'PARAMQRY',
      0xDC => 'SXEXT',
      0xDD => 'SCENPROTECT',
      0xDE => 'OLESIZE',
  
      #P294
      0xDF => 'UDDESC',
      0xE0 => 'XF',
      0xE1 => 'INTERFACEHDR',
      0xE2 => 'INTERFACEEND',
      0xE3 => 'SXVS',
      0xEA => 'TABIDCONF',
      0xEB => 'MSODRAWINGGROUP',
      0xEC => 'MSODRAWING',
      0xED => 'MSODRAWINGSELECTION',
      0xEF => 'PHONETICINFO',
      0xF0 => 'SXRULE',
  
      0xF1 => 'SXEXT',
      0xF2 => 'SXFILT',
      0xF6 => 'SXNAME',
      0xF7 => 'SXSELECT',
      0xF8 => 'SXPAIR',
      0xF9 => 'SXFMLA',
      0xFB => 'SXFORMAT',
      0xFC => 'SST',
      0xFD => 'LABELSST',
      0xFF => 'EXTSST',
  
      0x100 => 'SXVDEX',
      0x103 => 'SXFORMULA',
      0x122 => 'SXDBEX',
      0x13D => 'TABID',
      0x160 => 'USESELFS',
      0x161 => 'DSF',
      0x162 => 'XL5MODIFY',
      0x1A5 => 'FILESHARING2',
      0x1A9 => 'USERBVIEW',
      0x1AA => 'USERVIEWBEGIN',
  
      0x1AB => 'USERSVIEWEND',
      0x1AD => 'QSI',
      0x1AE => 'SUPBOOK',
      0x1AF => 'PROT4REV',
      0x1B0 => 'CONDFMT',
      0x1B1 => 'CF',
      0x1B2 => 'DVAL',
  
      #P295
      0x1B5 => 'DCONBIN',
      0x1B6 => 'TXO',
      0x1B7 => 'REFRESHALL',
      0x1B8 => 'HLINK',
      0x1BA => 'CODENAME',
      0x1BB => 'SXFDBTYPE',
      0x1BC => 'PROT4REVPASS',
      0x1BE => 'DV',
      0x200 => 'DIMENSIONS',
      0x201 => 'BLANK',
  
      0x202 => 'Integer',            #Not Documented
      0x203 => 'NUMBER',
      0x204 => 'LABEL',
      0x205 => 'BOOLERR',
      0x207 => 'STRING',
      0x208 => 'ROW',
      0x20B => 'INDEX',
      0x218 => 'NAME',
      0x221 => 'ARRAY',
      0x223 => 'EXTERNNAME',
      0x225 => 'DEFAULTROWHEIGHT',
  
      0x231 => 'FONT',
      0x236 => 'TABLE',
      0x23E => 'WINDOW2',
      0x293 => 'STYLE',
      0x406 => 'FORMULA',
      0x41E => 'FORMAT',
  
      0x18 => 'NAME',
  
      0x06 => 'FORMULA',
  
      0x09  => 'BOF(BIFF2)',
      0x209 => 'BOF(BIFF3)',
      0x409 => 'BOF(BIFF4)',
      0x809 => 'BOF(BIFF5-7)',
  
      0x31 => 'FONT', 0x27E => 'RK',
  
      #Chart/Graph
      0x1001 => 'UNITS',
      0x1002 => 'CHART',
      0x1003 => 'SERISES',
      0x1006 => 'DATAFORMAT',
      0x1007 => 'LINEFORMAT',
      0x1009 => 'MAKERFORMAT',
      0x100A => 'AREAFORMAT',
      0x100B => 'PIEFORMAT',
      0x100C => 'ATTACHEDLABEL',
      0x100D => 'SERIESTEXT',
      0x1014 => 'CHARTFORMAT',
      0x1015 => 'LEGEND',
      0x1016 => 'SERIESLIST',
      0x1017 => 'BAR',
      0x1018 => 'LINE',
      0x1019 => 'PIE',
      0x101A => 'AREA',
      0x101B => 'SCATTER',
      0x101C => 'CHARTLINE',
      0x101D => 'AXIS',
      0x101E => 'TICK',
      0x101F => 'VALUERANGE',
      0x1020 => 'CATSERRANGE',
      0x1021 => 'AXISLINEFORMAT',
      0x1022 => 'CHARTFORMATLINK',
      0x1024 => 'DEFAULTTEXT',
      0x1025 => 'TEXT',
      0x1026 => 'FONTX',
      0x1027 => 'OBJECTLINK',
      0x1032 => 'FRAME',
      0x1033 => 'BEGIN',
      0x1034 => 'END',
      0x1035 => 'PLOTAREA',
      0x103A => '3D',
      0x103C => 'PICF',
      0x103D => 'DROPBAR',
      0x103E => 'RADAR',
      0x103F => 'SURFACE',
      0x1040 => 'RADARAREA',
      0x1041 => 'AXISPARENT',
      0x1043 => 'LEGENDXN',
      0x1044 => 'SHTPROPS',
      0x1045 => 'SERTOCRT',
      0x1046 => 'AXESUSED',
      0x1048 => 'SBASEREF',
      0x104A => 'SERPARENT',
      0x104B => 'SERAUXTREND',
      0x104E => 'IFMT',
      0x104F => 'POS',
      0x1050 => 'ALRUNS',
      0x1051 => 'AI',
      0x105B => 'SERAUXERRBAR',
      0x105D => 'SERFMT',
      0x1060 => 'FBI',
      0x1061 => 'BOPPOP',
      0x1062 => 'AXCEXT',
      0x1063 => 'DAT',
      0x1064 => 'PLOTGROWTH',
      0x1065 => 'SINDEX',
      0x1066 => 'GELFRAME',
      0x1067 => 'BPOPPOPCUSTOM',
  );
  
  #------------------------------------------------------------------------------
  # subDUMP (for Spreadsheet::ParseExcel)
  #------------------------------------------------------------------------------
  sub subDUMP {
      my ( $oBook, $bOp, $bLen, $sWk ) = @_;
      printf "%04X:%-23s (Len:%3d) : %s\n",
        $bOp, OpName($bOp), $bLen, unpack( "H40", $sWk );
  }
  
  #------------------------------------------------------------------------------
  # Spreadsheet::ParseExcel->OpName
  #------------------------------------------------------------------------------
  sub OpName {
      my ($bOp) = @_;
      return ( defined $NameTbl{$bOp} ) ? $NameTbl{$bOp} : 'undef';
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Dump - A class for dumping Excel records.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
  
SPREADSHEET_PARSEEXCEL_DUMP

$fatpacked{"Spreadsheet/ParseExcel/FmtDefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_FMTDEFAULT';
  package Spreadsheet::ParseExcel::FmtDefault;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtDefault - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Spreadsheet::ParseExcel::Utility qw(ExcelFmt);
  our $VERSION = '0.65';
  
  my %hFmtDefault = (
      0x00 => 'General',
      0x01 => '0',
      0x02 => '0.00',
      0x03 => '#,##0',
      0x04 => '#,##0.00',
      0x05 => '($#,##0_);($#,##0)',
      0x06 => '($#,##0_);[Red]($#,##0)',
      0x07 => '($#,##0.00_);($#,##0.00_)',
      0x08 => '($#,##0.00_);[Red]($#,##0.00_)',
      0x09 => '0%',
      0x0A => '0.00%',
      0x0B => '0.00E+00',
      0x0C => '# ?/?',
      0x0D => '# ??/??',
      0x0E => 'yyyy-mm-dd',      # Was 'm-d-yy', which is bad as system default
      0x0F => 'd-mmm-yy',
      0x10 => 'd-mmm',
      0x11 => 'mmm-yy',
      0x12 => 'h:mm AM/PM',
      0x13 => 'h:mm:ss AM/PM',
      0x14 => 'h:mm',
      0x15 => 'h:mm:ss',
      0x16 => 'm-d-yy h:mm',
  
      #0x17-0x24 -- Differs in Natinal
      0x25 => '(#,##0_);(#,##0)',
      0x26 => '(#,##0_);[Red](#,##0)',
      0x27 => '(#,##0.00);(#,##0.00)',
      0x28 => '(#,##0.00);[Red](#,##0.00)',
      0x29 => '_(*#,##0_);_(*(#,##0);_(*"-"_);_(@_)',
      0x2A => '_($*#,##0_);_($*(#,##0);_(*"-"_);_(@_)',
      0x2B => '_(*#,##0.00_);_(*(#,##0.00);_(*"-"??_);_(@_)',
      0x2C => '_($*#,##0.00_);_($*(#,##0.00);_(*"-"??_);_(@_)',
      0x2D => 'mm:ss',
      0x2E => '[h]:mm:ss',
      0x2F => 'mm:ss.0',
      0x30 => '##0.0E+0',
      0x31 => '@',
  );
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub new {
      my ( $sPkg, %hKey ) = @_;
      my $oThis = {};
      bless $oThis;
      return $oThis;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $oThis, $sTxt, $sCode ) = @_;
      return $sTxt if ( ( !defined($sCode) ) || ( $sCode eq '_native_' ) );
      return pack( 'U*', unpack( 'n*', $sTxt ) );
  }
  
  #------------------------------------------------------------------------------
  # FmtStringDef (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub FmtStringDef {
      my ( $oThis, $iFmtIdx, $oBook, $rhFmt ) = @_;
      my $sFmtStr = $oBook->{FormatStr}->{$iFmtIdx};
  
      if ( !( defined($sFmtStr) ) && defined($rhFmt) ) {
          $sFmtStr = $rhFmt->{$iFmtIdx};
      }
      $sFmtStr = $hFmtDefault{$iFmtIdx} unless ($sFmtStr);
      return $sFmtStr;
  }
  
  #------------------------------------------------------------------------------
  # FmtString (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub FmtString {
      my ( $oThis, $oCell, $oBook ) = @_;
  
      my $sFmtStr =
        $oThis->FmtStringDef( $oBook->{Format}[ $oCell->{FormatNo} ]->{FmtIdx},
          $oBook );
  
      # Special case for cells that use Lotus123 style leading
      # apostrophe to designate text formatting.
      if ( $oBook->{Format}[ $oCell->{FormatNo} ]->{Key123} ) {
          $sFmtStr = '@';
      }
  
      unless ( defined($sFmtStr) ) {
          if ( $oCell->{Type} eq 'Numeric' ) {
              if ( int( $oCell->{Val} ) != $oCell->{Val} ) {
                  $sFmtStr = '0.00';
              }
              else {
                  $sFmtStr = '0';
              }
          }
          elsif ( $oCell->{Type} eq 'Date' ) {
              if ( int( $oCell->{Val} ) <= 0 ) {
                  $sFmtStr = 'h:mm:ss';
              }
              else {
                  $sFmtStr = 'yyyy-mm-dd';
              }
          }
          else {
              $sFmtStr = '@';
          }
      }
      return $sFmtStr;
  }
  
  #------------------------------------------------------------------------------
  # ValFmt (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub ValFmt {
      my ( $oThis, $oCell, $oBook ) = @_;
  
      my ( $Dt, $iFmtIdx, $iNumeric, $Flg1904 );
  
      if ( $oCell->{Type} eq 'Text' ) {
          $Dt =
            ( ( defined $oCell->{Val} ) && ( $oCell->{Val} ne '' ) )
            ? $oThis->TextFmt( $oCell->{Val}, $oCell->{Code} )
            : '';
  
          return $Dt;
      }
      else {
          $Dt      = $oCell->{Val};
          $Flg1904 = $oBook->{Flg1904};
          my $sFmtStr = $oThis->FmtString( $oCell, $oBook );
  
          return ExcelFmt( $sFmtStr, $Dt, $Flg1904, $oCell->{Type} );
      }
  }
  
  #------------------------------------------------------------------------------
  # ChkType (for Spreadsheet::ParseExcel::FmtDefault)
  #------------------------------------------------------------------------------
  sub ChkType {
      my ( $oPkg, $iNumeric, $iFmtIdx ) = @_;
      if ($iNumeric) {
          if (   ( ( $iFmtIdx >= 0x0E ) && ( $iFmtIdx <= 0x16 ) )
              || ( ( $iFmtIdx >= 0x2D ) && ( $iFmtIdx <= 0x2F ) ) )
          {
              return "Date";
          }
          else {
              return "Numeric";
          }
      }
      else {
          return "Text";
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtDefault - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTDEFAULT

$fatpacked{"Spreadsheet/ParseExcel/FmtJapan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_FMTJAPAN';
  package Spreadsheet::ParseExcel::FmtJapan;
  use utf8;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtJapan - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Encode qw(find_encoding decode);
  use base 'Spreadsheet::ParseExcel::FmtDefault';
  our $VERSION = '0.65';
  
  my %FormatTable = (
      0x00 => 'General',
      0x01 => '0',
      0x02 => '0.00',
      0x03 => '#,##0',
      0x04 => '#,##0.00',
      0x05 => '(\\#,##0_);(\\#,##0)',
      0x06 => '(\\#,##0_);[Red](\\#,##0)',
      0x07 => '(\\#,##0.00_);(\\#,##0.00_)',
      0x08 => '(\\#,##0.00_);[Red](\\#,##0.00_)',
      0x09 => '0%',
      0x0A => '0.00%',
      0x0B => '0.00E+00',
      0x0C => '# ?/?',
      0x0D => '# ??/??',
  
      #    0x0E => 'm/d/yy',
      0x0E => 'yyyy/m/d',
      0x0F => 'd-mmm-yy',
      0x10 => 'd-mmm',
      0x11 => 'mmm-yy',
      0x12 => 'h:mm AM/PM',
      0x13 => 'h:mm:ss AM/PM',
      0x14 => 'h:mm',
      0x15 => 'h:mm:ss',
  
      #    0x16 => 'm/d/yy h:mm',
      0x16 => 'yyyy/m/d h:mm',
  
      #0x17-0x24 -- Differs in Natinal
      0x1E => 'm/d/yy',
      0x1F => 'yyyy""m""d""',
      0x20 => 'h""mm""',
      0x21 => 'h""mm""ss""',
  
      #0x17-0x24 -- Differs in Natinal
      0x25 => '(#,##0_);(#,##0)',
      0x26 => '(#,##0_);[Red](#,##0)',
      0x27 => '(#,##0.00);(#,##0.00)',
      0x28 => '(#,##0.00);[Red](#,##0.00)',
      0x29 => '_(*#,##0_);_(*(#,##0);_(*"-"_);_(@_)',
      0x2A => '_(\\*#,##0_);_(\\*(#,##0);_(*"-"_);_(@_)',
      0x2B => '_(*#,##0.00_);_(*(#,##0.00);_(*"-"??_);_(@_)',
      0x2C => '_(\\*#,##0.00_);_(\\*(#,##0.00);_(*"-"??_);_(@_)',
      0x2D => 'mm:ss',
      0x2E => '[h]:mm:ss',
      0x2F => 'mm:ss.0',
      0x30 => '##0.0E+0',
      0x31 => '@',
  
      0x37 => 'yyyy""m""',
      0x38 => 'm""d""',
      0x39 => 'ge.m.d',
      0x3A => 'ggge""m""d""',
  );
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  sub new {
      my ( $class, %args ) = @_;
      my $encoding = $args{Code} || $args{encoding};
      my $self = { Code => $encoding };
      if($encoding){
          $self->{encoding} = find_encoding($encoding eq 'sjis' ? 'cp932' : $encoding)
              or do{
                  require Carp;
                  Carp::croak(qq{Unknown encoding '$encoding'});
              };
      }
      return bless $self, $class;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $self, $text, $input_encoding ) = @_;
      if(!defined $input_encoding){
          $input_encoding = 'utf8';
      }
      elsif($input_encoding eq '_native_'){
          $input_encoding = 'cp932'; # Shift_JIS in Microsoft products
      }
      $text = decode($input_encoding, $text);
      return $self->{Code} ? $self->{encoding}->encode($text) : $text;
  }
  #------------------------------------------------------------------------------
  # FmtStringDef (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  sub FmtStringDef {
      my ( $self, $format_index, $book ) = @_;
      return $self->SUPER::FmtStringDef( $format_index, $book, \%FormatTable );
  }
  
  #------------------------------------------------------------------------------
  # CnvNengo (for Spreadsheet::ParseExcel::FmtJapan)
  #------------------------------------------------------------------------------
  
  # Convert A.D. into Japanese Nengo (aka Gengo)
  
  my @Nengo = (
  	{
  		name      => '', # Heisei
  		abbr_name => 'H',
  
  		base      => 1988,
  		start     => 19890108,
  	},
  	{
  		name      => '', # Showa
  		abbr_name => 'S',
  
  		base      => 1925,
  		start     => 19261225,
  	},
  	{
  		name      => '', # Taisho
  		abbr_name => 'T',
  
  		base      => 1911,
  		start     => 19120730,
  	},
  	{
  		name      => '', # Meiji
  		abbr_name => 'M',
  
  		base      => 1867,
  		start     => 18680908,
  	},
  );
  
  # Usage: CnvNengo(name => @tm) or CnvNeng(abbr_name => @tm)
  sub CnvNengo {
      my ( $kind, @tm ) = @_;
      my $year = $tm[5] + 1900;
      my $wk = ($year * 10000) + ($tm[4] * 100) + ($tm[3] * 1);
      #my $wk = sprintf( '%04d%02d%02d', $year, $tm[4], $tm[3] );
      foreach my $nengo(@Nengo){
          if( $wk >= $nengo->{start} ){
              return $nengo->{$kind} . ($year - $nengo->{base});
          }
      }
      return $year;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtJapan - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTJAPAN

$fatpacked{"Spreadsheet/ParseExcel/FmtJapan2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_FMTJAPAN2';
  package Spreadsheet::ParseExcel::FmtJapan2;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtJapan2 - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Jcode;
  use Unicode::Map;
  use base 'Spreadsheet::ParseExcel::FmtJapan';
  our $VERSION = '0.65';
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtJapan2)
  #------------------------------------------------------------------------------
  sub new {
      my ( $sPkg, %hKey ) = @_;
      my $oMap = Unicode::Map->new('CP932Excel');
      die "NO MAP FILE CP932Excel!!"
        unless ( -r Unicode::Map->mapping("CP932Excel") );
  
      my $oThis = {
          Code    => $hKey{Code},
          _UniMap => $oMap,
      };
      bless $oThis;
      $oThis->SUPER::new(%hKey);
      return $oThis;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtJapan2)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $oThis, $sTxt, $sCode ) = @_;
  
      #    $sCode = 'sjis' if((! defined($sCode)) || ($sCode eq '_native_'));
      if ( $oThis->{Code} ) {
          if ( !defined($sCode) ) {
              $sTxt =~ s/(.)/\x00$1/sg;
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
          }
          elsif ( $sCode eq 'ucs2' ) {
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
          }
          return Jcode::convert( $sTxt, $oThis->{Code}, 'sjis' );
      }
      else {
          return $sTxt;
      }
  }
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtJapan2 - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTJAPAN2

$fatpacked{"Spreadsheet/ParseExcel/FmtUnicode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_FMTUNICODE';
  package Spreadsheet::ParseExcel::FmtUnicode;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::FmtUnicode - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Unicode::Map;
  use base 'Spreadsheet::ParseExcel::FmtDefault';
  
  our $VERSION = '0.65';
  
  #------------------------------------------------------------------------------
  # new (for Spreadsheet::ParseExcel::FmtUnicode)
  #------------------------------------------------------------------------------
  sub new {
      my ( $sPkg, %hKey ) = @_;
      my $sMap = $hKey{Unicode_Map};
      my $oMap;
      $oMap = Unicode::Map->new($sMap) if $sMap;
      my $oThis = {
          Unicode_Map => $sMap,
          _UniMap     => $oMap,
      };
      bless $oThis;
      return $oThis;
  }
  
  #------------------------------------------------------------------------------
  # TextFmt (for Spreadsheet::ParseExcel::FmtUnicode)
  #------------------------------------------------------------------------------
  sub TextFmt {
      my ( $oThis, $sTxt, $sCode ) = @_;
      if ( $oThis->{_UniMap} ) {
          if ( !defined($sCode) ) {
              my $sSv = $sTxt;
              $sTxt =~ s/(.)/\x00$1/sg;
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
              $sTxt = $sSv unless ($sTxt);
          }
          elsif ( $sCode eq 'ucs2' ) {
              $sTxt = $oThis->{_UniMap}->from_unicode($sTxt);
          }
  
          #        $sTxt = $oThis->{_UniMap}->from_unicode($sTxt)
          #                     if(defined($sCode) && $sCode eq 'ucs2');
          return $sTxt;
      }
      else {
          return $sTxt;
      }
  }
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::FmtUnicode - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FMTUNICODE

$fatpacked{"Spreadsheet/ParseExcel/Font.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_FONT';
  package Spreadsheet::ParseExcel::Font;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Font - A class for Cell fonts.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.65';
  
  sub new {
      my ( $class, %rhIni ) = @_;
      my $self = \%rhIni;
  
      bless $self, $class;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Font - A class for Cell fonts.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
  
SPREADSHEET_PARSEEXCEL_FONT

$fatpacked{"Spreadsheet/ParseExcel/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_FORMAT';
  package Spreadsheet::ParseExcel::Format;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Format - A class for Cell formats.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.65';
  
  sub new {
      my ( $class, %rhIni ) = @_;
      my $self = \%rhIni;
  
      bless $self, $class;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Format - A class for Cell formats.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_FORMAT

$fatpacked{"Spreadsheet/ParseExcel/SaveParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_SAVEPARSER';
  package Spreadsheet::ParseExcel::SaveParser;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::SaveParser - Rewrite an existing Excel file.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use Spreadsheet::ParseExcel;
  use Spreadsheet::ParseExcel::SaveParser::Workbook;
  use Spreadsheet::ParseExcel::SaveParser::Worksheet;
  use Spreadsheet::WriteExcel;
  use base 'Spreadsheet::ParseExcel';
  
  our $VERSION = '0.65';
  
  ###############################################################################
  #
  # new()
  #
  sub new {
  
      my ( $package, %params ) = @_;
      $package->SUPER::new(%params);
  }
  
  ###############################################################################
  #
  # Create()
  #
  sub Create {
  
      my ( $self, $formatter ) = @_;
  
      #0. New $workbook
      my $workbook = Spreadsheet::ParseExcel::Workbook->new();
      $workbook->{SheetCount} = 0;
  
      # User specified formatter class.
      if ($formatter) {
          $workbook->{FmtClass} = $formatter;
      }
      else {
          $workbook->{FmtClass} = Spreadsheet::ParseExcel::FmtDefault->new();
      }
  
      return Spreadsheet::ParseExcel::SaveParser::Workbook->new($workbook);
  }
  
  ###############################################################################
  #
  # Parse()
  #
  sub Parse {
  
      my ( $self, $sFile, $formatter ) = @_;
  
      my $workbook = $self->SUPER::Parse( $sFile, $formatter );
  
      return undef unless defined $workbook;
      return Spreadsheet::ParseExcel::SaveParser::Workbook->new($workbook);
  }
  
  ###############################################################################
  #
  # SaveAs()
  #
  sub SaveAs {
  
      my ( $self, $workbook, $filename ) = @_;
  
      $workbook->SaveAs($filename);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::SaveParser - Rewrite an existing Excel file.
  
  =head1 SYNOPSIS
  
  
  
  Say we start with an Excel file that looks like this:
  
      -----------------------------------------------------
     |   |      A      |      B      |      C      |
      -----------------------------------------------------
     | 1 | Hello       | ...         | ...         |  ...
     | 2 | World       | ...         | ...         |  ...
     | 3 | *Bold text* | ...         | ...         |  ...
     | 4 | ...         | ...         | ...         |  ...
     | 5 | ...         | ...         | ...         |  ...
  
  
  Then we process it with the following program:
  
      #!/usr/bin/perl
  
      use strict;
      use warnings;
  
      use Spreadsheet::ParseExcel;
      use Spreadsheet::ParseExcel::SaveParser;
  
  
      # Open an existing file with SaveParser
      my $parser   = Spreadsheet::ParseExcel::SaveParser->new();
      my $template = $parser->Parse('template.xls');
  
  
      # Get the first worksheet.
      my $worksheet = $template->worksheet(0);
      my $row  = 0;
      my $col  = 0;
  
  
      # Overwrite the string in cell A1
      $worksheet->AddCell( $row, $col, 'New string' );
  
  
      # Add a new string in cell B1
      $worksheet->AddCell( $row, $col + 1, 'Newer' );
  
  
      # Add a new string in cell C1 with the format from cell A3.
      my $cell = $worksheet->get_cell( $row + 2, $col );
      my $format_number = $cell->{FormatNo};
  
      $worksheet->AddCell( $row, $col + 2, 'Newest', $format_number );
  
  
      # Write over the existing file or write a new file.
      $template->SaveAs('newfile.xls');
  
  
  We should now have an Excel file that looks like this:
  
      -----------------------------------------------------
     |   |      A      |      B      |      C      |
      -----------------------------------------------------
     | 1 | New string  | Newer       | *Newest*    |  ...
     | 2 | World       | ...         | ...         |  ...
     | 3 | *Bold text* | ...         | ...         |  ...
     | 4 | ...         | ...         | ...         |  ...
     | 5 | ...         | ...         | ...         |  ...
  
  
  
  =head1 DESCRIPTION
  
  The C<Spreadsheet::ParseExcel::SaveParser> module rewrite an existing Excel file by reading it with C<Spreadsheet::ParseExcel> and rewriting it with C<Spreadsheet::WriteExcel>.
  
  =head1 METHODS
  
  =head1 Parser
  
  =head2 new()
  
      $parse = new Spreadsheet::ParseExcel::SaveParser();
  
  Constructor.
  
  =head2 Parse()
  
      $workbook = $parse->Parse($sFileName);
  
      $workbook = $parse->Parse($sFileName , $formatter);
  
  Returns a L</Workbook> object. If an error occurs, returns undef.
  
  The optional C<$formatter> is a Formatter Class to format the value of cells.
  
  
  =head1 Workbook
  
  The C<Parse()> method returns a C<Spreadsheet::ParseExcel::SaveParser::Workbook> object.
  
  This is a subclass of the L<Spreadsheet::ParseExcel::Workbook> and has the following methods:
  
  =head2 worksheets()
  
  Returns an array of L</Worksheet> objects. This was most commonly used to iterate over the worksheets in a workbook:
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
  =head2 worksheet()
  
  The C<worksheet()> method returns a single C<Worksheet> object using either its name or index:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  Returns C<undef> if the sheet name or index doesn't exist.
  
  
  =head2 AddWorksheet()
  
      $workbook = $workbook->AddWorksheet($name, %properties);
  
  Create a new Worksheet object of type C<Spreadsheet::ParseExcel::Worksheet>.
  
  The C<%properties> hash contains the properties of new Worksheet.
  
  
  =head2 AddFont
  
      $workbook = $workbook->AddFont(%properties);
  
  Create new Font object of type C<Spreadsheet::ParseExcel::Font>.
  
  The C<%properties> hash contains the properties of new Font.
  
  
  =head2 AddFormat
  
      $workbook = $workbook->AddFormat(%properties);
  
  The C<%properties> hash contains the properties of new Font.
  
  
  =head1 Worksheet
  
  Spreadsheet::ParseExcel::SaveParser::Worksheet
  
  Worksheet is a subclass of Spreadsheet::ParseExcel::Worksheet.
  And has these methods :
  
  
  The C<Worksbook::worksheet()> method returns a C<Spreadsheet::ParseExcel::SaveParser::Worksheet> object.
  
  This is a subclass of the L<Spreadsheet::ParseExcel::Worksheet> and has the following methods:
  
  
  =head1 AddCell
  
      $workbook = $worksheet->AddCell($row, $col, $value, $format [$encoding]);
  
  Create new Cell object of type C<Spreadsheet::ParseExcel::Cell>.
  
  The C<$format> parameter is the format number rather than a full format object.
  
  To specify just same as another cell,
  you can set it like below:
  
      $row            = 0;
      $col            = 0;
      $worksheet      = $template->worksheet(0);
      $cell           = $worksheet->get_cell( $row, $col );
      $format_number  = $cell->{FormatNo};
  
      $worksheet->AddCell($row +1, $coll, 'New data', $format_number);
  
  
  
  
  =head1 TODO
  
  Please note that this module is currently (versions 0.50-0.60) undergoing a major
  restructuring and rewriting.
  
  =head1 Known Problems
  
  
  You can only rewrite the features that Spreadsheet::WriteExcel supports so
  macros, graphs and some other features in the original Excel file will be lost.
  Also, formulas aren't rewritten, only the result of a formula is written.
  
  Only last print area will remain. (Others will be removed)
  
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2002 Kawai Takanori and Nippon-RAD Co. OP Division
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  
  =cut
SPREADSHEET_PARSEEXCEL_SAVEPARSER

$fatpacked{"Spreadsheet/ParseExcel/SaveParser/Workbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKBOOK';
  package Spreadsheet::ParseExcel::SaveParser::Workbook;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::SaveParser::Workbook - A class for SaveParser Workbooks.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  use base 'Spreadsheet::ParseExcel::Workbook';
  our $VERSION = '0.65';
  
  #==============================================================================
  # Spreadsheet::ParseExcel::SaveParser::Workbook
  #==============================================================================
  
  sub new {
      my ( $sPkg, $oBook ) = @_;
      return undef unless ( defined $oBook );
      my %oThis = %$oBook;
      bless \%oThis, $sPkg;
  
      # re-bless worksheets (and set their _Book properties !!!)
      my $sWkP = ref($sPkg) || "$sPkg";
      $sWkP =~ s/Workbook$/Worksheet/;
      map { bless( $_, $sWkP ); } @{ $oThis{Worksheet} };
      map { $_->{_Book} = \%oThis; } @{ $oThis{Worksheet} };
      return \%oThis;
  }
  
  #------------------------------------------------------------------------------
  # Parse (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub Parse {
      my ( $sClass, $sFile, $oWkFmt ) = @_;
      my $oBook = Spreadsheet::ParseExcel::Workbook->Parse( $sFile, $oWkFmt );
      bless $oBook, $sClass;
  
      # re-bless worksheets (and set their _Book properties !!!)
      my $sWkP = ref($sClass) || "$sClass";
      $sWkP =~ s/Workbook$/Worksheet/;
      map { bless( $_, $sWkP ); } @{ $oBook->{Worksheet} };
      map { $_->{_Book} = $oBook; } @{ $oBook->{Worksheet} };
      return $oBook;
  }
  
  #------------------------------------------------------------------------------
  # SaveAs (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub SaveAs {
      my ( $oBook, $sName ) = @_;
  
      # Create a new Excel workbook
      my $oWrEx = Spreadsheet::WriteExcel->new($sName);
      $oWrEx->compatibility_mode();
      my %hFmt;
  
      my $iNo  = 0;
      my @aAlH = (
          'left', 'left',    'center', 'right',
          'fill', 'justify', 'merge',  'equal_space'
      );
      my @aAlV = ( 'top', 'vcenter', 'bottom', 'vjustify', 'vequal_space' );
  
      foreach my $pFmt ( @{ $oBook->{Format} } ) {
          my $oFmt = $oWrEx->addformat();    # Add Formats
          unless ( $pFmt->{Style} ) {
              $hFmt{$iNo} = $oFmt;
              my $rFont = $pFmt->{Font};
  
              $oFmt->set_font( $rFont->{Name} );
              $oFmt->set_size( $rFont->{Height} );
              $oFmt->set_color( $rFont->{Color} );
              $oFmt->set_bold( $rFont->{Bold} );
              $oFmt->set_italic( $rFont->{Italic} );
              $oFmt->set_underline( $rFont->{Underline} );
              $oFmt->set_font_strikeout( $rFont->{Strikeout} );
              $oFmt->set_font_script( $rFont->{Super} );
  
              $oFmt->set_hidden( $rFont->{Hidden} );    #Add
  
              $oFmt->set_locked( $pFmt->{Lock} );
  
              $oFmt->set_align( $aAlH[ $pFmt->{AlignH} ] );
              $oFmt->set_align( $aAlV[ $pFmt->{AlignV} ] );
  
              $oFmt->set_rotation( $pFmt->{Rotate} );
  
              $oFmt->set_num_format(
                  $oBook->{FmtClass}->FmtStringDef( $pFmt->{FmtIdx}, $oBook ) );
  
              $oFmt->set_text_wrap( $pFmt->{Wrap} );
  
              $oFmt->set_pattern( $pFmt->{Fill}->[0] );
              $oFmt->set_fg_color( $pFmt->{Fill}->[1] )
                if ( ( $pFmt->{Fill}->[1] >= 8 )
                  && ( $pFmt->{Fill}->[1] <= 63 ) );
              $oFmt->set_bg_color( $pFmt->{Fill}->[2] )
                if ( ( $pFmt->{Fill}->[2] >= 8 )
                  && ( $pFmt->{Fill}->[2] <= 63 ) );
  
              $oFmt->set_left(
                  ( $pFmt->{BdrStyle}->[0] > 7 ) ? 3 : $pFmt->{BdrStyle}->[0] );
              $oFmt->set_right(
                  ( $pFmt->{BdrStyle}->[1] > 7 ) ? 3 : $pFmt->{BdrStyle}->[1] );
              $oFmt->set_top(
                  ( $pFmt->{BdrStyle}->[2] > 7 ) ? 3 : $pFmt->{BdrStyle}->[2] );
              $oFmt->set_bottom(
                  ( $pFmt->{BdrStyle}->[3] > 7 ) ? 3 : $pFmt->{BdrStyle}->[3] );
  
              $oFmt->set_left_color( $pFmt->{BdrColor}->[0] )
                if ( ( $pFmt->{BdrColor}->[0] >= 8 )
                  && ( $pFmt->{BdrColor}->[0] <= 63 ) );
              $oFmt->set_right_color( $pFmt->{BdrColor}->[1] )
                if ( ( $pFmt->{BdrColor}->[1] >= 8 )
                  && ( $pFmt->{BdrColor}->[1] <= 63 ) );
              $oFmt->set_top_color( $pFmt->{BdrColor}->[2] )
                if ( ( $pFmt->{BdrColor}->[2] >= 8 )
                  && ( $pFmt->{BdrColor}->[2] <= 63 ) );
              $oFmt->set_bottom_color( $pFmt->{BdrColor}->[3] )
                if ( ( $pFmt->{BdrColor}->[3] >= 8 )
                  && ( $pFmt->{BdrColor}->[3] <= 63 ) );
          }
          $iNo++;
      }
      for ( my $iSheet = 0 ; $iSheet < $oBook->{SheetCount} ; $iSheet++ ) {
          my $oWkS = $oBook->{Worksheet}[$iSheet];
          my $oWrS = $oWrEx->addworksheet( $oWkS->{Name} );
  
          #Landscape
          if ( !$oWkS->{Landscape} ) {    # Landscape (0:Horizontal, 1:Vertical)
              $oWrS->set_landscape();
          }
          else {
              $oWrS->set_portrait();
          }
  
          #Protect
          if ( defined $oWkS->{Protect} )
          {    # Protect ('':NoPassword, Password:Password)
              if ( $oWkS->{Protect} ne '' ) {
                  $oWrS->protect( $oWkS->{Protect} );
              }
              else {
                  $oWrS->protect();
              }
          }
          if ( $oWkS->{Scale} != 100 ) {
  
              # Pages on fit with width and Heigt
              $oWrS->fit_to_pages( $oWkS->{FitWidth}, $oWkS->{FitHeight} );
  
              #Print Scale and reset FitWidth/FitHeight
              $oWrS->set_print_scale( $oWkS->{Scale} );
          }
          else {
  
              #Print Scale
              $oWrS->set_print_scale( $oWkS->{Scale} );
  
              # Pages on fit with width and Heigt
              $oWrS->fit_to_pages( $oWkS->{FitWidth}, $oWkS->{FitHeight} );
          }
  
          # Paper Size
          $oWrS->set_paper( $oWkS->{PaperSize} );
  
          # Margin
          $oWrS->set_margin_left( $oWkS->{LeftMargin} );
          $oWrS->set_margin_right( $oWkS->{RightMargin} );
          $oWrS->set_margin_top( $oWkS->{TopMargin} );
          $oWrS->set_margin_bottom( $oWkS->{BottomMargin} );
  
          # HCenter
          $oWrS->center_horizontally() if ( $oWkS->{HCenter} );
  
          # VCenter
          $oWrS->center_vertically() if ( $oWkS->{VCenter} );
  
          # Header, Footer
          $oWrS->set_header( $oWkS->{Header}, $oWkS->{HeaderMargin} );
          $oWrS->set_footer( $oWkS->{Footer}, $oWkS->{FooterMargin} );
  
          # Print Area
          if ( ref( $oBook->{PrintArea}[$iSheet] ) eq 'ARRAY' ) {
              my $raP;
              for $raP ( @{ $oBook->{PrintArea}[$iSheet] } ) {
                  $oWrS->print_area(@$raP);
              }
          }
  
          # Print Title
          my $raW;
          foreach $raW ( @{ $oBook->{PrintTitle}[$iSheet]->{Row} } ) {
              $oWrS->repeat_rows(@$raW);
          }
          foreach $raW ( @{ $oBook->{PrintTitle}[$iSheet]->{Column} } ) {
              $oWrS->repeat_columns(@$raW);
          }
  
          # Print Gridlines
          if ( $oWkS->{PrintGrid} == 1 ) {
              $oWrS->hide_gridlines(0);
          }
          else {
              $oWrS->hide_gridlines(1);
          }
  
          # Print Headings
          if ( $oWkS->{PrintHeaders} ) {
              $oWrS->print_row_col_headers();
          }
  
          # Horizontal Page Breaks
          $oWrS->set_h_pagebreaks( @{ $oWkS->{HPageBreak} } );
  
          # Veritical Page Breaks
          $oWrS->set_v_pagebreaks( @{ $oWkS->{VPageBreak} } );
  
  
  
  #        PageStart    => $oWkS->{PageStart},            # Page number for start
  #        UsePage      => $oWkS->{UsePage},              # Use own start page number
  #        NoColor      => $oWkS->{NoColor},               # Print in black-white
  #        Draft        => $oWkS->{Draft},                 # Print in draft mode
  #        Notes        => $oWkS->{Notes},                 # Print notes
  #        LeftToRight  => $oWkS->{LeftToRight},           # Left to Right
  
  
          for (
              my $iC = $oWkS->{MinCol} ;
              defined $oWkS->{MaxCol} && $iC <= $oWkS->{MaxCol} ;
              $iC++
            )
          {
              if ( defined $oWkS->{ColWidth}[$iC] ) {
                  if ( $oWkS->{ColWidth}[$iC] > 0 ) {
                      $oWrS->set_column( $iC, $iC, $oWkS->{ColWidth}[$iC] )
                        ;    #, undef, 1) ;
                  }
                  else {
                      $oWrS->set_column( $iC, $iC, 0, undef, 1 );
                  }
              }
          }
          
  		my $merged_areas = $oWkS->get_merged_areas();
  		my $merged_areas_h = {};
  		if ($merged_areas) {
  			foreach my $range (@$merged_areas) {
  				$merged_areas_h->{$range->[0]}{$range->[1]} = $range;
  			}
  		}
  		
  		for (
              my $iR = $oWkS->{MinRow} ;
              defined $oWkS->{MaxRow} && $iR <= $oWkS->{MaxRow} ;
              $iR++
            )
          {
              $oWrS->set_row( $iR, $oWkS->{RowHeight}[$iR] );
              for (
                  my $iC = $oWkS->{MinCol} ;
                  defined $oWkS->{MaxCol} && $iC <= $oWkS->{MaxCol} ;
                  $iC++
                )
              {
  
                  my $oWkC = $oWkS->{Cells}[$iR][$iC];
                  if ($oWkC) {
                      if ( $oWkC->{Merged} and exists $merged_areas_h->{$iR}{$iC} ) {
                          my $oFmtN = $oWrEx->addformat();
                          $oFmtN->copy( $hFmt{ $oWkC->{FormatNo} } );
  						$oWrS->merge_range (
  							@{$merged_areas_h->{$iR}{$iC}},
                              $oBook->{FmtClass}
                                ->TextFmt( $oWkC->{Val}, $oWkC->{Code} ),
                              $oFmtN
                          );
                      }
                      else {
                          $oWrS->write(
                              $iR,
                              $iC,
                              $oBook->{FmtClass}
                                ->TextFmt( $oWkC->{Val}, $oWkC->{Code} ),
                              $hFmt{ $oWkC->{FormatNo} }
                          );
                      }
                  }
              }
          }
      }
      return $oWrEx;
  }
  
  #------------------------------------------------------------------------------
  # AddWorksheet (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddWorksheet {
      my ( $oBook, $sName, %hAttr ) = @_;
      $oBook->AddFormat if ( $#{ $oBook->{Format} } < 0 );
      $hAttr{Name}         ||= $sName;
      $hAttr{LeftMargin}   ||= 0;
      $hAttr{RightMargin}  ||= 0;
      $hAttr{TopMargin}    ||= 0;
      $hAttr{BottomMargin} ||= 0;
      $hAttr{HeaderMargin} ||= 0;
      $hAttr{FooterMargin} ||= 0;
      $hAttr{FitWidth}     ||= 0;
      $hAttr{FitHeight}    ||= 0;
      $hAttr{PrintGrid}    ||= 0;
      my $oWkS = Spreadsheet::ParseExcel::SaveParser::Worksheet->new(%hAttr);
      $oWkS->{_Book}                              = $oBook;
      $oWkS->{_SheetNo}                           = $oBook->{SheetCount};
      $oBook->{Worksheet}[ $oBook->{SheetCount} ] = $oWkS;
      $oBook->{SheetCount}++;
      return $oWkS;    #$oBook->{SheetCount} - 1;
  }
  
  #------------------------------------------------------------------------------
  # AddFont (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddFont {
      my ( $oBook, %hAttr ) = @_;
      $hAttr{Name}      ||= 'Arial';
      $hAttr{Height}    ||= 10;
      $hAttr{Bold}      ||= 0;
      $hAttr{Italic}    ||= 0;
      $hAttr{Underline} ||= 0;
      $hAttr{Strikeout} ||= 0;
      $hAttr{Super}     ||= 0;
      push @{ $oBook->{Font} }, Spreadsheet::ParseExcel::Font->new(%hAttr);
      return $#{ $oBook->{Font} };
  }
  
  #------------------------------------------------------------------------------
  # AddFormat (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddFormat {
      my ( $oBook, %hAttr ) = @_;
      $hAttr{Fill}     ||= [ 0, 0, 0 ];
      $hAttr{BdrStyle} ||= [ 0, 0, 0, 0 ];
      $hAttr{BdrColor} ||= [ 0, 0, 0, 0 ];
      $hAttr{AlignH}    ||= 0;
      $hAttr{AlignV}    ||= 0;
      $hAttr{Rotate}    ||= 0;
      $hAttr{Landscape} ||= 0;
      $hAttr{FmtIdx}    ||= 0;
  
      if ( !defined( $hAttr{Font} ) ) {
          my $oFont;
          if ( defined $hAttr{FontNo} ) {
              $oFont = $oBook->{Font}[ $hAttr{FontNo} ];
          }
          elsif ( !defined $oFont ) {
              if ( $#{ $oBook->{Font} } >= 0 ) {
                  $oFont = $oBook->{Font}[0];
              }
              else {
                  my $iNo = $oBook->AddFont;
                  $oFont = $oBook->{Font}[$iNo];
              }
          }
          $hAttr{Font} = $oFont;
      }
      push @{ $oBook->{Format} }, Spreadsheet::ParseExcel::Format->new(%hAttr);
      return $#{ $oBook->{Format} };
  }
  
  #------------------------------------------------------------------------------
  # AddCell (for Spreadsheet::ParseExcel::SaveParser::Workbook)
  #------------------------------------------------------------------------------
  sub AddCell {
      my ( $oBook, $iSheet, $iR, $iC, $sVal, $oCell, $sCode ) = @_;
      my %rhKey;
      $oCell ||= $oBook->{Worksheet}[$iSheet]
  		->{Cells}[$iR][$iC]->{FormatNo} || 0;
      my $iFmt =
        ( UNIVERSAL::isa( $oCell, 'Spreadsheet::ParseExcel::Cell' ) )
        ? $oCell->{FormatNo}
        : ( ref($oCell) ) ? 0
        :                   $oCell + 0;
      $rhKey{FormatNo}    = $iFmt;
      $rhKey{Format}      = $oBook->{Format}[$iFmt];
      $rhKey{Val}         = $sVal;
      $rhKey{Code}        = $sCode || '_native_';
      $oBook->{_CurSheet} = $iSheet;
  
  	my $merged_areas = $oBook->{Worksheet}[$iSheet]->get_merged_areas();
  	my $merged_areas_h = {};
  	if ($merged_areas) {
  		foreach my $range (@$merged_areas) {
  			$merged_areas_h->{$range->[0]}{$range->[1]} = $range;
  		}
  	}
  
      my $oNewCell =
        Spreadsheet::ParseExcel::_NewCell( $oBook, $iR, $iC, %rhKey );
      Spreadsheet::ParseExcel::_SetDimension( $oBook, $iR, $iC, $iC );
  
  	$oNewCell->{Merged} = 1
  		if exists $merged_areas_h->{$iR}{$iC};
  
      return $oNewCell;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::SaveParser::Workbook - A class for SaveParser Workbooks.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKBOOK

$fatpacked{"Spreadsheet/ParseExcel/SaveParser/Worksheet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKSHEET';
  package Spreadsheet::ParseExcel::SaveParser::Worksheet;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::SaveParser::Worksheet - A class for SaveParser Worksheets.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  #==============================================================================
  # Spreadsheet::ParseExcel::SaveParser::Worksheet
  #==============================================================================
  
  use base 'Spreadsheet::ParseExcel::Worksheet';
  our $VERSION = '0.65';
  
  sub new {
      my ( $sClass, %rhIni ) = @_;
      $sClass->SUPER::new(%rhIni);    # returns object
  }
  
  #------------------------------------------------------------------------------
  # AddCell (for Spreadsheet::ParseExcel::SaveParser::Worksheet)
  #------------------------------------------------------------------------------
  sub AddCell {
      my ( $oSelf, $iR, $iC, $sVal, $oCell, $sCode ) = @_;
      
  	$oSelf->{_Book}
        ->AddCell( $oSelf->{_SheetNo}, $iR, $iC, $sVal, $oCell, $sCode );
  }
  
  #------------------------------------------------------------------------------
  # Protect (for Spreadsheet::ParseExcel::SaveParser::Worksheet)
  #  - Password = undef   ->  No protect
  #  - Password = ''      ->  Protected. No password
  #  - Password = $pwd    ->  Protected. Password = $pwd
  #------------------------------------------------------------------------------
  sub Protect {
      my ( $oSelf, $sPassword ) = @_;
      $oSelf->{Protect} = $sPassword;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::SaveParser::Worksheet - A class for SaveParser Worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_SAVEPARSER_WORKSHEET

$fatpacked{"Spreadsheet/ParseExcel/Utility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_UTILITY';
  package Spreadsheet::ParseExcel::Utility;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Utility - Utility functions for ParseExcel.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  require Exporter;
  use vars qw(@ISA @EXPORT_OK);
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(ExcelFmt LocaltimeExcel ExcelLocaltime
    col2int int2col sheetRef xls2csv);
  
  our $VERSION = '0.65';
  
  my $qrNUMBER = qr/(^[+-]?\d+(\.\d+)?$)|(^[+-]?\d+\.?(\d*)[eE][+-](\d+))$/;
  
  ###############################################################################
  #
  # ExcelFmt()
  #
  # This function takes an Excel style number format and converts a number into
  # that format. for example: 'hh:mm:ss AM/PM' + 0.01023148 = '12:14:44 AM'.
  #
  # It does this with a type of templating mechanism. The format string is parsed
  # to identify tokens that need to be replaced and their position within the
  # string is recorded. These can be thought of as placeholders. The number is
  # then converted to the required formats and substituted into the placeholders.
  #
  # Interested parties should refer to the Excel documentation on cell formats for
  # more information: http://office.microsoft.com/en-us/excel/HP051995001033.aspx
  # The Microsoft documentation for the Excel Binary File Format, [MS-XLS].pdf,
  # also contains a ABNF grammar for number format strings.
  #
  # Maintainers notes:
  # ==================
  #
  # Note on format subsections:
  # A format string can contain 4 possible sub-sections separated by semi-colons:
  # Positive numbers, negative numbers, zero values, and text.
  # For example: _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
  #
  # Note on conditional formats.
  # A number format in Excel can have a conditional expression such as:
  #     [>9999999](000)000-0000;000-0000
  # This is equivalent to the following in Perl:
  #     $format = $number > 9999999 ? '(000)000-0000' : '000-0000';
  # Nested conditionals are also possible but we don't support them.
  #
  # Efficiency: The excessive use of substr() isn't very efficient. However,
  # it probably doesn't merit rewriting this function with a parser or regular
  # expressions and \G.
  #
  # TODO: I think the single quote handling may not be required. Check.
  #
  sub ExcelFmt {
  
      my ( $format_str, $number, $is_1904, $number_type, $want_subformats ) = @_;
  
      # Return text strings without further formatting.
      return $number unless $number =~ $qrNUMBER;
  
      # Handle OpenOffice.org GENERAL format.
      $format_str = '@' if uc($format_str) eq "GENERAL";
  
      # Check for a conditional at the start of the format. See notes above.
      my $conditional;
      if ( $format_str =~ /^\[([<>=][^\]]+)\](.*)$/ ) {
          $conditional = $1;
          $format_str  = $2;
      }
  
      # Ignore the underscore token which is used to indicate a padding space.
      $format_str =~ s/_/ /g;
  
      # Split the format string into 4 possible sub-sections: positive numbers,
      # negative numbers, zero values, and text. See notes above.
      my @formats;
      my $section      = 0;
      my $double_quote = 0;
      my $single_quote = 0;
  
      # Initial parsing of the format string to remove escape characters. This
      # also handles quoted strings. See note about single quotes above.
    CHARACTER:
      for my $char ( split //, $format_str ) {
  
          if ( $double_quote or $single_quote ) {
              $formats[$section] .= $char;
              $double_quote = 0 if $char eq '"';
              $single_quote = 0;
              next CHARACTER;
          }
  
          if ( $char eq ';' ) {
              $section++;
              next CHARACTER;
          }
          elsif ( $char eq '"' ) {
              $double_quote = 1;
          }
          elsif ( $char eq '!' ) {
              $single_quote = 1;
          }
          elsif ( $char eq '\\' ) {
              $single_quote = 1;
          }
          elsif ( $char eq '(' ) {
              next CHARACTER;    # Ignore.
          }
          elsif ( $char eq ')' ) {
              next CHARACTER;    # Ignore.
          }
  
          # Convert upper case OpenOffice.org date/time formats to lowercase..
          $char = lc($char) if $char =~ /[DMYHS]/;
  
          $formats[$section] .= $char;
      }
  
      # Select the appropriate format from the 4 possible sub-sections:
      # positive numbers, negative numbers, zero values, and text.
      # We ignore the Text section since non-numeric values are returned
      # unformatted at the start of the function.
      my $format;
      $section = 0;
  
      if ( @formats == 1 ) {
          $section = 0;
      }
      elsif ( @formats == 2 ) {
          if ( $number < 0 ) {
              $section = 1;
          }
          else {
              $section = 0;
          }
      }
      elsif ( @formats == 3 ) {
          if ( $number == 0 ) {
              $section = 2;
          }
          elsif ( $number < 0 ) {
              $section = 1;
          }
          else {
              $section = 0;
          }
      }
      else {
          $section = 0;
      }
  
      # Override the previous choice if the format is conditional.
      if ($conditional) {
  
          # TODO. Replace string eval with a function.
          $section = eval "$number $conditional" ? 0 : 1;
      }
  
      # We now have the required format.
      $format = $formats[$section];
  
      # The format string can contain one of the following colours:
      # [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]
      # or the string [ColorX] where x is a colour index from 1 to 56.
      # We don't use the colour but we return it to the caller.
      #
      my $color = '';
      if ( $format =~ s/^(\[[A-Za-z]{3,}(\d{1,2})?\])// ) {
          $color = $1;
      }
  
      # Remove the locale, such as [$-409], from the format string.
      my $locale = '';
      if ( $format =~ s/^(\[\$?-F?\d+\])// ) {
          $locale = $1;
      }
  
      # Replace currency locale, such as [$$-409], with $ in the format string.
      # See the RT#60547 test cases in 21_number_format_user.t.
      if ( $format =~ s/(\[\$([^-]+)(-\d+)?\])/$2/s ) {
          $locale = $1;
      }
  
  
      # Remove leading # from '# ?/?', '# ??/??' fraction formats.
      $format =~ s{# \?}{?}g;
  
      # Parse the format string and create an AoA of placeholders that contain
      # the parts of the string to be replaced. The format of the information
      # stored is: [ $token, $start_pos, $end_pos, $option_info ].
      #
      my $format_mode  = '';    # Either: '', 'number', 'date'
      my $pos          = 0;     # Character position within format string.
      my @placeholders = ();    # Arefs with parts of the format to be replaced.
      my $token        = '';    # The actual format extracted from the total str.
      my $start_pos;            # A position variable. Initial parser position.
      my $token_start = -1;     # A position variable.
      my $decimal_pos = -1;     # Position of the punctuation char "." or ",".
      my $comma_count = 0;      # Count of the commas in the format.
      my $is_fraction = 0;      # Number format is a fraction.
      my $is_currency = 0;      # Number format is a currency.
      my $is_percent  = 0;      # Number format is a percentage.
      my $is_12_hour  = 0;      # Time format is using 12 hour clock.
      my $seen_dot    = 0;      # Treat only the first "." as the decimal point.
  
      # Parse the format.
    PARSER:
      while ( $pos < length $format ) {
          $start_pos = $pos;
          my $char = substr( $format, $pos, 1 );
  
          # Ignore control format characters such as '#0+-.?eE,%'. However,
          # only ignore '.' if it is the first one encountered. RT 45502.
          if ( ( !$seen_dot && $char !~ /[#0\+\-\.\?eE\,\%]/ )
              || $char !~ /[#0\+\-\?eE\,\%]/ )
          {
  
              if ( $token_start != -1 ) {
                  push @placeholders,
                    [
                      substr( $format, $token_start, $pos - $token_start ),
                      $decimal_pos, $pos - $token_start
                    ];
                  $token_start = -1;
              }
          }
  
          # Processing for quoted strings within the format. See notes above.
          if ( $char eq '"' ) {
              $double_quote = $double_quote ? 0 : 1;
              $pos++;
              next PARSER;
          }
          elsif ( $char eq '!' ) {
              $single_quote = 1;
              $pos++;
              next PARSER;
          }
          elsif ( $char eq '\\' ) {
              if ( $single_quote != 1 ) {
                  $single_quote = 1;
                  $pos++;
                  next PARSER;
              }
          }
  
          if (   ( defined($double_quote) and ($double_quote) )
              or ( defined($single_quote) and ($single_quote) )
              or ( $seen_dot && $char eq '.' ) )
          {
              $single_quote = 0;
              if (
                  ( $format_mode ne 'date' )
                  and (  ( substr( $format, $pos, 2 ) eq "\x81\xA2" )
                      || ( substr( $format, $pos, 2 ) eq "\x81\xA3" )
                      || ( substr( $format, $pos, 2 ) eq "\xA2\xA4" )
                      || ( substr( $format, $pos, 2 ) eq "\xA2\xA5" ) )
                )
              {
  
                  # The above matches are currency symbols.
                  push @placeholders,
                    [ substr( $format, $pos, 2 ), length($token), 2 ];
                  $is_currency = 1;
                  $pos += 2;
              }
              else {
                  $pos++;
              }
          }
          elsif (
              ( $char =~ /[#0\+\.\?eE\,\%]/ )
              || (    ( $format_mode ne 'date' )
                  and ( ( $char eq '-' ) || ( $char eq '(' ) || ( $char eq ')' ) )
              )
            )
          {
              $format_mode = 'number' unless $format_mode;
              if ( substr( $format, $pos, 1 ) =~ /[#0]/ ) {
                  if (
                      substr( $format, $pos ) =~
                      /^([#0]+[\.]?[0#]*[eE][\+\-][0#]+)/ )
                  {
                      push @placeholders, [ $1, $pos, length($1) ];
                      $pos += length($1);
                  }
                  else {
                      if ( $token_start == -1 ) {
                          $token_start = $pos;
                          $decimal_pos = length($token);
                      }
                  }
              }
              elsif ( substr( $format, $pos, 1 ) eq '?' ) {
  
                  # Look for a fraction format like ?/? or ??/??
                  if ( $token_start != -1 ) {
                      push @placeholders,
                        [
                          substr(
                              $format, $token_start, $pos - $token_start + 1
                          ),
                          $decimal_pos,
                          $pos - $token_start + 1
                        ];
                  }
                  $token_start = $pos;
  
                  # Find the end of the fraction format.
                FRACTION:
                  while ( $pos < length($format) ) {
                      if ( substr( $format, $pos, 1 ) eq '/' ) {
                          $is_fraction = 1;
                      }
                      elsif ( substr( $format, $pos, 1 ) eq '?' ) {
                          $pos++;
                          next FRACTION;
                      }
                      else {
                          if ( $is_fraction
                              && ( substr( $format, $pos, 1 ) =~ /[0-9]/ ) )
                          {
  
                              # TODO: Could invert if() logic and remove this.
                              $pos++;
                              next FRACTION;
                          }
                          else {
                              last FRACTION;
                          }
                      }
                      $pos++;
                  }
                  $pos--;
  
                  push @placeholders,
                    [
                      substr( $format, $token_start, $pos - $token_start + 1 ),
                      length($token), $pos - $token_start + 1
                    ];
                  $token_start = -1;
              }
              elsif ( substr( $format, $pos, 3 ) =~ /^[eE][\+\-][0#]$/ ) {
                  if ( substr( $format, $pos ) =~ /([eE][\+\-][0#]+)/ ) {
                      push @placeholders, [ $1, $pos, length($1) ];
                      $pos += length($1);
                  }
                  $token_start = -1;
              }
              else {
                  if ( $token_start != -1 ) {
                      push @placeholders,
                        [
                          substr( $format, $token_start, $pos - $token_start ),
                          $decimal_pos, $pos - $token_start
                        ];
                      $token_start = -1;
                  }
                  if ( substr( $format, $pos, 1 ) =~ /[\+\-]/ ) {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                      $is_currency = 1;
                  }
                  elsif ( substr( $format, $pos, 1 ) eq '.' ) {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                      $seen_dot = 1;
                  }
                  elsif ( substr( $format, $pos, 1 ) eq ',' ) {
                      $comma_count++;
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                  }
                  elsif ( substr( $format, $pos, 1 ) eq '%' ) {
                      $is_percent = 1;
                  }
                  elsif (( substr( $format, $pos, 1 ) eq '(' )
                      || ( substr( $format, $pos, 1 ) eq ')' ) )
                  {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                      $is_currency = 1;
                  }
              }
              $pos++;
          }
          elsif ( $char =~ /[ymdhsapg]/i ) {
              $format_mode = 'date' unless $format_mode;
              if ( substr( $format, $pos, 5 ) =~ /am\/pm/i ) {
                  push @placeholders, [ 'am/pm', length($token), 5 ];
                  $is_12_hour = 1;
                  $pos += 5;
              }
              elsif ( substr( $format, $pos, 3 ) =~ /a\/p/i ) {
                  push @placeholders, [ 'a/p', length($token), 3 ];
                  $is_12_hour = 1;
                  $pos += 3;
              }
              elsif ( substr( $format, $pos, 5 ) eq 'mmmmm' ) {
                  push @placeholders, [ 'mmmmm', length($token), 5 ];
                  $pos += 5;
              }
              elsif (( substr( $format, $pos, 4 ) eq 'mmmm' )
                  || ( substr( $format, $pos, 4 ) eq 'dddd' )
                  || ( substr( $format, $pos, 4 ) eq 'yyyy' )
                  || ( substr( $format, $pos, 4 ) eq 'ggge' ) )
              {
                  push @placeholders,
                    [ substr( $format, $pos, 4 ), length($token), 4 ];
                  $pos += 4;
              }
              elsif (( substr( $format, $pos, 3 ) eq 'ddd' )
                  || ( substr( $format, $pos, 3 ) eq 'mmm' )
                  || ( substr( $format, $pos, 3 ) eq 'yyy' ) )
              {
                  push @placeholders,
                    [ substr( $format, $pos, 3 ), length($token), 3 ];
                  $pos += 3;
              }
              elsif (( substr( $format, $pos, 2 ) eq 'yy' )
                  || ( substr( $format, $pos, 2 ) eq 'mm' )
                  || ( substr( $format, $pos, 2 ) eq 'dd' )
                  || ( substr( $format, $pos, 2 ) eq 'hh' )
                  || ( substr( $format, $pos, 2 ) eq 'ss' )
                  || ( substr( $format, $pos, 2 ) eq 'ge' ) )
              {
                  if (
                         ( substr( $format, $pos, 2 ) eq 'mm' )
                      && (@placeholders)
                      && (   ( $placeholders[-1]->[0] eq 'h' )
                          or ( $placeholders[-1]->[0] eq 'hh' ) )
                    )
                  {
  
                      # For this case 'm' is minutes not months.
                      push @placeholders, [ 'mm', length($token), 2, 'minutes' ];
                  }
                  else {
                      push @placeholders,
                        [ substr( $format, $pos, 2 ), length($token), 2 ];
                  }
                  if (   ( substr( $format, $pos, 2 ) eq 'ss' )
                      && ( @placeholders > 1 ) )
                  {
                      if (   ( $placeholders[-2]->[0] eq 'm' )
                          || ( $placeholders[-2]->[0] eq 'mm' ) )
                      {
  
                          # For this case 'm' is minutes not months.
                          push( @{ $placeholders[-2] }, 'minutes' );
                      }
                  }
                  $pos += 2;
              }
              elsif (( substr( $format, $pos, 1 ) eq 'm' )
                  || ( substr( $format, $pos, 1 ) eq 'd' )
                  || ( substr( $format, $pos, 1 ) eq 'h' )
                  || ( substr( $format, $pos, 1 ) eq 's' ) )
              {
                  if (
                         ( substr( $format, $pos, 1 ) eq 'm' )
                      && (@placeholders)
                      && (   ( $placeholders[-1]->[0] eq 'h' )
                          or ( $placeholders[-1]->[0] eq 'hh' ) )
                    )
                  {
  
                      # For this case 'm' is minutes not months.
                      push @placeholders, [ 'm', length($token), 1, 'minutes' ];
                  }
                  else {
                      push @placeholders,
                        [ substr( $format, $pos, 1 ), length($token), 1 ];
                  }
                  if (   ( substr( $format, $pos, 1 ) eq 's' )
                      && ( @placeholders > 1 ) )
                  {
                      if (   ( $placeholders[-2]->[0] eq 'm' )
                          || ( $placeholders[-2]->[0] eq 'mm' ) )
                      {
  
                          # For this case 'm' is minutes not months.
                          push( @{ $placeholders[-2] }, 'minutes' );
                      }
                  }
                  $pos += 1;
              }
          }
          elsif ( ( substr( $format, $pos, 3 ) eq '[h]' ) ) {
              $format_mode = 'date' unless $format_mode;
              push @placeholders, [ '[h]', length($token), 3 ];
              $pos += 3;
          }
          elsif ( ( substr( $format, $pos, 4 ) eq '[mm]' ) ) {
              $format_mode = 'date' unless $format_mode;
              push @placeholders, [ '[mm]', length($token), 4 ];
              $pos += 4;
          }
          elsif ( $char eq '@' ) {
              push @placeholders, [ '@', length($token), 1 ];
              $pos++;
          }
          elsif ( $char eq '*' ) {
              push @placeholders,
                [ substr( $format, $pos, 1 ), length($token), 1 ];
          }
          else {
              $pos++;
          }
          $pos++ if ( $pos == $start_pos );    #No Format match
          $token .= substr( $format, $start_pos, $pos - $start_pos );
  
      }    # End of parsing.
  
      # Copy the located format string to a result string that we will perform
      # the substitutions on and return to the user.
      my $result = $token;
  
      # Add a placeholder between the decimal/comma and end of the token, if any.
      if ( $token_start != -1 ) {
          push @placeholders,
            [
              substr( $format, $token_start, $pos - $token_start + 1 ),
              $decimal_pos, $pos - $token_start + 1
            ];
      }
  
      #
      # In the next sections we process date, number and text formats. We take a
      # format such as yyyy/mm/dd and replace it with something like 2008/12/25.
      #
      if ( ( $format_mode eq 'date' ) && ( $number =~ $qrNUMBER ) ) {
  
          # The maximum allowable date in Excel is 9999-12-31T23:59:59.000 which
          # equates to 2958465.999+ in the 1900 epoch and 2957003.999+ in the
          # 1904 epoch. We use 0 as the minimum in both epochs. The 1904 system
          # actually supports negative numbers but that isn't worth the effort.
          my $min_date = 0;
          my $max_date = 2958466;
          $max_date = 2957004 if $is_1904;
  
          if ( $number < $min_date || $number >= $max_date ) {
              return $number;    # Return unformatted number.
          }
  
          # Process date formats.
          my @time = ExcelLocaltime( $number, $is_1904 );
  
          #    0     1     2      3     4       5      6      7
          my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;
  
          $month++;              # localtime() zero indexed month.
          $year += 1900;         # localtime() year.
  
          my @full_month_name = qw(
            None January February March April May June July
            August September October November December
          );
          my @short_month_name = qw(
            None Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
          );
          my @full_day_name = qw(
            Sunday Monday Tuesday Wednesday Thursday Friday Saturday
          );
          my @short_day_name = qw(
            Sun Mon Tue Wed Thu Fri Sat
          );
  
          # Replace the placeholders in the template such as yyyy mm dd with
          # actual numbers or strings.
          my $replacement;
          for my $placeholder ( reverse @placeholders ) {
  
              if ( $placeholder->[-1] eq 'minutes' ) {
  
                  # For this case 'm/mm' is minutes not months.
                  if ( $placeholder->[0] eq 'mm' ) {
                      $replacement = sprintf( "%02d", $min );
                  }
                  else {
                      $replacement = sprintf( "%d", $min );
                  }
              }
              elsif ( $placeholder->[0] eq 'yyyy' ) {
  
                  # 4 digit Year. 2000 -> 2000.
                  $replacement = sprintf( '%04d', $year );
              }
              elsif ( $placeholder->[0] eq 'yy' ) {
  
                  # 2 digit Year. 2000 -> 00.
                  $replacement = sprintf( '%02d', $year % 100 );
              }
              elsif ( $placeholder->[0] eq 'mmmmm' ) {
  
                  # First character of the month name. 1 -> J.
                  $replacement = substr( $short_month_name[$month], 0, 1 );
              }
              elsif ( $placeholder->[0] eq 'mmmm' ) {
  
                  # Full month name. 1 -> January.
                  $replacement = $full_month_name[$month];
              }
              elsif ( $placeholder->[0] eq 'mmm' ) {
  
                  # Short month name. 1 -> Jan.
                  $replacement = $short_month_name[$month];
              }
              elsif ( $placeholder->[0] eq 'mm' ) {
  
                  # 2 digit month. 1 -> 01.
                  $replacement = sprintf( '%02d', $month );
              }
              elsif ( $placeholder->[0] eq 'm' ) {
  
                  # 1 digit month. 1 -> 1.
                  $replacement = sprintf( '%d', $month );
              }
              elsif ( $placeholder->[0] eq 'dddd' ) {
  
                  # Full day name. Wednesday (for example.)
                  $replacement = $full_day_name[$wday];
              }
              elsif ( $placeholder->[0] eq 'ddd' ) {
  
                  # Short day name. Wed (for example.)
                  $replacement = $short_day_name[$wday];
              }
              elsif ( $placeholder->[0] eq 'dd' ) {
  
                  # 2 digit day. 1 -> 01.
                  $replacement = sprintf( '%02d', $day );
              }
              elsif ( $placeholder->[0] eq 'd' ) {
  
                  # 1 digit day. 1 -> 1.
                  $replacement = sprintf( '%d', $day );
              }
              elsif ( $placeholder->[0] eq 'hh' ) {
  
                  # 2 digit hour.
                  if ($is_12_hour) {
                      my $hour_tmp = $hour % 12;
                      $hour_tmp = 12 if $hour % 12 == 0;
                      $replacement = sprintf( '%d', $hour_tmp );
                  }
                  else {
                      $replacement = sprintf( '%02d', $hour );
                  }
              }
              elsif ( $placeholder->[0] eq 'h' ) {
  
                  # 1 digit hour.
                  if ($is_12_hour) {
                      my $hour_tmp = $hour % 12;
                      $hour_tmp = 12 if $hour % 12 == 0;
                      $replacement = sprintf( '%2d', $hour_tmp );
                  }
                  else {
                      $replacement = sprintf( '%d', $hour );
                  }
              }
              elsif ( $placeholder->[0] eq 'ss' ) {
  
                  # 2 digit seconds.
                  $replacement = sprintf( '%02d', $sec );
              }
              elsif ( $placeholder->[0] eq 's' ) {
  
                  # 1 digit seconds.
                  $replacement = sprintf( '%d', $sec );
              }
              elsif ( $placeholder->[0] eq 'am/pm' ) {
  
                  # AM/PM.
                  $replacement = ( $hour >= 12 ) ? 'PM' : 'AM';
              }
              elsif ( $placeholder->[0] eq 'a/p' ) {
  
                  # AM/PM.
                  $replacement = ( $hour >= 12 ) ? 'P' : 'A';
              }
              elsif ( $placeholder->[0] eq '.' ) {
  
                  # Decimal point for seconds.
                  $replacement = '.';
              }
              elsif ( $placeholder->[0] =~ /(^0+$)/ ) {
  
                  # Milliseconds. For example h:ss.000.
                  my $length = length($1);
                  $replacement =
                    substr( sprintf( "%.${length}f", $msec / 1000 ), 2, $length );
              }
              elsif ( $placeholder->[0] eq '[h]' ) {
  
                  # Hours modulus 24. 25 displays as 25 not as 1.
                  $replacement = sprintf( '%d', int($number) * 24 + $hour );
              }
              elsif ( $placeholder->[0] eq '[mm]' ) {
  
                  # Mins modulus 60. 72 displays as 72 not as 12.
                  $replacement =
                    sprintf( '%d', ( int($number) * 24 + $hour ) * 60 + $min );
              }
              elsif ( $placeholder->[0] eq 'ge' ) {
                  require Spreadsheet::ParseExcel::FmtJapan;
                  # Japanese Nengo (aka Gengo) in initialism (abbr. name)
                   $replacement =
                    Spreadsheet::ParseExcel::FmtJapan::CnvNengo( abbr_name => @time );
              }
              elsif ( $placeholder->[0] eq 'ggge' ) {
                  require Spreadsheet::ParseExcel::FmtJapan;
                  # Japanese Nengo (aka Gengo) in Kanji (full name)
                   $replacement =
                    Spreadsheet::ParseExcel::FmtJapan::CnvNengo( name => @time );
              }
              elsif ( $placeholder->[0] eq '@' ) {
  
                  # Text format.
                  $replacement = $number;
              }
              elsif ( $placeholder->[0] eq ',' ) {
                  next;
              }
  
              # Substitute the replacement string back into the template.
              substr( $result, $placeholder->[1], $placeholder->[2],
                  $replacement );
          }
      }
      elsif ( ( $format_mode eq 'number' ) && ( $number =~ $qrNUMBER ) ) {
  
          # Process non date formats.
          if (@placeholders) {
              while ( $placeholders[-1]->[0] eq ',' ) {
                  $comma_count--;
                  substr(
                      $result,
                      $placeholders[-1]->[1],
                      $placeholders[-1]->[2], ''
                  );
                  $number /= 1000;
                  pop @placeholders;
              }
  
              my $number_format = join( '', map { $_->[0] } @placeholders );
              my $number_result;
              my $str_length    = 0;
              my $engineering   = 0;
              my $is_decimal    = 0;
              my $is_integer    = 0;
              my $after_decimal = undef;
  
              for my $token ( split //, $number_format ) {
                  if ( $token eq '.' ) {
                      $str_length++;
                      $is_decimal = 1;
                  }
                  elsif ( ( $token eq 'E' ) || ( $token eq 'e' ) ) {
                      $engineering = 1;
                  }
                  elsif ( $token eq '0' ) {
                      $str_length++;
                      $after_decimal++ if $is_decimal;
                      $is_integer = 1;
                  }
                  elsif ( $token eq '#' ) {
                      $after_decimal++ if $is_decimal;
                      $is_integer = 1;
                  }
                  elsif ( $token eq '?' ) {
                      $after_decimal++ if $is_decimal;
                  }
              }
  
              $number *= 100.0 if $is_percent;
  
              my $data = ($is_currency) ? abs($number) : $number + 0;
  
              if ($is_fraction) {
                  $number_result = sprintf( "%0${str_length}d", int($data) );
              }
              else {
                  if ($is_decimal) {
  
                      if ( defined $after_decimal ) {
                          $number_result =
                            sprintf "%0${str_length}.${after_decimal}f", $data;
                      }
                      else {
                          $number_result = sprintf "%0${str_length}f", $data;
                      }
  
                      # Fix for Perl and sprintf not rounding up like Excel.
                      # http://rt.cpan.org/Public/Bug/Display.html?id=45626
                      if ( $data =~ /^${number_result}5/ ) {
                          $number_result =
                            sprintf "%0${str_length}.${after_decimal}f",
                            $data . '1';
                      }
                  }
                  else {
                      $number_result = sprintf( "%0${str_length}.0f", $data );
                  }
              }
  
              $number_result = AddComma($number_result) if $comma_count > 0;
  
              my $number_length = length($number_result);
              my $decimal_pos   = -1;
              my $replacement;
  
              for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {
                  my $placeholder = $placeholders[$i];
  
                  if ( $placeholder->[0] =~
                      /([#0]*)([\.]?)([0#]*)([eE])([\+\-])([0#]+)/ )
                  {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          MakeE( $placeholder->[0], $number ) );
                  }
                  elsif ( $placeholder->[0] =~ /\// ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          MakeFraction( $placeholder->[0], $number, $is_integer )
                      );
                  }
                  elsif ( $placeholder->[0] eq '.' ) {
                      $number_length--;
                      $decimal_pos = $number_length;
                  }
                  elsif ( $placeholder->[0] eq '+' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          ( $number > 0 )
                          ? '+'
                          : ( ( $number == 0 ) ? '+' : '-' ) );
                  }
                  elsif ( $placeholder->[0] eq '-' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          ( $number > 0 )
                          ? ''
                          : ( ( $number == 0 ) ? '' : '-' ) );
                  }
                  elsif ( $placeholder->[0] eq '@' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          $number );
                  }
                  elsif ( $placeholder->[0] eq '*' ) {
                      substr( $result, $placeholder->[1], $placeholder->[2], '' );
                  }
                  elsif (( $placeholder->[0] eq "\xA2\xA4" )
                      or ( $placeholder->[0] eq "\xA2\xA5" )
                      or ( $placeholder->[0] eq "\x81\xA2" )
                      or ( $placeholder->[0] eq "\x81\xA3" ) )
                  {
                      substr(
                          $result,           $placeholder->[1],
                          $placeholder->[2], $placeholder->[0]
                      );
                  }
                  elsif (( $placeholder->[0] eq '(' )
                      or ( $placeholder->[0] eq ')' ) )
                  {
                      substr(
                          $result,           $placeholder->[1],
                          $placeholder->[2], $placeholder->[0]
                      );
                  }
                  else {
                      if ( $number_length > 0 ) {
                          if ( $i <= 0 ) {
                              $replacement =
                                substr( $number_result, 0, $number_length );
                              $number_length = 0;
                          }
                          else {
                              my $real_part_length = length( $placeholder->[0] );
                              if ( $decimal_pos >= 0 ) {
                                  my $format = $placeholder->[0];
                                  $format =~ s/^#+//;
                                  $real_part_length = length $format;
                                  $real_part_length =
                                    ( $number_length <= $real_part_length )
                                    ? $number_length
                                    : $real_part_length;
                              }
                              else {
                                  $real_part_length =
                                    ( $number_length <= $real_part_length )
                                    ? $number_length
                                    : $real_part_length;
                              }
                              $replacement =
                                substr( $number_result,
                                  $number_length - $real_part_length,
                                  $real_part_length );
                              $number_length -= $real_part_length;
                          }
                      }
                      else {
                          $replacement = '';
                      }
                      substr( $result, $placeholder->[1], $placeholder->[2],
                          "\x00" . $replacement );
                  }
              }
              $replacement =
                ( $number_length > 0 )
                ? substr( $number_result, 0, $number_length )
                : '';
              $result =~ s/\x00/$replacement/;
              $result =~ s/\x00//g;
          }
      }
      else {
  
          # Process text formats
          my $is_text = 0;
          for ( my $i = @placeholders - 1 ; $i >= 0 ; $i-- ) {
              my $placeholder = $placeholders[$i];
              if ( $placeholder->[0] eq '@' ) {
                  substr( $result, $placeholder->[1], $placeholder->[2],
                      $number );
                  $is_text++;
              }
              else {
                  substr( $result, $placeholder->[1], $placeholder->[2], '' );
              }
          }
  
          $result = $number unless $is_text;
  
      }    # End of placeholder substitutions.
  
      # Trim the leading and trailing whitespace from the results.
      $result =~ s/^\s+//;
      $result =~ s/\s+$//;
  
      # Fix for negative currency.
      $result =~ s/^\$\-/\-\$/;
      $result =~ s/^\$ \-/\-\$ /;
  
      # Return color and locale strings if required.
      if ($want_subformats) {
          return ( $result, $color, $locale );
      }
      else {
          return $result;
      }
  }
  
  #------------------------------------------------------------------------------
  # AddComma (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub AddComma {
      my ($sNum) = @_;
  
      if ( $sNum =~ /^([^\d]*)(\d\d\d\d+)(\.*.*)$/ ) {
          my ( $sPre, $sObj, $sAft ) = ( $1, $2, $3 );
          for ( my $i = length($sObj) - 3 ; $i > 0 ; $i -= 3 ) {
              substr( $sObj, $i, 0, ',' );
          }
          return $sPre . $sObj . $sAft;
      }
      else {
          return $sNum;
      }
  }
  
  #------------------------------------------------------------------------------
  # MakeFraction (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub MakeFraction {
      my ( $sFmt, $iData, $iFlg ) = @_;
      my $iBunbo;
      my $iShou;
  
      #1. Init
      # print "FLG: $iFlg\n";
      if ($iFlg) {
          $iShou = $iData - int($iData);
          return '' if ( $iShou == 0 );
      }
      else {
          $iShou = $iData;
      }
      $iShou = abs($iShou);
      my $sSWk;
  
      #2.Calc BUNBO
      #2.1 BUNBO defined
      if ( $sFmt =~ /\/(\d+)$/ ) {
          $iBunbo = $1;
          return sprintf( "%d/%d", $iShou * $iBunbo, $iBunbo );
      }
      else {
  
          #2.2 Calc BUNBO
          $sFmt =~ /\/(\?+)$/;
          my $iKeta = length($1);
          my $iSWk  = 1;
          my $sSWk  = '';
          my $iBunsi;
          for ( my $iBunbo = 2 ; $iBunbo < 10**$iKeta ; $iBunbo++ ) {
              $iBunsi = int( $iShou * $iBunbo + 0.5 );
              my $iCmp = abs( $iShou - ( $iBunsi / $iBunbo ) );
              if ( $iCmp < $iSWk ) {
                  $iSWk = $iCmp;
                  $sSWk = sprintf( "%d/%d", $iBunsi, $iBunbo );
                  last if ( $iSWk == 0 );
              }
          }
          return $sSWk;
      }
  }
  
  #------------------------------------------------------------------------------
  # MakeE (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub MakeE {
      my ( $sFmt, $iData ) = @_;
  
      $sFmt =~ /(([#0]*)[\.]?[#0]*)([eE])([\+\-][0#]+)/;
      my ( $sKari, $iKeta, $sE, $sSisu ) = ( $1, length($2), $3, $4 );
      $iKeta = 1 if ( $iKeta <= 0 );
  
      my $iLog10 = 0;
      $iLog10 = ( $iData == 0 ) ? 0 : ( log( abs($iData) ) / log(10) );
      $iLog10 = (
          int( $iLog10 / $iKeta ) +
            ( ( ( $iLog10 - int( $iLog10 / $iKeta ) ) < 0 ) ? -1 : 0 ) ) * $iKeta;
  
      my $sUe = ExcelFmt( $sKari, $iData * ( 10**( $iLog10 * -1 ) ), 0 );
      my $sShita = ExcelFmt( $sSisu, $iLog10, 0 );
      return $sUe . $sE . $sShita;
  }
  
  #------------------------------------------------------------------------------
  # LeapYear (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub LeapYear {
      my ($iYear) = @_;
      return 1 if ( $iYear == 1900 );    #Special for Excel
      return ( ( ( $iYear % 4 ) == 0 )
            && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) )
        ? 1
        : 0;
  }
  
  #------------------------------------------------------------------------------
  # LocaltimeExcel (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub LocaltimeExcel {
      my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec, $flg1904 )
        = @_;
  
      #0. Init
      $iMon++;
      $iYear += 1900;
  
      #1. Calc Time
      my $iTime;
      $iTime = $iHour;
      $iTime *= 60;
      $iTime += $iMin;
      $iTime *= 60;
      $iTime += $iSec;
      $iTime += $iMSec / 1000.0 if ( defined($iMSec) );
      $iTime /= 86400.0;    #3600*24(1day in seconds)
      my $iY;
      my $iYDays;
  
      #2. Calc Days
      if ($flg1904) {
          $iY = 1904;
          $iTime--;         #Start from Jan 1st
          $iYDays = 366;
      }
      else {
          $iY     = 1900;
          $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)
      }
      while ( $iY < $iYear ) {
          $iTime += $iYDays;
          $iY++;
          $iYDays = ( LeapYear($iY) ) ? 366 : 365;
      }
      for ( my $iM = 1 ; $iM < $iMon ; $iM++ ) {
          if (   $iM == 1
              || $iM == 3
              || $iM == 5
              || $iM == 7
              || $iM == 8
              || $iM == 10
              || $iM == 12 )
          {
              $iTime += 31;
          }
          elsif ( $iM == 4 || $iM == 6 || $iM == 9 || $iM == 11 ) {
              $iTime += 30;
          }
          elsif ( $iM == 2 ) {
              $iTime += ( LeapYear($iYear) ) ? 29 : 28;
          }
      }
      $iTime += $iDay;
      return $iTime;
  }
  
  my @month_days = qw(
    0 31 28 31 30 31 30 31 31 30 31 30 31
  );
  
  #------------------------------------------------------------------------------
  # ExcelLocaltime (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  sub ExcelLocaltime {
  
      my ( $dObj, $flg1904 ) = @_;
      my ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );
      my ( $iDt, $iTime, $iYDays, $iMD );
  
      $iDt   = int($dObj);
      $iTime = $dObj - $iDt;
  
      #1. Calc Days
      if ($flg1904) {
          $iYear = 1904;
          $iDt++;    #Start from Jan 1st
          $iYDays = 366;
          $iwDay = ( ( $iDt + 4 ) % 7 );
      }
      else {
          $iYear  = 1900;
          $iYDays = 366;    #In Excel 1900 is leap year (That's not TRUE!)
          $iwDay = ( ( $iDt + 6 ) % 7 );
      }
      while ( $iDt > $iYDays ) {
          $iDt -= $iYDays;
          $iYear++;
          $iYDays =
            (      ( ( $iYear % 4 ) == 0 )
                && ( ( $iYear % 100 ) || ( $iYear % 400 ) == 0 ) ) ? 366 : 365;
      }
      $iYear -= 1900;       # Localtime year is relative to 1900.
  
      for ( $iMon = 1 ; $iMon <= 12 ; $iMon++ ) {
          $iMD = $month_days[$iMon];
          $iMD++ if $iMon == 2 and $iYear % 4 == 0;
  
          last if ( $iDt <= $iMD );
          $iDt -= $iMD;
      }
  
      #2. Calc Time
      $iDay = $iDt;
      $iTime += ( 0.0005 / 86400.0 );
      if ($iTime >= 1.0)
      {
          $iTime -= int($iTime);
          $iwDay = ($iwDay == 6) ? 0 : $iwDay + 1;
          if ($iDay == $iMD)
          {
              if ($iMon == 12)
              {
                  $iMon = 1;
                  $iYear++;
              }
              else
              {
                  $iMon++;
              }
              $iDay = 1;
          }
          else
          {
              $iDay++;
          }
      }
  
      # Localtime month is 0 based.
      $iMon  -= 1;
      $iTime *= 24.0;
      $iHour = int($iTime);
      $iTime -= $iHour;
      $iTime *= 60.0;
      $iMin = int($iTime);
      $iTime -= $iMin;
      $iTime *= 60.0;
      $iSec = int($iTime);
      $iTime -= $iSec;
      $iTime *= 1000.0;
      $iMSec = int($iTime);
  
      return ( $iSec, $iMin, $iHour, $iDay, $iMon, $iYear, $iwDay, $iMSec );
  }
  
  # -----------------------------------------------------------------------------
  # col2int (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  # converts a excel row letter into an int for use in an array
  sub col2int {
      my $result = 0;
      my $str    = shift;
      my $incr   = 0;
  
      for ( my $i = length($str) ; $i > 0 ; $i-- ) {
          my $char = substr( $str, $i - 1 );
          my $curr += ord( lc($char) ) - ord('a') + 1;
          $curr *= $incr if ($incr);
          $result += $curr;
          $incr   += 26;
      }
  
      # this is one out as we range 0..x-1 not 1..x
      $result--;
  
      return $result;
  }
  
  # -----------------------------------------------------------------------------
  # int2col (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  ### int2col
  # convert a column number into column letters
  # @note this is quite a brute force coarse method
  #   does not manage values over 701 (ZZ)
  # @arg number, to convert
  # @returns string, column name
  #
  sub int2col {
      my $out = "";
      my $val = shift;
  
      do {
          $out .= chr( ( $val % 26 ) + ord('A') );
          $val = int( $val / 26 ) - 1;
      } while ( $val >= 0 );
  
      return scalar reverse $out;
  }
  
  # -----------------------------------------------------------------------------
  # sheetRef (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  # -----------------------------------------------------------------------------
  ### sheetRef
  # convert an excel letter-number address into a useful array address
  # @note that also Excel uses X-Y notation, we normally use Y-X in arrays
  # @args $str, excel coord eg. A2
  # @returns an array - 2 elements - column, row, or undefined
  #
  sub sheetRef {
      my $str = shift;
      my @ret;
  
      $str =~ m/^(\D+)(\d+)$/;
  
      if ( $1 && $2 ) {
          push( @ret, $2 - 1, col2int($1) );
      }
      if ( $ret[0] < 0 ) {
          undef @ret;
      }
  
      return @ret;
  }
  
  # -----------------------------------------------------------------------------
  # xls2csv (for Spreadsheet::ParseExcel::Utility)
  #------------------------------------------------------------------------------
  ### xls2csv
  # convert a chunk of an excel file into csv text chunk
  # @args $param, sheet-colrow:colrow (1-A1:B2 or A1:B2 for sheet 1
  # @args $rotate, 0 or 1 decides if output should be rotated or not
  # @returns string containing a chunk of csv
  #
  sub xls2csv {
      my ( $filename, $regions, $rotate ) = @_;
      my $sheet = 0;
  
      # We need Text::CSV_XS for proper CSV handling.
      require Text::CSV_XS;
  
      # extract any sheet number from the region string
      $regions =~ m/^(\d+)-(.*)/;
  
      if ($2) {
          $sheet   = $1 - 1;
          $regions = $2;
      }
  
      # now extract the start and end regions
      $regions =~ m/(.*):(.*)/;
  
      if ( !$1 || !$2 ) {
          print STDERR "Bad Params";
          return "";
      }
  
      my @start = sheetRef($1);
      my @end   = sheetRef($2);
      if ( !@start ) {
          print STDERR "Bad coorinates - $1";
          return "";
      }
      if ( !@end ) {
          print STDERR "Bad coorinates - $2";
          return "";
      }
  
      if ( $start[1] > $end[1] ) {
          print STDERR "Bad COLUMN ordering\n";
          print STDERR "Start column " . int2col( $start[1] );
          print STDERR " after end column " . int2col( $end[1] ) . "\n";
          return "";
      }
      if ( $start[0] > $end[0] ) {
          print STDERR "Bad ROW ordering\n";
          print STDERR "Start row " . ( $start[0] + 1 );
          print STDERR " after end row " . ( $end[0] + 1 ) . "\n";
          exit;
      }
  
      # start the excel object now
      my $oExcel = new Spreadsheet::ParseExcel;
      my $oBook  = $oExcel->Parse($filename);
  
      # open the sheet
      my $oWkS = $oBook->{Worksheet}[$sheet];
  
      # now check that the region exists in the file
      # if not truncate to the possible region
      # output a warning msg
      if ( $start[1] < $oWkS->{MinCol} ) {
          print STDERR int2col( $start[1] )
            . " < min col "
            . int2col( $oWkS->{MinCol} )
            . " Resetting\n";
          $start[1] = $oWkS->{MinCol};
      }
      if ( $end[1] > $oWkS->{MaxCol} ) {
          print STDERR int2col( $end[1] )
            . " > max col "
            . int2col( $oWkS->{MaxCol} )
            . " Resetting\n";
          $end[1] = $oWkS->{MaxCol};
      }
      if ( $start[0] < $oWkS->{MinRow} ) {
          print STDERR ""
            . ( $start[0] + 1 )
            . " < min row "
            . ( $oWkS->{MinRow} + 1 )
            . " Resetting\n";
          $start[0] = $oWkS->{MinCol};
      }
      if ( $end[0] > $oWkS->{MaxRow} ) {
          print STDERR ""
            . ( $end[0] + 1 )
            . " > max row "
            . ( $oWkS->{MaxRow} + 1 )
            . " Resetting\n";
          $end[0] = $oWkS->{MaxRow};
  
      }
  
      my $x1 = $start[1];
      my $y1 = $start[0];
      my $x2 = $end[1];
      my $y2 = $end[0];
  
      my @cell_data;
      my $row = 0;
  
      if ( !$rotate ) {
          for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {
              for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {
                  my $cell = $oWkS->{Cells}[$y][$x];
  
                  my $value;
                  if ( defined $cell ) {
                      $value .= $cell->value();
                  }
                  else {
                      $value = '';
                  }
  
                  push @{ $cell_data[$row] }, $value;
              }
              $row++;
          }
      }
      else {
          for ( my $x = $x1 ; $x <= $x2 ; $x++ ) {
              for ( my $y = $y1 ; $y <= $y2 ; $y++ ) {
                  my $cell = $oWkS->{Cells}[$y][$x];
  
                  my $value;
                  if ( defined $cell ) {
                      $value .= $cell->value();
                  }
                  else {
                      $value = '';
                  }
  
                  push @{ $cell_data[$row] }, $value;
              }
              $row++;
          }
      }
  
      # Create the CSV output string.
      my $csv = Text::CSV_XS->new( { binary => 1, eol => $/ } );
      my $output = "";
  
      for my $row (@cell_data) {
          $csv->combine(@$row);
          $output .= $csv->string();
      }
  
      return $output;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Utility - Utility functions for Spreadsheet::ParseExcel.
  
  =head1 SYNOPSIS
  
      use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);
  
      # Convert localtime to Excel time
      my $datetime = LocaltimeExcel(11, 10, 12, 23, 2, 64); # 1964-3-23 12:10:11
  
      print $datetime, "\n"; # 23459.5070717593 (Excel date/time format)
  
      # Convert Excel Time to localtime
      my @time = ExcelLocaltime($datetime);
      print join(":", @time), "\n";   # 11:10:12:23:2:64:1:0
  
      # Formatting
      print ExcelFmt('yyyy-mm-dd', $datetime), "\n"; # 1964-3-23
      print ExcelFmt('m-d-yy',     $datetime), "\n"; # 3-23-64
      print ExcelFmt('#,##0',      $datetime), "\n"; # 23,460
      print ExcelFmt('#,##0.00',   $datetime), "\n"; # 23,459.51
  
  =head1 DESCRIPTION
  
  The C<Spreadsheet::ParseExcel::Utility> module provides utility functions for working with ParseExcel and Excel data.
  
  =head1 Functions
  
  C<Spreadsheet::ParseExcel::Utility> can export the following functions:
  
      ExcelFmt
      ExcelLocaltime
      LocaltimeExcel
      col2int
      int2col
      sheetRef
      xls2csv
  
  These functions must be imported implicitly:
  
      # Just one function.
      use Spreadsheet::ParseExcel::Utility 'col2int';
  
      # More than one.
      use Spreadsheet::ParseExcel::Utility qw(ExcelFmt ExcelLocaltime LocaltimeExcel);
  
  
  =head2 ExcelFmt($format_string, $number, $is_1904)
  
  Excel stores data such as dates and currency values as numbers. The way these numbers are displayed is controlled by the number format string for the cell. For example a cell with a number format of C<'$#,##0.00'> for currency and a value of 1234.567 would be displayed as follows:
  
      '$#,##0.00' + 1234.567 = '$1,234.57'.
  
  The C<ExcelFmt()> function tries to emulate this formatting so that the user can convert raw numbers returned by C<Spreadsheet::ParseExel> to a desired format. For example:
  
      print ExcelFmt('$#,##0.00', 1234.567); # $1,234.57.
  
  The syntax of the function is:
  
      my $text = ExcelFmt($format_string, $number, $is_1904);
  
  Where C<$format_string> is an Excel number format string, C<$number> is a real or integer number and C<is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.
  
  C<ExcelFmt()> is also used internally to convert numbers returned by the C<Cell::unformatted()> method to the formatted value returned by the C<Cell::value()> method:
  
  
      my $cell = $worksheet->get_cell( 0, 0 );
  
      print $cell->unformatted(), "\n"; # 1234.567
      print $cell->value(),       "\n"; # $1,234.57
  
  The most common usage for C<ExcelFmt> is to convert numbers to dates. Dates and times in Excel are represented by real numbers, for example "1 Jan 2001 12:30 PM" is represented by the number 36892.521. The integer part of the number stores the number of days since the epoch and the fractional part stores the percentage of the day. By applying an Excel number format the number is converted to the desired string representation:
  
      print ExcelFmt('d mmm yyyy h:mm AM/PM', 36892.521);  # 1 Jan 2001 12:30 PM
  
  C<$is_1904> is an optional flag to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch. Excel for Windows generally uses 1900 and Excel for Mac OS uses 1904. The C<$is1904> flag isn't required very often by a casual user and can usually be ignored.
  
  
  =head2 ExcelLocaltime($excel_datetime, $is_1904)
  
  The C<ExcelLocaltime()> function converts from an Excel date/time number to a C<localtime()>-like array of values:
  
          my @time = ExcelLocaltime($excel_datetime);
  
          #    0     1     2      3     4       5      6      7
          my ( $sec, $min, $hour, $day, $month, $year, $wday, $msec ) = @time;
  
  The array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. This means that you will usually need to do the following:
  
          $month++;
          $year += 1900;
  
  See also Perl's documentation for L<localtime()|perlfunc>:
  
  The C<$is_1904> flag is an optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.
  
  =head2 LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec, $is_1904)
  
  The C<LocaltimeExcel()> function converts from a C<localtime()>-like array of values to an Excel date/time number:
  
      $excel_datetime = LocaltimeExcel($sec, $min, $hour, $day, $month, $year, $wday, $msec);
  
  The array elements from C<(0 .. 6)> are the same as Perl's C<localtime()>. The last element C<$msec> is milliseconds. In particular it should be noted that, in common with C<localtime()>, the month is zero indexed and the year is the number of years since 1900. See also Perl's documentation for L<localtime()|perlfunc>:
  
  The C<$wday> and C<$msec> elements are usually optional. This time elements can also be zeroed if they aren't of interest:
  
                                      # sec, min, hour, day, month, year
      $excel_datetime = LocaltimeExcel( 0,   0,   0,    1,   0,     101 );
  
      print ExcelFmt('d mmm yyyy', $excel_datetime);  # 1 Jan 2001
  
  The C<$is_1904> flag is also optional. It is used to indicate that dates should use Excel's 1904 epoch instead of the default 1900 epoch.
  
  
  =head2 col2int($column)
  
  The C<col2int()> function converts an Excel column letter to an zero-indexed column number:
  
      print col2int('A');  # 0
      print col2int('AA'); # 26
  
  This function was contributed by Kevin Mulholland.
  
  
  =head2 int2col($column_number)
  
  The C<int2col()> function converts an zero-indexed Excel column number to a column letter:
  
      print int2col(0);  # 'A'
      print int2col(26); # 'AA'
  
  This function was contributed by Kevin Mulholland.
  
  
  =head2 sheetRef($cell_string)
  
  The C<sheetRef()> function converts an Excel cell reference in 'A1' notation to a zero-indexed C<(row, col)> pair.
  
      my ($row, $col) = sheetRef('A1'); # ( 0, 0 )
      my ($row, $col) = sheetRef('C2'); # ( 1, 2 )
  
  This function was contributed by Kevin Mulholland.
  
  
  =head2 xls2csv($filename, $region, $rotate)
  
  The C<xls2csv()> function converts a section of an Excel file into a CSV text string.
  
      $csv_text = xls2csv($filename, $region, $rotate);
  
  Where:
  
      $region = "sheet-colrow:colrow"
      For example '1-A1:B2' means 'A1:B2' for sheet 1.
  
      and
  
      $rotate  = 0 or 1 (output is rotated/transposed or not)
  
  This function requires C<Text::CSV_XS> to be installed. It was contributed by Kevin Mulholland along with the C<xls2csv> script in the C<sample> directory of the distro.
  
  See also the following xls2csv utilities: Ken Prows' C<xls2csv>: http://search.cpan.org/~ken/xls2csv/script/xls2csv and H.Merijn Brand's C<xls2csv> (which is part of Spreadsheet::Read): http://search.cpan.org/~hmbrand/Spreadsheet-Read/
  
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_UTILITY

$fatpacked{"Spreadsheet/ParseExcel/Workbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_WORKBOOK';
  package Spreadsheet::ParseExcel::Workbook;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Workbook - A class for Workbooks.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  
  our $VERSION = '0.65';
  
  ###############################################################################
  #
  # new()
  #
  # Constructor.
  #
  sub new {
      my ($class) = @_;
      my $self = {};
      bless $self, $class;
  }
  
  ###############################################################################
  sub color_idx_to_rgb {
      my( $workbook, $iidx ) = @_;
  
      my $palette = $workbook->{aColor};
      return ( ( defined $palette->[$iidx] ) ? $palette->[$iidx] : $palette->[0] );
  }
  
  ###############################################################################
  #
  # worksheet()
  #
  # This method returns a single Worksheet object using either its name or index.
  #
  sub worksheet {
      my ( $oBook, $sName ) = @_;
      my $oWkS;
      foreach $oWkS ( @{ $oBook->{Worksheet} } ) {
          return $oWkS if ( $oWkS->{Name} eq $sName );
      }
      if ( $sName =~ /^\d+$/ ) {
          return $oBook->{Worksheet}->[$sName];
      }
      return undef;
  }
  
  ###############################################################################
  #
  # worksheets()
  #
  # Returns an array of Worksheet objects.
  #
  sub worksheets {
      my $self = shift;
  
      return @{ $self->{Worksheet} };
  }
  
  ###############################################################################
  #
  # worksheet_count()
  #
  # Returns the number Woksheet objects in the Workbook.
  #
  sub worksheet_count {
  
      my $self = shift;
  
      return $self->{SheetCount};
  }
  
  ###############################################################################
  #
  # get_filename()
  #
  # Returns the name of the Excel file of C<undef> if the data was read from a filehandle rather than a file.
  #
  sub get_filename {
  
      my $self = shift;
  
      return $self->{File};
  }
  
  ###############################################################################
  #
  # get_print_areas()
  #
  # Returns an array ref of print areas.
  #
  # TODO. This should really be a Worksheet method.
  #
  sub get_print_areas {
  
      my $self = shift;
  
      return $self->{PrintArea};
  }
  
  ###############################################################################
  #
  # get_print_titles()
  #
  # Returns an array ref of print title hash refs.
  #
  # TODO. This should really be a Worksheet method.
  #
  sub get_print_titles {
  
      my $self = shift;
  
      return $self->{PrintTitle};
  }
  
  ###############################################################################
  #
  # using_1904_date()
  #
  # Returns true if the Excel file is using the 1904 date epoch.
  #
  sub using_1904_date {
  
      my $self = shift;
  
      return $self->{Flg1904};
  }
  
  ###############################################################################
  #
  # ParseAbort()
  #
  # Todo
  #
  sub ParseAbort {
      my ( $self, $val ) = @_;
      $self->{_ParseAbort} = $val;
  }
  
  =head2 get_active_sheet()
  
  Return the number of the active (open) worksheet (at the time the workbook
  was saved.  May return undef.
  
  =cut
  
  sub get_active_sheet {
      my $workbook = shift;
  
      return $workbook->{ActiveSheet};
  }
  
  ###############################################################################
  #
  # Parse(). Deprecated.
  #
  # Syntactic wrapper around Spreadsheet::ParseExcel::Parse().
  # This method is *deprecated* since it doesn't conform to the current
  # error handling in the S::PE Parse() method.
  #
  sub Parse {
  
      my ( $class, $source, $formatter ) = @_;
      my $excel = Spreadsheet::ParseExcel->new();
      my $workbook = $excel->Parse( $source, $formatter );
      $workbook->{_Excel} = $excel;
      return $workbook;
  }
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *Worksheet = *worksheet;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Workbook - A class for Workbooks.
  
  =head1 SYNOPSIS
  
  See the documentation for Spreadsheet::ParseExcel.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for L<Spreadsheet::ParseExcel>.
  
  
  =head1 Methods
  
  The following Workbook methods are available:
  
      $workbook->worksheets()
      $workbook->worksheet()
      $workbook->worksheet_count()
      $workbook->get_filename()
      $workbook->get_print_areas()
      $workbook->get_print_titles()
      $workbook->using_1904_date()
  
  
  =head2 worksheets()
  
  The C<worksheets()> method returns an array of Worksheet objects. This was most commonly used to iterate over the worksheets in a workbook:
  
      for my $worksheet ( $workbook->worksheets() ) {
          ...
      }
  
  
  =head2 worksheet()
  
  The C<worksheet()> method returns a single C<Worksheet> object using either its name or index:
  
      $worksheet = $workbook->worksheet('Sheet1');
      $worksheet = $workbook->worksheet(0);
  
  Returns C<undef> if the sheet name or index doesn't exist.
  
  
  =head2 worksheet_count()
  
  The C<worksheet_count()> method returns the number of Woksheet objects in the Workbook.
  
      my $worksheet_count = $workbook->worksheet_count();
  
  
  =head2 get_filename()
  
  The C<get_filename()> method returns the name of the Excel file of C<undef> if the data was read from a filehandle rather than a file.
  
      my $filename = $workbook->get_filename();
  
  
  =head2 get_print_areas()
  
  The C<get_print_areas()> method returns an array ref of print areas.
  
      my $print_areas = $workbook->get_print_areas();
  
  Each print area is as follows:
  
      [ $start_row, $start_col, $end_row, $end_col ]
  
  Returns undef if there are no print areas.
  
  
  =head2 get_print_titles()
  
  The C<get_print_titles()> method returns an array ref of print title hash refs.
  
      my $print_titles = $workbook->get_print_titles();
  
  Each print title array ref is as follows:
  
      {
          Row    => [ $start_row, $end_row ],
          Column => [ $start_col, $end_col ],
      }
  
  
  Returns undef if there are no print titles.
  
  
  =head2 using_1904_date()
  
  The C<using_1904_date()> method returns true if the Excel file is using the 1904 date epoch instead of the 1900 epoch.
  
      my $using_1904_date = $workbook->using_1904_date();
  
   The Windows version of Excel generally uses the 1900 epoch while the Mac version of Excel generally uses the 1904 epoch.
  
  Returns 0 if the 1900 epoch is in use.
  
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_WORKBOOK

$fatpacked{"Spreadsheet/ParseExcel/Worksheet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPREADSHEET_PARSEEXCEL_WORKSHEET';
  package Spreadsheet::ParseExcel::Worksheet;
  
  ###############################################################################
  #
  # Spreadsheet::ParseExcel::Worksheet - A class for Worksheets.
  #
  # Used in conjunction with Spreadsheet::ParseExcel.
  #
  # Copyright (c) 2014      Douglas Wilson
  # Copyright (c) 2009-2013 John McNamara
  # Copyright (c) 2006-2008 Gabor Szabo
  # Copyright (c) 2000-2006 Kawai Takanori
  #
  # perltidy with standard settings.
  #
  # Documentation after __END__
  #
  
  use strict;
  use warnings;
  use Scalar::Util qw(weaken);
  
  our $VERSION = '0.65';
  
  ###############################################################################
  #
  # new()
  #
  sub new {
  
      my ( $class, %properties ) = @_;
  
      my $self = \%properties;
  
      weaken $self->{_Book};
  
      $self->{Cells}       = undef;
      $self->{DefColWidth} = 8.43;
  
      return bless $self, $class;
  }
  
  ###############################################################################
  #
  # get_cell( $row, $col )
  #
  # Returns the Cell object at row $row and column $col, if defined.
  #
  sub get_cell {
  
      my ( $self, $row, $col ) = @_;
  
      if (   !defined $row
          || !defined $col
          || !defined $self->{MaxRow}
          || !defined $self->{MaxCol} )
      {
  
          # Return undef if no arguments are given or if no cells are defined.
          return undef;
      }
      elsif ($row < $self->{MinRow}
          || $row > $self->{MaxRow}
          || $col < $self->{MinCol}
          || $col > $self->{MaxCol} )
      {
  
          # Return undef if outside allowable row/col range.
          return undef;
      }
      else {
  
          # Return the Cell object.
          return $self->{Cells}->[$row]->[$col];
      }
  }
  
  ###############################################################################
  #
  # row_range()
  #
  # Returns a two-element list ($min, $max) containing the minimum and maximum
  # defined rows in the worksheet.
  #
  # If there is no row defined $max is smaller than $min.
  #
  sub row_range {
  
      my $self = shift;
  
      my $min = $self->{MinRow} || 0;
      my $max = defined( $self->{MaxRow} ) ? $self->{MaxRow} : ( $min - 1 );
  
      return ( $min, $max );
  }
  
  ###############################################################################
  #
  # col_range()
  #
  # Returns a two-element list ($min, $max) containing the minimum and maximum
  # defined cols in the worksheet.
  #
  # If there is no column defined $max is smaller than $min.
  #
  sub col_range {
  
      my $self = shift;
  
      my $min = $self->{MinCol} || 0;
      my $max = defined( $self->{MaxCol} ) ? $self->{MaxCol} : ( $min - 1 );
  
      return ( $min, $max );
  }
  
  ###############################################################################
  #
  # get_name()
  #
  # Returns the name of the worksheet.
  #
  sub get_name {
  
      my $self = shift;
  
      return $self->{Name};
  }
  
  ###############################################################################
  #
  # sheet_num()
  #
  sub sheet_num {
  
      my $self = shift;
  
      return $self->{_SheetNo};
  }
  
  ###############################################################################
  #
  # get_h_pagebreaks()
  #
  # Returns an array ref of row numbers where a horizontal page break occurs.
  #
  sub get_h_pagebreaks {
  
      my $self = shift;
  
      return $self->{HPageBreak};
  }
  
  ###############################################################################
  #
  # get_v_pagebreaks()
  #
  # Returns an array ref of column numbers where a vertical page break occurs.
  #
  sub get_v_pagebreaks {
  
      my $self = shift;
  
      return $self->{VPageBreak};
  }
  
  ###############################################################################
  #
  # get_merged_areas()
  #
  # Returns an array ref of cells that are merged.
  #
  sub get_merged_areas {
  
      my $self = shift;
  
      return $self->{MergedArea};
  }
  
  ###############################################################################
  #
  # get_row_heights()
  #
  # Returns an array of row heights.
  #
  sub get_row_heights {
  
      my $self = shift;
  
      if ( wantarray() ) {
        return unless $self->{RowHeight};
        return @{ $self->{RowHeight} };
      }
      return $self->{RowHeight};
  }
  
  ###############################################################################
  #
  # get_col_widths()
  #
  # Returns an array of column widths.
  #
  sub get_col_widths {
  
      my $self = shift;
  
      if ( wantarray() ) {
        return unless $self->{ColWidth};
        return @{ $self->{ColWidth} };
      }
      return $self->{ColWidth};
  }
  
  ###############################################################################
  #
  # get_default_row_height()
  #
  # Returns the default row height for the worksheet. Generally 12.75.
  #
  sub get_default_row_height {
  
      my $self = shift;
  
      return $self->{DefRowHeight};
  }
  
  ###############################################################################
  #
  # get_default_col_width()
  #
  # Returns the default column width for the worksheet. Generally 8.43.
  #
  sub get_default_col_width {
  
      my $self = shift;
  
      return $self->{DefColWidth};
  }
  
  ###############################################################################
  #
  # _get_row_properties()
  #
  # Returns an array_ref of row properties.
  # TODO. This is a placeholder for a future method.
  #
  sub _get_row_properties {
  
      my $self = shift;
  
      return $self->{RowProperties};
  }
  
  ###############################################################################
  #
  # _get_col_properties()
  #
  # Returns an array_ref of column properties.
  # TODO. This is a placeholder for a future method.
  #
  sub _get_col_properties {
  
      my $self = shift;
  
      return $self->{ColProperties};
  }
  
  ###############################################################################
  #
  # get_header()
  #
  # Returns the worksheet header string.
  #
  sub get_header {
  
      my $self = shift;
  
      return $self->{Header};
  }
  
  ###############################################################################
  #
  # get_footer()
  #
  # Returns the worksheet footer string.
  #
  sub get_footer {
  
      my $self = shift;
  
      return $self->{Footer};
  }
  
  ###############################################################################
  #
  # get_margin_left()
  #
  # Returns the left margin of the worksheet in inches.
  #
  sub get_margin_left {
  
      my $self = shift;
  
      return $self->{LeftMargin};
  }
  
  ###############################################################################
  #
  # get_margin_right()
  #
  # Returns the right margin of the worksheet in inches.
  #
  sub get_margin_right {
  
      my $self = shift;
  
      return $self->{RightMargin};
  }
  
  ###############################################################################
  #
  # get_margin_top()
  #
  # Returns the top margin of the worksheet in inches.
  #
  sub get_margin_top {
  
      my $self = shift;
  
      return $self->{TopMargin};
  }
  
  ###############################################################################
  #
  # get_margin_bottom()
  #
  # Returns the bottom margin of the worksheet in inches.
  #
  sub get_margin_bottom {
  
      my $self = shift;
  
      return $self->{BottomMargin};
  }
  
  ###############################################################################
  #
  # get_margin_header()
  #
  # Returns the header margin of the worksheet in inches.
  #
  sub get_margin_header {
  
      my $self = shift;
  
      return $self->{HeaderMargin};
  }
  
  ###############################################################################
  #
  # get_margin_footer()
  #
  # Returns the footer margin of the worksheet in inches.
  #
  sub get_margin_footer {
  
      my $self = shift;
  
      return $self->{FooterMargin};
  }
  
  ###############################################################################
  #
  # get_paper()
  #
  # Returns the printer paper size.
  #
  sub get_paper {
  
      my $self = shift;
  
      return $self->{PaperSize};
  }
  
  ###############################################################################
  #
  # get_start_page()
  #
  # Returns the page number that printing will start from.
  #
  sub get_start_page {
  
      my $self = shift;
  
      # Only return the page number if the "First page number" option is set.
      if ( $self->{UsePage} ) {
          return $self->{PageStart};
      }
      else {
          return 0;
      }
  }
  
  ###############################################################################
  #
  # get_print_order()
  #
  # Returns the Worksheet page printing order.
  #
  sub get_print_order {
  
      my $self = shift;
  
      return $self->{LeftToRight};
  }
  
  ###############################################################################
  #
  # get_print_scale()
  #
  # Returns the workbook scale for printing.
  #
  sub get_print_scale {
  
      my $self = shift;
  
      return $self->{Scale};
  }
  
  ###############################################################################
  #
  # get_fit_to_pages()
  #
  # Returns the number of pages wide and high that the printed worksheet page
  # will fit to.
  #
  sub get_fit_to_pages {
  
      my $self = shift;
  
      if ( !$self->{PageFit} ) {
          return ( 0, 0 );
      }
      else {
          return ( $self->{FitWidth}, $self->{FitHeight} );
      }
  }
  
  ###############################################################################
  #
  # is_portrait()
  #
  # Returns true if the worksheet has been set for printing in portrait mode.
  #
  sub is_portrait {
  
      my $self = shift;
  
      return $self->{Landscape};
  }
  
  ###############################################################################
  #
  # is_centered_horizontally()
  #
  # Returns true if the worksheet has been centered horizontally for printing.
  #
  sub is_centered_horizontally {
  
      my $self = shift;
  
      return $self->{HCenter};
  }
  
  ###############################################################################
  #
  # is_centered_vertically()
  #
  # Returns true if the worksheet has been centered vertically for printing.
  #
  sub is_centered_vertically {
  
      my $self = shift;
  
      return $self->{HCenter};
  }
  
  ###############################################################################
  #
  # is_print_gridlines()
  #
  # Returns true if the worksheet print "gridlines" option is turned on.
  #
  sub is_print_gridlines {
  
      my $self = shift;
  
      return $self->{PrintGrid};
  }
  
  ###############################################################################
  #
  # is_print_row_col_headers()
  #
  # Returns true if the worksheet print "row and column headings" option is on.
  #
  sub is_print_row_col_headers {
  
      my $self = shift;
  
      return $self->{PrintHeaders};
  }
  
  ###############################################################################
  #
  # is_print_black_and_white()
  #
  # Returns true if the worksheet print "black and white" option is turned on.
  #
  sub is_print_black_and_white {
  
      my $self = shift;
  
      return $self->{NoColor};
  }
  
  ###############################################################################
  #
  # is_print_draft()
  #
  # Returns true if the worksheet print "draft" option is turned on.
  #
  sub is_print_draft {
  
      my $self = shift;
  
      return $self->{Draft};
  }
  
  ###############################################################################
  #
  # is_print_comments()
  #
  # Returns true if the worksheet print "comments" option is turned on.
  #
  sub is_print_comments {
  
      my $self = shift;
  
      return $self->{Notes};
  }
  
  =head2 get_tab_color()
  
  Return color index of tab, or undef if not set.
  
  =cut
  
  sub get_tab_color {
      my $worksheet = shift;
  
      return $worksheet->{TabColor};
  }
  
  =head2 is_sheet_hidden()
  
  Return true if sheet is hidden
  
  =cut
  
  sub is_sheet_hidden {
      my $worksheet = shift;
  
      return $worksheet->{SheetHidden};
  }
  
  =head2 is_row_hidden($row)
  
  In scalar context, return true if $row is hidden
  In array context, return an array whose elements are true
  if the corresponding row is hidden.
  
  =cut
  
  sub is_row_hidden {
      my $worksheet = shift;
  
      my ($row) = @_;
  
      unless ( $worksheet->{RowHidden} ) {
          return () if (wantarray);
          return 0;
      }
  
      return @{ $worksheet->{RowHidden} } if (wantarray);
      return $worksheet->{RowHidden}[$row];
  }
  
  =head2 is_col_hidden($col)
  
  In scalar context, return true if $col is hidden
  In array context, return an array whose elements are true
  if the corresponding column is hidden.
  
  =cut
  
  sub is_col_hidden {
      my $worksheet = shift;
  
      my ($col) = @_;
  
      unless ( $worksheet->{ColHidden} ) {
          return () if (wantarray);
          return 0;
      }
  
      return @{ $worksheet->{ColHidden} } if (wantarray);
      return $worksheet->{ColHidden}[$col];
  }
  
  ###############################################################################
  #
  # Mapping between legacy method names and new names.
  #
  {
      no warnings;    # Ignore warnings about variables used only once.
      *sheetNo  = *sheet_num;
      *Cell     = *get_cell;
      *RowRange = *row_range;
      *ColRange = *col_range;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Spreadsheet::ParseExcel::Worksheet - A class for Worksheets.
  
  =head1 SYNOPSIS
  
  See the documentation for L<Spreadsheet::ParseExcel>.
  
  =head1 DESCRIPTION
  
  This module is used in conjunction with Spreadsheet::ParseExcel. See the documentation for Spreadsheet::ParseExcel.
  
  =head1 Methods
  
  The C<Spreadsheet::ParseExcel::Worksheet> class encapsulates the properties of an Excel worksheet. It has the following methods:
  
      $worksheet->get_cell()
      $worksheet->row_range()
      $worksheet->col_range()
      $worksheet->get_name()
      $worksheet->get_h_pagebreaks()
      $worksheet->get_v_pagebreaks()
      $worksheet->get_merged_areas()
      $worksheet->get_row_heights()
      $worksheet->get_col_widths()
      $worksheet->get_default_row_height()
      $worksheet->get_default_col_width()
      $worksheet->get_header()
      $worksheet->get_footer()
      $worksheet->get_margin_left()
      $worksheet->get_margin_right()
      $worksheet->get_margin_top()
      $worksheet->get_margin_bottom()
      $worksheet->get_margin_header()
      $worksheet->get_margin_footer()
      $worksheet->get_paper()
      $worksheet->get_start_page()
      $worksheet->get_print_order()
      $worksheet->get_print_scale()
      $worksheet->get_fit_to_pages()
      $worksheet->is_portrait()
      $worksheet->is_centered_horizontally()
      $worksheet->is_centered_vertically()
      $worksheet->is_print_gridlines()
      $worksheet->is_print_row_col_headers()
      $worksheet->is_print_black_and_white()
      $worksheet->is_print_draft()
      $worksheet->is_print_comments()
  
  
  =head2 get_cell($row, $col)
  
  Return the L</Cell> object at row C<$row> and column C<$col> if it is defined. Otherwise returns undef.
  
      my $cell = $worksheet->get_cell($row, $col);
  
  =head2 row_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum defined rows in the worksheet. If there is no row defined C<$max> is smaller than C<$min>.
  
      my ( $row_min, $row_max ) = $worksheet->row_range();
  
  =head2 col_range()
  
  Returns a two-element list C<($min, $max)> containing the minimum and maximum of defined columns in the worksheet. If there is no column defined C<$max> is smaller than C<$min>.
  
      my ( $col_min, $col_max ) = $worksheet->col_range();
  
  
  =head2 get_name()
  
  The C<get_name()> method returns the name of the worksheet.
  
      my $name = $worksheet->get_name();
  
  
  =head2 get_h_pagebreaks()
  
  The C<get_h_pagebreaks()> method returns an array ref of row numbers where a horizontal page break occurs.
  
      my $h_pagebreaks = $worksheet->get_h_pagebreaks();
  
  Returns C<undef> if there are no pagebreaks.
  
  
  =head2 get_v_pagebreaks()
  
  The C<get_v_pagebreaks()> method returns an array ref of column numbers where a vertical page break occurs.
  
      my $v_pagebreaks = $worksheet->get_v_pagebreaks();
  
  Returns C<undef> if there are no pagebreaks.
  
  
  =head2 get_merged_areas()
  
  The C<get_merged_areas()> method returns an array ref of cells that are merged.
  
      my $merged_areas = $worksheet->get_merged_areas();
  
  Each merged area is represented as follows:
  
      [ $start_row, $start_col, $end_row, $end_col]
  
  Returns C<undef> if there are no merged areas.
  
  
  =head2 get_row_heights()
  
  The C<get_row_heights()> method returns an array_ref of row heights in scalar context,
  and an array in list context.
  
      my $row_heights = $worksheet->get_row_heights();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_col_widths()
  
  The C<get_col_widths()> method returns an array_ref of column widths in scalar context,
  and an array in list context.
  
      my $col_widths = $worksheet->get_col_widths();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_default_row_height()
  
  The C<get_default_row_height()> method returns the default row height for the worksheet. Generally 12.75.
  
      my $default_row_height = $worksheet->get_default_row_height();
  
  
  =head2 get_default_col_width()
  
  The C<get_default_col_width()> method returns the default column width for the worksheet. Generally 8.43.
  
      my $default_col_width = $worksheet->get_default_col_width();
  
  
  =head2 get_header()
  
  The C<get_header()> method returns the worksheet header string. This string can contain control codes for alignment and font properties. Refer to the Excel on-line help on headers and footers or to the Spreadsheet::WriteExcel documentation for set_header().
  
      my $header = $worksheet->get_header();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_footer()
  
  The C<get_footer()> method returns the worksheet footer string. This string can contain control codes for alignment and font properties. Refer to the Excel on-line help on headers and footers or to the Spreadsheet::WriteExcel documentation for set_header().
  
      my $footer = $worksheet->get_footer();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_left()
  
  The C<get_margin_left()> method returns the left margin of the worksheet in inches.
  
      my $margin_left = $worksheet->get_margin_left();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_right()
  
  The C<get_margin_right()> method returns the right margin of the worksheet in inches.
  
      my $margin_right = $worksheet->get_margin_right();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_top()
  
  The C<get_margin_top()> method returns the top margin of the worksheet in inches.
  
      my $margin_top = $worksheet->get_margin_top();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_bottom()
  
  The C<get_margin_bottom()> method returns the bottom margin of the worksheet in inches.
  
      my $margin_bottom = $worksheet->get_margin_bottom();
  
  Returns C<undef> if the property isn't set.
  
  
  =head2 get_margin_header()
  
  The C<get_margin_header()> method returns the header margin of the worksheet in inches.
  
      my $margin_header = $worksheet->get_margin_header();
  
  Returns a default value of 0.5 if not set.
  
  
  =head2 get_margin_footer()
  
  The C<get_margin_footer()> method returns the footer margin of the worksheet in inches.
  
      my $margin_footer = $worksheet->get_margin_footer();
  
  Returns a default value of 0.5 if not set.
  
  
  =head2 get_paper()
  
  The C<get_paper()> method returns the printer paper size.
  
      my $paper = $worksheet->get_paper();
  
  The value corresponds to the formats shown below:
  
      Index   Paper format            Paper size
      =====   ============            ==========
        0     Printer default         -
        1     Letter                  8 1/2 x 11 in
        2     Letter Small            8 1/2 x 11 in
        3     Tabloid                 11 x 17 in
        4     Ledger                  17 x 11 in
        5     Legal                   8 1/2 x 14 in
        6     Statement               5 1/2 x 8 1/2 in
        7     Executive               7 1/4 x 10 1/2 in
        8     A3                      297 x 420 mm
        9     A4                      210 x 297 mm
       10     A4 Small                210 x 297 mm
       11     A5                      148 x 210 mm
       12     B4                      250 x 354 mm
       13     B5                      182 x 257 mm
       14     Folio                   8 1/2 x 13 in
       15     Quarto                  215 x 275 mm
       16     -                       10x14 in
       17     -                       11x17 in
       18     Note                    8 1/2 x 11 in
       19     Envelope  9             3 7/8 x 8 7/8
       20     Envelope 10             4 1/8 x 9 1/2
       21     Envelope 11             4 1/2 x 10 3/8
       22     Envelope 12             4 3/4 x 11
       23     Envelope 14             5 x 11 1/2
       24     C size sheet            -
       25     D size sheet            -
       26     E size sheet            -
       27     Envelope DL             110 x 220 mm
       28     Envelope C3             324 x 458 mm
       29     Envelope C4             229 x 324 mm
       30     Envelope C5             162 x 229 mm
       31     Envelope C6             114 x 162 mm
       32     Envelope C65            114 x 229 mm
       33     Envelope B4             250 x 353 mm
       34     Envelope B5             176 x 250 mm
       35     Envelope B6             176 x 125 mm
       36     Envelope                110 x 230 mm
       37     Monarch                 3.875 x 7.5 in
       38     Envelope                3 5/8 x 6 1/2 in
       39     Fanfold                 14 7/8 x 11 in
       40     German Std Fanfold      8 1/2 x 12 in
       41     German Legal Fanfold    8 1/2 x 13 in
       256    User defined
  
  The two most common paper sizes are C<1 = "US Letter"> and C<9 = A4>. Returns 9 by default.
  
  
  =head2 get_start_page()
  
  The C<get_start_page()> method returns the page number that printing will start from.
  
      my $start_page = $worksheet->get_start_page();
  
  Returns 0 if the property isn't set.
  
  
  =head2 get_print_order()
  
  The C<get_print_order()> method returns 0 if the worksheet print "page order" is "Down then over" (the default) or 1 if it is "Over then down".
  
      my $print_order = $worksheet->get_print_order();
  
  
  =head2 get_print_scale()
  
  The C<get_print_scale()> method returns the workbook scale for printing. The print scale factor can be in the range 10 .. 400.
  
      my $print_scale = $worksheet->get_print_scale();
  
  Returns 100 by default.
  
  
  =head2 get_fit_to_pages()
  
  The C<get_fit_to_pages()> method returns the number of pages wide and high that the printed worksheet page will fit to.
  
      my ($pages_wide, $pages_high) = $worksheet->get_fit_to_pages();
  
  Returns (0, 0) if the property isn't set.
  
  
  =head2 is_portrait()
  
  The C<is_portrait()> method returns true if the worksheet has been set for printing in portrait mode.
  
      my $is_portrait = $worksheet->is_portrait();
  
  Returns 0 if the worksheet has been set for printing in horizontal mode.
  
  
  =head2 is_centered_horizontally()
  
  The C<is_centered_horizontally()> method returns true if the worksheet has been centered horizontally for printing.
  
      my $is_centered_horizontally = $worksheet->is_centered_horizontally();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_centered_vertically()
  
  The C<is_centered_vertically()> method returns true if the worksheet has been centered vertically for printing.
  
      my $is_centered_vertically = $worksheet->is_centered_vertically();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_gridlines()
  
  The C<is_print_gridlines()> method returns true if the worksheet print "gridlines" option is turned on.
  
      my $is_print_gridlines = $worksheet->is_print_gridlines();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_row_col_headers()
  
  The C<is_print_row_col_headers()> method returns true if the worksheet print "row and column headings" option is turned on.
  
      my $is_print_row_col_headers = $worksheet->is_print_row_col_headers();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_black_and_white()
  
  The C<is_print_black_and_white()> method returns true if the worksheet print "black and white" option is turned on.
  
      my $is_print_black_and_white = $worksheet->is_print_black_and_white();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_draft()
  
  The C<is_print_draft()> method returns true if the worksheet print "draft" option is turned on.
  
      my $is_print_draft = $worksheet->is_print_draft();
  
  Returns 0 if the property isn't set.
  
  
  =head2 is_print_comments()
  
  The C<is_print_comments()> method returns true if the worksheet print "comments" option is turned on.
  
      my $is_print_comments = $worksheet->is_print_comments();
  
  Returns 0 if the property isn't set.
  
  
  =head1 AUTHOR
  
  Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
  
  Maintainer 0.40-0.59: John McNamara jmcnamara@cpan.org
  
  Maintainer 0.27-0.33: Gabor Szabo szabgab@cpan.org
  
  Original author: Kawai Takanori kwitknr@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) 2014 Douglas Wilson
  
  Copyright (c) 2009-2013 John McNamara
  
  Copyright (c) 2006-2008 Gabor Szabo
  
  Copyright (c) 2000-2006 Kawai Takanori
  
  All rights reserved.
  
  You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl README file.
  
  =cut
SPREADSHEET_PARSEEXCEL_WORKSHEET

$fatpacked{"Term/Emit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_EMIT';
  # Term::Emit - Print with indentation, status, and closure
  #
  #  $Id: Emit.pm 395 2012-09-06 18:21:50Z steve $
  
  package Term::Emit;
  use warnings;
  use strict;
  use 5.008;
  
  use Exporter;
  use base qw/Exporter/;
  use Scope::Upper 0.06 qw/:words reap/;
  
  our $VERSION   = '0.0.4';
  our @EXPORT_OK = qw/emit emit_over emit_prog emit_text emit_done emit_none
      emit_emerg
      emit_alert
      emit_crit emit_fail emit_fatal
      emit_error
      emit_warn
      emit_note
      emit_info emit_ok
      emit_debug
      emit_notry
      emit_unk
      emit_yes
      emit_no/;
  our %EXPORT_TAGS = (all => [@EXPORT_OK]);
  
  use constant MIN_SEV => 0;
  use constant MAX_SEV => 15;
  our %SEVLEV = (
      EMERG => 15,
      ALERT => 13,
      CRIT  => 11,
      FAIL  => 11,
      FATAL => 11,
      ERROR => 9,
      WARN  => 7,
      NOTE  => 6,
      INFO  => 5,
      OK    => 5,
      DEBUG => 4,
      NOTRY => 3,
      UNK   => 2,
      OTHER => 1,
      YES   => 1,
      NO    => 0,
  );
  our %BASE_OBJECT = ();
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;    # Get the class name
      my $this  = {
          pos     => 0,                     # Current output column number
          progwid => 0,                     # Width of last progress message emitted
          msgs    => []
      };    # Closing message stack
      bless $this, $class;
      $this->setopts(@_);
      return $this;
  }
  
  sub base {
      my ($this) = _process_args(@_);
      return $this;
  }
  
  sub clone {
      my $this = shift;    # Object to clone
      return Term::Emit->new(%{$this}, _clean_opts(@_));
  }
  
  sub import {
      my $class = shift;
  
      # Yank option sets, if any, out from the arguments
      my %opts = ();
      my @args = ();
      while (@_) {
          my $arg = shift;
          if (ref($arg) eq 'HASH') {
              %opts = (%opts, %{$arg});    #merge
              next;
          }
          push @args, $arg;
      }
      %opts = _clean_opts(%opts);
  
      # Create the default base object
      $BASE_OBJECT{0} ||= new Term::Emit(%opts);
  
      # Continue exporter's work
      return $class->export_to_level(1, $class, @args);
  }
  
  #
  # Set options
  #
  sub setopts {
      my ($this, $opts, %args) = _process_args(@_);
  
      # Merge & clean 'em
      %args = (%{$opts}, %args);
      %args = _clean_opts(%args);    ###why does this not work here?? -fh vs fh
  
      # Process args
      my $deffh = select();
      no strict 'refs';
      $this->{fh} 
          = $args{fh}
          || $this->{fh}
          || \*{$deffh};
      use strict 'refs';
      $this->{envbase} 
          = $args{envbase}
          || $this->{envbase}
          || 'term_emit_fd';    ### TODO: apply to all envvars we use, not just _fd
      $this->{bullets}
          = exists $ENV{term_emit_bullets} ? $ENV{term_emit_bullets}
          : exists $args{bullets}          ? $args{bullets}
          : exists $this->{bullets}        ? $this->{bullets}
          :                                  0;
      $this->{closestat} 
          = $args{closestat}
          || $this->{closestat}
          || 'DONE';
      $this->{color}
          = exists $ENV{term_emit_color}
          ? $ENV{term_emit_color}
          : $args{color}
          || $this->{color}
          || 0;
      $this->{ellipsis}
          = exists $ENV{term_emit_ellipsis}
          ? $ENV{term_emit_ellipsis}
          : $args{ellipsis}
          || $this->{ellipsis}
          || '...';
      $this->{maxdepth}
          = exists $ENV{term_emit_maxdepth} ? $ENV{term_emit_maxdepth}
          : exists $args{maxdepth}          ? $args{maxdepth}
          :   $this->{maxdepth};    #undef=all, 0=none, 3=just first 3 levels, etc
      $this->{showseverity}
          = exists $ENV{term_emit_showseverity} ? $ENV{term_emit_showseverity}
          : exists $args{showseverity}          ? $args{showseverity}
          :                                  $this->{showseverity};
      $this->{step}
          = exists $ENV{term_emit_step} ? $ENV{term_emit_step}
          : exists $args{step}          ? $args{step}
          : defined $this->{step}       ? $this->{step}
          :                               2;
      $this->{timestamp} = $args{timestamp}
          || $this->{timestamp}
          || 0;
      $this->{trailer}
          = exists $ENV{term_emit_trailer}
          ? $ENV{term_emit_trailer}
          : $args{trailer}
          || $this->{trailer}
          || q{.};
      $this->{width}
          = exists $ENV{term_emit_width}
          ? $ENV{term_emit_width}
          : $args{width}
          || $this->{width}
          || 80;
  
      #    $this->{timefmt}   = $args{timefmt}   || $this->{timefmt}   || undef;   # Timestamp format
      #    $this->{pos} = $args{pos}
      #        if defined $args{pos};
  
      # Recompute a few things
      # TODO: Allow bullets to be given as CSV:  "* ,+ ,- ,  " for example.
      # TODO: Put this in a sub of its own.
      $this->{bullet_width} = 0;
      if (ref $this->{bullets} eq 'ARRAY') {
          foreach my $b (@{$this->{bullets}}) {
              $this->{bullet_width} = length($b)
                  if length($b) > $this->{bullet_width};
          }
      }
      elsif ($this->{bullets}) {
          $this->{bullet_width} = length($this->{bullets});
  
          return 0;
      }
  }
  
  #
  # Emit a message, starting a new level
  #
  sub emit {
      my ($this, $opts, @args) = _process_args(@_);
      my $jn = defined $, ? $, : q{};
      if (@args && ref($args[0]) eq 'ARRAY') {
  
          # Using [opentext, closetext] notation
          my $pair  = shift @args;
          my $otext = $pair->[0] || '';
          my $ctext = $pair->[1] || $otext;
          unshift @args, $otext;
          $opts->{closetext} = $ctext;
      }
      my $msg = join $jn, @args;
      if (!@args) {
  
          # Use our caller's subroutine name as the message
          (undef, undef, undef, $msg) = caller(1);
          $msg =~ s{^main::}{}sxm;
      }
  
      #  Tied closure:
      #   If we're returning into a list context,
      #   then we're tying closure to the scope of the caller's list element.
      return Term::Emit::TiedClosure->new($this, $opts, $msg)
          if wantarray;
  
      # Store context
      my $cmsg
          = defined $opts->{closetext}
          ? $opts->{closetext}
          : $msg;
      push @{$this->{msgs}}, [$msg, $cmsg];
      my $level = $ENV{$this->_envvar()}++ || 0;
  
      # Setup the scope reaper for autoclosure
      reap sub {
          $this->emit_done({%{$opts}, want_level => $level}, $this->{closestat});
      } => SCOPE(1);
  
      # Filtering by level?
      return 1
          if defined($this->{maxdepth}) && $level >= $this->{maxdepth};
  
      # Start back at the left
      my $s = 1;
      $s = $this->_spew("\n")
          if $this->{pos};
      return $s unless $s;
      $this->{pos}     = 0;
      $this->{progwid} = 0;
  
      # Level adjust?
      $level += $opts->{adjust_level}
          if $opts->{adjust_level} && $opts->{adjust_level} =~ m{^-?\d+$}sxm;
  
      # Timestamp
      my $tsr = defined $opts->{timestamp}? $opts->{timestamp} : $this->{timestamp};
      $tsr = \&_timestamp if $tsr && !ref($tsr);
      my $ts = $tsr? &$tsr($level) : q{};
  
      # The message
      my $bullet = $this->_bullet($level);
      my $indent = q{ } x ($this->{step} * $level);
      my $tlen   = 0;
      my $span   = $this->{width} - length($ts) - length($bullet) - ($this->{step} * $level) - 10;
      my @mlines = _wrap($msg, int($span * 2 / 3), $span);
      while (defined(my $txt = shift @mlines)) {
          $s = $this->_spew($ts . $bullet . $indent . $txt);
          return $s unless $s;
          $s = $this->_spew(@mlines ? "\n" : $this->{ellipsis});
          return $s unless $s;
          $tlen   = length($txt);
          $bullet = q{ } x $this->{bullet_width};    # Only bullet the first line
          $ts     = q{ } x length($ts);              # Only timestamp the first line
      }
      $this->{pos} += length($ts) + ($this->{step} * $level) + length($bullet) + $tlen + length($this->{ellipsis});
      return 1;
  }
  
  #
  # Complete the current level, with status
  #
  sub emit_done {
      my ($this, $opts, @args) = _process_args(@_);
      my $want_level = $opts->{want_level};
      my $sev        = shift @args || 'DONE';
      my $sevlev     = defined $SEVLEV{uc $sev}? $SEVLEV{uc $sev} : $SEVLEV{'OTHER'};
  
      # Test that we're at the right level - do this BEFORE changing the envvar
      my $ret_level = ($ENV{$this->_envvar()} || 0) - 1;
      return
          if defined $want_level && $ret_level != $want_level;
  
      # Decrement level
      return $sevlev
          if !$ENV{$this->_envvar()};
      my $level = --$ENV{$this->_envvar()};
      delete $ENV{$this->_envvar()}
          if $level <= 0;
  
      # Filtering - level & severity
      my $showseverity
          = defined $opts->{showseverity}  ? $opts->{showseverity}
          : defined($this->{showseverity}) ? $this->{showseverity}
          :                             MAX_SEV;
      if (   $sevlev < $showseverity
          && defined($this->{maxdepth})
          && $level >= $this->{maxdepth})
      {
          pop @{$this->{msgs}};    # discard it
          return $sevlev;
      }
  
      # Are we silently closing this level?
      if ($opts->{silent}) {
          my $s = 1;
          $s = $this->_spew("\n")
              if $this->{pos};
          return $s unless $s;
          $this->{pos}     = 0;
          $this->{progwid} = 0;
          pop @{$this->{msgs}};    # discard it
          return $sevlev;
      }
  
      # Make the severity text
      my $sevstr = " [$sev]\n";
      my $slen   = 8;              # make left justified within max width 3+5
      $sevstr = " [" . _colorize($sev, $sev) . "]\n"
          if $this->{color};
  
      # Re-issue message if needed
      my $msgs = pop @{$this->{msgs}};
      my ($omsg, $cmsg) = @{$msgs};    # Opening and closing messages
                                       # -(if not the same, force a re-issue)-
      if ($this->{pos} && ($omsg ne $cmsg)) {
          # Closing differs from opening, so we need to re-issue with the closing
          my $s = $this->_spew("\n");
          return $s unless $s;
          $this->{pos} = 0;
      }
      if ($this->{pos} 
          && defined($this->{maxdepth})
          && $level >= $this->{maxdepth}) {
          # This would be level-filtered, but severity overrode it, so we need to re-issue
          my $s = $this->_spew("\n");
          return $s unless $s;
          $this->{pos} = 0;
      }
      if ($this->{pos} == 0) {
          # Timestamp
          my $tsr = defined $opts->{timestamp}? $opts->{timestamp} : $this->{timestamp};
          $tsr = \&_timestamp if $tsr && !ref($tsr);
          my $ts = $tsr? &$tsr($level) : q{};
  
          my $bullet = $this->_bullet($level);
          my $indent = q{ } x ($this->{step} * $level);
          my $tlen   = 0;
          my $span   = $this->{width} - length($ts) - ($this->{step} * $level) - 10;
          my @mlines = _wrap($cmsg, int($span * 2 / 3), $span);
          while (defined(my $txt = shift @mlines)) {
              my $s;
              $s = $this->_spew($ts . $bullet . $indent . $txt);
              return $s unless $s;
              $s = $this->_spew("\n")
                  if @mlines;
              return $s unless $s;
              $tlen   = length($txt);
              $bullet = q{ } x $this->{bullet_width};    # Only bullet the first line
              $ts     = q{ } x length($ts);              # Only timestamp the first line
          }
          $this->{pos} += length($ts) + length($bullet) + ($this->{step} * $level) + $tlen;
      }
  
      # Trailer
      my $ndots = $this->{width} - $this->{pos} - $slen;
      my $s     = 1;
      $s = $this->_spew($this->{trailer} x $ndots)
          if $ndots > 0;
      return $s unless $s;
  
      # Severity
      $s = $this->_spew($sevstr);
      return $s unless $s;
      $this->{pos} = 0;
  
      # Reason option?
      my $reason = $opts->{reason};
      $opts->{force} = 1; # Always give reason if we got thru above level filtering
      $s = emit_text($opts, $reason)
          if $reason;
      return $s unless $s;
  
      # Return with a severity value
      return $sevlev;
  }
  
  #
  # Progress output
  #
  sub emit_over {
      my ($this, $opts, @args) = _process_args(@_);
  
      # Filtering by level?
      my $level = $ENV{$this->_envvar()} || 0;
      return 1
          if defined($this->{maxdepth}) && $level > $this->{maxdepth};
  
      # Erase prior progress output
      my $s = 1;
      $s = $this->_spew(qq{\b} x $this->{progwid});
      return $s unless $s;
      $s = $this->_spew(q{ } x $this->{progwid});
      return $s unless $s;
      $s = $this->_spew(qq{\b} x $this->{progwid});
      return $s unless $s;
      $this->{pos} -= $this->{progwid};
      $this->{progwid} = 0;
  
      return $this->emit_prog(@args);
  }
  
  sub emit_prog {
      my ($this, $opts, @args) = _process_args(@_);
      my $jn = defined $, ? $, : q{};
      my $msg = join $jn, @args;
      my $s;
  
      # Filtering by level?
      my $level = $ENV{$this->_envvar()} || 0;
      return 1
          if defined($this->{maxdepth}) && $level > $this->{maxdepth};
  
      # Start a new line?
      my $avail = $this->{width} - $this->{pos} - 10;
      if (length($msg) > $avail) {
          my $level  = $ENV{$this->_envvar()};
          my $bspace = q{ } x $this->{bullet_width};
          my $indent = q{ } x ($this->{step} * $level);
          $s = $this->_spew("\n");
          return $s unless $s;
          $s = $this->_spew($bspace . $indent);
          return $s unless $s;
          $this->{pos}     = length($bspace) + length($indent);
          $this->{progwid} = 0;
      }
  
      # The text
      $s = $this->_spew($msg);
      return $s unless $s;
      $this->{pos}     += length($msg);
      $this->{progwid} += length($msg);
  
      return 1;
  }
  
  #
  # Issue additional info at the current level
  #
  sub emit_text {
      my ($this, $opts, @args) = _process_args(@_);
      my $jn = defined $, ? $, : q{};
      my $msg = join $jn, @args;
  
      # Filtering by level?
      my $level = $ENV{$this->_envvar()} || 0;
      return 1
          if !$opts->{force} && defined($this->{maxdepth}) && $level > $this->{maxdepth};
  
      # Start a new line
      my $s = 1;
      $s = $this->_spew("\n")
          if $this->{pos};
      return $s unless $s;
  
      # Level adjust?
      $level++;    # We're over by one by default
      $level += $opts->{adjust_level}
          if $opts->{adjust_level} && $opts->{adjust_level} =~ m{^-?\d+$}sxm;
  
      # Emit the text
      my $indent = q{ } x ($this->{step} * $level);
      my $span = $this->{width} - ($this->{step} * $level) - 10;
      my @mlines = _wrap($msg, int($span * 2 / 3), $span);
      while (defined(my $txt = shift @mlines)) {
          my $bspace = q{ } x $this->{bullet_width};
          $s = $this->_spew($bspace . $indent . $txt . "\n");
          return $s unless $s;
          $this->{pos} = 0;
      }
      return 1;
  }
  
  sub emit_emerg {emit_done @_, "EMERG"};    # syslog: Off the scale!
  sub emit_alert {emit_done @_, "ALERT"};    # syslog: A major subsystem is unusable.
  sub emit_crit  {emit_done @_, "CRIT"};     # syslog: a critical subsystem is not working entirely.
  sub emit_fail  {emit_done @_, "FAIL"};     # Failure
  sub emit_fatal {emit_done @_, "FATAL"};    # Fatal error
  sub emit_error {emit_done @_, "ERROR"};    # syslog 'err': Bugs, bad data, files not found, ...
  sub emit_warn  {emit_done @_, "WARN"};     # syslog 'warning'
  sub emit_note  {emit_done @_, "NOTE"};     # syslog 'notice'
  sub emit_info  {emit_done @_, "INFO"};     # syslog 'info'
  sub emit_ok    {emit_done @_, "OK"};       # copacetic
  sub emit_debug {emit_done @_, "DEBUG"};    # syslog: Really boring diagnostic output.
  sub emit_notry {emit_done @_, "NOTRY"};    # Untried
  sub emit_unk   {emit_done @_, "UNK"};      # Unknown
  sub emit_yes   {emit_done @_, "YES"};      # Yes
  sub emit_no    {emit_done @_, "NO"};       # No
  sub emit_none  {emit_done {-silent => 1}, @_, "NONE"}
  # *Special* closes level quietly (prints no wrapup severity)
  
  #
  # Return the bullet string for the given level
  #
  sub _bullet {
      my ($this, $level) = @_;
      my $bullet = q{};
      if (ref($this->{bullets}) eq 'ARRAY') {
          my $pmax = $#{$this->{bullets}};
          $bullet = $this->{bullets}->[$level > $pmax ? $pmax : $level];
      }
  
      # TODO: Allow bullets to be given as CSV:  "* ,+ ,- ,  " for example.
      elsif ($this->{bullets}) {
          $bullet = $this->{bullets};
      }
      else {
          return q{};
      }
      my $pad = q{ } x ($this->{bullet_width} - length($bullet));
      return $bullet . $pad;
  }
  
  #
  # Clean option keys
  #
  sub _clean_opts {
      my %in  = @_;
      my %out = ();
      foreach my $k (keys %in) {
          my $v = $in{$k};
          delete $in{$k};
          $k =~ s{^\s*-?(\w+)\s*}{$1}sxm;
          $out{lc $k} = $v;
      }
      return %out;
  }
  
  #
  # Add ANSI color to a string, if ANSI is enabled
  ### TODO:  use Term::ANSIColor, a standard module (verify what perl version introduced it, tho)
  #
  sub _colorize {
      my ($str, $sev) = @_;
      my $zon  = q{};
      my $zoff = q{};
      $zon = chr(27) . '[1;31;40m' if $sev =~ m{\bEMERG(ENCY)?}i;        #bold red on black
      $zon = chr(27) . '[1;35m'    if $sev =~ m{\bALERT\b}i;             #bold magenta
      $zon = chr(27) . '[1;31m'    if $sev =~ m{\bCRIT(ICAL)?\b}i;       #bold red
      $zon = chr(27) . '[1;31m'    if $sev =~ m{\bFAIL(URE)?\b}i;        #bold red
      $zon = chr(27) . '[1;31m'    if $sev =~ m{\bFATAL\b}i;             #bold red
      $zon = chr(27) . '[31m'      if $sev =~ m{\bERR(OR)?\b}i;          #red
      $zon = chr(27) . '[33m'      if $sev =~ m{\bWARN(ING)?\b}i;        #yellow
      $zon = chr(27) . '[36m'      if $sev =~ m{\bNOTE\b}i;              #cyan
      $zon = chr(27) . '[32m'      if $sev =~ m{\bINFO(RMATION)?\b}i;    #green
      $zon = chr(27) . '[1;32m'    if $sev =~ m{\bOK\b}i;                #bold green
      $zon = chr(27) . '[37;43m'   if $sev =~ m{\bDEBUG\b}i;             #grey on yellow
      $zon = chr(27) . '[30;47m'   if $sev =~ m{\bNOTRY\b}i;             #black on grey
      $zon = chr(27) . '[1;37;47m' if $sev =~ m{\bUNK(OWN)?\b}i;         #bold white on gray
      $zon = chr(27) . '[32m'      if $sev =~ m{\bYES\b}i;               #green
      $zon = chr(27) . '[31m'      if $sev =~ m{\bNO\b}i;                #red
      $zoff = chr(27) . '[0m' if $zon;
      return $zon . $str . $zoff;
  }
  
  #
  # The level's envvar for this filehandle
  #
  sub _envvar {
      my $this = shift;
      return $this->{envbase} . _oid($this->{fh});
  }
  
  # Return an output identifier for the filehandle
  #
  sub _oid {
      my $fh = shift;
      return 'str' if ref($fh) eq 'SCALAR';
      return 0 if ref($fh);
      return fileno($fh || q{}) || 0;
  }
  
  #
  # Figure out what was passed to us
  #
  #   Each $BASE_OBJECT in the hash is associated with one output ID (the oid).
  #    The oid is just the fileno() of the file handle for normal output,
  #    or the special text "str" when output is to a scalar string reference.
  #    That's why we use a base object _hash_ instead of an array.
  #   The $BASE_OBJECT{0} is the default one.  It's equivalent to whatever
  #    oid was specified in the "use Term::Emit ... {-fh=>$blah}" which typically
  #    is STDOUT (oid=1) but may be anything.
  #
  #   So what're we doing here?  We have to figure out which base object to use.
  #   Our subs can be called four ways:
  #       A) emit "blah";
  #       B) emit *LOG, "blah";
  #       C) $tobj->emit "blah";
  #       D) $tobj->emit *LOG, "blah";
  #   Also note that "emit {-fh=>*LOG},..." is considered equivalent to case B,
  #   while "$tobj->emit {-fh=>*LOG},..." is considered equivalent to case D.
  #
  #   In case A, we simply use the default base object $BASE_OBJECT{0}.
  #   In case B, we get the oid of *LOG and use that base object.
  #       If the base object does not exist, then we make one,
  #       cloning it from base object 0 but overriding with the file handle.
  #   In case C, we use the base object $tobj - this is classic OO perl.
  #   In case D, it's like case B except that if we have to make a new
  #       base object, we clone from $tobj instead of base object 0.
  #
  sub _process_args {
      my $this = ref($_[0]) eq __PACKAGE__ ? shift : $BASE_OBJECT{0};
      my $oid = _oid($_[0]);
      if ($oid) {
  
          # We're given a filehandle or scalar ref for output.
          #   Find the associated base object or make a new one for it
          my $fh = shift;
          if ($fh eq $BASE_OBJECT{0}->{fh}) {
  
              # Use base object 0, 'cuz it matches
              $oid = 0;
          }
          elsif (!exists $BASE_OBJECT{$oid}) {
              $BASE_OBJECT{$oid} = $this->clone(-fh => $fh);
          }
          $this = $BASE_OBJECT{$oid};
      }
      my $opts = {};
      if (ref($_[0]) eq 'HASH') {
          $opts = {_clean_opts(%{shift()})};
      }
      return ($this, $opts, @_);
  }
  
  #
  # Emit output to filehandle, string, whatever...
  #
  sub _spew {
      my $this = shift;
      my $out  = shift;
      my $fh   = $this->{fh};
      return ref($fh) eq 'SCALAR' ? ${$fh} .= $out : print {$fh} $out;
  }
  
  #
  # Default timestamp 
  #
  sub _timestamp {
      my $level = shift; #fwiw
      my ($s, $m, $h) = localtime(time());
      return sprintf "%2.2d:%2.2d:%2.2d ", $h, $m, $s;
  }
  
  #
  # Wrap text to fit within line lengths
  #   (Do we want to delete this and add a dependency to Text::Wrap ??)
  #
  sub _wrap {
      my ($msg, $min, $max) = @_;
      return ($msg)
          if !defined $msg
              || $max < 3
              || $min > $max;
  
      # First split on newlines
      my @lines = ();
      foreach my $line (split(/\n/, $msg)) {
          my $split = $line;
  
          # Then if each segment is more than the width, wrap it
          while (length($split) > $max) {
  
              # Look backwards for whitespace to split on
              my $pos = $max;
              while ($pos >= $min) {
                  if (substr($split, $pos, 1) =~ m{\s}sxm) {
                      $pos++;
                      last;
                  }
                  $pos--;
              }
              $pos = $max if $pos < $min;    #no good place to break, use the max
  
              # Break it
              my $chunk = substr($split, 0, $pos);
              $chunk =~ s{\s+$}{}sxm;
              push @lines, $chunk;
              $split = substr($split, $pos, length($split) - $pos);
          }
          $split =~ s{\s+$}{}sxm;            #trim
          push @lines, $split;
      }
      return @lines;
  }
  
  ### O ###
  
  package Term::Emit::TiedClosure;
  
  sub new {
      my ($proto, $base, @args) = @_;
      my $class = ref($proto) || $proto;     # Get the class name
      my $this = {-base => $base};
      bless($this, $class);
      $base->emit(@args);
      return $this;
  }
  
  sub DESTROY {
      my $this = shift;
      return $this->{-base}->emit_done();
  }
  
  1;                                         # EOM
  __END__
  
  =head1 NAME
  
  Term::Emit - Print with indentation, status, and closure
  
  =head1 VERSION
  
  This document describes Term::Emit version 0.0.4
  
  =head1 SYNOPSIS
  
  For a script like this:
  
      use Term::Emit qw/:all/;
      emit "System parameter updates";
        emit "CLOCK_UTC";
        #...do_something();
        emit_ok;
  
        emit "NTP Servers";
        #...do_something();
        emit_error;
  
        emit "DNS Servers";
        #...do_something();
        emit_warn;
  
  You get this output:
  
     System parameter updates...
       CLOCK_UTC................................................. [OK]
       NTP Servers............................................... [ERROR]
       DNS Servers............................................... [WARN]
     System parameter updates.................................... [DONE]
  
  =head1 DESCRIPTION
  
  The C<Term::Emit> package is used to print balanced and nested messages
  with a completion status.  These messages indent easily within each other,
  autocomplete on scope exit, are easily parsed, may be bulleted, can be filtered,
  and even can show status in color.
  
  For example, you write code like this:
  
      use Term::Emit qw/:all/;
      emit "Reconfiguring the grappolator";
      do_whatchamacallit();
      do_something_else();
  
  It begins by printing:
  
      Reconfiguring the grappolator...
  
  Then it does "whatchamacallit" and "something else".  When these are complete
  it adds the rest of the line: a bunch of dots and the [DONE].
  
      Reconfiguring the grappolator............................... [DONE]
  
  Your do_whatchamacallit() and do_something_else() subroutines may also C<emit>
  what they're doing, and indicate success or failure or whatever, so you
  can get nice output like this:
  
      Reconfiguring the grappolator...
        Processing whatchamacallit................................ [WARN]
        Fibulating something else...
          Fibulation phase one.................................... [OK]
          Fibulation phase two.................................... [ERROR]
          Wrapup of fibulation.................................... [OK]
      Reconfiguring the grappolator............................... [DONE]
  
  
  A series of examples will make I<Term::Emit> easier to understand.
  
  =head2 Basics
  
      use Term::Emit ':all';
      emit "Frobnicating the biffolator";
      sleep 1; # simulate the frobnication process
      emit_done;
  
  First this prints:
  
      Frobnicating the biffolator...
  
  Then after the "frobnication" process is complete, the line is
  continued so it looks like this:
  
      Frobnicating the biffolator................................ [DONE]
  
  =head2 Autocompletion
  
  In the above example, we end with a I<emit_done> call to indicate that
  the thing we told about (I<Frobnicating the biffolator>) is now done.
  We don't need to do the C<emit_done>.  It will be called automatically
  for us when the current scope is exited (for this example: when the program ends).
  So the code example could be just this:
  
      use Term::Emit ':all';
      emit "Frobnicating the biffolator";
      sleep 1; # simulate the frobnication process
  
  and we'd get the same results.  
  
  Yeah, autocompletion may not seem so useful YET,
  but hang in there and you'll soon see how wonderful it is.
  
  =head2 Completion Severity
  
  There's many ways a task can complete.  It can be simply DONE, or it can
  complete with an ERROR, or it can be OK, etc.  These completion codes are
  called the I<severity code>s.  C<Term::Emit> defines many different severity codes.
  The severity codes are borrowed from the UNIX syslog subsystem,
  plus a few from VMS and other sources.  They should be familiar to you.
  
  Severity codes also have an associated numerical value.
  This value is called the I<severity level>.
  It's useful for comparing severities to eachother or filtering out
  severities you don't want to be bothered with.
  
  Here are the severity codes and their severity values.
  Those on the same line are considered equal in severity:
  
      EMERG => 15,
      ALERT => 13,
      CRIT  => 11, FAIL => 11, FATAL => 11,
      ERROR => 9,
      WARN  => 7,
      NOTE  => 6,
      INFO  => 5, OK => 5,
      DEBUG => 4,
      NOTRY => 3,
      UNK   => 2,
      YES   => 1,
      NO    => 0,
  
  You may make up your own severities if what you want is not listed.
  Please keep the length to 5 characters or less, otherwise the text may wrap.
  Any severity not listed is given the value 1.
  
  To complete with a different severity, call C<emit_done> with the
  severity code like this:
  
      emit_done "WARN";
  
  C<emit_done> returns with the severity value from the above table,
  otherwise it returns 1, unless there's an error in which case it
  returns false.
  
  As a convienence, it's easier to use these functions which do the same thing,
  only simpler:
  
       Function          Equivalent                       Usual Meaning
      ----------      -----------------      -----------------------------------------------------
      emit_emerg      emit_done "EMERG";     syslog: Off the scale!
      emit_alert      emit_done "ALERT";     syslog: A major subsystem is unusable.
      emit_crit       emit_done "CRIT";      syslog: a critical subsystem is not working entirely.
      emit_fail       emit_done "FAIL";      Failure
      emit_fatal      emit_done "FATAL";     Fatal error
      emit_error      emit_done "ERROR";     syslog 'err': Bugs, bad data, files not found, ...
      emit_warn       emit_done "WARN";      syslog 'warning'
      emit_note       emit_done "NOTE";      syslog 'notice'
      emit_info       emit_done "INFO";      syslog 'info'
      emit_ok         emit_done "OK";        copacetic
      emit_debug      emit_done "DEBUG";     syslog: Really boring diagnostic output.
      emit_notry      emit_done "NOTRY";     Untried
      emit_unk        emit_done "UNK";       Unknown
      emit_yes        emit_done "YES";       Yes
      emit_no         emit_done "NO";        No
  
  We'll change our simple example to give a FATAL completion:
  
      use Term::Emit ':all';
      emit "Frobnicating the biffolator";
      sleep 1; # simulate the frobnication process
      emit_fatal;
  
  Here's how it looks:
  
      Frobnicating the biffolator................................ [FATAL]
  
  =head3 Severity Colors
  
  A spiffy little feature of C<Term::Emit> is that you can enable colorization of the
  severity codes.  That means that the severity code inside the square brackets
  is printed in color, so it's easy to see.  The standard ANSI color escape sequences
  are used to do the colorization.
  
  Here's the colors:
  
      EMERG    bold red on black
      ALERT    bold magenta
      CRIT     bold red
      FAIL     bold red
      FATAL    bold red
      ERROR    red
      WARN     yellow (usually looks orange)
      NOTE     cyan
      INFO     green
      OK       bold green
      DEBUG    grey on yellow/orange
      NOTRY    black on grey
      UNK      bold white on grey
      DONE     default font color (unchanged)
      YES      green
      NO       red
  
  To use colors, do this when you I<use> Term::Emit:
  
      use Term::Emit ":all", {-color => 1};
          -or-
      Term::Emit::setopts(-color => 1);
  
  Run sample003.pl, included with this module, to see how it looks on
  your terminal.
  
  =head2 Nested Messages
  
  Nested calls to C<emit> will automatically indent with eachother.
  You do this:
  
      use Term::Emit ":all";
      emit "Aaa";
      emit "Bbb";
      emit "Ccc";
  
  and you'll get output like this:
  
      Aaa...
        Bbb...
          Ccc.......................... [DONE]
        Bbb............................ [DONE]
      Aaa.............................. [DONE]
  
  Notice how "Bbb" is indented within the "Aaa" item, and that "Ccc" is
  within the "Bbb" item.  Note too how the Bbb and Aaa items were repeated
  because their initial lines were interrupted by more-inner tasks.
  
  You can control the indentation with the I<-step> attribute,
  and you may turn off or alter the repeated text (Bbb and Aaa) as you wish.
  
  =head3 Nesting Across Processes
  
  If you write a Perl script that uses Term::Emit, and this script invokes other
  scripts that also use Term::Emit, some nice magic happens.  The inner scripts become
  aware of the outer, and they "nest" their indentation levels appropriately.
  Pretty cool, eh?
  
  =head3 Filtering-out Deeper Levels (Verbosity)
  
  Often a script will have a verbosity option (-v usually), that allows
  a user to control how much output to see.  Term::Emit makes this easy
  with the -maxdepth option.
  
  Suppose your script has the verbose option in $opts{verbose}, where 0 means
  no output, 1 means some output, 2 means more output, etc.  In your script,
  do this:
  
      Term::Emit::setopts(-maxdepth => $opts{verbose});
  
  Then output will be filtered from nothing to full-on based on the verbosity setting.
  
  =head4 ...But Show Severe Messages
  
  If you're using -maxdepth to filter messages, sometimes you still want 
  to see a message regardless of the depth filtering - for example, a severe error.
  To set this, use the -showseverity option.  All messages that have
  at least that severity value or higher will be shown, regardless of the depth 
  filtering.  Thus, a better filter would look like:
  
      Term::Emit::setopts(-maxdepth     => $opts{verbose},
                          -showseverity => 7);
  
  See L</Completion Severity> above for the severity numbers.
  Note that the severity is rolled up to the deepest message filtered by
  the -maxdepth setting; any -reason text is hooked to that level.
  
  =head2 Closing with Different Text
  
  Suppose you want the opening and closing messages to be different.
  Such as I<"Starting gompchomper"> and I<"End of the gomp">.
  
  To do this, use the C<-closetext> option, like this:
  
      emit {-closetext => "End of the gomp"}, "Starting gompchomper";
  
  Now, instead of the start message being repeated at the end, you get
  custom end text.
  
  A convienent shorthand notation for I<-closetext> is to instead call
  C<emit> with a pair of strings as an array reference, like this:
  
      emit ["Start text", "End text"];
  
  Using the array reference notation is easier, and it will override
  the -closetext option if you use both.  So don't use both.
  
  =head3 Changing the 'close text' afterwards
  
  *** TODO:  Provide an easy way to do this! ***
  
  OK, you got me!  I didn't think of this case when I built this module.
  
  It's not easy to do now, even with access to the base object.
  For now, I recommend you use -reason and give extra reason text.
  When I fix it, it'll probably take the form of setopts(-closetext => "blah")
  and emit_done {-closetext=>"blah"};
  
  =head2 Closing with Different Severities, or... Why Autocompletion is Nice
  
  So far our examples have been rather boring.  They're not vey real-world.
  In a real script, you'll be doing various steps, checking status as you go,
  and bailing out with an error status on each failed check.  It's only when
  you get to the bottom of all the steps that you know it's succeeded.
  Here's where emit becomes more useful:
  
      use Term::Emit qw/:all/, {-closestat => "ERROR"};
      emit "Juxquolating the garfibnotor";
      return
          if !do_kibvoration();
      return
          if !do_rumbalation();
      $fail_reason = do_major_cleanup();
      return emit_warn {-reason => $fail_reason}
           if $fail_reason;
      emit_ok;
  
  In this example, we set C<-closestat> to "ERROR".  This means that if we
  exit scope without doing a emit_done() (or its equivalents), a emit_error()
  will automatically be called.
  
  Next we do_kibvoration and do_runbalation (whatever these are!).
  If either fails, we simply return.  Automatically then, the emit_error()
  will be called to close out the context.
  
  In the third step, we do_major_cleanup().  If that fails, we explicitly
  close out with a warning (the emit_warn), and we pass some reason text.
  
  If we get thru all three steps, we close out with an OK.
  
  
  =head2 Output to Other File Handles
  
  By default, C<Term::Emit> writes its output to STDOUT (or whatever select()
  is set to).  You can tell C<Term::Emit> to use another file handle like this:
  
      use Term::Emit qw/:all/, {-fh => *LOG};
          -or-
      Term::Emit::setopts(-fh => *LOG);
  
  Individual "emit" lines may also take a file handle as the first
  argument, in a manner similar to a print statement:
  
      emit *LOG, "this", " and ", "that";
  
  Note the required comma after the C<*LOG> -- if it was a C<print> you
  would omit the comma.
  
  =head3 Output to Strings
  
  If you give Term::Emit a scalar (string) reference instead of a file handle,
  then Term::Emit's output will be appended to this string.
  
  For example:
  
      my $out = "";
      use Term::Emit qw/:all/, {-fh => \$out};
          -or-
      Term::Emit::setopts(-fh => \$out);
  
  Individual "emit" lines may also take a scalar reference as the first
  argument:
  
      emit \$out, "this ", " and ", "that";
  
  =head2 Output Independence
  
  C<Term::Emit> separates output contexts by file handle.  That means the
  indentation, autoclosure, bullet style, width, etc. for any output told
  to STDERR is independent of output told to STDOUT, and independent
  of output told to a string.  All output to a string is lumped together
  into one context.
  
  =head3 Return Status
  
  Like C<print>, the C<emit> function returns a true value on success
  and false on failure.  Failure can occur, for example, when attempting
  to emit to a closed filehandle.
  
  To get the return status, you must assign into a scalar context,
  not a list context:
  
        my $stat;
        $stat = emit "Whatever";      # OK. This puts status into $stat
        ($stat) = emit "Whatever";    # NOT what it looks like!
  
  In list context, the closure for C<emit> is bound to the list variable's
  scope and autoclosure is disabled.  Probably not what you wanted.
  
  =head2 Message Bullets
  
  You may preceed each message with a bullet.
  A bullet is usually a single character
  such as a dash or an asterix, but may be multiple characters.
  You probably want to include a space after each bullet, too.
  
  You may have a different bullet for each nesting level.
  Levels deeper than the number of defined bulelts will use the last bullet.
  
  Define bullets by passing an array reference of the bullet strings
  with C<-bullet>.  If you want the bullet to be the same for all levels,
  just pass the string.  Here's some popular bullet definitions:
  
      -bullets => "* "
      -bullets => [" * ", " + ", " - ", "   "]
  
  Here's an example with bullets turned on:
  
   * Loading system information...
   +   Defined IP interface information......................... [OK]
   +   Running IP interface information......................... [OK]
   +   Web proxy definitions.................................... [OK]
   +   NTP Servers.............................................. [OK]
   +   Timezone settings........................................ [OK]
   +   Internal clock UTC setting............................... [OK]
   +   sshd Revocation settings................................. [OK]
   * Loading system information................................. [OK]
   * Loading current CAS parameters............................. [OK]
   * RDA CAS Setup 8.10-2...
   +   Updating configuration...
   -     System parameter updates............................... [OK]
   -     Updating CAS parameter values...
           Updating default web page index...................... [OK]
   -     Updating CAS parameter values.......................... [OK]
   +   Updating configuration................................... [OK]
   +   Forced stopping web server............................... [OK]
   +   Restarting web server.................................... [OK]
   +   Loading crontab jobs...remcon............................ [OK]
   * RDA CAS Setup 8.10-2....................................... [DONE]
  
  =head2 Mixing Term::Emit with print'ed Output
  
  Internally, Term::Emit keeps track of the output cursor position.  It only
  knows about what it has spewed to the screen (or logfile or string...).
  If you intermix C<print> statements with your C<emit> output, then things
  will likely get screwy.  So, you'll need to tell Term::Emit where you've
  left the cursor.  Do this by setting the I<-pos> option:
  
      emit "Skrawning all xyzons";
      print "\nHey, look at me, I'm printed output!\n";
      Term::Emit::setopts (-pos => 0);  # Tell where we left the cursor
  
  
  =head1 EXPORTS
  
  Nothing is exported by default.  You'll want to do one of these:
  
      use Term::Emit qw/emit emit_done/;    # To get just these two functions
      use Term::Emit qw/:all/;              # To get all functions
  
  Most of the time, you'll want the :all form.
  
  
  =head1 SUBROUTINES/METHODS
  
  Although an object-oriented interface exists for I<Term::Emit>, it is uncommon
  to use it that way.  The recommended interface is to use the class methods
  in a procedural fashion.
  Use C<emit()> similar to how you would use C<print()>.
  
  =head2 Methods
  
  The following subsections list the methods available:
  
  =head3 C<base>
  
  Internal base object accessor.  Called with no arguments, it returns
  the Term::Emit object associated with the default output filehandle.
  When called with a filehandle, it returns the Term::Emit object associated
  with that filehandle.
  
  =head3 C<clone>
  
  Clones the current I<Term::Emit> object and returns a new copy.
  Any given attributes override the cloned object.
  In most cases you will NOT need to clone I<Term::Emit> objects yourself.
  
  =head3 C<new>
  
  Constructor for a Term::Emit object.
  In most cases you will B<NOT> need to create I<Term::Emit> objects yourself.
  
  =head3 C<setopts>
  
  Sets options on a Term::Emit object. For example to enable colored severities,
  or to set the indentation step size.  Call it like this:
  
          Term::Emit::setopts(-fh    => *MYLOG,
                              -step  => 3,
                              -color => 1);
  
  See L</Options>.
  
  =head3 C<emit>
  
  Use C<emit> to emit a message similar to how you would use C<print>.
  
  Procedural call syntax:
  
      emit LIST
      emit *FH, LIST
      emit \$out, LIST
      emit {ATTRS}, LIST
  
  Object-oriented call syntax:
  
      $tobj->emit (LIST)
      $tobj->emit (*FH, LIST)
      $tobj->emit (\$out, LIST)
      $tobj->emit ({ATTRS}, LIST)
  
  =head3 C<emit_done>
  
  Closes the current message level, re-printing the message
  if necessary, printing dot-dot trailers to get proper alignment,
  and the given completion severity.
  
  =head3 C<emit_alert>
  
  =head3 C<emit_crit>
  
  =head3 C<emit_debug>
  
  =head3 C<emit_emerg>
  
  =head3 C<emit_error>
  
  =head3 C<emit_fail>
  
  =head3 C<emit_fatal>
  
  =head3 C<emit_info>
  
  =head3 C<emit_no>
  
  =head3 C<emit_note>
  
  =head3 C<emit_notry>
  
  =head3 C<emit_ok>
  
  =head3 C<emit_unk>
  
  =head3 C<emit_warn>
  
  =head3 C<emit_yes>
  
  All these are convienence methods that call C<emit_done()>
  with the indicated severity.  For example, C<emit_fail()> is
  equivalent to C<emit_done "FAIL">.  See L</Completion Severity>.
  
  =head3 C<emit_none>
  
  This is equivalent to emit_done, except that it does NOT print
  a wrapup line or a completion severity.  It simply closes out
  the current level with no message.
  
  =head3 C<emit_over>
  
  =head3 C<emit_prog>
  
  Emits a progress indication, such as a percent or M/N or whatever
  you devise.  In fact, this simply puts *any* string on the same line
  as the original message (for the current level).
  
  Using C<emit_over> will first backspace over a prior progress string
  (if any) to clear it, then it will write the progress string.
  The prior progress string could have been emitted by emit_over
  or emit_prog; it doesn't matter.
  
  C<emit_prog> does not backspace, it simply puts the string out there.
  
  For example,
  
    use Term::Emit qw/:all/;
    emit "Varigating the shaft";
    emit_prog '10%...';
    emit_prog '20%...';
  
  gives this output:
  
    Varigating the shaft...10%...20%...
  
  Keep your progress string small!  The string is treated as an indivisible
  entity and won't be split.  If the progress string is too big to fit on the
  line, a new line will be started with the appropriate indentation.
  
  With creativity, there's lots of progress indicator styles you could
  use.  Percents, countdowns, spinners, etc.
  Look at sample005.pl included with this package.
  Here's some styles to get you thinking:
  
          Style       Example output
          -----       --------------
          N           3       (overwrites prior number)
          M/N         3/7     (overwrites prior numbers)
          percent     20%     (overwrites prior percent)
          dots        ....    (these just go on and on, one dot for every step)
          tics        .........:.........:...
                              (like dots above but put a colon every tenth)
          countdown   9... 8... 7...
                              (liftoff!)
  
  
  =head3 C<emit_text>
  
  This prints the given text without changing the current level.
  Use it to give additional information, such as a blob of description.
  Lengthy lines will be wrapped to fit nicely in the given width.
  
  =head2 Options
  
  The I<emit*> functions, the I<setopts()> function, and I<use Term::Emit> take the following
  optional attributes.  Supply options and their values as a hash reference,
  like this:
  
      use Term::Emit ':all', {-fh => \$out,
                              -step => 1,
                              -color => 1};
      emit {-fh => *LOG}, "This and that";
      emit {-color => 1}, "Severities in living color";
  
  The leading dash on the option name is optional, but encouraged;
  and the option name may be any letter case, but all lowercase is preferred.
  
  =head3 -adjust_level
  
  Only valid for C<emit> and C<emit_text>.  Supply an integer value.
  
  This adjusts the indentation level of the message inwards (positive) or
  outwards (negative) for just this message.  It does not affect filtering
  via the I<maxdepth> attribute.  But it does affect the bullet character(s)
  if bullets are enabled.
  
  =head3 -bullets
  
  Enables or disables the use of bullet characters in front of messages.
  Set to a false value to disable the use of bullets - this is the default.
  Set to a scalar character string to enable that character(s) as the bullet.
  Set to an array reference of strings to use different characters for each
  nesting level.  See L</Message Bullets>.
  
  =head3 -closestat
  
  Sets the severity code to use when autocompleting a message.
  This is set to "DONE" by default.  See
  L</Closing with Different Severities, or... Why Autocompletion is Nice> above.
  
  =head3 -closetext
  
  Valid only for C<emit>.
  
  Supply a string to be used as the closing text that's paired
  with this level.  Normally, the text you use when you emit() a message
  is the text used to close it out.  This option lets you specify
  different closing text.  See L</Closing with Different Text>.
  
  =head3 -color
  
  Set to a true value to render the completion severities in color.
  ANSI escape sequences are used for the colors.  The default is
  to not use colors.  See L</Severity Colors> above.
  
  =head3 -ellipsis
  
  Sets the string to use for the ellipsis at the end of a message.
  The default is "..." (three periods).  Set it to a short string.
  This option is often used in combination with I<-trailer>.
  
      Frobnicating the bellfrey...
                               ^^^_____ These dots are the ellipsis
  
  =head3 -envbase
  
  May only be set before making the first I<emit()> call.
  
  Sets the base part of the environment variable used to maintain
  level-context across process calls.  The default is "term_emit_".
  See L</CONFIGURATION AND ENVIRONMENT>.
  
  =head3 -fh
  
  Designates the filehandle or scalar to receive output.  You may alter
  the default output, or specify it on individual emit* calls.
  
      use Term::Emit ':all', {-fh => *STDERR};  # Change default output to STDERR
      emit "Now this goes to STDERR instead of STDOUT";
      emit {-fh => *STDOUT}, "This goes to STDOUT";
      emit {-fh => \$outstr}, "This goes to a string";
  
  The emit* methods have a shorthand notation for the filehandle.
  If the first argument is a filehandle or a scalar reference, it is
  presumed to be the -fh attribute.  So the last two lines of the above
  example could be written like this:
  
      emit *STDOUT, "This goes to STDOUT";
      emit \$outstr, "This goes to a string";
  
  The default filehandle is whatever was C<select()>'ed, which
  is typically STDOUT.
  
  =head3 -maxdepth
  
  Only valid with C<setopts()> and I<use Term::Emit>.
  
  Filters messages by setting the maximum depth of messages tha will be printed.
  Set to undef (the default) to see all messages.
  Set to 0 to disable B<all> messages from Term::Emit.
  Set to a positive integer to see only messages at that depth and less.
  
  =head3 -pos
  
  Used to reset what Term::Emit thinks the cursor position is.
  You may have to do this is you mix ordinary print statements
  with emit's.
  
  Set this to 0 to indicate we're at the start of a new line
  (as in, just after a print "\n").  See L</Mixing Term::Emit with print'ed Output>.
  
  =head3 -reason
  
  Only valid for emit_done (and its equivalents like emit_warn,
  emit_error, etc.).
  
  Causes emit_done() to emit the given reason string on the following line(s),
  indented underneath the completed message.  This is useful to supply additional
  failure text to explain to a user why a certain task failed.
  
  This programming metaphor is commonly used:
  
      .
      .
      .
      my $fail_reason = do_something_that_may_fail();
      return emit_fail {-reason => $fail_reason}
          if $fail_reason;
      .
      .
      .
  
  =head3 -silent
  
  Only valid for emit(), emit_done(), and it's equivalents, like emit_ok, emit_warn, etc.
  
  Set this option to a true value to make an emit_done() close out silently.
  This means that the severity code, the trailer (dot dots), and
  the possible repeat of the message are turned off.
  
  The return status from the call is will still be the appropriate
  value for the severity code.
  
  =head3 -step
  
  Sets the indentation step size (number of spaces) for nesting messages.
  The default is 2.
  Set to 0 to disable indentation - all messages will be left justified.
  Set to a small positive integer to use that step size.
  
  =head3 -timestamp
  
  If false (the default), emitted lines are not prefixed with a timestamp.
  If true, the default local timestamp HH::MM::SS is prefixed to each emit line.
  If it's a coderef, then that function is called to get the timestamp string.
  The function is passed the current indent level, for what it's worth.
  Note that no delimiter is provided between the timestamp string and the 
  emitted line, so you should provide your own (a space or colon or whatever).
  Also, emit_text() output is NOT timestamped, just that from emit() and 
  its closure.
  
  =head3 -trailer
  
  The B<single> character used to trail after a message up to the
  completion severity.
  The default is the dot (the period, ".").  Here's what messages
  look like if you change it to an underscore:
  
    The code:
      use Term::Emit ':all', {-trailer => '_'};
      emit "Xerikineting";
  
    The output:
      Xerikineting...______________________________ [DONE]
  
  Note that the ellipsis after the message is still "...";
  use -ellipsis to change that string as well.
  
  =head3 -want_level
  
  Indicates the needed matching scope level for an autoclosure call
  to emit_done().  This is really an internal option and you should
  not use it.  If you do, I'll bet your output would get all screwy.
  So don't use it.
  
  =head3 -width
  
  Sets the terminal width of your output device.  I<Term::Emit> has no
  idea how wide your terminal screen is, so use this option to
  indicate the width.  The default is 80.
  
  You may want to use L<Term::Size::Any|Term::Size::Any>
  to determine your device's width:
  
      use Term::Emit ':all';
      use Term::Size::Any 'chars';
      my ($cols, $rows) = chars();
      Term::Emit::setopts(-width => $cols);
        .
        .
        .
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  I<Term::Emit> requires no configuration files or environment variables.
  However, it does set environment variables with this form of name:
  
      term_emit_fd#_th#
  
  This envvar holds the current level of messages (represented
  visually by indentation), so that indentation can be smoothly
  maintained across process contexts.
  
  In this envvar's name, fd# is the fileno() of the output file handle to which
  the messages are written.  By default output is to STDERR,
  which has a fileno of 2, so the envvar would be C<term_emit_fd2>.
  If output is being written to a string (C<<-fh => \$some_string>>),
  then fd# is the string "str", for example C<term_emit_fdstr>
  
  When Term::Emit is used with threads, the thread ID is placed
  in th# in the envvar.
  Thus for thread #7, writing Term::Emit messages to STDERR, the envvar
  would be C<term_emit_fd2_th7>.
  For the main thread, th# and the leading underscore are omitted.
  
  Under normal operation, this environment variable is deleted
  before the program exits, so generally you won't see it.
  
  Note: If your program's output seems excessively indented, it may be
  that this envvar has been left over from some other aborted run.
  Check for it and delete it if found.
  
  =head1 DEPENDENCIES
  
  This pure-Perl module depends upon Scope::Upper.
  
  =head1 DIAGNOSTICS
  
  None.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  
  =head1 BUGS AND LIMITATIONS
  
  =for author to fill in:
      A list of known problems with the module, together with some
      indication Whether they are likely to be fixed in an upcoming
      release. Also a list of restrictions on the features the module
      does provide: data types that cannot be handled, performance issues
      and the circumstances in which they may arise, practical
      limitations on the size of data sets, special cases that are not
      (yet) handled, etc.
  
  Limitation:  Output in a threaded environment isn't always pretty.
  It works OK and won't blow up, but indentation may get a bit screwy.
  I'm workin' on it.
  
  Bugs: No bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-term-emit@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  =head1 SEE ALSO
  
  To format C<Term::Emit> output to HTML, use
  L<Term::Emit::Format::HTML|Term::Emit::Format::HTML> .
  
  Other modules like C<Term::Emit> but not quite the same:
  
  =over 4
  
  =item *
  
  L<Debug::Message|Debug::Message>
  
  =item *
  
  L<Log::Dispatch|Log::Dispatch>
  
  =item *
  
  L<PTools::Debug|PTools::Debug>
  
  =item *
  
  L<Term::Activity|Term::Activity>
  
  =item *
  
  L<Term::ProgressBar|Term::ProgressBar>
  
  =back
  
  =head1 AUTHOR
  
  Steve Roscio  C<< <roscio@cpan.org> >>
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanx to Paul Vencel for his review of this package, and to Jimmy Maguire
  for his namespace advice.
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2009-2012, Steve Roscio C<< <roscio@cpan.org> >>.  All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  Because this software is licensed free of charge, there is no warranty
  for the software, to the extent permitted by applicable law.  Except when
  otherwise stated in writing the copyright holders and/or other parties
  provide the software "as is" without warranty of any kind, either
  expressed or implied, including, but not limited to, the implied
  warranties of merchantability and fitness for a particular purpose.  The
  entire risk as to the quality and performance of the software is with
  you.  Should the software prove defective, you assume the cost of all
  necessary servicing, repair, or correction.
  
  In no event unless required by applicable law or agreed to in writing
  will any copyright holder, or any other party who may modify and/or
  redistribute the software as permitted by the above licence, be
  liable to you for damages, including any general, special, incidental,
  or consequential damages arising out of the use or inability to use
  the software (including but not limited to loss of data or data being
  rendered inaccurate or losses sustained by you or third parties or a
  failure of the software to operate with any other software), even if
  such holder or other party has been advised of the possibility of
  such damages.
  
  =for me to do:
      * Get this to work back at 5.006
      * Validate any given options
      * Fixup anonymous literals
      * Hmmm... how to setopts() the default -fh  vs. setopts() for a particular -fh?
      * Make a 'print' wrapper to keep track of position,
         and POD about interaction with print
         then a function to reset the internal position (or use a setopts() attr)
      * Make emit() use indirect object notation so it's a drop-in for print
          ** But do we want the overhead of IO::Handle?
      * Timestamps - maybe do in another module?
          Allow timestamps in something akin to sprintf format within the strings.
          IE, solve this problem:
              emit ["Starting Frobnication process at %T",
                    "Frobnication process complete at %T"];
      * emit_more : another emit at the same level as the prior?
         for example:
             emit "yomama";
             emit_more "yopapa";  # does not start a new context, like emit_text
               but at upper level (or call it "yell"?)
      * Thread support
      * Add a "Closing Silently" section up around the closing w/diff text section.
      * Read envvars for secondary defaults, so qx() wrapping looks consistent.
      * Envvars for color, width, maxdepth, etc...
         ** export the envvars (in setopts()) so wrapped scripts pick 'em up
         ** clean up the envvars, iff we set 'em
         ** make 'em work by fd# as well, not just default.  IE, have
              term_emit_color apply to the default fd, but
              term_emit_fd2_color applies to stdout.  And so on.
TERM_EMIT

$fatpacked{"darwin-2level/Scope/Upper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SCOPE_UPPER';
  package Scope::Upper;
  
  use 5.006_001;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  Scope::Upper - Act on upper scopes.
  
  =head1 VERSION
  
  Version 0.28
  
  =cut
  
  our $VERSION;
  BEGIN {
   $VERSION = '0.28';
  }
  
  =head1 SYNOPSIS
  
  L</reap>, L</localize>, L</localize_elem>, L</localize_delete> and L</WORDS> :
  
      package Scope;
  
      use Scope::Upper qw<
       reap localize localize_elem localize_delete
       :words
      >;
  
      sub new {
       my ($class, $name) = @_;
  
       localize '$tag' => bless({ name => $name }, $class) => UP;
  
       reap { print Scope->tag->name, ": end\n" } UP;
      }
  
      # Get the tag stored in the caller namespace
      sub tag {
       my $l   = 0;
       my $pkg = __PACKAGE__;
       $pkg    = caller $l++ while $pkg eq __PACKAGE__;
  
       no strict 'refs';
       ${$pkg . '::tag'};
      }
  
      sub name { shift->{name} }
  
      # Locally capture warnings and reprint them with the name prefixed
      sub catch {
       localize_elem '%SIG', '__WARN__' => sub {
        print Scope->tag->name, ': ', @_;
       } => UP;
      }
  
      # Locally clear @INC
      sub private {
       for (reverse 0 .. $#INC) {
        # First UP is the for loop, second is the sub boundary
        localize_delete '@INC', $_ => UP UP;
       }
      }
  
      ...
  
      package UserLand;
  
      {
       Scope->new("top");    # initializes $UserLand::tag
  
       {
        Scope->catch;
        my $one = 1 + undef; # prints "top: Use of uninitialized value..."
  
        {
         Scope->private;
         eval { require Cwd };
         print $@;           # prints "Can't locate Cwd.pm in @INC
        }                    #         (@INC contains:) at..."
  
        require Cwd;         # loads Cwd.pm
       }
  
      }                      # prints "top: done"
  
  L</unwind> and L</want_at> :
  
      package Try;
  
      use Scope::Upper qw<unwind want_at :words>;
  
      sub try (&) {
       my @result = shift->();
       my $cx = SUB UP; # Point to the sub above this one
       unwind +(want_at($cx) ? @result : scalar @result) => $cx;
      }
  
      ...
  
      sub zap {
       try {
        my @things = qw<a b c>;
        return @things; # returns to try() and then outside zap()
        # not reached
       };
       # not reached
      }
  
      my @stuff = zap(); # @stuff contains qw<a b c>
      my $stuff = zap(); # $stuff contains 3
  
  L</uplevel> :
  
      package Uplevel;
  
      use Scope::Upper qw<uplevel CALLER>;
  
      sub target {
       faker(@_);
      }
  
      sub faker {
       uplevel {
        my $sub = (caller 0)[3];
        print "$_[0] from $sub()";
       } @_ => CALLER(1);
      }
  
      target('hello'); # "hello from Uplevel::target()"
  
  L</uid> and L</validate_uid> :
  
      use Scope::Upper qw<uid validate_uid>;
  
      my $uid;
  
      {
       $uid = uid();
       {
        if ($uid eq uid(UP)) { # yes
         ...
        }
        if (validate_uid($uid)) { # yes
         ...
        }
       }
      }
  
      if (validate_uid($uid)) { # no
       ...
      }
  
  =head1 DESCRIPTION
  
  This module lets you defer actions I<at run-time> that will take place when the control flow returns into an upper scope.
  Currently, you can:
  
  =over 4
  
  =item *
  
  hook an upper scope end with L</reap> ;
  
  =item *
  
  localize variables, array/hash values or deletions of elements in higher contexts with respectively L</localize>, L</localize_elem> and L</localize_delete> ;
  
  =item *
  
  return values immediately to an upper level with L</unwind>, L</yield> and L</leave> ;
  
  =item *
  
  gather information about an upper context with L</want_at> and L</context_info> ;
  
  =item *
  
  execute a subroutine in the setting of an upper subroutine stack frame with L</uplevel> ;
  
  =item *
  
  uniquely identify contexts with L</uid> and L</validate_uid>.
  
  =back
  
  =head1 FUNCTIONS
  
  In all those functions, C<$context> refers to the target scope.
  
  You have to use one or a combination of L</WORDS> to build the C<$context> passed to these functions.
  This is needed in order to ensure that the module still works when your program is ran in the debugger.
  The only thing you can assume is that it is an I<absolute> indicator of the frame, which means that you can safely store it at some point and use it when needed, and it will still denote the original scope.
  
  =cut
  
  BEGIN {
   require XSLoader;
   XSLoader::load(__PACKAGE__, $VERSION);
  }
  
  =head2 C<reap>
  
      reap { ... };
      reap { ... } $context;
      &reap($callback, $context);
  
  Adds a destructor that calls C<$callback> (in void context) when the upper scope represented by C<$context> ends.
  
  =head2 C<localize>
  
      localize $what, $value;
      localize $what, $value, $context;
  
  Introduces a C<local> delayed to the time of first return into the upper scope denoted by C<$context>.
  C<$what> can be :
  
  =over 4
  
  =item *
  
  A glob, in which case C<$value> can either be a glob or a reference.
  L</localize> follows then the same syntax as C<local *x = $value>.
  For example, if C<$value> is a scalar reference, then the C<SCALAR> slot of the glob will be set to C<$$value> - just like C<local *x = \1> sets C<$x> to C<1>.
  
  =item *
  
  A string beginning with a sigil, representing the symbol to localize and to assign to.
  If the sigil is C<'$'>, L</localize> follows the same syntax as C<local $x = $value>, i.e. C<$value> isn't dereferenced.
  For example,
  
      localize '$x', \'foo' => HERE;
  
  will set C<$x> to a reference to the string C<'foo'>.
  Other sigils (C<'@'>, C<'%'>, C<'&'> and C<'*'>) require C<$value> to be a reference of the corresponding type.
  
  When the symbol is given by a string, it is resolved when the actual localization takes place and not when L</localize> is called.
  Thus, if the symbol name is not qualified, it will refer to the variable in the package where the localization actually takes place and not in the one where the L</localize> call was compiled.
  For example,
  
      {
       package Scope;
       sub new { localize '$tag', $_[0] => UP }
      }
  
      {
       package Tool;
       {
        Scope->new;
        ...
       }
      }
  
  will localize C<$Tool::tag> and not C<$Scope::tag>.
  If you want the other behaviour, you just have to specify C<$what> as a glob or a qualified name.
  
  Note that if C<$what> is a string denoting a variable that wasn't declared beforehand, the relevant slot will be vivified as needed and won't be deleted from the glob when the localization ends.
  This situation never arises with C<local> because it only compiles when the localized variable is already declared.
  Although I believe it shouldn't be a problem as glob slots definedness is pretty much an implementation detail, this behaviour may change in the future if proved harmful.
  
  =back
  
  =head2 C<localize_elem>
  
      localize_elem $what, $key, $value;
      localize_elem $what, $key, $value, $context;
  
  Introduces a C<local $what[$key] = $value> or C<local $what{$key} = $value> delayed to the time of first return into the upper scope denoted by C<$context>.
  Unlike L</localize>, C<$what> must be a string and the type of localization is inferred from its sigil.
  The two only valid types are array and hash ; for anything besides those, L</localize_elem> will throw an exception.
  C<$key> is either an array index or a hash key, depending of which kind of variable you localize.
  
  If C<$what> is a string pointing to an undeclared variable, the variable will be vivified as soon as the localization occurs and emptied when it ends, although it will still exist in its glob.
  
  =head2 C<localize_delete>
  
      localize_delete $what, $key;
      localize_delete $what, $key, $context;
  
  Introduces the deletion of a variable or an array/hash element delayed to the time of first return into the upper scope denoted by C<$context>.
  C<$what> can be:
  
  =over 4
  
  =item *
  
  A glob, in which case C<$key> is ignored and the call is equivalent to C<local *x>.
  
  =item *
  
  A string beginning with C<'@'> or C<'%'>, for which the call is equivalent to respectively C<local $a[$key]; delete $a[$key]> and C<local $h{$key}; delete $h{$key}>.
  
  =item *
  
  A string beginning with C<'&'>, which more or less does C<undef &func> in the upper scope.
  It's actually more powerful, as C<&func> won't even C<exists> anymore.
  C<$key> is ignored.
  
  =back
  
  =head2 C<unwind>
  
      unwind;
      unwind @values, $context;
  
  Returns C<@values> I<from> the subroutine, eval or format context pointed by or just above C<$context>, and immediately restarts the program flow at this point - thus effectively returning C<@values> to an upper scope.
  If C<@values> is empty, then the C<$context> parameter is optional and defaults to the current context (making the call equivalent to a bare C<return;>) ; otherwise it is mandatory.
  
  The upper context isn't coerced onto C<@values>, which is hence always evaluated in list context.
  This means that
  
      my $num = sub {
       my @a = ('a' .. 'z');
       unwind @a => HERE;
       # not reached
      }->();
  
  will set C<$num> to C<'z'>.
  You can use L</want_at> to handle these cases.
  
  =head2 C<yield>
  
      yield;
      yield @values, $context;
  
  Returns C<@values> I<from> the context pointed by or just above C<$context>, and immediately restarts the program flow at this point.
  If C<@values> is empty, then the C<$context> parameter is optional and defaults to the current context ; otherwise it is mandatory.
  
  L</yield> differs from L</unwind> in that it can target I<any> upper scope (besides a C<s///e> substitution context) and not necessarily a sub, an eval or a format.
  Hence you can use it to return values from a C<do> or a C<map> block :
  
      my $now = do {
       local $@;
       eval { require Time::HiRes } or yield time() => HERE;
       Time::HiRes::time();
      };
  
      my @uniq = map {
       yield if $seen{$_}++; # returns the empty list from the block
       ...
      } @things;
  
  Like for L</unwind>, the upper context isn't coerced onto C<@values>.
  You can use the fifth value returned by L</context_info> to handle context coercion.
  
  =head2 C<leave>
  
      leave;
      leave @values;
  
  Immediately returns C<@values> from the current block, whatever it may be (besides a C<s///e> substitution context).
  C<leave> is actually a synonym for C<yield HERE>, while C<leave @values> is a synonym for C<yield @values, HERE>.
  
  Like for L</yield>, you can use the fifth value returned by L</context_info> to handle context coercion.
  
  =head2 C<want_at>
  
      my $want = want_at;
      my $want = want_at $context;
  
  Like L<perlfunc/wantarray>, but for the subroutine, eval or format context located at or just above C<$context>.
  
  It can be used to revise the example showed in L</unwind> :
  
      my $num = sub {
       my @a = ('a' .. 'z');
       unwind +(want_at(HERE) ? @a : scalar @a) => HERE;
       # not reached
      }->();
  
  will rightfully set C<$num> to C<26>.
  
  =head2 C<context_info>
  
      my ($package, $filename, $line, $subroutine, $hasargs,
          $wantarray, $evaltext, $is_require, $hints, $bitmask,
          $hinthash) = context_info $context;
  
  Gives information about the context denoted by C<$context>, akin to what L<perlfunc/caller> provides but not limited only to subroutine, eval and format contexts.
  When C<$context> is omitted, it defaults to the current context.
  
  The returned values are, in order :
  
  =over 4
  
  =item *
  
  I<(index 0)> : the namespace in use when the context was created ;
  
  =item *
  
  I<(index 1)> : the name of the file at the point where the context was created ;
  
  =item *
  
  I<(index 2)> : the line number at the point where the context was created ;
  
  =item *
  
  I<(index 3)> : the name of the subroutine called for this context, or C<undef> if this is not a subroutine context ;
  
  =item *
  
  I<(index 4)> : a boolean indicating whether a new instance of C<@_> was set up for this context, or C<undef> if this is not a subroutine context ;
  
  =item *
  
  I<(index 5)> : the context (in the sense of L<perlfunc/wantarray>) in which the context (in our sense) is executed ;
  
  =item *
  
  I<(index 6)> : the contents of the string being compiled for this context, or C<undef> if this is not an eval context ;
  
  =item *
  
  I<(index 7)> : a boolean indicating whether this eval context was created by C<require>, or C<undef> if this is not an eval context ;
  
  =item *
  
  I<(index 8)> : the value of the lexical hints in use when the context was created ;
  
  =item *
  
  I<(index 9)> : a bit string representing the warnings in use when the context was created ;
  
  =item *
  
  I<(index 10)> : a reference to the lexical hints hash in use when the context was created (only on perl 5.10 or greater).
  
  =back
  
  =head2 C<uplevel>
  
      my @ret = uplevel { ...; return @ret };
      my @ret = uplevel { my @args = @_; ...; return @ret } @args, $context;
      my @ret = &uplevel($callback, @args, $context);
  
  Executes the code reference C<$callback> with arguments C<@args> as if it were located at the subroutine stack frame pointed by C<$context>, effectively fooling C<caller> and C<die> into believing that the call actually happened higher in the stack.
  The code is executed in the context of the C<uplevel> call, and what it returns is returned as-is by C<uplevel>.
  
      sub target {
       faker(@_);
      }
  
      sub faker {
       uplevel {
        map { 1 / $_ } @_;
       } @_ => CALLER(1);
      }
  
      my @inverses = target(1, 2, 4); # @inverses contains (0, 0.5, 0.25)
      my $count    = target(1, 2, 4); # $count is 3
  
  Note that if C<@args> is empty, then the C<$context> parameter is optional and defaults to the current context ; otherwise it is mandatory.
  
  L<Sub::Uplevel> also implements a pure-Perl version of C<uplevel>.
  Both are identical, with the following caveats :
  
  =over 4
  
  =item *
  
  The L<Sub::Uplevel> implementation of C<uplevel> may execute a code reference in the context of B<any> upper stack frame.
  The L<Scope::Upper> version can only uplevel to a B<subroutine> stack frame, and will croak if you try to target an C<eval> or a format.
  
  =item *
  
  Exceptions thrown from the code called by this version of C<uplevel> will not be caught by C<eval> blocks between the target frame and the uplevel call, while they will for L<Sub::Uplevel>'s version.
  This means that :
  
      eval {
       sub {
        local $@;
        eval {
         sub {
          uplevel { die 'wut' } CALLER(2); # for Scope::Upper
          # uplevel(3, sub { die 'wut' })  # for Sub::Uplevel
         }->();
        };
        print "inner block: $@";
        $@ and exit;
       }->();
      };
      print "outer block: $@";
  
  will print "inner block: wut..." with L<Sub::Uplevel> and "outer block: wut..." with L<Scope::Upper>.
  
  =item *
  
  L<Sub::Uplevel> globally overrides the Perl keyword C<caller>, while L<Scope::Upper> does not.
  
  =back
  
  A simple wrapper lets you mimic the interface of L<Sub::Uplevel/uplevel> :
  
      use Scope::Upper;
  
      sub uplevel {
       my $frame = shift;
       my $code  = shift;
       my $cxt   = Scope::Upper::CALLER($frame);
       &Scope::Upper::uplevel($code => @_ => $cxt);
      }
  
  Albeit the three exceptions listed above, it passes all the tests of L<Sub::Uplevel>.
  
  =head2 C<uid>
  
      my $uid = uid;
      my $uid = uid $context;
  
  Returns an unique identifier (UID) for the context (or dynamic scope) pointed by C<$context>, or for the current context if C<$context> is omitted.
  This UID will only be valid for the life time of the context it represents, and another UID will be generated next time the same scope is executed.
  
      my $uid;
  
      {
       $uid = uid;
       if ($uid eq uid()) { # yes, this is the same context
        ...
       }
       {
        if ($uid eq uid()) { # no, we are one scope below
         ...
        }
        if ($uid eq uid(UP)) { # yes, UP points to the same scope as $uid
         ...
        }
       }
      }
  
      # $uid is now invalid
  
      {
       if ($uid eq uid()) { # no, this is another block
        ...
       }
      }
  
  For example, each loop iteration gets its own UID :
  
      my %uids;
  
      for (1 .. 5) {
       my $uid = uid;
       $uids{$uid} = $_;
      }
  
      # %uids has 5 entries
  
  The UIDs are not guaranteed to be numbers, so you must use the C<eq> operator to compare them.
  
  To check whether a given UID is valid, you can use the L</validate_uid> function.
  
  =head2 C<validate_uid>
  
      my $is_valid = validate_uid $uid;
  
  Returns true if and only if C<$uid> is the UID of a currently valid context (that is, it designates a scope that is higher than the current one in the call stack).
  
      my $uid;
  
      {
       $uid = uid();
       if (validate_uid($uid)) { # yes
        ...
       }
       {
        if (validate_uid($uid)) { # yes
         ...
        }
       }
      }
  
      if (validate_uid($uid)) { # no
       ...
      }
  
  =head1 CONSTANTS
  
  =head2 C<SU_THREADSAFE>
  
  True iff the module could have been built when thread-safety features.
  
  =head1 WORDS
  
  =head2 Constants
  
  =head3 C<TOP>
  
      my $top_context = TOP;
  
  Returns the context that currently represents the highest scope.
  
  =head3 C<HERE>
  
      my $current_context = HERE;
  
  The context of the current scope.
  
  =head2 Getting a context from a context
  
  For any of those functions, C<$from> is expected to be a context.
  When omitted, it defaults to the current context.
  
  =head3 C<UP>
  
      my $upper_context = UP;
      my $upper_context = UP $from;
  
  The context of the scope just above C<$from>.
  If C<$from> points to the top-level scope in the current stack, then a warning is emitted and C<$from> is returned (see L</DIAGNOSTICS> for details).
  
  =head3 C<SUB>
  
      my $sub_context = SUB;
      my $sub_context = SUB $from;
  
  The context of the closest subroutine above C<$from>.
  If C<$from> already designates a subroutine context, then it is returned as-is ; hence C<SUB SUB == SUB>.
  If no subroutine context is present in the call stack, then a warning is emitted and the current context is returned (see L</DIAGNOSTICS> for details).
  
  =head3 C<EVAL>
  
      my $eval_context = EVAL;
      my $eval_context = EVAL $from;
  
  The context of the closest eval above C<$from>.
  If C<$from> already designates an eval context, then it is returned as-is ; hence C<EVAL EVAL == EVAL>.
  If no eval context is present in the call stack, then a warning is emitted and the current context is returned (see L</DIAGNOSTICS> for details).
  
  =head2 Getting a context from a level
  
  Here, C<$level> should denote a number of scopes above the current one.
  When omitted, it defaults to C<0> and those functions return the same context as L</HERE>.
  
  =head3 C<SCOPE>
  
      my $context = SCOPE;
      my $context = SCOPE $level;
  
  The C<$level>-th upper context, regardless of its type.
  If C<$level> points above the top-level scope in the current stack, then a warning is emitted and the top-level context is returned (see L</DIAGNOSTICS> for details).
  
  =head3 C<CALLER>
  
      my $context = CALLER;
      my $context = CALLER $level;
  
  The context of the C<$level>-th upper subroutine/eval/format.
  It kind of corresponds to the context represented by C<caller $level>, but while e.g. C<caller 0> refers to the caller context, C<CALLER 0> will refer to the top scope in the current context.
  If C<$level> points above the top-level scope in the current stack, then a warning is emitted and the top-level context is returned (see L</DIAGNOSTICS> for details).
  
  =head2 Examples
  
  Where L</reap> fires depending on the C<$cxt> :
  
      sub {
       eval {
        sub {
         {
          reap \&cleanup => $cxt;
          ...
         }     # $cxt = SCOPE(0) = HERE
         ...
        }->(); # $cxt = SCOPE(1) = UP = SUB = CALLER(0)
        ...
       };      # $cxt = SCOPE(2) = UP UP =  UP SUB = EVAL = CALLER(1)
       ...
      }->();   # $cxt = SCOPE(3) = SUB UP SUB = SUB EVAL = CALLER(2)
      ...
  
  Where L</localize>, L</localize_elem> and L</localize_delete> act depending on the C<$cxt> :
  
      sub {
       eval {
        sub {
         {
          localize '$x' => 1 => $cxt;
          # $cxt = SCOPE(0) = HERE
          ...
         }
         # $cxt = SCOPE(1) = UP = SUB = CALLER(0)
         ...
        }->();
        # $cxt = SCOPE(2) = UP UP = UP SUB = EVAL = CALLER(1)
        ...
       };
       # $cxt = SCOPE(3) = SUB UP SUB = SUB EVAL = CALLER(2)
       ...
      }->();
      # $cxt = SCOPE(4), UP SUB UP SUB = UP SUB EVAL = UP CALLER(2) = TOP
      ...
  
  Where L</unwind>, L</yield>, L</want_at>, L</context_info> and L</uplevel> point to depending on the C<$cxt>:
  
      sub {
       eval {
        sub {
         {
          unwind @things => $cxt;   # or yield @things => $cxt
                                    # or uplevel { ... } $cxt
          ...
         }
         ...
        }->(); # $cxt = SCOPE(0) = SCOPE(1) = HERE = UP = SUB = CALLER(0)
        ...
       };      # $cxt = SCOPE(2) = UP UP = UP SUB = EVAL = CALLER(1) (*)
       ...
      }->();   # $cxt = SCOPE(3) = SUB UP SUB = SUB EVAL = CALLER(2)
      ...
  
      # (*) Note that uplevel() will croak if you pass that scope frame,
      #     because it cannot target eval scopes.
  
  =head1 DIAGNOSTICS
  
  =head2 C<Cannot target a scope outside of the current stack>
  
  This warning is emitted when L</UP>, L</SCOPE> or L</CALLER> end up pointing to a context that is above the top-level context of the current stack.
  It indicates that you tried to go higher than the main scope, or to point across a C<DESTROY> method, a signal handler, an overloaded or tied method call, a C<require> statement or a C<sort> callback.
  In this case, the resulting context is the highest reachable one.
  
  =head2 C<No targetable %s scope in the current stack>
  
  This warning is emitted when you ask for an L</EVAL> or L</SUB> context and no such scope can be found in the call stack.
  The resulting context is the current one.
  
  =head1 EXPORT
  
  The functions L</reap>, L</localize>, L</localize_elem>, L</localize_delete>,  L</unwind>, L</yield>, L</leave>, L</want_at>, L</context_info> and L</uplevel> are only exported on request, either individually or by the tags C<':funcs'> and C<':all'>.
  
  The constant L</SU_THREADSAFE> is also only exported on request, individually or by the tags C<':consts'> and C<':all'>.
  
  Same goes for the words L</TOP>, L</HERE>, L</UP>, L</SUB>, L</EVAL>, L</SCOPE> and L</CALLER> that are only exported on request, individually or by the tags C<':words'> and C<':all'>.
  
  =cut
  
  use base qw<Exporter>;
  
  our @EXPORT      = ();
  our %EXPORT_TAGS = (
   funcs  => [ qw<
    reap
    localize localize_elem localize_delete
    unwind yield leave
    want_at context_info
    uplevel
    uid validate_uid
   > ],
   words  => [ qw<TOP HERE UP SUB EVAL SCOPE CALLER> ],
   consts => [ qw<SU_THREADSAFE> ],
  );
  our @EXPORT_OK   = map { @$_ } values %EXPORT_TAGS;
  $EXPORT_TAGS{'all'} = [ @EXPORT_OK ];
  
  =head1 CAVEATS
  
  It is not possible to act upon a scope that belongs to another perl 'stack', i.e. to target a scope across a C<DESTROY> method, a signal handler, an overloaded or tied method call, a C<require> statement or a C<sort> callback.
  
  Be careful that local variables are restored in the reverse order in which they were localized.
  Consider those examples:
  
      local $x = 0;
      {
       reap sub { print $x } => HERE;
       local $x = 1;
       ...
      }
      # prints '0'
      ...
      {
       local $x = 1;
       reap sub { $x = 2 } => HERE;
       ...
      }
      # $x is 0
  
  The first case is "solved" by moving the C<local> before the C<reap>, and the second by using L</localize> instead of L</reap>.
  
  The effects of L</reap>, L</localize> and L</localize_elem> can't cross C<BEGIN> blocks, hence calling those functions in C<import> is deemed to be useless.
  This is an hopeless case because C<BEGIN> blocks are executed once while localizing constructs should do their job at each run.
  However, it's possible to hook the end of the current scope compilation with L<B::Hooks::EndOfScope>.
  
  Some rare oddities may still happen when running inside the debugger.
  It may help to use a perl higher than 5.8.9 or 5.10.0, as they contain some context-related fixes.
  
  Calling C<goto> to replace an L</uplevel>'d code frame does not work :
  
  =over 4
  
  =item *
  
  for a C<perl> older than the 5.8 series ;
  
  =item *
  
  for a C<DEBUGGING> C<perl> run with debugging flags set (as in C<perl -D ...>) ;
  
  =item *
  
  when the runloop callback is replaced by another module.
  
  =back
  
  In those three cases, L</uplevel> will look for a C<goto &sub> statement in its callback and, if there is one, throw an exception before executing the code.
  
  Moreover, in order to handle C<goto> statements properly, L</uplevel> currently has to suffer a run-time overhead proportional to the size of the callback in every case (with a small ratio), and proportional to the size of B<all> the code executed as the result of the L</uplevel> call (including subroutine calls inside the callback) when a C<goto> statement is found in the L</uplevel> callback.
  Despite this shortcoming, this XS version of L</uplevel> should still run way faster than the pure-Perl version from L<Sub::Uplevel>.
  
  Starting from C<perl> 5.19.4, it is unfortunately no longer possible to reliably throw exceptions from L</uplevel>'d code while the debugger is in use.
  This may be solved in a future version depending on how the core evolves.
  
  =head1 DEPENDENCIES
  
  L<perl> 5.6.1.
  
  A C compiler.
  This module may happen to build with a C++ compiler as well, but don't rely on it, as no guarantee is made in this regard.
  
  L<XSLoader> (core since perl 5.6.0).
  
  =head1 SEE ALSO
  
  L<perlfunc/local>, L<perlsub/"Temporary Values via local()">.
  
  L<Alias>, L<Hook::Scope>, L<Scope::Guard>, L<Guard>.
  
  L<Sub::Uplevel>.
  
  L<Continuation::Escape> is a thin wrapper around L<Scope::Upper> that gives you a continuation passing style interface to L</unwind>.
  It's easier to use, but it requires you to have control over the scope where you want to return.
  
  L<Scope::Escape>.
  
  =head1 AUTHOR
  
  Vincent Pit, C<< <perl at profvince.com> >>, L<http://www.profvince.com>.
  
  You can contact me by mail or on C<irc.perl.org> (vincent).
  
  =head1 BUGS
  
  Please report any bugs or feature requests to C<bug-scope-upper at rt.cpan.org>, or through the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Scope-Upper>.
  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Scope::Upper
  
  =head1 ACKNOWLEDGEMENTS
  
  Inspired by Ricardo Signes.
  
  Thanks to Shawn M. Moore for motivation.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2008,2009,2010,2011,2012,2013,2014,2015 Vincent Pit, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  1; # End of Scope::Upper
DARWIN-2LEVEL_SCOPE_UPPER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Term::Emit qw/ :all /;
use Spreadsheet::ParseExcel;
use Excel::Writer::XLSX;

our $VERSION = '0.02';

my %opts = ();
GetOptions( \%opts, 'verbose+', 'output=s', 'help|?', 'man' ) || pod2usage(1);
&pod2usage(1) if ( $opts{'help'} );
&pod2usage( -exitval => 0, -verbose => 2 ) if ( $opts{'man'} );

Term::Emit::setopts(
    -color        => 1,
    -maxdepth     => $opts{'verbose'} || 0,
    -bullets      => ["* ", "- " ],
    -showseverity => 7,
);

my $xls_file      = $ARGV[0];  # Spreadsheet::ParseExcel will fail on file not found
my $xls_workbook  = _get_xls_workbook($xls_file);
my $xlsx_workbook = _get_xlsx_workbook( $opts{'output'} || $xls_file );

emit "Processing XLS worksheets";
foreach my $xls_worksheet ( $xls_workbook->worksheets() ) {
    emit "Processing worksheet '" . $xls_worksheet->get_name() . "'";
    my $xlsx_worksheet = $xlsx_workbook->add_worksheet( $xls_worksheet->get_name() );
    my ( $row_min, $row_max ) = $xls_worksheet->row_range();
    my ( $col_min, $col_max ) = $xls_worksheet->col_range();

    for my $row ( $row_min .. $row_max ) {
        for my $col ( $col_min .. $col_max ) {
            my $xls_cell = $xls_worksheet->get_cell( $row, $col );
            next unless $xls_cell;
            my $format = _convert_xls_format( $xls_cell->get_format(), $xlsx_workbook );
            $xlsx_worksheet->write( $row, $col, $xls_cell->value(), $format );
        }
    }
    emit_done;
}
emit_done;

$xlsx_workbook->close();

sub _get_xls_workbook {
    my ( $file ) = @_;

    emit "Parsing XLS file";
    my $parser   = Spreadsheet::ParseExcel->new();
    my $workbook = $parser->parse($file);
    unless ( ref($workbook) eq 'Spreadsheet::ParseExcel::Workbook' ) {
        emit_fatal;
        if ( length($parser->error()) > 0 ) {
            die $parser->error() . ".\n";
        }
        else {
            die "XLS parser died from unknown error\n";
        }
    }
    emit_done;

    return $workbook;
}

sub _get_xlsx_workbook {
    my ( $file ) = @_;

    emit "Creating XLSX file";
    $file =~ s/\.xls$/\.xlsx/;
    my $workbook = Excel::Writer::XLSX->new( $file );
    unless ( ref($workbook) eq 'Excel::Writer::XLSX' ) {
        emit_fatal;
        die "Failure creating XLSX workbook\n";
    }
    emit_done;

    return $workbook;
}

sub _convert_xls_format {
    my ( $xls_format, $xlsx_workbook ) = @_;

    return undef unless ( ref($xls_format) eq 'Spreadsheet::ParseExcel::Format' );

    my $format = $xlsx_workbook->add_format();
    $format->set_format_properties(
        font           => $xls_format->{'Font'}->{'Name'},
        size           => $xls_format->{'Font'}->{'Height'},
        color          => $xls_format->{'Font'}->{'Color'},
        bold           => $xls_format->{'Font'}->{'Bold'} || 0,
        italic         => $xls_format->{'Font'}->{'Italic'} || 0,
        underline      => $xls_format->{'Font'}->{'UnderlineStyle'},
        font_strikeout => $xls_format->{'Font'}->{'Strikeout'} || 0,
        font_script    => $xls_format->{'Font'}->{'Super'} || 0,
        align          => $xls_format->{'AlignH'} || 0,
        valign         => $xls_format->{'AlignV'} || 0,
        indent         => $xls_format->{'Indent'} || 0,
        text_wrap      => $xls_format->{'Wrap'} || 0,
        shrink         => $xls_format->{'Shrink'} || 0,
        rotation       => $xls_format->{'Rotate'} || 0,
        text_justlast  => $xls_format->{'JustLast'} || 0,
        left           => @{$xls_format->{'BdrStyle'}}[0],
        right          => @{$xls_format->{'BdrStyle'}}[1],
        top            => @{$xls_format->{'BdrStyle'}}[2],
        bottom         => @{$xls_format->{'BdrStyle'}}[3],
        left_color     => @{$xls_format->{'BdrColor'}}[0],
        right_color    => @{$xls_format->{'BdrColor'}}[1],
        top_color      => @{$xls_format->{'BdrColor'}}[2],
        bottom_color   => @{$xls_format->{'BdrColor'}}[3],
        pattern        => @{$xls_format->{'Fill'}}[0],
        fg_color       => @{$xls_format->{'Fill'}}[1],
        bg_color       => @{$xls_format->{'Fill'}}[2],
        locked         => $xls_format->{'Lock'} || 0,
        hidden         => $xls_format->{'Hidden'} || 0,
    );

    return $format;
}

__END__

=head1 NAME

xls2xlsx - Convert a .xls file to a .xlsx file

=head1 SYNOPSIS

xls2xlsx [-hmv] [-o file] file

  Options:
    -o   output file name

    -h   usage help
    -m   man file
    -v   controls 'chattiness'

=head1 DESCRIPTION

B<xls2xlsx> will convert an old .xls file into the newer .xlsx formatted file.

=cut
